globalThis.GPUShaderStage === void 0 && (globalThis.GPUShaderStage = { VERTEX: 1, FRAGMENT: 2, COMPUTE: 4 });
const Ku = "182", So = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 }, Qc = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 }, _3 = 0, h1 = 1, x3 = 2, bF = 3, A5 = 0, Af = 1, p5 = 2, $a = 3, Zs = 0, si = 1, er = 2, ms = 0, gs = 1, fh = 2, Ah = 3, ph = 4, oh = 5, Wr = 100, S_ = 101, T_ = 102, y3 = 103, v3 = 104, Ga = 200, w_ = 201, M_ = 202, E_ = 203, Tf = 204, wf = 205, R_ = 206, C_ = 207, P_ = 208, N_ = 209, D_ = 210, m5 = 211, g5 = 212, _5 = 213, x5 = 214, Mf = 0, Ef = 1, Rf = 2, Vl = 3, Cf = 4, Pf = 5, Nf = 6, Df = 7, tA = 0, b3 = 1, S3 = 2, Dr = 0, L_ = 1, I_ = 2, B_ = 3, F_ = 4, T3 = 5, U_ = 6, O_ = 7, Bv = "attached", y5 = "detached", A0 = 300, no = 301, qo = 302, Gu = 303, zu = 304, Gl = 306, zl = 1e3, xr = 1001, ql = 1002, ei = 1003, p0 = 1004, SF = 1004, Aa = 1005, TF = 1005, qn = 1006, Uu = 1007, wF = 1007, $r = 1008, v5 = 1008, Mi = 1009, Ou = 1010, ku = 1011, Oo = 1012, _r = 1013, Jn = 1014, Ei = 1015, Ri = 1016, m0 = 1017, g0 = 1018, Js = 1020, _0 = 35902, x0 = 35899, k_ = 1021, nA = 1022, Pi = 1023, Lr = 1026, ds = 1027, Yh = 1028, Zu = 1029, fs = 1030, Qh = 1031, b5 = 1032, Kh = 1033, Rl = 33776, Cl = 33777, Pl = 33778, Nl = 33779, Lf = 35840, If = 35841, Bf = 35842, Ff = 35843, mh = 36196, gh = 37492, _h = 37496, xh = 37488, yh = 37489, qu = 37490, vh = 37491, bh = 37808, Sh = 37809, Th = 37810, wh = 37811, Mh = 37812, Eh = 37813, Rh = 37814, Ch = 37815, Ph = 37816, Nh = 37817, Dh = 37818, Lh = 37819, Ih = 37820, Bh = 37821, Fh = 36492, d1 = 36494, f1 = 36495, Uh = 36283, Oh = 36284, Hu = 36285, kh = 36286, S5 = 2200, T5 = 2201, w5 = 2202, Fp = 2300, A1 = 2301, Wg = 2302, Kc = 2400, Zc = 2401, Up = 2402, V_ = 2500, w3 = 2501, M5 = 0, E5 = 1, Fv = 2, R5 = 3200, MF = 3201, EF = 3202, RF = 3203, xa = 0, M3 = 1, Ds = "", gr = "srgb", Hl = "srgb-linear", Vh = "linear", vt = "srgb", $g = "", E3 = "rg", C5 = "ga", P5 = 0, Tu = 7680, N5 = 7681, D5 = 7682, L5 = 7683, I5 = 34055, B5 = 34056, F5 = 5386, U5 = 512, O5 = 513, k5 = 514, V5 = 515, G5 = 516, z5 = 517, q5 = 518, p1 = 519, G_ = 512, iA = 513, z_ = 514, rA = 515, q_ = 516, H_ = 517, sA = 518, W_ = 519, Wu = 35044, Du = 35048, CF = 35040, PF = 35045, NF = 35049, DF = 35041, LF = 35046, IF = 35050, BF = 35042, FF = "100", Uv = "300 es", jr = 2e3, io = 2001, pa = {
  COMPUTE: "compute",
  RENDER: "render"
}, UF = {
  PERSPECTIVE: "perspective",
  LINEAR: "linear",
  FLAT: "flat"
}, OF = {
  NORMAL: "normal",
  CENTROID: "centroid",
  SAMPLE: "sample",
  FIRST: "first",
  EITHER: "either"
};
function R3(i) {
  for (let e = i.length - 1; e >= 0; --e)
    if (i[e] >= 65535) return !0;
  return !1;
}
const kF = {
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array
};
function af(i, e) {
  return new kF[i](e);
}
function Uf(i) {
  return ArrayBuffer.isView(i) && !(i instanceof DataView);
}
function Op(i) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", i);
}
function C3() {
  const i = Op("canvas");
  return i.style.display = "block", i;
}
const hM = {};
let $u = null;
function VF(i) {
  $u = i;
}
function GF() {
  return $u;
}
function Of(...i) {
  const e = "THREE." + i.shift();
  $u ? $u("log", e, ...i) : console.log(e, ...i);
}
function Me(...i) {
  const e = "THREE." + i.shift();
  $u ? $u("warn", e, ...i) : console.warn(e, ...i);
}
function Ie(...i) {
  const e = "THREE." + i.shift();
  $u ? $u("error", e, ...i) : console.error(e, ...i);
}
function li(...i) {
  const e = i.join(" ");
  e in hM || (hM[e] = !0, Me(...i));
}
function zF(i, e, t) {
  return new Promise(function(n, r) {
    function s() {
      switch (i.clientWaitSync(e, i.SYNC_FLUSH_COMMANDS_BIT, 0)) {
        case i.WAIT_FAILED:
          r();
          break;
        case i.TIMEOUT_EXPIRED:
          setTimeout(s, t);
          break;
        default:
          n();
      }
    }
    setTimeout(s, t);
  });
}
class lo {
  /**
   * Adds the given event listener to the given event type.
   *
   * @param {string} type - The type of event to listen to.
   * @param {Function} listener - The function that gets called when the event is fired.
   */
  addEventListener(e, t) {
    this._listeners === void 0 && (this._listeners = {});
    const n = this._listeners;
    n[e] === void 0 && (n[e] = []), n[e].indexOf(t) === -1 && n[e].push(t);
  }
  /**
   * Returns `true` if the given event listener has been added to the given event type.
   *
   * @param {string} type - The type of event.
   * @param {Function} listener - The listener to check.
   * @return {boolean} Whether the given event listener has been added to the given event type.
   */
  hasEventListener(e, t) {
    const n = this._listeners;
    return n === void 0 ? !1 : n[e] !== void 0 && n[e].indexOf(t) !== -1;
  }
  /**
   * Removes the given event listener from the given event type.
   *
   * @param {string} type - The type of event.
   * @param {Function} listener - The listener to remove.
   */
  removeEventListener(e, t) {
    const n = this._listeners;
    if (n === void 0) return;
    const r = n[e];
    if (r !== void 0) {
      const s = r.indexOf(t);
      s !== -1 && r.splice(s, 1);
    }
  }
  /**
   * Dispatches an event object.
   *
   * @param {Object} event - The event that gets fired.
   */
  dispatchEvent(e) {
    const t = this._listeners;
    if (t === void 0) return;
    const n = t[e.type];
    if (n !== void 0) {
      e.target = this;
      const r = n.slice(0);
      for (let s = 0, o = r.length; s < o; s++)
        r[s].call(this, e);
      e.target = null;
    }
  }
}
const ss = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let dM = 1234567;
const ah = Math.PI / 180, Gh = 180 / Math.PI;
function To() {
  const i = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, n = Math.random() * 4294967295 | 0;
  return (ss[i & 255] + ss[i >> 8 & 255] + ss[i >> 16 & 255] + ss[i >> 24 & 255] + "-" + ss[e & 255] + ss[e >> 8 & 255] + "-" + ss[e >> 16 & 15 | 64] + ss[e >> 24 & 255] + "-" + ss[t & 63 | 128] + ss[t >> 8 & 255] + "-" + ss[t >> 16 & 255] + ss[t >> 24 & 255] + ss[n & 255] + ss[n >> 8 & 255] + ss[n >> 16 & 255] + ss[n >> 24 & 255]).toLowerCase();
}
function dn(i, e, t) {
  return Math.max(e, Math.min(t, i));
}
function P3(i, e) {
  return (i % e + e) % e;
}
function qF(i, e, t, n, r) {
  return n + (i - e) * (r - n) / (t - e);
}
function HF(i, e, t) {
  return i !== e ? (t - i) / (e - i) : 0;
}
function vp(i, e, t) {
  return (1 - t) * i + t * e;
}
function WF(i, e, t, n) {
  return vp(i, e, 1 - Math.exp(-t * n));
}
function $F(i, e = 1) {
  return e - Math.abs(P3(i, e * 2) - e);
}
function jF(i, e, t) {
  return i <= e ? 0 : i >= t ? 1 : (i = (i - e) / (t - e), i * i * (3 - 2 * i));
}
function XF(i, e, t) {
  return i <= e ? 0 : i >= t ? 1 : (i = (i - e) / (t - e), i * i * i * (i * (i * 6 - 15) + 10));
}
function YF(i, e) {
  return i + Math.floor(Math.random() * (e - i + 1));
}
function QF(i, e) {
  return i + Math.random() * (e - i);
}
function KF(i) {
  return i * (0.5 - Math.random());
}
function ZF(i) {
  i !== void 0 && (dM = i);
  let e = dM += 1831565813;
  return e = Math.imul(e ^ e >>> 15, e | 1), e ^= e + Math.imul(e ^ e >>> 7, e | 61), ((e ^ e >>> 14) >>> 0) / 4294967296;
}
function JF(i) {
  return i * ah;
}
function eU(i) {
  return i * Gh;
}
function tU(i) {
  return (i & i - 1) === 0 && i !== 0;
}
function nU(i) {
  return Math.pow(2, Math.ceil(Math.log(i) / Math.LN2));
}
function iU(i) {
  return Math.pow(2, Math.floor(Math.log(i) / Math.LN2));
}
function rU(i, e, t, n, r) {
  const s = Math.cos, o = Math.sin, a = s(t / 2), l = o(t / 2), u = s((e + n) / 2), c = o((e + n) / 2), A = s((e - n) / 2), m = o((e - n) / 2), _ = s((n - e) / 2), y = o((n - e) / 2);
  switch (r) {
    case "XYX":
      i.set(a * c, l * A, l * m, a * u);
      break;
    case "YZY":
      i.set(l * m, a * c, l * A, a * u);
      break;
    case "ZXZ":
      i.set(l * A, l * m, a * c, a * u);
      break;
    case "XZX":
      i.set(a * c, l * y, l * _, a * u);
      break;
    case "YXY":
      i.set(l * _, a * c, l * y, a * u);
      break;
    case "ZYZ":
      i.set(l * y, l * _, a * c, a * u);
      break;
    default:
      Me("MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r);
  }
}
function Ls(i, e) {
  switch (e.constructor) {
    case Float32Array:
      return i;
    case Uint32Array:
      return i / 4294967295;
    case Uint16Array:
      return i / 65535;
    case Uint8Array:
      return i / 255;
    case Int32Array:
      return Math.max(i / 2147483647, -1);
    case Int16Array:
      return Math.max(i / 32767, -1);
    case Int8Array:
      return Math.max(i / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function En(i, e) {
  switch (e.constructor) {
    case Float32Array:
      return i;
    case Uint32Array:
      return Math.round(i * 4294967295);
    case Uint16Array:
      return Math.round(i * 65535);
    case Uint8Array:
      return Math.round(i * 255);
    case Int32Array:
      return Math.round(i * 2147483647);
    case Int16Array:
      return Math.round(i * 32767);
    case Int8Array:
      return Math.round(i * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
const zh = {
  DEG2RAD: ah,
  RAD2DEG: Gh,
  /**
   * Generate a [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier)
   * (universally unique identifier).
   *
   * @static
   * @method
   * @return {string} The UUID.
   */
  generateUUID: To,
  /**
   * Clamps the given value between min and max.
   *
   * @static
   * @method
   * @param {number} value - The value to clamp.
   * @param {number} min - The min value.
   * @param {number} max - The max value.
   * @return {number} The clamped value.
   */
  clamp: dn,
  /**
   * Computes the Euclidean modulo of the given parameters that
   * is `( ( n % m ) + m ) % m`.
   *
   * @static
   * @method
   * @param {number} n - The first parameter.
   * @param {number} m - The second parameter.
   * @return {number} The Euclidean modulo.
   */
  euclideanModulo: P3,
  /**
   * Performs a linear mapping from range `<a1, a2>` to range `<b1, b2>`
   * for the given value.
   *
   * @static
   * @method
   * @param {number} x - The value to be mapped.
   * @param {number} a1 - Minimum value for range A.
   * @param {number} a2 - Maximum value for range A.
   * @param {number} b1 - Minimum value for range B.
   * @param {number} b2 - Maximum value for range B.
   * @return {number} The mapped value.
   */
  mapLinear: qF,
  /**
   * Returns the percentage in the closed interval `[0, 1]` of the given value
   * between the start and end point.
   *
   * @static
   * @method
   * @param {number} x - The start point
   * @param {number} y - The end point.
   * @param {number} value - A value between start and end.
   * @return {number} The interpolation factor.
   */
  inverseLerp: HF,
  /**
   * Returns a value linearly interpolated from two known points based on the given interval -
   * `t = 0` will return `x` and `t = 1` will return `y`.
   *
   * @static
   * @method
   * @param {number} x - The start point
   * @param {number} y - The end point.
   * @param {number} t - The interpolation factor in the closed interval `[0, 1]`.
   * @return {number} The interpolated value.
   */
  lerp: vp,
  /**
   * Smoothly interpolate a number from `x` to `y` in  a spring-like manner using a delta
   * time to maintain frame rate independent movement. For details, see
   * [Frame rate independent damping using lerp](http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/).
   *
   * @static
   * @method
   * @param {number} x - The current point.
   * @param {number} y - The target point.
   * @param {number} lambda - A higher lambda value will make the movement more sudden,
   * and a lower value will make the movement more gradual.
   * @param {number} dt - Delta time in seconds.
   * @return {number} The interpolated value.
   */
  damp: WF,
  /**
   * Returns a value that alternates between `0` and the given `length` parameter.
   *
   * @static
   * @method
   * @param {number} x - The value to pingpong.
   * @param {number} [length=1] - The positive value the function will pingpong to.
   * @return {number} The alternated value.
   */
  pingpong: $F,
  /**
   * Returns a value in the range `[0,1]` that represents the percentage that `x` has
   * moved between `min` and `max`, but smoothed or slowed down the closer `x` is to
   * the `min` and `max`.
   *
   * See [Smoothstep](http://en.wikipedia.org/wiki/Smoothstep) for more details.
   *
   * @static
   * @method
   * @param {number} x - The value to evaluate based on its position between min and max.
   * @param {number} min - The min value. Any x value below min will be `0`.
   * @param {number} max - The max value. Any x value above max will be `1`.
   * @return {number} The alternated value.
   */
  smoothstep: jF,
  /**
   * A [variation on smoothstep](https://en.wikipedia.org/wiki/Smoothstep#Variations)
   * that has zero 1st and 2nd order derivatives at x=0 and x=1.
   *
   * @static
   * @method
   * @param {number} x - The value to evaluate based on its position between min and max.
   * @param {number} min - The min value. Any x value below min will be `0`.
   * @param {number} max - The max value. Any x value above max will be `1`.
   * @return {number} The alternated value.
   */
  smootherstep: XF,
  /**
   * Returns a random integer from `<low, high>` interval.
   *
   * @static
   * @method
   * @param {number} low - The lower value boundary.
   * @param {number} high - The upper value boundary
   * @return {number} A random integer.
   */
  randInt: YF,
  /**
   * Returns a random float from `<low, high>` interval.
   *
   * @static
   * @method
   * @param {number} low - The lower value boundary.
   * @param {number} high - The upper value boundary
   * @return {number} A random float.
   */
  randFloat: QF,
  /**
   * Returns a random integer from `<-range/2, range/2>` interval.
   *
   * @static
   * @method
   * @param {number} range - Defines the value range.
   * @return {number} A random float.
   */
  randFloatSpread: KF,
  /**
   * Returns a deterministic pseudo-random float in the interval `[0, 1]`.
   *
   * @static
   * @method
   * @param {number} [s] - The integer seed.
   * @return {number} A random float.
   */
  seededRandom: ZF,
  /**
   * Converts degrees to radians.
   *
   * @static
   * @method
   * @param {number} degrees - A value in degrees.
   * @return {number} The converted value in radians.
   */
  degToRad: JF,
  /**
   * Converts radians to degrees.
   *
   * @static
   * @method
   * @param {number} radians - A value in radians.
   * @return {number} The converted value in degrees.
   */
  radToDeg: eU,
  /**
   * Returns `true` if the given number is a power of two.
   *
   * @static
   * @method
   * @param {number} value - The value to check.
   * @return {boolean} Whether the given number is a power of two or not.
   */
  isPowerOfTwo: tU,
  /**
   * Returns the smallest power of two that is greater than or equal to the given number.
   *
   * @static
   * @method
   * @param {number} value - The value to find a POT for.
   * @return {number} The smallest power of two that is greater than or equal to the given number.
   */
  ceilPowerOfTwo: nU,
  /**
   * Returns the largest power of two that is less than or equal to the given number.
   *
   * @static
   * @method
   * @param {number} value - The value to find a POT for.
   * @return {number} The largest power of two that is less than or equal to the given number.
   */
  floorPowerOfTwo: iU,
  /**
   * Sets the given quaternion from the [Intrinsic Proper Euler Angles](https://en.wikipedia.org/wiki/Euler_angles)
   * defined by the given angles and order.
   *
   * Rotations are applied to the axes in the order specified by order:
   * rotation by angle `a` is applied first, then by angle `b`, then by angle `c`.
   *
   * @static
   * @method
   * @param {Quaternion} q - The quaternion to set.
   * @param {number} a - The rotation applied to the first axis, in radians.
   * @param {number} b - The rotation applied to the second axis, in radians.
   * @param {number} c - The rotation applied to the third axis, in radians.
   * @param {('XYX'|'XZX'|'YXY'|'YZY'|'ZXZ'|'ZYZ')} order - A string specifying the axes order.
   */
  setQuaternionFromProperEuler: rU,
  /**
   * Normalizes the given value according to the given typed array.
   *
   * @static
   * @method
   * @param {number} value - The float value in the range `[0,1]` to normalize.
   * @param {TypedArray} array - The typed array that defines the data type of the value.
   * @return {number} The normalize value.
   */
  normalize: En,
  /**
   * Denormalizes the given value according to the given typed array.
   *
   * @static
   * @method
   * @param {number} value - The value to denormalize.
   * @param {TypedArray} array - The typed array that defines the data type of the value.
   * @return {number} The denormalize (float) value in the range `[0,1]`.
   */
  denormalize: Ls
};
class Le {
  /**
   * Constructs a new 2D vector.
   *
   * @param {number} [x=0] - The x value of this vector.
   * @param {number} [y=0] - The y value of this vector.
   */
  constructor(e = 0, t = 0) {
    Le.prototype.isVector2 = !0, this.x = e, this.y = t;
  }
  /**
   * Alias for {@link Vector2#x}.
   *
   * @type {number}
   */
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  /**
   * Alias for {@link Vector2#y}.
   *
   * @type {number}
   */
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  /**
   * Sets the vector components.
   *
   * @param {number} x - The value of the x component.
   * @param {number} y - The value of the y component.
   * @return {Vector2} A reference to this vector.
   */
  set(e, t) {
    return this.x = e, this.y = t, this;
  }
  /**
   * Sets the vector components to the same value.
   *
   * @param {number} scalar - The value to set for all vector components.
   * @return {Vector2} A reference to this vector.
   */
  setScalar(e) {
    return this.x = e, this.y = e, this;
  }
  /**
   * Sets the vector's x component to the given value
   *
   * @param {number} x - The value to set.
   * @return {Vector2} A reference to this vector.
   */
  setX(e) {
    return this.x = e, this;
  }
  /**
   * Sets the vector's y component to the given value
   *
   * @param {number} y - The value to set.
   * @return {Vector2} A reference to this vector.
   */
  setY(e) {
    return this.y = e, this;
  }
  /**
   * Allows to set a vector component with an index.
   *
   * @param {number} index - The component index. `0` equals to x, `1` equals to y.
   * @param {number} value - The value to set.
   * @return {Vector2} A reference to this vector.
   */
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  /**
   * Returns the value of the vector component which matches the given index.
   *
   * @param {number} index - The component index. `0` equals to x, `1` equals to y.
   * @return {number} A vector component value.
   */
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  /**
   * Returns a new vector with copied values from this instance.
   *
   * @return {Vector2} A clone of this instance.
   */
  clone() {
    return new this.constructor(this.x, this.y);
  }
  /**
   * Copies the values of the given vector to this instance.
   *
   * @param {Vector2} v - The vector to copy.
   * @return {Vector2} A reference to this vector.
   */
  copy(e) {
    return this.x = e.x, this.y = e.y, this;
  }
  /**
   * Adds the given vector to this instance.
   *
   * @param {Vector2} v - The vector to add.
   * @return {Vector2} A reference to this vector.
   */
  add(e) {
    return this.x += e.x, this.y += e.y, this;
  }
  /**
   * Adds the given scalar value to all components of this instance.
   *
   * @param {number} s - The scalar to add.
   * @return {Vector2} A reference to this vector.
   */
  addScalar(e) {
    return this.x += e, this.y += e, this;
  }
  /**
   * Adds the given vectors and stores the result in this instance.
   *
   * @param {Vector2} a - The first vector.
   * @param {Vector2} b - The second vector.
   * @return {Vector2} A reference to this vector.
   */
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this;
  }
  /**
   * Adds the given vector scaled by the given factor to this instance.
   *
   * @param {Vector2} v - The vector.
   * @param {number} s - The factor that scales `v`.
   * @return {Vector2} A reference to this vector.
   */
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this;
  }
  /**
   * Subtracts the given vector from this instance.
   *
   * @param {Vector2} v - The vector to subtract.
   * @return {Vector2} A reference to this vector.
   */
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this;
  }
  /**
   * Subtracts the given scalar value from all components of this instance.
   *
   * @param {number} s - The scalar to subtract.
   * @return {Vector2} A reference to this vector.
   */
  subScalar(e) {
    return this.x -= e, this.y -= e, this;
  }
  /**
   * Subtracts the given vectors and stores the result in this instance.
   *
   * @param {Vector2} a - The first vector.
   * @param {Vector2} b - The second vector.
   * @return {Vector2} A reference to this vector.
   */
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this;
  }
  /**
   * Multiplies the given vector with this instance.
   *
   * @param {Vector2} v - The vector to multiply.
   * @return {Vector2} A reference to this vector.
   */
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this;
  }
  /**
   * Multiplies the given scalar value with all components of this instance.
   *
   * @param {number} scalar - The scalar to multiply.
   * @return {Vector2} A reference to this vector.
   */
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this;
  }
  /**
   * Divides this instance by the given vector.
   *
   * @param {Vector2} v - The vector to divide.
   * @return {Vector2} A reference to this vector.
   */
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this;
  }
  /**
   * Divides this vector by the given scalar.
   *
   * @param {number} scalar - The scalar to divide.
   * @return {Vector2} A reference to this vector.
   */
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  /**
   * Multiplies this vector (with an implicit 1 as the 3rd component) by
   * the given 3x3 matrix.
   *
   * @param {Matrix3} m - The matrix to apply.
   * @return {Vector2} A reference to this vector.
   */
  applyMatrix3(e) {
    const t = this.x, n = this.y, r = e.elements;
    return this.x = r[0] * t + r[3] * n + r[6], this.y = r[1] * t + r[4] * n + r[7], this;
  }
  /**
   * If this vector's x or y value is greater than the given vector's x or y
   * value, replace that value with the corresponding min value.
   *
   * @param {Vector2} v - The vector.
   * @return {Vector2} A reference to this vector.
   */
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this;
  }
  /**
   * If this vector's x or y value is less than the given vector's x or y
   * value, replace that value with the corresponding max value.
   *
   * @param {Vector2} v - The vector.
   * @return {Vector2} A reference to this vector.
   */
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this;
  }
  /**
   * If this vector's x or y value is greater than the max vector's x or y
   * value, it is replaced by the corresponding value.
   * If this vector's x or y value is less than the min vector's x or y value,
   * it is replaced by the corresponding value.
   *
   * @param {Vector2} min - The minimum x and y values.
   * @param {Vector2} max - The maximum x and y values in the desired range.
   * @return {Vector2} A reference to this vector.
   */
  clamp(e, t) {
    return this.x = dn(this.x, e.x, t.x), this.y = dn(this.y, e.y, t.y), this;
  }
  /**
   * If this vector's x or y values are greater than the max value, they are
   * replaced by the max value.
   * If this vector's x or y values are less than the min value, they are
   * replaced by the min value.
   *
   * @param {number} minVal - The minimum value the components will be clamped to.
   * @param {number} maxVal - The maximum value the components will be clamped to.
   * @return {Vector2} A reference to this vector.
   */
  clampScalar(e, t) {
    return this.x = dn(this.x, e, t), this.y = dn(this.y, e, t), this;
  }
  /**
   * If this vector's length is greater than the max value, it is replaced by
   * the max value.
   * If this vector's length is less than the min value, it is replaced by the
   * min value.
   *
   * @param {number} min - The minimum value the vector length will be clamped to.
   * @param {number} max - The maximum value the vector length will be clamped to.
   * @return {Vector2} A reference to this vector.
   */
  clampLength(e, t) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(dn(n, e, t));
  }
  /**
   * The components of this vector are rounded down to the nearest integer value.
   *
   * @return {Vector2} A reference to this vector.
   */
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
  }
  /**
   * The components of this vector are rounded up to the nearest integer value.
   *
   * @return {Vector2} A reference to this vector.
   */
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
  }
  /**
   * The components of this vector are rounded to the nearest integer value
   *
   * @return {Vector2} A reference to this vector.
   */
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  }
  /**
   * The components of this vector are rounded towards zero (up if negative,
   * down if positive) to an integer value.
   *
   * @return {Vector2} A reference to this vector.
   */
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this;
  }
  /**
   * Inverts this vector - i.e. sets x = -x and y = -y.
   *
   * @return {Vector2} A reference to this vector.
   */
  negate() {
    return this.x = -this.x, this.y = -this.y, this;
  }
  /**
   * Calculates the dot product of the given vector with this instance.
   *
   * @param {Vector2} v - The vector to compute the dot product with.
   * @return {number} The result of the dot product.
   */
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  /**
   * Calculates the cross product of the given vector with this instance.
   *
   * @param {Vector2} v - The vector to compute the cross product with.
   * @return {number} The result of the cross product.
   */
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  /**
   * Computes the square of the Euclidean length (straight-line length) from
   * (0, 0) to (x, y). If you are comparing the lengths of vectors, you should
   * compare the length squared instead as it is slightly more efficient to calculate.
   *
   * @return {number} The square length of this vector.
   */
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  /**
   * Computes the  Euclidean length (straight-line length) from (0, 0) to (x, y).
   *
   * @return {number} The length of this vector.
   */
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  /**
   * Computes the Manhattan length of this vector.
   *
   * @return {number} The length of this vector.
   */
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  /**
   * Converts this vector to a unit vector - that is, sets it equal to a vector
   * with the same direction as this one, but with a vector length of `1`.
   *
   * @return {Vector2} A reference to this vector.
   */
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  /**
   * Computes the angle in radians of this vector with respect to the positive x-axis.
   *
   * @return {number} The angle in radians.
   */
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  /**
   * Returns the angle between the given vector and this instance in radians.
   *
   * @param {Vector2} v - The vector to compute the angle with.
   * @return {number} The angle in radians.
   */
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const n = this.dot(e) / t;
    return Math.acos(dn(n, -1, 1));
  }
  /**
   * Computes the distance from the given vector to this instance.
   *
   * @param {Vector2} v - The vector to compute the distance to.
   * @return {number} The distance.
   */
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  /**
   * Computes the squared distance from the given vector to this instance.
   * If you are just comparing the distance with another distance, you should compare
   * the distance squared instead as it is slightly more efficient to calculate.
   *
   * @param {Vector2} v - The vector to compute the squared distance to.
   * @return {number} The squared distance.
   */
  distanceToSquared(e) {
    const t = this.x - e.x, n = this.y - e.y;
    return t * t + n * n;
  }
  /**
   * Computes the Manhattan distance from the given vector to this instance.
   *
   * @param {Vector2} v - The vector to compute the Manhattan distance to.
   * @return {number} The Manhattan distance.
   */
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  /**
   * Sets this vector to a vector with the same direction as this one, but
   * with the specified length.
   *
   * @param {number} length - The new length of this vector.
   * @return {Vector2} A reference to this vector.
   */
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  /**
   * Linearly interpolates between the given vector and this instance, where
   * alpha is the percent distance along the line - alpha = 0 will be this
   * vector, and alpha = 1 will be the given one.
   *
   * @param {Vector2} v - The vector to interpolate towards.
   * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
   * @return {Vector2} A reference to this vector.
   */
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this;
  }
  /**
   * Linearly interpolates between the given vectors, where alpha is the percent
   * distance along the line - alpha = 0 will be first vector, and alpha = 1 will
   * be the second one. The result is stored in this instance.
   *
   * @param {Vector2} v1 - The first vector.
   * @param {Vector2} v2 - The second vector.
   * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
   * @return {Vector2} A reference to this vector.
   */
  lerpVectors(e, t, n) {
    return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this;
  }
  /**
   * Returns `true` if this vector is equal with the given one.
   *
   * @param {Vector2} v - The vector to test for equality.
   * @return {boolean} Whether this vector is equal with the given one.
   */
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  /**
   * Sets this vector's x value to be `array[ offset ]` and y
   * value to be `array[ offset + 1 ]`.
   *
   * @param {Array<number>} array - An array holding the vector component values.
   * @param {number} [offset=0] - The offset into the array.
   * @return {Vector2} A reference to this vector.
   */
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this;
  }
  /**
   * Writes the components of this vector to the given array. If no array is provided,
   * the method returns a new instance.
   *
   * @param {Array<number>} [array=[]] - The target array holding the vector components.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Array<number>} The vector components.
   */
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e;
  }
  /**
   * Sets the components of this vector from the given buffer attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute holding vector data.
   * @param {number} index - The index into the attribute.
   * @return {Vector2} A reference to this vector.
   */
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this;
  }
  /**
   * Rotates this vector around the given center by the given angle.
   *
   * @param {Vector2} center - The point around which to rotate.
   * @param {number} angle - The angle to rotate, in radians.
   * @return {Vector2} A reference to this vector.
   */
  rotateAround(e, t) {
    const n = Math.cos(t), r = Math.sin(t), s = this.x - e.x, o = this.y - e.y;
    return this.x = s * n - o * r + e.x, this.y = s * r + o * n + e.y, this;
  }
  /**
   * Sets each component of this vector to a pseudo-random value between `0` and
   * `1`, excluding `1`.
   *
   * @return {Vector2} A reference to this vector.
   */
  random() {
    return this.x = Math.random(), this.y = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class hr {
  /**
   * Constructs a new quaternion.
   *
   * @param {number} [x=0] - The x value of this quaternion.
   * @param {number} [y=0] - The y value of this quaternion.
   * @param {number} [z=0] - The z value of this quaternion.
   * @param {number} [w=1] - The w value of this quaternion.
   */
  constructor(e = 0, t = 0, n = 0, r = 1) {
    this.isQuaternion = !0, this._x = e, this._y = t, this._z = n, this._w = r;
  }
  /**
   * Interpolates between two quaternions via SLERP. This implementation assumes the
   * quaternion data are managed in flat arrays.
   *
   * @param {Array<number>} dst - The destination array.
   * @param {number} dstOffset - An offset into the destination array.
   * @param {Array<number>} src0 - The source array of the first quaternion.
   * @param {number} srcOffset0 - An offset into the first source array.
   * @param {Array<number>} src1 -  The source array of the second quaternion.
   * @param {number} srcOffset1 - An offset into the second source array.
   * @param {number} t - The interpolation factor in the range `[0,1]`.
   * @see {@link Quaternion#slerp}
   */
  static slerpFlat(e, t, n, r, s, o, a) {
    let l = n[r + 0], u = n[r + 1], c = n[r + 2], A = n[r + 3], m = s[o + 0], _ = s[o + 1], y = s[o + 2], T = s[o + 3];
    if (a <= 0) {
      e[t + 0] = l, e[t + 1] = u, e[t + 2] = c, e[t + 3] = A;
      return;
    }
    if (a >= 1) {
      e[t + 0] = m, e[t + 1] = _, e[t + 2] = y, e[t + 3] = T;
      return;
    }
    if (A !== T || l !== m || u !== _ || c !== y) {
      let b = l * m + u * _ + c * y + A * T;
      b < 0 && (m = -m, _ = -_, y = -y, T = -T, b = -b);
      let S = 1 - a;
      if (b < 0.9995) {
        const E = Math.acos(b), R = Math.sin(E);
        S = Math.sin(S * E) / R, a = Math.sin(a * E) / R, l = l * S + m * a, u = u * S + _ * a, c = c * S + y * a, A = A * S + T * a;
      } else {
        l = l * S + m * a, u = u * S + _ * a, c = c * S + y * a, A = A * S + T * a;
        const E = 1 / Math.sqrt(l * l + u * u + c * c + A * A);
        l *= E, u *= E, c *= E, A *= E;
      }
    }
    e[t] = l, e[t + 1] = u, e[t + 2] = c, e[t + 3] = A;
  }
  /**
   * Multiplies two quaternions. This implementation assumes the quaternion data are managed
   * in flat arrays.
   *
   * @param {Array<number>} dst - The destination array.
   * @param {number} dstOffset - An offset into the destination array.
   * @param {Array<number>} src0 - The source array of the first quaternion.
   * @param {number} srcOffset0 - An offset into the first source array.
   * @param {Array<number>} src1 -  The source array of the second quaternion.
   * @param {number} srcOffset1 - An offset into the second source array.
   * @return {Array<number>} The destination array.
   * @see {@link Quaternion#multiplyQuaternions}.
   */
  static multiplyQuaternionsFlat(e, t, n, r, s, o) {
    const a = n[r], l = n[r + 1], u = n[r + 2], c = n[r + 3], A = s[o], m = s[o + 1], _ = s[o + 2], y = s[o + 3];
    return e[t] = a * y + c * A + l * _ - u * m, e[t + 1] = l * y + c * m + u * A - a * _, e[t + 2] = u * y + c * _ + a * m - l * A, e[t + 3] = c * y - a * A - l * m - u * _, e;
  }
  /**
   * The x value of this quaternion.
   *
   * @type {number}
   * @default 0
   */
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  /**
   * The y value of this quaternion.
   *
   * @type {number}
   * @default 0
   */
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  /**
   * The z value of this quaternion.
   *
   * @type {number}
   * @default 0
   */
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  /**
   * The w value of this quaternion.
   *
   * @type {number}
   * @default 1
   */
  get w() {
    return this._w;
  }
  set w(e) {
    this._w = e, this._onChangeCallback();
  }
  /**
   * Sets the quaternion components.
   *
   * @param {number} x - The x value of this quaternion.
   * @param {number} y - The y value of this quaternion.
   * @param {number} z - The z value of this quaternion.
   * @param {number} w - The w value of this quaternion.
   * @return {Quaternion} A reference to this quaternion.
   */
  set(e, t, n, r) {
    return this._x = e, this._y = t, this._z = n, this._w = r, this._onChangeCallback(), this;
  }
  /**
   * Returns a new quaternion with copied values from this instance.
   *
   * @return {Quaternion} A clone of this instance.
   */
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  /**
   * Copies the values of the given quaternion to this instance.
   *
   * @param {Quaternion} quaternion - The quaternion to copy.
   * @return {Quaternion} A reference to this quaternion.
   */
  copy(e) {
    return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this;
  }
  /**
   * Sets this quaternion from the rotation specified by the given
   * Euler angles.
   *
   * @param {Euler} euler - The Euler angles.
   * @param {boolean} [update=true] - Whether the internal `onChange` callback should be executed or not.
   * @return {Quaternion} A reference to this quaternion.
   */
  setFromEuler(e, t = !0) {
    const n = e._x, r = e._y, s = e._z, o = e._order, a = Math.cos, l = Math.sin, u = a(n / 2), c = a(r / 2), A = a(s / 2), m = l(n / 2), _ = l(r / 2), y = l(s / 2);
    switch (o) {
      case "XYZ":
        this._x = m * c * A + u * _ * y, this._y = u * _ * A - m * c * y, this._z = u * c * y + m * _ * A, this._w = u * c * A - m * _ * y;
        break;
      case "YXZ":
        this._x = m * c * A + u * _ * y, this._y = u * _ * A - m * c * y, this._z = u * c * y - m * _ * A, this._w = u * c * A + m * _ * y;
        break;
      case "ZXY":
        this._x = m * c * A - u * _ * y, this._y = u * _ * A + m * c * y, this._z = u * c * y + m * _ * A, this._w = u * c * A - m * _ * y;
        break;
      case "ZYX":
        this._x = m * c * A - u * _ * y, this._y = u * _ * A + m * c * y, this._z = u * c * y - m * _ * A, this._w = u * c * A + m * _ * y;
        break;
      case "YZX":
        this._x = m * c * A + u * _ * y, this._y = u * _ * A + m * c * y, this._z = u * c * y - m * _ * A, this._w = u * c * A - m * _ * y;
        break;
      case "XZY":
        this._x = m * c * A - u * _ * y, this._y = u * _ * A - m * c * y, this._z = u * c * y + m * _ * A, this._w = u * c * A + m * _ * y;
        break;
      default:
        Me("Quaternion: .setFromEuler() encountered an unknown order: " + o);
    }
    return t === !0 && this._onChangeCallback(), this;
  }
  /**
   * Sets this quaternion from the given axis and angle.
   *
   * @param {Vector3} axis - The normalized axis.
   * @param {number} angle - The angle in radians.
   * @return {Quaternion} A reference to this quaternion.
   */
  setFromAxisAngle(e, t) {
    const n = t / 2, r = Math.sin(n);
    return this._x = e.x * r, this._y = e.y * r, this._z = e.z * r, this._w = Math.cos(n), this._onChangeCallback(), this;
  }
  /**
   * Sets this quaternion from the given rotation matrix.
   *
   * @param {Matrix4} m - A 4x4 matrix of which the upper 3x3 of matrix is a pure rotation matrix (i.e. unscaled).
   * @return {Quaternion} A reference to this quaternion.
   */
  setFromRotationMatrix(e) {
    const t = e.elements, n = t[0], r = t[4], s = t[8], o = t[1], a = t[5], l = t[9], u = t[2], c = t[6], A = t[10], m = n + a + A;
    if (m > 0) {
      const _ = 0.5 / Math.sqrt(m + 1);
      this._w = 0.25 / _, this._x = (c - l) * _, this._y = (s - u) * _, this._z = (o - r) * _;
    } else if (n > a && n > A) {
      const _ = 2 * Math.sqrt(1 + n - a - A);
      this._w = (c - l) / _, this._x = 0.25 * _, this._y = (r + o) / _, this._z = (s + u) / _;
    } else if (a > A) {
      const _ = 2 * Math.sqrt(1 + a - n - A);
      this._w = (s - u) / _, this._x = (r + o) / _, this._y = 0.25 * _, this._z = (l + c) / _;
    } else {
      const _ = 2 * Math.sqrt(1 + A - n - a);
      this._w = (o - r) / _, this._x = (s + u) / _, this._y = (l + c) / _, this._z = 0.25 * _;
    }
    return this._onChangeCallback(), this;
  }
  /**
   * Sets this quaternion to the rotation required to rotate the direction vector
   * `vFrom` to the direction vector `vTo`.
   *
   * @param {Vector3} vFrom - The first (normalized) direction vector.
   * @param {Vector3} vTo - The second (normalized) direction vector.
   * @return {Quaternion} A reference to this quaternion.
   */
  setFromUnitVectors(e, t) {
    let n = e.dot(t) + 1;
    return n < 1e-8 ? (n = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = n)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = n), this.normalize();
  }
  /**
   * Returns the angle between this quaternion and the given one in radians.
   *
   * @param {Quaternion} q - The quaternion to compute the angle with.
   * @return {number} The angle in radians.
   */
  angleTo(e) {
    return 2 * Math.acos(Math.abs(dn(this.dot(e), -1, 1)));
  }
  /**
   * Rotates this quaternion by a given angular step to the given quaternion.
   * The method ensures that the final quaternion will not overshoot `q`.
   *
   * @param {Quaternion} q - The target quaternion.
   * @param {number} step - The angular step in radians.
   * @return {Quaternion} A reference to this quaternion.
   */
  rotateTowards(e, t) {
    const n = this.angleTo(e);
    if (n === 0) return this;
    const r = Math.min(1, t / n);
    return this.slerp(e, r), this;
  }
  /**
   * Sets this quaternion to the identity quaternion; that is, to the
   * quaternion that represents "no rotation".
   *
   * @return {Quaternion} A reference to this quaternion.
   */
  identity() {
    return this.set(0, 0, 0, 1);
  }
  /**
   * Inverts this quaternion via {@link Quaternion#conjugate}. The
   * quaternion is assumed to have unit length.
   *
   * @return {Quaternion} A reference to this quaternion.
   */
  invert() {
    return this.conjugate();
  }
  /**
   * Returns the rotational conjugate of this quaternion. The conjugate of a
   * quaternion represents the same rotation in the opposite direction about
   * the rotational axis.
   *
   * @return {Quaternion} A reference to this quaternion.
   */
  conjugate() {
    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
  }
  /**
   * Calculates the dot product of this quaternion and the given one.
   *
   * @param {Quaternion} v - The quaternion to compute the dot product with.
   * @return {number} The result of the dot product.
   */
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  /**
   * Computes the squared Euclidean length (straight-line length) of this quaternion,
   * considered as a 4 dimensional vector. This can be useful if you are comparing the
   * lengths of two quaternions, as this is a slightly more efficient calculation than
   * {@link Quaternion#length}.
   *
   * @return {number} The squared Euclidean length.
   */
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  /**
   * Computes the Euclidean length (straight-line length) of this quaternion,
   * considered as a 4 dimensional vector.
   *
   * @return {number} The Euclidean length.
   */
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  /**
   * Normalizes this quaternion - that is, calculated the quaternion that performs
   * the same rotation as this one, but has a length equal to `1`.
   *
   * @return {Quaternion} A reference to this quaternion.
   */
  normalize() {
    let e = this.length();
    return e === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this;
  }
  /**
   * Multiplies this quaternion by the given one.
   *
   * @param {Quaternion} q - The quaternion.
   * @return {Quaternion} A reference to this quaternion.
   */
  multiply(e) {
    return this.multiplyQuaternions(this, e);
  }
  /**
   * Pre-multiplies this quaternion by the given one.
   *
   * @param {Quaternion} q - The quaternion.
   * @return {Quaternion} A reference to this quaternion.
   */
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  /**
   * Multiplies the given quaternions and stores the result in this instance.
   *
   * @param {Quaternion} a - The first quaternion.
   * @param {Quaternion} b - The second quaternion.
   * @return {Quaternion} A reference to this quaternion.
   */
  multiplyQuaternions(e, t) {
    const n = e._x, r = e._y, s = e._z, o = e._w, a = t._x, l = t._y, u = t._z, c = t._w;
    return this._x = n * c + o * a + r * u - s * l, this._y = r * c + o * l + s * a - n * u, this._z = s * c + o * u + n * l - r * a, this._w = o * c - n * a - r * l - s * u, this._onChangeCallback(), this;
  }
  /**
   * Performs a spherical linear interpolation between quaternions.
   *
   * @param {Quaternion} qb - The target quaternion.
   * @param {number} t - The interpolation factor in the closed interval `[0, 1]`.
   * @return {Quaternion} A reference to this quaternion.
   */
  slerp(e, t) {
    if (t <= 0) return this;
    if (t >= 1) return this.copy(e);
    let n = e._x, r = e._y, s = e._z, o = e._w, a = this.dot(e);
    a < 0 && (n = -n, r = -r, s = -s, o = -o, a = -a);
    let l = 1 - t;
    if (a < 0.9995) {
      const u = Math.acos(a), c = Math.sin(u);
      l = Math.sin(l * u) / c, t = Math.sin(t * u) / c, this._x = this._x * l + n * t, this._y = this._y * l + r * t, this._z = this._z * l + s * t, this._w = this._w * l + o * t, this._onChangeCallback();
    } else
      this._x = this._x * l + n * t, this._y = this._y * l + r * t, this._z = this._z * l + s * t, this._w = this._w * l + o * t, this.normalize();
    return this;
  }
  /**
   * Performs a spherical linear interpolation between the given quaternions
   * and stores the result in this quaternion.
   *
   * @param {Quaternion} qa - The source quaternion.
   * @param {Quaternion} qb - The target quaternion.
   * @param {number} t - The interpolation factor in the closed interval `[0, 1]`.
   * @return {Quaternion} A reference to this quaternion.
   */
  slerpQuaternions(e, t, n) {
    return this.copy(e).slerp(t, n);
  }
  /**
   * Sets this quaternion to a uniformly random, normalized quaternion.
   *
   * @return {Quaternion} A reference to this quaternion.
   */
  random() {
    const e = 2 * Math.PI * Math.random(), t = 2 * Math.PI * Math.random(), n = Math.random(), r = Math.sqrt(1 - n), s = Math.sqrt(n);
    return this.set(
      r * Math.sin(e),
      r * Math.cos(e),
      s * Math.sin(t),
      s * Math.cos(t)
    );
  }
  /**
   * Returns `true` if this quaternion is equal with the given one.
   *
   * @param {Quaternion} quaternion - The quaternion to test for equality.
   * @return {boolean} Whether this quaternion is equal with the given one.
   */
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w;
  }
  /**
   * Sets this quaternion's components from the given array.
   *
   * @param {Array<number>} array - An array holding the quaternion component values.
   * @param {number} [offset=0] - The offset into the array.
   * @return {Quaternion} A reference to this quaternion.
   */
  fromArray(e, t = 0) {
    return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this;
  }
  /**
   * Writes the components of this quaternion to the given array. If no array is provided,
   * the method returns a new instance.
   *
   * @param {Array<number>} [array=[]] - The target array holding the quaternion components.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Array<number>} The quaternion components.
   */
  toArray(e = [], t = 0) {
    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e;
  }
  /**
   * Sets the components of this quaternion from the given buffer attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute holding quaternion data.
   * @param {number} index - The index into the attribute.
   * @return {Quaternion} A reference to this quaternion.
   */
  fromBufferAttribute(e, t) {
    return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this._onChangeCallback(), this;
  }
  /**
   * This methods defines the serialization result of this class. Returns the
   * numerical elements of this quaternion in an array of format `[x, y, z, w]`.
   *
   * @return {Array<number>} The serialized quaternion.
   */
  toJSON() {
    return this.toArray();
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class j {
  /**
   * Constructs a new 3D vector.
   *
   * @param {number} [x=0] - The x value of this vector.
   * @param {number} [y=0] - The y value of this vector.
   * @param {number} [z=0] - The z value of this vector.
   */
  constructor(e = 0, t = 0, n = 0) {
    j.prototype.isVector3 = !0, this.x = e, this.y = t, this.z = n;
  }
  /**
   * Sets the vector components.
   *
   * @param {number} x - The value of the x component.
   * @param {number} y - The value of the y component.
   * @param {number} z - The value of the z component.
   * @return {Vector3} A reference to this vector.
   */
  set(e, t, n) {
    return n === void 0 && (n = this.z), this.x = e, this.y = t, this.z = n, this;
  }
  /**
   * Sets the vector components to the same value.
   *
   * @param {number} scalar - The value to set for all vector components.
   * @return {Vector3} A reference to this vector.
   */
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this;
  }
  /**
   * Sets the vector's x component to the given value
   *
   * @param {number} x - The value to set.
   * @return {Vector3} A reference to this vector.
   */
  setX(e) {
    return this.x = e, this;
  }
  /**
   * Sets the vector's y component to the given value
   *
   * @param {number} y - The value to set.
   * @return {Vector3} A reference to this vector.
   */
  setY(e) {
    return this.y = e, this;
  }
  /**
   * Sets the vector's z component to the given value
   *
   * @param {number} z - The value to set.
   * @return {Vector3} A reference to this vector.
   */
  setZ(e) {
    return this.z = e, this;
  }
  /**
   * Allows to set a vector component with an index.
   *
   * @param {number} index - The component index. `0` equals to x, `1` equals to y, `2` equals to z.
   * @param {number} value - The value to set.
   * @return {Vector3} A reference to this vector.
   */
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  /**
   * Returns the value of the vector component which matches the given index.
   *
   * @param {number} index - The component index. `0` equals to x, `1` equals to y, `2` equals to z.
   * @return {number} A vector component value.
   */
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  /**
   * Returns a new vector with copied values from this instance.
   *
   * @return {Vector3} A clone of this instance.
   */
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  /**
   * Copies the values of the given vector to this instance.
   *
   * @param {Vector3} v - The vector to copy.
   * @return {Vector3} A reference to this vector.
   */
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this;
  }
  /**
   * Adds the given vector to this instance.
   *
   * @param {Vector3} v - The vector to add.
   * @return {Vector3} A reference to this vector.
   */
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this;
  }
  /**
   * Adds the given scalar value to all components of this instance.
   *
   * @param {number} s - The scalar to add.
   * @return {Vector3} A reference to this vector.
   */
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this;
  }
  /**
   * Adds the given vectors and stores the result in this instance.
   *
   * @param {Vector3} a - The first vector.
   * @param {Vector3} b - The second vector.
   * @return {Vector3} A reference to this vector.
   */
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this;
  }
  /**
   * Adds the given vector scaled by the given factor to this instance.
   *
   * @param {Vector3|Vector4} v - The vector.
   * @param {number} s - The factor that scales `v`.
   * @return {Vector3} A reference to this vector.
   */
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this;
  }
  /**
   * Subtracts the given vector from this instance.
   *
   * @param {Vector3} v - The vector to subtract.
   * @return {Vector3} A reference to this vector.
   */
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this;
  }
  /**
   * Subtracts the given scalar value from all components of this instance.
   *
   * @param {number} s - The scalar to subtract.
   * @return {Vector3} A reference to this vector.
   */
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this;
  }
  /**
   * Subtracts the given vectors and stores the result in this instance.
   *
   * @param {Vector3} a - The first vector.
   * @param {Vector3} b - The second vector.
   * @return {Vector3} A reference to this vector.
   */
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this;
  }
  /**
   * Multiplies the given vector with this instance.
   *
   * @param {Vector3} v - The vector to multiply.
   * @return {Vector3} A reference to this vector.
   */
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this;
  }
  /**
   * Multiplies the given scalar value with all components of this instance.
   *
   * @param {number} scalar - The scalar to multiply.
   * @return {Vector3} A reference to this vector.
   */
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this;
  }
  /**
   * Multiplies the given vectors and stores the result in this instance.
   *
   * @param {Vector3} a - The first vector.
   * @param {Vector3} b - The second vector.
   * @return {Vector3} A reference to this vector.
   */
  multiplyVectors(e, t) {
    return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this;
  }
  /**
   * Applies the given Euler rotation to this vector.
   *
   * @param {Euler} euler - The Euler angles.
   * @return {Vector3} A reference to this vector.
   */
  applyEuler(e) {
    return this.applyQuaternion(fM.setFromEuler(e));
  }
  /**
   * Applies a rotation specified by an axis and an angle to this vector.
   *
   * @param {Vector3} axis - A normalized vector representing the rotation axis.
   * @param {number} angle - The angle in radians.
   * @return {Vector3} A reference to this vector.
   */
  applyAxisAngle(e, t) {
    return this.applyQuaternion(fM.setFromAxisAngle(e, t));
  }
  /**
   * Multiplies this vector with the given 3x3 matrix.
   *
   * @param {Matrix3} m - The 3x3 matrix.
   * @return {Vector3} A reference to this vector.
   */
  applyMatrix3(e) {
    const t = this.x, n = this.y, r = this.z, s = e.elements;
    return this.x = s[0] * t + s[3] * n + s[6] * r, this.y = s[1] * t + s[4] * n + s[7] * r, this.z = s[2] * t + s[5] * n + s[8] * r, this;
  }
  /**
   * Multiplies this vector by the given normal matrix and normalizes
   * the result.
   *
   * @param {Matrix3} m - The normal matrix.
   * @return {Vector3} A reference to this vector.
   */
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  /**
   * Multiplies this vector (with an implicit 1 in the 4th dimension) by m, and
   * divides by perspective.
   *
   * @param {Matrix4} m - The matrix to apply.
   * @return {Vector3} A reference to this vector.
   */
  applyMatrix4(e) {
    const t = this.x, n = this.y, r = this.z, s = e.elements, o = 1 / (s[3] * t + s[7] * n + s[11] * r + s[15]);
    return this.x = (s[0] * t + s[4] * n + s[8] * r + s[12]) * o, this.y = (s[1] * t + s[5] * n + s[9] * r + s[13]) * o, this.z = (s[2] * t + s[6] * n + s[10] * r + s[14]) * o, this;
  }
  /**
   * Applies the given Quaternion to this vector.
   *
   * @param {Quaternion} q - The Quaternion.
   * @return {Vector3} A reference to this vector.
   */
  applyQuaternion(e) {
    const t = this.x, n = this.y, r = this.z, s = e.x, o = e.y, a = e.z, l = e.w, u = 2 * (o * r - a * n), c = 2 * (a * t - s * r), A = 2 * (s * n - o * t);
    return this.x = t + l * u + o * A - a * c, this.y = n + l * c + a * u - s * A, this.z = r + l * A + s * c - o * u, this;
  }
  /**
   * Projects this vector from world space into the camera's normalized
   * device coordinate (NDC) space.
   *
   * @param {Camera} camera - The camera.
   * @return {Vector3} A reference to this vector.
   */
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix);
  }
  /**
   * Unprojects this vector from the camera's normalized device coordinate (NDC)
   * space into world space.
   *
   * @param {Camera} camera - The camera.
   * @return {Vector3} A reference to this vector.
   */
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld);
  }
  /**
   * Transforms the direction of this vector by a matrix (the upper left 3 x 3
   * subset of the given 4x4 matrix and then normalizes the result.
   *
   * @param {Matrix4} m - The matrix.
   * @return {Vector3} A reference to this vector.
   */
  transformDirection(e) {
    const t = this.x, n = this.y, r = this.z, s = e.elements;
    return this.x = s[0] * t + s[4] * n + s[8] * r, this.y = s[1] * t + s[5] * n + s[9] * r, this.z = s[2] * t + s[6] * n + s[10] * r, this.normalize();
  }
  /**
   * Divides this instance by the given vector.
   *
   * @param {Vector3} v - The vector to divide.
   * @return {Vector3} A reference to this vector.
   */
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this;
  }
  /**
   * Divides this vector by the given scalar.
   *
   * @param {number} scalar - The scalar to divide.
   * @return {Vector3} A reference to this vector.
   */
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  /**
   * If this vector's x, y or z value is greater than the given vector's x, y or z
   * value, replace that value with the corresponding min value.
   *
   * @param {Vector3} v - The vector.
   * @return {Vector3} A reference to this vector.
   */
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this;
  }
  /**
   * If this vector's x, y or z value is less than the given vector's x, y or z
   * value, replace that value with the corresponding max value.
   *
   * @param {Vector3} v - The vector.
   * @return {Vector3} A reference to this vector.
   */
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this;
  }
  /**
   * If this vector's x, y or z value is greater than the max vector's x, y or z
   * value, it is replaced by the corresponding value.
   * If this vector's x, y or z value is less than the min vector's x, y or z value,
   * it is replaced by the corresponding value.
   *
   * @param {Vector3} min - The minimum x, y and z values.
   * @param {Vector3} max - The maximum x, y and z values in the desired range.
   * @return {Vector3} A reference to this vector.
   */
  clamp(e, t) {
    return this.x = dn(this.x, e.x, t.x), this.y = dn(this.y, e.y, t.y), this.z = dn(this.z, e.z, t.z), this;
  }
  /**
   * If this vector's x, y or z values are greater than the max value, they are
   * replaced by the max value.
   * If this vector's x, y or z values are less than the min value, they are
   * replaced by the min value.
   *
   * @param {number} minVal - The minimum value the components will be clamped to.
   * @param {number} maxVal - The maximum value the components will be clamped to.
   * @return {Vector3} A reference to this vector.
   */
  clampScalar(e, t) {
    return this.x = dn(this.x, e, t), this.y = dn(this.y, e, t), this.z = dn(this.z, e, t), this;
  }
  /**
   * If this vector's length is greater than the max value, it is replaced by
   * the max value.
   * If this vector's length is less than the min value, it is replaced by the
   * min value.
   *
   * @param {number} min - The minimum value the vector length will be clamped to.
   * @param {number} max - The maximum value the vector length will be clamped to.
   * @return {Vector3} A reference to this vector.
   */
  clampLength(e, t) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(dn(n, e, t));
  }
  /**
   * The components of this vector are rounded down to the nearest integer value.
   *
   * @return {Vector3} A reference to this vector.
   */
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
  }
  /**
   * The components of this vector are rounded up to the nearest integer value.
   *
   * @return {Vector3} A reference to this vector.
   */
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
  }
  /**
   * The components of this vector are rounded to the nearest integer value
   *
   * @return {Vector3} A reference to this vector.
   */
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
  }
  /**
   * The components of this vector are rounded towards zero (up if negative,
   * down if positive) to an integer value.
   *
   * @return {Vector3} A reference to this vector.
   */
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this;
  }
  /**
   * Inverts this vector - i.e. sets x = -x, y = -y and z = -z.
   *
   * @return {Vector3} A reference to this vector.
   */
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
  }
  /**
   * Calculates the dot product of the given vector with this instance.
   *
   * @param {Vector3} v - The vector to compute the dot product with.
   * @return {number} The result of the dot product.
   */
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  /**
   * Computes the square of the Euclidean length (straight-line length) from
   * (0, 0, 0) to (x, y, z). If you are comparing the lengths of vectors, you should
   * compare the length squared instead as it is slightly more efficient to calculate.
   *
   * @return {number} The square length of this vector.
   */
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  /**
   * Computes the  Euclidean length (straight-line length) from (0, 0, 0) to (x, y, z).
   *
   * @return {number} The length of this vector.
   */
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  /**
   * Computes the Manhattan length of this vector.
   *
   * @return {number} The length of this vector.
   */
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  /**
   * Converts this vector to a unit vector - that is, sets it equal to a vector
   * with the same direction as this one, but with a vector length of `1`.
   *
   * @return {Vector3} A reference to this vector.
   */
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  /**
   * Sets this vector to a vector with the same direction as this one, but
   * with the specified length.
   *
   * @param {number} length - The new length of this vector.
   * @return {Vector3} A reference to this vector.
   */
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  /**
   * Linearly interpolates between the given vector and this instance, where
   * alpha is the percent distance along the line - alpha = 0 will be this
   * vector, and alpha = 1 will be the given one.
   *
   * @param {Vector3} v - The vector to interpolate towards.
   * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
   * @return {Vector3} A reference to this vector.
   */
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this;
  }
  /**
   * Linearly interpolates between the given vectors, where alpha is the percent
   * distance along the line - alpha = 0 will be first vector, and alpha = 1 will
   * be the second one. The result is stored in this instance.
   *
   * @param {Vector3} v1 - The first vector.
   * @param {Vector3} v2 - The second vector.
   * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
   * @return {Vector3} A reference to this vector.
   */
  lerpVectors(e, t, n) {
    return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this;
  }
  /**
   * Calculates the cross product of the given vector with this instance.
   *
   * @param {Vector3} v - The vector to compute the cross product with.
   * @return {Vector3} The result of the cross product.
   */
  cross(e) {
    return this.crossVectors(this, e);
  }
  /**
   * Calculates the cross product of the given vectors and stores the result
   * in this instance.
   *
   * @param {Vector3} a - The first vector.
   * @param {Vector3} b - The second vector.
   * @return {Vector3} A reference to this vector.
   */
  crossVectors(e, t) {
    const n = e.x, r = e.y, s = e.z, o = t.x, a = t.y, l = t.z;
    return this.x = r * l - s * a, this.y = s * o - n * l, this.z = n * a - r * o, this;
  }
  /**
   * Projects this vector onto the given one.
   *
   * @param {Vector3} v - The vector to project to.
   * @return {Vector3} A reference to this vector.
   */
  projectOnVector(e) {
    const t = e.lengthSq();
    if (t === 0) return this.set(0, 0, 0);
    const n = e.dot(this) / t;
    return this.copy(e).multiplyScalar(n);
  }
  /**
   * Projects this vector onto a plane by subtracting this
   * vector projected onto the plane's normal from this vector.
   *
   * @param {Vector3} planeNormal - The plane normal.
   * @return {Vector3} A reference to this vector.
   */
  projectOnPlane(e) {
    return Vx.copy(this).projectOnVector(e), this.sub(Vx);
  }
  /**
   * Reflects this vector off a plane orthogonal to the given normal vector.
   *
   * @param {Vector3} normal - The (normalized) normal vector.
   * @return {Vector3} A reference to this vector.
   */
  reflect(e) {
    return this.sub(Vx.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  /**
   * Returns the angle between the given vector and this instance in radians.
   *
   * @param {Vector3} v - The vector to compute the angle with.
   * @return {number} The angle in radians.
   */
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const n = this.dot(e) / t;
    return Math.acos(dn(n, -1, 1));
  }
  /**
   * Computes the distance from the given vector to this instance.
   *
   * @param {Vector3} v - The vector to compute the distance to.
   * @return {number} The distance.
   */
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  /**
   * Computes the squared distance from the given vector to this instance.
   * If you are just comparing the distance with another distance, you should compare
   * the distance squared instead as it is slightly more efficient to calculate.
   *
   * @param {Vector3} v - The vector to compute the squared distance to.
   * @return {number} The squared distance.
   */
  distanceToSquared(e) {
    const t = this.x - e.x, n = this.y - e.y, r = this.z - e.z;
    return t * t + n * n + r * r;
  }
  /**
   * Computes the Manhattan distance from the given vector to this instance.
   *
   * @param {Vector3} v - The vector to compute the Manhattan distance to.
   * @return {number} The Manhattan distance.
   */
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z);
  }
  /**
   * Sets the vector components from the given spherical coordinates.
   *
   * @param {Spherical} s - The spherical coordinates.
   * @return {Vector3} A reference to this vector.
   */
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  /**
   * Sets the vector components from the given spherical coordinates.
   *
   * @param {number} radius - The radius.
   * @param {number} phi - The phi angle in radians.
   * @param {number} theta - The theta angle in radians.
   * @return {Vector3} A reference to this vector.
   */
  setFromSphericalCoords(e, t, n) {
    const r = Math.sin(t) * e;
    return this.x = r * Math.sin(n), this.y = Math.cos(t) * e, this.z = r * Math.cos(n), this;
  }
  /**
   * Sets the vector components from the given cylindrical coordinates.
   *
   * @param {Cylindrical} c - The cylindrical coordinates.
   * @return {Vector3} A reference to this vector.
   */
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  /**
   * Sets the vector components from the given cylindrical coordinates.
   *
   * @param {number} radius - The radius.
   * @param {number} theta - The theta angle in radians.
   * @param {number} y - The y value.
   * @return {Vector3} A reference to this vector.
   */
  setFromCylindricalCoords(e, t, n) {
    return this.x = e * Math.sin(t), this.y = n, this.z = e * Math.cos(t), this;
  }
  /**
   * Sets the vector components to the position elements of the
   * given transformation matrix.
   *
   * @param {Matrix4} m - The 4x4 matrix.
   * @return {Vector3} A reference to this vector.
   */
  setFromMatrixPosition(e) {
    const t = e.elements;
    return this.x = t[12], this.y = t[13], this.z = t[14], this;
  }
  /**
   * Sets the vector components to the scale elements of the
   * given transformation matrix.
   *
   * @param {Matrix4} m - The 4x4 matrix.
   * @return {Vector3} A reference to this vector.
   */
  setFromMatrixScale(e) {
    const t = this.setFromMatrixColumn(e, 0).length(), n = this.setFromMatrixColumn(e, 1).length(), r = this.setFromMatrixColumn(e, 2).length();
    return this.x = t, this.y = n, this.z = r, this;
  }
  /**
   * Sets the vector components from the specified matrix column.
   *
   * @param {Matrix4} m - The 4x4 matrix.
   * @param {number} index - The column index.
   * @return {Vector3} A reference to this vector.
   */
  setFromMatrixColumn(e, t) {
    return this.fromArray(e.elements, t * 4);
  }
  /**
   * Sets the vector components from the specified matrix column.
   *
   * @param {Matrix3} m - The 3x3 matrix.
   * @param {number} index - The column index.
   * @return {Vector3} A reference to this vector.
   */
  setFromMatrix3Column(e, t) {
    return this.fromArray(e.elements, t * 3);
  }
  /**
   * Sets the vector components from the given Euler angles.
   *
   * @param {Euler} e - The Euler angles to set.
   * @return {Vector3} A reference to this vector.
   */
  setFromEuler(e) {
    return this.x = e._x, this.y = e._y, this.z = e._z, this;
  }
  /**
   * Sets the vector components from the RGB components of the
   * given color.
   *
   * @param {Color} c - The color to set.
   * @return {Vector3} A reference to this vector.
   */
  setFromColor(e) {
    return this.x = e.r, this.y = e.g, this.z = e.b, this;
  }
  /**
   * Returns `true` if this vector is equal with the given one.
   *
   * @param {Vector3} v - The vector to test for equality.
   * @return {boolean} Whether this vector is equal with the given one.
   */
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  /**
   * Sets this vector's x value to be `array[ offset ]`, y value to be `array[ offset + 1 ]`
   * and z value to be `array[ offset + 2 ]`.
   *
   * @param {Array<number>} array - An array holding the vector component values.
   * @param {number} [offset=0] - The offset into the array.
   * @return {Vector3} A reference to this vector.
   */
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this;
  }
  /**
   * Writes the components of this vector to the given array. If no array is provided,
   * the method returns a new instance.
   *
   * @param {Array<number>} [array=[]] - The target array holding the vector components.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Array<number>} The vector components.
   */
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e;
  }
  /**
   * Sets the components of this vector from the given buffer attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute holding vector data.
   * @param {number} index - The index into the attribute.
   * @return {Vector3} A reference to this vector.
   */
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this;
  }
  /**
   * Sets each component of this vector to a pseudo-random value between `0` and
   * `1`, excluding `1`.
   *
   * @return {Vector3} A reference to this vector.
   */
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
  }
  /**
   * Sets this vector to a uniformly random point on a unit sphere.
   *
   * @return {Vector3} A reference to this vector.
   */
  randomDirection() {
    const e = Math.random() * Math.PI * 2, t = Math.random() * 2 - 1, n = Math.sqrt(1 - t * t);
    return this.x = n * Math.cos(e), this.y = t, this.z = n * Math.sin(e), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const Vx = /* @__PURE__ */ new j(), fM = /* @__PURE__ */ new hr();
class fn {
  /**
   * Constructs a new 3x3 matrix. The arguments are supposed to be
   * in row-major order. If no arguments are provided, the constructor
   * initializes the matrix as an identity matrix.
   *
   * @param {number} [n11] - 1-1 matrix element.
   * @param {number} [n12] - 1-2 matrix element.
   * @param {number} [n13] - 1-3 matrix element.
   * @param {number} [n21] - 2-1 matrix element.
   * @param {number} [n22] - 2-2 matrix element.
   * @param {number} [n23] - 2-3 matrix element.
   * @param {number} [n31] - 3-1 matrix element.
   * @param {number} [n32] - 3-2 matrix element.
   * @param {number} [n33] - 3-3 matrix element.
   */
  constructor(e, t, n, r, s, o, a, l, u) {
    fn.prototype.isMatrix3 = !0, this.elements = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, t, n, r, s, o, a, l, u);
  }
  /**
   * Sets the elements of the matrix.The arguments are supposed to be
   * in row-major order.
   *
   * @param {number} [n11] - 1-1 matrix element.
   * @param {number} [n12] - 1-2 matrix element.
   * @param {number} [n13] - 1-3 matrix element.
   * @param {number} [n21] - 2-1 matrix element.
   * @param {number} [n22] - 2-2 matrix element.
   * @param {number} [n23] - 2-3 matrix element.
   * @param {number} [n31] - 3-1 matrix element.
   * @param {number} [n32] - 3-2 matrix element.
   * @param {number} [n33] - 3-3 matrix element.
   * @return {Matrix3} A reference to this matrix.
   */
  set(e, t, n, r, s, o, a, l, u) {
    const c = this.elements;
    return c[0] = e, c[1] = r, c[2] = a, c[3] = t, c[4] = s, c[5] = l, c[6] = n, c[7] = o, c[8] = u, this;
  }
  /**
   * Sets this matrix to the 3x3 identity matrix.
   *
   * @return {Matrix3} A reference to this matrix.
   */
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ), this;
  }
  /**
   * Copies the values of the given matrix to this instance.
   *
   * @param {Matrix3} m - The matrix to copy.
   * @return {Matrix3} A reference to this matrix.
   */
  copy(e) {
    const t = this.elements, n = e.elements;
    return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], this;
  }
  /**
   * Extracts the basis of this matrix into the three axis vectors provided.
   *
   * @param {Vector3} xAxis - The basis's x axis.
   * @param {Vector3} yAxis - The basis's y axis.
   * @param {Vector3} zAxis - The basis's z axis.
   * @return {Matrix3} A reference to this matrix.
   */
  extractBasis(e, t, n) {
    return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this;
  }
  /**
   * Set this matrix to the upper 3x3 matrix of the given 4x4 matrix.
   *
   * @param {Matrix4} m - The 4x4 matrix.
   * @return {Matrix3} A reference to this matrix.
   */
  setFromMatrix4(e) {
    const t = e.elements;
    return this.set(
      t[0],
      t[4],
      t[8],
      t[1],
      t[5],
      t[9],
      t[2],
      t[6],
      t[10]
    ), this;
  }
  /**
   * Post-multiplies this matrix by the given 3x3 matrix.
   *
   * @param {Matrix3} m - The matrix to multiply with.
   * @return {Matrix3} A reference to this matrix.
   */
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  /**
   * Pre-multiplies this matrix by the given 3x3 matrix.
   *
   * @param {Matrix3} m - The matrix to multiply with.
   * @return {Matrix3} A reference to this matrix.
   */
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  /**
   * Multiples the given 3x3 matrices and stores the result
   * in this matrix.
   *
   * @param {Matrix3} a - The first matrix.
   * @param {Matrix3} b - The second matrix.
   * @return {Matrix3} A reference to this matrix.
   */
  multiplyMatrices(e, t) {
    const n = e.elements, r = t.elements, s = this.elements, o = n[0], a = n[3], l = n[6], u = n[1], c = n[4], A = n[7], m = n[2], _ = n[5], y = n[8], T = r[0], b = r[3], S = r[6], E = r[1], R = r[4], C = r[7], L = r[2], D = r[5], B = r[8];
    return s[0] = o * T + a * E + l * L, s[3] = o * b + a * R + l * D, s[6] = o * S + a * C + l * B, s[1] = u * T + c * E + A * L, s[4] = u * b + c * R + A * D, s[7] = u * S + c * C + A * B, s[2] = m * T + _ * E + y * L, s[5] = m * b + _ * R + y * D, s[8] = m * S + _ * C + y * B, this;
  }
  /**
   * Multiplies every component of the matrix by the given scalar.
   *
   * @param {number} s - The scalar.
   * @return {Matrix3} A reference to this matrix.
   */
  multiplyScalar(e) {
    const t = this.elements;
    return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this;
  }
  /**
   * Computes and returns the determinant of this matrix.
   *
   * @return {number} The determinant.
   */
  determinant() {
    const e = this.elements, t = e[0], n = e[1], r = e[2], s = e[3], o = e[4], a = e[5], l = e[6], u = e[7], c = e[8];
    return t * o * c - t * a * u - n * s * c + n * a * l + r * s * u - r * o * l;
  }
  /**
   * Inverts this matrix, using the [analytic method](https://en.wikipedia.org/wiki/Invertible_matrix#Analytic_solution).
   * You can not invert with a determinant of zero. If you attempt this, the method produces
   * a zero matrix instead.
   *
   * @return {Matrix3} A reference to this matrix.
   */
  invert() {
    const e = this.elements, t = e[0], n = e[1], r = e[2], s = e[3], o = e[4], a = e[5], l = e[6], u = e[7], c = e[8], A = c * o - a * u, m = a * l - c * s, _ = u * s - o * l, y = t * A + n * m + r * _;
    if (y === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const T = 1 / y;
    return e[0] = A * T, e[1] = (r * u - c * n) * T, e[2] = (a * n - r * o) * T, e[3] = m * T, e[4] = (c * t - r * l) * T, e[5] = (r * s - a * t) * T, e[6] = _ * T, e[7] = (n * l - u * t) * T, e[8] = (o * t - n * s) * T, this;
  }
  /**
   * Transposes this matrix in place.
   *
   * @return {Matrix3} A reference to this matrix.
   */
  transpose() {
    let e;
    const t = this.elements;
    return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this;
  }
  /**
   * Computes the normal matrix which is the inverse transpose of the upper
   * left 3x3 portion of the given 4x4 matrix.
   *
   * @param {Matrix4} matrix4 - The 4x4 matrix.
   * @return {Matrix3} A reference to this matrix.
   */
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  /**
   * Transposes this matrix into the supplied array, and returns itself unchanged.
   *
   * @param {Array<number>} r - An array to store the transposed matrix elements.
   * @return {Matrix3} A reference to this matrix.
   */
  transposeIntoArray(e) {
    const t = this.elements;
    return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this;
  }
  /**
   * Sets the UV transform matrix from offset, repeat, rotation, and center.
   *
   * @param {number} tx - Offset x.
   * @param {number} ty - Offset y.
   * @param {number} sx - Repeat x.
   * @param {number} sy - Repeat y.
   * @param {number} rotation - Rotation, in radians. Positive values rotate counterclockwise.
   * @param {number} cx - Center x of rotation.
   * @param {number} cy - Center y of rotation
   * @return {Matrix3} A reference to this matrix.
   */
  setUvTransform(e, t, n, r, s, o, a) {
    const l = Math.cos(s), u = Math.sin(s);
    return this.set(
      n * l,
      n * u,
      -n * (l * o + u * a) + o + e,
      -r * u,
      r * l,
      -r * (-u * o + l * a) + a + t,
      0,
      0,
      1
    ), this;
  }
  /**
   * Scales this matrix with the given scalar values.
   *
   * @param {number} sx - The amount to scale in the X axis.
   * @param {number} sy - The amount to scale in the Y axis.
   * @return {Matrix3} A reference to this matrix.
   */
  scale(e, t) {
    return this.premultiply(Gx.makeScale(e, t)), this;
  }
  /**
   * Rotates this matrix by the given angle.
   *
   * @param {number} theta - The rotation in radians.
   * @return {Matrix3} A reference to this matrix.
   */
  rotate(e) {
    return this.premultiply(Gx.makeRotation(-e)), this;
  }
  /**
   * Translates this matrix by the given scalar values.
   *
   * @param {number} tx - The amount to translate in the X axis.
   * @param {number} ty - The amount to translate in the Y axis.
   * @return {Matrix3} A reference to this matrix.
   */
  translate(e, t) {
    return this.premultiply(Gx.makeTranslation(e, t)), this;
  }
  // for 2D Transforms
  /**
   * Sets this matrix as a 2D translation transform.
   *
   * @param {number|Vector2} x - The amount to translate in the X axis or alternatively a translation vector.
   * @param {number} y - The amount to translate in the Y axis.
   * @return {Matrix3} A reference to this matrix.
   */
  makeTranslation(e, t) {
    return e.isVector2 ? this.set(
      1,
      0,
      e.x,
      0,
      1,
      e.y,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      e,
      0,
      1,
      t,
      0,
      0,
      1
    ), this;
  }
  /**
   * Sets this matrix as a 2D rotational transformation.
   *
   * @param {number} theta - The rotation in radians.
   * @return {Matrix3} A reference to this matrix.
   */
  makeRotation(e) {
    const t = Math.cos(e), n = Math.sin(e);
    return this.set(
      t,
      -n,
      0,
      n,
      t,
      0,
      0,
      0,
      1
    ), this;
  }
  /**
   * Sets this matrix as a 2D scale transform.
   *
   * @param {number} x - The amount to scale in the X axis.
   * @param {number} y - The amount to scale in the Y axis.
   * @return {Matrix3} A reference to this matrix.
   */
  makeScale(e, t) {
    return this.set(
      e,
      0,
      0,
      0,
      t,
      0,
      0,
      0,
      1
    ), this;
  }
  /**
   * Returns `true` if this matrix is equal with the given one.
   *
   * @param {Matrix3} matrix - The matrix to test for equality.
   * @return {boolean} Whether this matrix is equal with the given one.
   */
  equals(e) {
    const t = this.elements, n = e.elements;
    for (let r = 0; r < 9; r++)
      if (t[r] !== n[r]) return !1;
    return !0;
  }
  /**
   * Sets the elements of the matrix from the given array.
   *
   * @param {Array<number>} array - The matrix elements in column-major order.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Matrix3} A reference to this matrix.
   */
  fromArray(e, t = 0) {
    for (let n = 0; n < 9; n++)
      this.elements[n] = e[n + t];
    return this;
  }
  /**
   * Writes the elements of this matrix to the given array. If no array is provided,
   * the method returns a new instance.
   *
   * @param {Array<number>} [array=[]] - The target array holding the matrix elements in column-major order.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Array<number>} The matrix elements in column-major order.
   */
  toArray(e = [], t = 0) {
    const n = this.elements;
    return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e;
  }
  /**
   * Returns a matrix with copied values from this instance.
   *
   * @return {Matrix3} A clone of this instance.
   */
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const Gx = /* @__PURE__ */ new fn(), AM = /* @__PURE__ */ new fn().set(
  0.4123908,
  0.3575843,
  0.1804808,
  0.212639,
  0.7151687,
  0.0721923,
  0.0193308,
  0.1191948,
  0.9505322
), pM = /* @__PURE__ */ new fn().set(
  3.2409699,
  -1.5373832,
  -0.4986108,
  -0.9692436,
  1.8759675,
  0.0415551,
  0.0556301,
  -0.203977,
  1.0569715
);
function sU() {
  const i = {
    enabled: !0,
    workingColorSpace: Hl,
    /**
     * Implementations of supported color spaces.
     *
     * Required:
     *	- primaries: chromaticity coordinates [ rx ry gx gy bx by ]
     *	- whitePoint: reference white [ x y ]
     *	- transfer: transfer function (pre-defined)
     *	- toXYZ: Matrix3 RGB to XYZ transform
     *	- fromXYZ: Matrix3 XYZ to RGB transform
     *	- luminanceCoefficients: RGB luminance coefficients
     *
     * Optional:
     *  - outputColorSpaceConfig: { drawingBufferColorSpace: ColorSpace, toneMappingMode: 'extended' | 'standard' }
     *  - workingColorSpaceConfig: { unpackColorSpace: ColorSpace }
     *
     * Reference:
     * - https://www.russellcottrell.com/photo/matrixCalculator.htm
     */
    spaces: {},
    convert: function(r, s, o) {
      return this.enabled === !1 || s === o || !s || !o || (this.spaces[s].transfer === vt && (r.r = Dl(r.r), r.g = Dl(r.g), r.b = Dl(r.b)), this.spaces[s].primaries !== this.spaces[o].primaries && (r.applyMatrix3(this.spaces[s].toXYZ), r.applyMatrix3(this.spaces[o].fromXYZ)), this.spaces[o].transfer === vt && (r.r = pf(r.r), r.g = pf(r.g), r.b = pf(r.b))), r;
    },
    workingToColorSpace: function(r, s) {
      return this.convert(r, this.workingColorSpace, s);
    },
    colorSpaceToWorking: function(r, s) {
      return this.convert(r, s, this.workingColorSpace);
    },
    getPrimaries: function(r) {
      return this.spaces[r].primaries;
    },
    getTransfer: function(r) {
      return r === Ds ? Vh : this.spaces[r].transfer;
    },
    getToneMappingMode: function(r) {
      return this.spaces[r].outputColorSpaceConfig.toneMappingMode || "standard";
    },
    getLuminanceCoefficients: function(r, s = this.workingColorSpace) {
      return r.fromArray(this.spaces[s].luminanceCoefficients);
    },
    define: function(r) {
      Object.assign(this.spaces, r);
    },
    // Internal APIs
    _getMatrix: function(r, s, o) {
      return r.copy(this.spaces[s].toXYZ).multiply(this.spaces[o].fromXYZ);
    },
    _getDrawingBufferColorSpace: function(r) {
      return this.spaces[r].outputColorSpaceConfig.drawingBufferColorSpace;
    },
    _getUnpackColorSpace: function(r = this.workingColorSpace) {
      return this.spaces[r].workingColorSpaceConfig.unpackColorSpace;
    },
    // Deprecated
    fromWorkingColorSpace: function(r, s) {
      return li("ColorManagement: .fromWorkingColorSpace() has been renamed to .workingToColorSpace()."), i.workingToColorSpace(r, s);
    },
    toWorkingColorSpace: function(r, s) {
      return li("ColorManagement: .toWorkingColorSpace() has been renamed to .colorSpaceToWorking()."), i.colorSpaceToWorking(r, s);
    }
  }, e = [0.64, 0.33, 0.3, 0.6, 0.15, 0.06], t = [0.2126, 0.7152, 0.0722], n = [0.3127, 0.329];
  return i.define({
    [Hl]: {
      primaries: e,
      whitePoint: n,
      transfer: Vh,
      toXYZ: AM,
      fromXYZ: pM,
      luminanceCoefficients: t,
      workingColorSpaceConfig: { unpackColorSpace: gr },
      outputColorSpaceConfig: { drawingBufferColorSpace: gr }
    },
    [gr]: {
      primaries: e,
      whitePoint: n,
      transfer: vt,
      toXYZ: AM,
      fromXYZ: pM,
      luminanceCoefficients: t,
      outputColorSpaceConfig: { drawingBufferColorSpace: gr }
    }
  }), i;
}
const Xt = /* @__PURE__ */ sU();
function Dl(i) {
  return i < 0.04045 ? i * 0.0773993808 : Math.pow(i * 0.9478672986 + 0.0521327014, 2.4);
}
function pf(i) {
  return i < 31308e-7 ? i * 12.92 : 1.055 * Math.pow(i, 0.41666) - 0.055;
}
let gd;
class H5 {
  /**
   * Returns a data URI containing a representation of the given image.
   *
   * @param {(HTMLImageElement|HTMLCanvasElement)} image - The image object.
   * @param {string} [type='image/png'] - Indicates the image format.
   * @return {string} The data URI.
   */
  static getDataURL(e, t = "image/png") {
    if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u")
      return e.src;
    let n;
    if (e instanceof HTMLCanvasElement)
      n = e;
    else {
      gd === void 0 && (gd = Op("canvas")), gd.width = e.width, gd.height = e.height;
      const r = gd.getContext("2d");
      e instanceof ImageData ? r.putImageData(e, 0, 0) : r.drawImage(e, 0, 0, e.width, e.height), n = gd;
    }
    return n.toDataURL(t);
  }
  /**
   * Converts the given sRGB image data to linear color space.
   *
   * @param {(HTMLImageElement|HTMLCanvasElement|ImageBitmap|Object)} image - The image object.
   * @return {HTMLCanvasElement|Object} The converted image.
   */
  static sRGBToLinear(e) {
    if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
      const t = Op("canvas");
      t.width = e.width, t.height = e.height;
      const n = t.getContext("2d");
      n.drawImage(e, 0, 0, e.width, e.height);
      const r = n.getImageData(0, 0, e.width, e.height), s = r.data;
      for (let o = 0; o < s.length; o++)
        s[o] = Dl(s[o] / 255) * 255;
      return n.putImageData(r, 0, 0), t;
    } else if (e.data) {
      const t = e.data.slice(0);
      for (let n = 0; n < t.length; n++)
        t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[n] = Math.floor(Dl(t[n] / 255) * 255) : t[n] = Dl(t[n]);
      return {
        data: t,
        width: e.width,
        height: e.height
      };
    } else
      return Me("ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e;
  }
}
let oU = 0;
class Lu {
  /**
   * Constructs a new video texture.
   *
   * @param {any} [data=null] - The data definition of a texture.
   */
  constructor(e = null) {
    this.isSource = !0, Object.defineProperty(this, "id", { value: oU++ }), this.uuid = To(), this.data = e, this.dataReady = !0, this.version = 0;
  }
  /**
   * Returns the dimensions of the source into the given target vector.
   *
   * @param {(Vector2|Vector3)} target - The target object the result is written into.
   * @return {(Vector2|Vector3)} The dimensions of the source.
   */
  getSize(e) {
    const t = this.data;
    return typeof HTMLVideoElement < "u" && t instanceof HTMLVideoElement ? e.set(t.videoWidth, t.videoHeight, 0) : typeof VideoFrame < "u" && t instanceof VideoFrame ? e.set(t.displayHeight, t.displayWidth, 0) : t !== null ? e.set(t.width, t.height, t.depth || 0) : e.set(0, 0, 0), e;
  }
  /**
   * When the property is set to `true`, the engine allocates the memory
   * for the texture (if necessary) and triggers the actual texture upload
   * to the GPU next time the source is used.
   *
   * @type {boolean}
   * @default false
   * @param {boolean} value
   */
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  /**
   * Serializes the source into JSON.
   *
   * @param {?(Object|string)} meta - An optional value holding meta information about the serialization.
   * @return {Object} A JSON object representing the serialized source.
   * @see {@link ObjectLoader#parse}
   */
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.images[this.uuid] !== void 0)
      return e.images[this.uuid];
    const n = {
      uuid: this.uuid,
      url: ""
    }, r = this.data;
    if (r !== null) {
      let s;
      if (Array.isArray(r)) {
        s = [];
        for (let o = 0, a = r.length; o < a; o++)
          r[o].isDataTexture ? s.push(zx(r[o].image)) : s.push(zx(r[o]));
      } else
        s = zx(r);
      n.url = s;
    }
    return t || (e.images[this.uuid] = n), n;
  }
}
function zx(i) {
  return typeof HTMLImageElement < "u" && i instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && i instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && i instanceof ImageBitmap ? H5.getDataURL(i) : i.data ? {
    data: Array.from(i.data),
    width: i.width,
    height: i.height,
    type: i.data.constructor.name
  } : (Me("Texture: Unable to serialize Texture."), {});
}
let aU = 0;
const qx = /* @__PURE__ */ new j();
class Ii extends lo {
  /**
   * Constructs a new texture.
   *
   * @param {?Object} [image=Texture.DEFAULT_IMAGE] - The image holding the texture data.
   * @param {number} [mapping=Texture.DEFAULT_MAPPING] - The texture mapping.
   * @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.
   * @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.
   * @param {number} [magFilter=LinearFilter] - The mag filter value.
   * @param {number} [minFilter=LinearMipmapLinearFilter] - The min filter value.
   * @param {number} [format=RGBAFormat] - The texture format.
   * @param {number} [type=UnsignedByteType] - The texture type.
   * @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.
   * @param {string} [colorSpace=NoColorSpace] - The color space.
   */
  constructor(e = Ii.DEFAULT_IMAGE, t = Ii.DEFAULT_MAPPING, n = xr, r = xr, s = qn, o = $r, a = Pi, l = Mi, u = Ii.DEFAULT_ANISOTROPY, c = Ds) {
    super(), this.isTexture = !0, Object.defineProperty(this, "id", { value: aU++ }), this.uuid = To(), this.name = "", this.source = new Lu(e), this.mipmaps = [], this.mapping = t, this.channel = 0, this.wrapS = n, this.wrapT = r, this.magFilter = s, this.minFilter = o, this.anisotropy = u, this.format = a, this.internalFormat = null, this.type = l, this.offset = new Le(0, 0), this.repeat = new Le(1, 1), this.center = new Le(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new fn(), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.colorSpace = c, this.userData = {}, this.updateRanges = [], this.version = 0, this.onUpdate = null, this.renderTarget = null, this.isRenderTargetTexture = !1, this.isArrayTexture = !!(e && e.depth && e.depth > 1), this.pmremVersion = 0;
  }
  /**
   * The width of the texture in pixels.
   */
  get width() {
    return this.source.getSize(qx).x;
  }
  /**
   * The height of the texture in pixels.
   */
  get height() {
    return this.source.getSize(qx).y;
  }
  /**
   * The depth of the texture in pixels.
   */
  get depth() {
    return this.source.getSize(qx).z;
  }
  /**
   * The image object holding the texture data.
   *
   * @type {?Object}
   */
  get image() {
    return this.source.data;
  }
  set image(e = null) {
    this.source.data = e;
  }
  /**
   * Updates the texture transformation matrix from the from the properties {@link Texture#offset},
   * {@link Texture#repeat}, {@link Texture#rotation}, and {@link Texture#center}.
   */
  updateMatrix() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }
  /**
   * Adds a range of data in the data texture to be updated on the GPU.
   *
   * @param {number} start - Position at which to start update.
   * @param {number} count - The number of components to update.
   */
  addUpdateRange(e, t) {
    this.updateRanges.push({ start: e, count: t });
  }
  /**
   * Clears the update ranges.
   */
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  /**
   * Returns a new texture with copied values from this instance.
   *
   * @return {Texture} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
  /**
   * Copies the values of the given texture to this instance.
   *
   * @param {Texture} source - The texture to copy.
   * @return {Texture} A reference to this instance.
   */
  copy(e) {
    return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.channel = e.channel, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.colorSpace = e.colorSpace, this.renderTarget = e.renderTarget, this.isRenderTargetTexture = e.isRenderTargetTexture, this.isArrayTexture = e.isArrayTexture, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this;
  }
  /**
   * Sets this texture's properties based on `values`.
   * @param {Object} values - A container with texture parameters.
   */
  setValues(e) {
    for (const t in e) {
      const n = e[t];
      if (n === void 0) {
        Me(`Texture.setValues(): parameter '${t}' has value of undefined.`);
        continue;
      }
      const r = this[t];
      if (r === void 0) {
        Me(`Texture.setValues(): property '${t}' does not exist.`);
        continue;
      }
      r && n && r.isVector2 && n.isVector2 || r && n && r.isVector3 && n.isVector3 || r && n && r.isMatrix3 && n.isMatrix3 ? r.copy(n) : this[t] = n;
    }
  }
  /**
   * Serializes the texture into JSON.
   *
   * @param {?(Object|string)} meta - An optional value holding meta information about the serialization.
   * @return {Object} A JSON object representing the serialized texture.
   * @see {@link ObjectLoader#parse}
   */
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.textures[this.uuid] !== void 0)
      return e.textures[this.uuid];
    const n = {
      metadata: {
        version: 4.7,
        type: "Texture",
        generator: "Texture.toJSON"
      },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(e).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    };
    return Object.keys(this.userData).length > 0 && (n.userData = this.userData), t || (e.textures[this.uuid] = n), n;
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   *
   * @fires Texture#dispose
   */
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  /**
   * Transforms the given uv vector with the textures uv transformation matrix.
   *
   * @param {Vector2} uv - The uv vector.
   * @return {Vector2} The transformed uv vector.
   */
  transformUv(e) {
    if (this.mapping !== A0) return e;
    if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1)
      switch (this.wrapS) {
        case zl:
          e.x = e.x - Math.floor(e.x);
          break;
        case xr:
          e.x = e.x < 0 ? 0 : 1;
          break;
        case ql:
          Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
          break;
      }
    if (e.y < 0 || e.y > 1)
      switch (this.wrapT) {
        case zl:
          e.y = e.y - Math.floor(e.y);
          break;
        case xr:
          e.y = e.y < 0 ? 0 : 1;
          break;
        case ql:
          Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
          break;
      }
    return this.flipY && (e.y = 1 - e.y), e;
  }
  /**
   * Setting this property to `true` indicates the engine the texture
   * must be updated in the next render. This triggers a texture upload
   * to the GPU and ensures correct texture parameter configuration.
   *
   * @type {boolean}
   * @default false
   * @param {boolean} value
   */
  set needsUpdate(e) {
    e === !0 && (this.version++, this.source.needsUpdate = !0);
  }
  /**
   * Setting this property to `true` indicates the engine the PMREM
   * must be regenerated.
   *
   * @type {boolean}
   * @default false
   * @param {boolean} value
   */
  set needsPMREMUpdate(e) {
    e === !0 && this.pmremVersion++;
  }
}
Ii.DEFAULT_IMAGE = null;
Ii.DEFAULT_MAPPING = A0;
Ii.DEFAULT_ANISOTROPY = 1;
class Kt {
  /**
   * Constructs a new 4D vector.
   *
   * @param {number} [x=0] - The x value of this vector.
   * @param {number} [y=0] - The y value of this vector.
   * @param {number} [z=0] - The z value of this vector.
   * @param {number} [w=1] - The w value of this vector.
   */
  constructor(e = 0, t = 0, n = 0, r = 1) {
    Kt.prototype.isVector4 = !0, this.x = e, this.y = t, this.z = n, this.w = r;
  }
  /**
   * Alias for {@link Vector4#z}.
   *
   * @type {number}
   */
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  /**
   * Alias for {@link Vector4#w}.
   *
   * @type {number}
   */
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  /**
   * Sets the vector components.
   *
   * @param {number} x - The value of the x component.
   * @param {number} y - The value of the y component.
   * @param {number} z - The value of the z component.
   * @param {number} w - The value of the w component.
   * @return {Vector4} A reference to this vector.
   */
  set(e, t, n, r) {
    return this.x = e, this.y = t, this.z = n, this.w = r, this;
  }
  /**
   * Sets the vector components to the same value.
   *
   * @param {number} scalar - The value to set for all vector components.
   * @return {Vector4} A reference to this vector.
   */
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this.w = e, this;
  }
  /**
   * Sets the vector's x component to the given value
   *
   * @param {number} x - The value to set.
   * @return {Vector4} A reference to this vector.
   */
  setX(e) {
    return this.x = e, this;
  }
  /**
   * Sets the vector's y component to the given value
   *
   * @param {number} y - The value to set.
   * @return {Vector4} A reference to this vector.
   */
  setY(e) {
    return this.y = e, this;
  }
  /**
   * Sets the vector's z component to the given value
   *
   * @param {number} z - The value to set.
   * @return {Vector4} A reference to this vector.
   */
  setZ(e) {
    return this.z = e, this;
  }
  /**
   * Sets the vector's w component to the given value
   *
   * @param {number} w - The value to set.
   * @return {Vector4} A reference to this vector.
   */
  setW(e) {
    return this.w = e, this;
  }
  /**
   * Allows to set a vector component with an index.
   *
   * @param {number} index - The component index. `0` equals to x, `1` equals to y,
   * `2` equals to z, `3` equals to w.
   * @param {number} value - The value to set.
   * @return {Vector4} A reference to this vector.
   */
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      case 3:
        this.w = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  /**
   * Returns the value of the vector component which matches the given index.
   *
   * @param {number} index - The component index. `0` equals to x, `1` equals to y,
   * `2` equals to z, `3` equals to w.
   * @return {number} A vector component value.
   */
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  /**
   * Returns a new vector with copied values from this instance.
   *
   * @return {Vector4} A clone of this instance.
   */
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  /**
   * Copies the values of the given vector to this instance.
   *
   * @param {Vector3|Vector4} v - The vector to copy.
   * @return {Vector4} A reference to this vector.
   */
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this;
  }
  /**
   * Adds the given vector to this instance.
   *
   * @param {Vector4} v - The vector to add.
   * @return {Vector4} A reference to this vector.
   */
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this;
  }
  /**
   * Adds the given scalar value to all components of this instance.
   *
   * @param {number} s - The scalar to add.
   * @return {Vector4} A reference to this vector.
   */
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this.w += e, this;
  }
  /**
   * Adds the given vectors and stores the result in this instance.
   *
   * @param {Vector4} a - The first vector.
   * @param {Vector4} b - The second vector.
   * @return {Vector4} A reference to this vector.
   */
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this;
  }
  /**
   * Adds the given vector scaled by the given factor to this instance.
   *
   * @param {Vector4} v - The vector.
   * @param {number} s - The factor that scales `v`.
   * @return {Vector4} A reference to this vector.
   */
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this;
  }
  /**
   * Subtracts the given vector from this instance.
   *
   * @param {Vector4} v - The vector to subtract.
   * @return {Vector4} A reference to this vector.
   */
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this;
  }
  /**
   * Subtracts the given scalar value from all components of this instance.
   *
   * @param {number} s - The scalar to subtract.
   * @return {Vector4} A reference to this vector.
   */
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this;
  }
  /**
   * Subtracts the given vectors and stores the result in this instance.
   *
   * @param {Vector4} a - The first vector.
   * @param {Vector4} b - The second vector.
   * @return {Vector4} A reference to this vector.
   */
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this;
  }
  /**
   * Multiplies the given vector with this instance.
   *
   * @param {Vector4} v - The vector to multiply.
   * @return {Vector4} A reference to this vector.
   */
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this;
  }
  /**
   * Multiplies the given scalar value with all components of this instance.
   *
   * @param {number} scalar - The scalar to multiply.
   * @return {Vector4} A reference to this vector.
   */
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this;
  }
  /**
   * Multiplies this vector with the given 4x4 matrix.
   *
   * @param {Matrix4} m - The 4x4 matrix.
   * @return {Vector4} A reference to this vector.
   */
  applyMatrix4(e) {
    const t = this.x, n = this.y, r = this.z, s = this.w, o = e.elements;
    return this.x = o[0] * t + o[4] * n + o[8] * r + o[12] * s, this.y = o[1] * t + o[5] * n + o[9] * r + o[13] * s, this.z = o[2] * t + o[6] * n + o[10] * r + o[14] * s, this.w = o[3] * t + o[7] * n + o[11] * r + o[15] * s, this;
  }
  /**
   * Divides this instance by the given vector.
   *
   * @param {Vector4} v - The vector to divide.
   * @return {Vector4} A reference to this vector.
   */
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this.w /= e.w, this;
  }
  /**
   * Divides this vector by the given scalar.
   *
   * @param {number} scalar - The scalar to divide.
   * @return {Vector4} A reference to this vector.
   */
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  /**
   * Sets the x, y and z components of this
   * vector to the quaternion's axis and w to the angle.
   *
   * @param {Quaternion} q - The Quaternion to set.
   * @return {Vector4} A reference to this vector.
   */
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const t = Math.sqrt(1 - e.w * e.w);
    return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this;
  }
  /**
   * Sets the x, y and z components of this
   * vector to the axis of rotation and w to the angle.
   *
   * @param {Matrix4} m - A 4x4 matrix of which the upper left 3x3 matrix is a pure rotation matrix.
   * @return {Vector4} A reference to this vector.
   */
  setAxisAngleFromRotationMatrix(e) {
    let t, n, r, s;
    const l = e.elements, u = l[0], c = l[4], A = l[8], m = l[1], _ = l[5], y = l[9], T = l[2], b = l[6], S = l[10];
    if (Math.abs(c - m) < 0.01 && Math.abs(A - T) < 0.01 && Math.abs(y - b) < 0.01) {
      if (Math.abs(c + m) < 0.1 && Math.abs(A + T) < 0.1 && Math.abs(y + b) < 0.1 && Math.abs(u + _ + S - 3) < 0.1)
        return this.set(1, 0, 0, 0), this;
      t = Math.PI;
      const R = (u + 1) / 2, C = (_ + 1) / 2, L = (S + 1) / 2, D = (c + m) / 4, B = (A + T) / 4, U = (y + b) / 4;
      return R > C && R > L ? R < 0.01 ? (n = 0, r = 0.707106781, s = 0.707106781) : (n = Math.sqrt(R), r = D / n, s = B / n) : C > L ? C < 0.01 ? (n = 0.707106781, r = 0, s = 0.707106781) : (r = Math.sqrt(C), n = D / r, s = U / r) : L < 0.01 ? (n = 0.707106781, r = 0.707106781, s = 0) : (s = Math.sqrt(L), n = B / s, r = U / s), this.set(n, r, s, t), this;
    }
    let E = Math.sqrt((b - y) * (b - y) + (A - T) * (A - T) + (m - c) * (m - c));
    return Math.abs(E) < 1e-3 && (E = 1), this.x = (b - y) / E, this.y = (A - T) / E, this.z = (m - c) / E, this.w = Math.acos((u + _ + S - 1) / 2), this;
  }
  /**
   * Sets the vector components to the position elements of the
   * given transformation matrix.
   *
   * @param {Matrix4} m - The 4x4 matrix.
   * @return {Vector4} A reference to this vector.
   */
  setFromMatrixPosition(e) {
    const t = e.elements;
    return this.x = t[12], this.y = t[13], this.z = t[14], this.w = t[15], this;
  }
  /**
   * If this vector's x, y, z or w value is greater than the given vector's x, y, z or w
   * value, replace that value with the corresponding min value.
   *
   * @param {Vector4} v - The vector.
   * @return {Vector4} A reference to this vector.
   */
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this;
  }
  /**
   * If this vector's x, y, z or w value is less than the given vector's x, y, z or w
   * value, replace that value with the corresponding max value.
   *
   * @param {Vector4} v - The vector.
   * @return {Vector4} A reference to this vector.
   */
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this;
  }
  /**
   * If this vector's x, y, z or w value is greater than the max vector's x, y, z or w
   * value, it is replaced by the corresponding value.
   * If this vector's x, y, z or w value is less than the min vector's x, y, z or w value,
   * it is replaced by the corresponding value.
   *
   * @param {Vector4} min - The minimum x, y and z values.
   * @param {Vector4} max - The maximum x, y and z values in the desired range.
   * @return {Vector4} A reference to this vector.
   */
  clamp(e, t) {
    return this.x = dn(this.x, e.x, t.x), this.y = dn(this.y, e.y, t.y), this.z = dn(this.z, e.z, t.z), this.w = dn(this.w, e.w, t.w), this;
  }
  /**
   * If this vector's x, y, z or w values are greater than the max value, they are
   * replaced by the max value.
   * If this vector's x, y, z or w values are less than the min value, they are
   * replaced by the min value.
   *
   * @param {number} minVal - The minimum value the components will be clamped to.
   * @param {number} maxVal - The maximum value the components will be clamped to.
   * @return {Vector4} A reference to this vector.
   */
  clampScalar(e, t) {
    return this.x = dn(this.x, e, t), this.y = dn(this.y, e, t), this.z = dn(this.z, e, t), this.w = dn(this.w, e, t), this;
  }
  /**
   * If this vector's length is greater than the max value, it is replaced by
   * the max value.
   * If this vector's length is less than the min value, it is replaced by the
   * min value.
   *
   * @param {number} min - The minimum value the vector length will be clamped to.
   * @param {number} max - The maximum value the vector length will be clamped to.
   * @return {Vector4} A reference to this vector.
   */
  clampLength(e, t) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(dn(n, e, t));
  }
  /**
   * The components of this vector are rounded down to the nearest integer value.
   *
   * @return {Vector4} A reference to this vector.
   */
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
  }
  /**
   * The components of this vector are rounded up to the nearest integer value.
   *
   * @return {Vector4} A reference to this vector.
   */
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
  }
  /**
   * The components of this vector are rounded to the nearest integer value
   *
   * @return {Vector4} A reference to this vector.
   */
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
  }
  /**
   * The components of this vector are rounded towards zero (up if negative,
   * down if positive) to an integer value.
   *
   * @return {Vector4} A reference to this vector.
   */
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this;
  }
  /**
   * Inverts this vector - i.e. sets x = -x, y = -y, z = -z, w = -w.
   *
   * @return {Vector4} A reference to this vector.
   */
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
  }
  /**
   * Calculates the dot product of the given vector with this instance.
   *
   * @param {Vector4} v - The vector to compute the dot product with.
   * @return {number} The result of the dot product.
   */
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  /**
   * Computes the square of the Euclidean length (straight-line length) from
   * (0, 0, 0, 0) to (x, y, z, w). If you are comparing the lengths of vectors, you should
   * compare the length squared instead as it is slightly more efficient to calculate.
   *
   * @return {number} The square length of this vector.
   */
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  /**
   * Computes the  Euclidean length (straight-line length) from (0, 0, 0, 0) to (x, y, z, w).
   *
   * @return {number} The length of this vector.
   */
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  /**
   * Computes the Manhattan length of this vector.
   *
   * @return {number} The length of this vector.
   */
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  /**
   * Converts this vector to a unit vector - that is, sets it equal to a vector
   * with the same direction as this one, but with a vector length of `1`.
   *
   * @return {Vector4} A reference to this vector.
   */
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  /**
   * Sets this vector to a vector with the same direction as this one, but
   * with the specified length.
   *
   * @param {number} length - The new length of this vector.
   * @return {Vector4} A reference to this vector.
   */
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  /**
   * Linearly interpolates between the given vector and this instance, where
   * alpha is the percent distance along the line - alpha = 0 will be this
   * vector, and alpha = 1 will be the given one.
   *
   * @param {Vector4} v - The vector to interpolate towards.
   * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
   * @return {Vector4} A reference to this vector.
   */
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this;
  }
  /**
   * Linearly interpolates between the given vectors, where alpha is the percent
   * distance along the line - alpha = 0 will be first vector, and alpha = 1 will
   * be the second one. The result is stored in this instance.
   *
   * @param {Vector4} v1 - The first vector.
   * @param {Vector4} v2 - The second vector.
   * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
   * @return {Vector4} A reference to this vector.
   */
  lerpVectors(e, t, n) {
    return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this.w = e.w + (t.w - e.w) * n, this;
  }
  /**
   * Returns `true` if this vector is equal with the given one.
   *
   * @param {Vector4} v - The vector to test for equality.
   * @return {boolean} Whether this vector is equal with the given one.
   */
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  /**
   * Sets this vector's x value to be `array[ offset ]`, y value to be `array[ offset + 1 ]`,
   * z value to be `array[ offset + 2 ]`, w value to be `array[ offset + 3 ]`.
   *
   * @param {Array<number>} array - An array holding the vector component values.
   * @param {number} [offset=0] - The offset into the array.
   * @return {Vector4} A reference to this vector.
   */
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this;
  }
  /**
   * Writes the components of this vector to the given array. If no array is provided,
   * the method returns a new instance.
   *
   * @param {Array<number>} [array=[]] - The target array holding the vector components.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Array<number>} The vector components.
   */
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e;
  }
  /**
   * Sets the components of this vector from the given buffer attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute holding vector data.
   * @param {number} index - The index into the attribute.
   * @return {Vector4} A reference to this vector.
   */
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this;
  }
  /**
   * Sets each component of this vector to a pseudo-random value between `0` and
   * `1`, excluding `1`.
   *
   * @return {Vector4} A reference to this vector.
   */
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class Ma extends lo {
  /**
   * Render target options.
   *
   * @typedef {Object} RenderTarget~Options
   * @property {boolean} [generateMipmaps=false] - Whether to generate mipmaps or not.
   * @property {number} [magFilter=LinearFilter] - The mag filter.
   * @property {number} [minFilter=LinearFilter] - The min filter.
   * @property {number} [format=RGBAFormat] - The texture format.
   * @property {number} [type=UnsignedByteType] - The texture type.
   * @property {?string} [internalFormat=null] - The texture's internal format.
   * @property {number} [wrapS=ClampToEdgeWrapping] - The texture's uv wrapping mode.
   * @property {number} [wrapT=ClampToEdgeWrapping] - The texture's uv wrapping mode.
   * @property {number} [anisotropy=1] - The texture's anisotropy value.
   * @property {string} [colorSpace=NoColorSpace] - The texture's color space.
   * @property {boolean} [depthBuffer=true] - Whether to allocate a depth buffer or not.
   * @property {boolean} [stencilBuffer=false] - Whether to allocate a stencil buffer or not.
   * @property {boolean} [resolveDepthBuffer=true] - Whether to resolve the depth buffer or not.
   * @property {boolean} [resolveStencilBuffer=true] - Whether  to resolve the stencil buffer or not.
   * @property {?Texture} [depthTexture=null] - Reference to a depth texture.
   * @property {number} [samples=0] - The MSAA samples count.
   * @property {number} [count=1] - Defines the number of color attachments . Must be at least `1`.
   * @property {number} [depth=1] - The texture depth.
   * @property {boolean} [multiview=false] - Whether this target is used for multiview rendering.
   */
  /**
   * Constructs a new render target.
   *
   * @param {number} [width=1] - The width of the render target.
   * @param {number} [height=1] - The height of the render target.
   * @param {RenderTarget~Options} [options] - The configuration object.
   */
  constructor(e = 1, t = 1, n = {}) {
    super(), n = Object.assign({
      generateMipmaps: !1,
      internalFormat: null,
      minFilter: qn,
      depthBuffer: !0,
      stencilBuffer: !1,
      resolveDepthBuffer: !0,
      resolveStencilBuffer: !0,
      depthTexture: null,
      samples: 0,
      count: 1,
      depth: 1,
      multiview: !1
    }, n), this.isRenderTarget = !0, this.width = e, this.height = t, this.depth = n.depth, this.scissor = new Kt(0, 0, e, t), this.scissorTest = !1, this.viewport = new Kt(0, 0, e, t);
    const r = { width: e, height: t, depth: n.depth }, s = new Ii(r);
    this.textures = [];
    const o = n.count;
    for (let a = 0; a < o; a++)
      this.textures[a] = s.clone(), this.textures[a].isRenderTargetTexture = !0, this.textures[a].renderTarget = this;
    this._setTextureOptions(n), this.depthBuffer = n.depthBuffer, this.stencilBuffer = n.stencilBuffer, this.resolveDepthBuffer = n.resolveDepthBuffer, this.resolveStencilBuffer = n.resolveStencilBuffer, this._depthTexture = null, this.depthTexture = n.depthTexture, this.samples = n.samples, this.multiview = n.multiview;
  }
  _setTextureOptions(e = {}) {
    const t = {
      minFilter: qn,
      generateMipmaps: !1,
      flipY: !1,
      internalFormat: null
    };
    e.mapping !== void 0 && (t.mapping = e.mapping), e.wrapS !== void 0 && (t.wrapS = e.wrapS), e.wrapT !== void 0 && (t.wrapT = e.wrapT), e.wrapR !== void 0 && (t.wrapR = e.wrapR), e.magFilter !== void 0 && (t.magFilter = e.magFilter), e.minFilter !== void 0 && (t.minFilter = e.minFilter), e.format !== void 0 && (t.format = e.format), e.type !== void 0 && (t.type = e.type), e.anisotropy !== void 0 && (t.anisotropy = e.anisotropy), e.colorSpace !== void 0 && (t.colorSpace = e.colorSpace), e.flipY !== void 0 && (t.flipY = e.flipY), e.generateMipmaps !== void 0 && (t.generateMipmaps = e.generateMipmaps), e.internalFormat !== void 0 && (t.internalFormat = e.internalFormat);
    for (let n = 0; n < this.textures.length; n++)
      this.textures[n].setValues(t);
  }
  /**
   * The texture representing the default color attachment.
   *
   * @type {Texture}
   */
  get texture() {
    return this.textures[0];
  }
  set texture(e) {
    this.textures[0] = e;
  }
  set depthTexture(e) {
    this._depthTexture !== null && (this._depthTexture.renderTarget = null), e !== null && (e.renderTarget = this), this._depthTexture = e;
  }
  /**
   * Instead of saving the depth in a renderbuffer, a texture
   * can be used instead which is useful for further processing
   * e.g. in context of post-processing.
   *
   * @type {?DepthTexture}
   * @default null
   */
  get depthTexture() {
    return this._depthTexture;
  }
  /**
   * Sets the size of this render target.
   *
   * @param {number} width - The width.
   * @param {number} height - The height.
   * @param {number} [depth=1] - The depth.
   */
  setSize(e, t, n = 1) {
    if (this.width !== e || this.height !== t || this.depth !== n) {
      this.width = e, this.height = t, this.depth = n;
      for (let r = 0, s = this.textures.length; r < s; r++)
        this.textures[r].image.width = e, this.textures[r].image.height = t, this.textures[r].image.depth = n, this.textures[r].isData3DTexture !== !0 && (this.textures[r].isArrayTexture = this.textures[r].image.depth > 1);
      this.dispose();
    }
    this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t);
  }
  /**
   * Returns a new render target with copied values from this instance.
   *
   * @return {RenderTarget} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
  /**
   * Copies the settings of the given render target. This is a structural copy so
   * no resources are shared between render targets after the copy. That includes
   * all MRT textures and the depth texture.
   *
   * @param {RenderTarget} source - The render target to copy.
   * @return {RenderTarget} A reference to this instance.
   */
  copy(e) {
    this.width = e.width, this.height = e.height, this.depth = e.depth, this.scissor.copy(e.scissor), this.scissorTest = e.scissorTest, this.viewport.copy(e.viewport), this.textures.length = 0;
    for (let t = 0, n = e.textures.length; t < n; t++) {
      this.textures[t] = e.textures[t].clone(), this.textures[t].isRenderTargetTexture = !0, this.textures[t].renderTarget = this;
      const r = Object.assign({}, e.textures[t].image);
      this.textures[t].source = new Lu(r);
    }
    return this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.resolveDepthBuffer = e.resolveDepthBuffer, this.resolveStencilBuffer = e.resolveStencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this;
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   *
   * @fires RenderTarget#dispose
   */
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class eo extends Ma {
  /**
   * Constructs a new 3D render target.
   *
   * @param {number} [width=1] - The width of the render target.
   * @param {number} [height=1] - The height of the render target.
   * @param {RenderTarget~Options} [options] - The configuration object.
   */
  constructor(e = 1, t = 1, n = {}) {
    super(e, t, n), this.isWebGLRenderTarget = !0;
  }
}
class y0 extends Ii {
  /**
   * Constructs a new data array texture.
   *
   * @param {?TypedArray} [data=null] - The buffer data.
   * @param {number} [width=1] - The width of the texture.
   * @param {number} [height=1] - The height of the texture.
   * @param {number} [depth=1] - The depth of the texture.
   */
  constructor(e = null, t = 1, n = 1, r = 1) {
    super(null), this.isDataArrayTexture = !0, this.image = { data: e, width: t, height: n, depth: r }, this.magFilter = ei, this.minFilter = ei, this.wrapR = xr, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.layerUpdates = /* @__PURE__ */ new Set();
  }
  /**
   * Describes that a specific layer of the texture needs to be updated.
   * Normally when {@link Texture#needsUpdate} is set to `true`, the
   * entire data texture array is sent to the GPU. Marking specific
   * layers will only transmit subsets of all mipmaps associated with a
   * specific depth in the array which is often much more performant.
   *
   * @param {number} layerIndex - The layer index that should be updated.
   */
  addLayerUpdate(e) {
    this.layerUpdates.add(e);
  }
  /**
   * Resets the layer updates registry.
   */
  clearLayerUpdates() {
    this.layerUpdates.clear();
  }
}
class lU extends eo {
  /**
   * Constructs a new array render target.
   *
   * @param {number} [width=1] - The width of the render target.
   * @param {number} [height=1] - The height of the render target.
   * @param {number} [depth=1] - The height of the render target.
   * @param {RenderTarget~Options} [options] - The configuration object.
   */
  constructor(e = 1, t = 1, n = 1, r = {}) {
    super(e, t, r), this.isWebGLArrayRenderTarget = !0, this.depth = n, this.texture = new y0(null, e, t, n), this._setTextureOptions(r), this.texture.isRenderTargetTexture = !0;
  }
}
class $_ extends Ii {
  /**
   * Constructs a new data array texture.
   *
   * @param {?TypedArray} [data=null] - The buffer data.
   * @param {number} [width=1] - The width of the texture.
   * @param {number} [height=1] - The height of the texture.
   * @param {number} [depth=1] - The depth of the texture.
   */
  constructor(e = null, t = 1, n = 1, r = 1) {
    super(null), this.isData3DTexture = !0, this.image = { data: e, width: t, height: n, depth: r }, this.magFilter = ei, this.minFilter = ei, this.wrapR = xr, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
class uU extends eo {
  /**
   * Constructs a new 3D render target.
   *
   * @param {number} [width=1] - The width of the render target.
   * @param {number} [height=1] - The height of the render target.
   * @param {number} [depth=1] - The height of the render target.
   * @param {RenderTarget~Options} [options] - The configuration object.
   */
  constructor(e = 1, t = 1, n = 1, r = {}) {
    super(e, t, r), this.isWebGL3DRenderTarget = !0, this.depth = n, this.texture = new $_(null, e, t, n), this._setTextureOptions(r), this.texture.isRenderTargetTexture = !0;
  }
}
class dr {
  /**
   * Constructs a new bounding box.
   *
   * @param {Vector3} [min=(Infinity,Infinity,Infinity)] - A vector representing the lower boundary of the box.
   * @param {Vector3} [max=(-Infinity,-Infinity,-Infinity)] - A vector representing the upper boundary of the box.
   */
  constructor(e = new j(1 / 0, 1 / 0, 1 / 0), t = new j(-1 / 0, -1 / 0, -1 / 0)) {
    this.isBox3 = !0, this.min = e, this.max = t;
  }
  /**
   * Sets the lower and upper boundaries of this box.
   * Please note that this method only copies the values from the given objects.
   *
   * @param {Vector3} min - The lower boundary of the box.
   * @param {Vector3} max - The upper boundary of the box.
   * @return {Box3} A reference to this bounding box.
   */
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  /**
   * Sets the upper and lower bounds of this box so it encloses the position data
   * in the given array.
   *
   * @param {Array<number>} array - An array holding 3D position data.
   * @return {Box3} A reference to this bounding box.
   */
  setFromArray(e) {
    this.makeEmpty();
    for (let t = 0, n = e.length; t < n; t += 3)
      this.expandByPoint(na.fromArray(e, t));
    return this;
  }
  /**
   * Sets the upper and lower bounds of this box so it encloses the position data
   * in the given buffer attribute.
   *
   * @param {BufferAttribute} attribute - A buffer attribute holding 3D position data.
   * @return {Box3} A reference to this bounding box.
   */
  setFromBufferAttribute(e) {
    this.makeEmpty();
    for (let t = 0, n = e.count; t < n; t++)
      this.expandByPoint(na.fromBufferAttribute(e, t));
    return this;
  }
  /**
   * Sets the upper and lower bounds of this box so it encloses the position data
   * in the given array.
   *
   * @param {Array<Vector3>} points - An array holding 3D position data as instances of {@link Vector3}.
   * @return {Box3} A reference to this bounding box.
   */
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, n = e.length; t < n; t++)
      this.expandByPoint(e[t]);
    return this;
  }
  /**
   * Centers this box on the given center vector and sets this box's width, height and
   * depth to the given size values.
   *
   * @param {Vector3} center - The center of the box.
   * @param {Vector3} size - The x, y and z dimensions of the box.
   * @return {Box3} A reference to this bounding box.
   */
  setFromCenterAndSize(e, t) {
    const n = na.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
  }
  /**
   * Computes the world-axis-aligned bounding box for the given 3D object
   * (including its children), accounting for the object's, and children's,
   * world transforms. The function may result in a larger box than strictly necessary.
   *
   * @param {Object3D} object - The 3D object to compute the bounding box for.
   * @param {boolean} [precise=false] - If set to `true`, the method computes the smallest
   * world-axis-aligned bounding box at the expense of more computation.
   * @return {Box3} A reference to this bounding box.
   */
  setFromObject(e, t = !1) {
    return this.makeEmpty(), this.expandByObject(e, t);
  }
  /**
   * Returns a new box with copied values from this instance.
   *
   * @return {Box3} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
  /**
   * Copies the values of the given box to this instance.
   *
   * @param {Box3} box - The box to copy.
   * @return {Box3} A reference to this bounding box.
   */
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  /**
   * Makes this box empty which means in encloses a zero space in 3D.
   *
   * @return {Box3} A reference to this bounding box.
   */
  makeEmpty() {
    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
  }
  /**
   * Returns true if this box includes zero points within its bounds.
   * Note that a box with equal lower and upper bounds still includes one
   * point, the one both bounds share.
   *
   * @return {boolean} Whether this box is empty or not.
   */
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  /**
   * Returns the center point of this box.
   *
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The center point.
   */
  getCenter(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  /**
   * Returns the dimensions of this box.
   *
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The size.
   */
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  /**
   * Expands the boundaries of this box to include the given point.
   *
   * @param {Vector3} point - The point that should be included by the bounding box.
   * @return {Box3} A reference to this bounding box.
   */
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  /**
   * Expands this box equilaterally by the given vector. The width of this
   * box will be expanded by the x component of the vector in both
   * directions. The height of this box will be expanded by the y component of
   * the vector in both directions. The depth of this box will be
   * expanded by the z component of the vector in both directions.
   *
   * @param {Vector3} vector - The vector that should expand the bounding box.
   * @return {Box3} A reference to this bounding box.
   */
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  /**
   * Expands each dimension of the box by the given scalar. If negative, the
   * dimensions of the box will be contracted.
   *
   * @param {number} scalar - The scalar value that should expand the bounding box.
   * @return {Box3} A reference to this bounding box.
   */
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  /**
   * Expands the boundaries of this box to include the given 3D object and
   * its children, accounting for the object's, and children's, world
   * transforms. The function may result in a larger box than strictly
   * necessary (unless the precise parameter is set to true).
   *
   * @param {Object3D} object - The 3D object that should expand the bounding box.
   * @param {boolean} precise - If set to `true`, the method expands the bounding box
   * as little as necessary at the expense of more computation.
   * @return {Box3} A reference to this bounding box.
   */
  expandByObject(e, t = !1) {
    e.updateWorldMatrix(!1, !1);
    const n = e.geometry;
    if (n !== void 0) {
      const s = n.getAttribute("position");
      if (t === !0 && s !== void 0 && e.isInstancedMesh !== !0)
        for (let o = 0, a = s.count; o < a; o++)
          e.isMesh === !0 ? e.getVertexPosition(o, na) : na.fromBufferAttribute(s, o), na.applyMatrix4(e.matrixWorld), this.expandByPoint(na);
      else
        e.boundingBox !== void 0 ? (e.boundingBox === null && e.computeBoundingBox(), rm.copy(e.boundingBox)) : (n.boundingBox === null && n.computeBoundingBox(), rm.copy(n.boundingBox)), rm.applyMatrix4(e.matrixWorld), this.union(rm);
    }
    const r = e.children;
    for (let s = 0, o = r.length; s < o; s++)
      this.expandByObject(r[s], t);
    return this;
  }
  /**
   * Returns `true` if the given point lies within or on the boundaries of this box.
   *
   * @param {Vector3} point - The point to test.
   * @return {boolean} Whether the bounding box contains the given point or not.
   */
  containsPoint(e) {
    return e.x >= this.min.x && e.x <= this.max.x && e.y >= this.min.y && e.y <= this.max.y && e.z >= this.min.z && e.z <= this.max.z;
  }
  /**
   * Returns `true` if this bounding box includes the entirety of the given bounding box.
   * If this box and the given one are identical, this function also returns `true`.
   *
   * @param {Box3} box - The bounding box to test.
   * @return {boolean} Whether the bounding box contains the given bounding box or not.
   */
  containsBox(e) {
    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z;
  }
  /**
   * Returns a point as a proportion of this box's width, height and depth.
   *
   * @param {Vector3} point - A point in 3D space.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} A point as a proportion of this box's width, height and depth.
   */
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  /**
   * Returns `true` if the given bounding box intersects with this bounding box.
   *
   * @param {Box3} box - The bounding box to test.
   * @return {boolean} Whether the given bounding box intersects with this bounding box.
   */
  intersectsBox(e) {
    return e.max.x >= this.min.x && e.min.x <= this.max.x && e.max.y >= this.min.y && e.min.y <= this.max.y && e.max.z >= this.min.z && e.min.z <= this.max.z;
  }
  /**
   * Returns `true` if the given bounding sphere intersects with this bounding box.
   *
   * @param {Sphere} sphere - The bounding sphere to test.
   * @return {boolean} Whether the given bounding sphere intersects with this bounding box.
   */
  intersectsSphere(e) {
    return this.clampPoint(e.center, na), na.distanceToSquared(e.center) <= e.radius * e.radius;
  }
  /**
   * Returns `true` if the given plane intersects with this bounding box.
   *
   * @param {Plane} plane - The plane to test.
   * @return {boolean} Whether the given plane intersects with this bounding box.
   */
  intersectsPlane(e) {
    let t, n;
    return e.normal.x > 0 ? (t = e.normal.x * this.min.x, n = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, n = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, n += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, n += e.normal.z * this.min.z), t <= -e.constant && n >= -e.constant;
  }
  /**
   * Returns `true` if the given triangle intersects with this bounding box.
   *
   * @param {Triangle} triangle - The triangle to test.
   * @return {boolean} Whether the given triangle intersects with this bounding box.
   */
  intersectsTriangle(e) {
    if (this.isEmpty())
      return !1;
    this.getCenter(wA), sm.subVectors(this.max, wA), _d.subVectors(e.a, wA), xd.subVectors(e.b, wA), yd.subVectors(e.c, wA), uu.subVectors(xd, _d), cu.subVectors(yd, xd), gc.subVectors(_d, yd);
    let t = [
      0,
      -uu.z,
      uu.y,
      0,
      -cu.z,
      cu.y,
      0,
      -gc.z,
      gc.y,
      uu.z,
      0,
      -uu.x,
      cu.z,
      0,
      -cu.x,
      gc.z,
      0,
      -gc.x,
      -uu.y,
      uu.x,
      0,
      -cu.y,
      cu.x,
      0,
      -gc.y,
      gc.x,
      0
    ];
    return !Hx(t, _d, xd, yd, sm) || (t = [1, 0, 0, 0, 1, 0, 0, 0, 1], !Hx(t, _d, xd, yd, sm)) ? !1 : (om.crossVectors(uu, cu), t = [om.x, om.y, om.z], Hx(t, _d, xd, yd, sm));
  }
  /**
   * Clamps the given point within the bounds of this box.
   *
   * @param {Vector3} point - The point to clamp.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The clamped point.
   */
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  /**
   * Returns the euclidean distance from any edge of this box to the specified point. If
   * the given point lies inside of this box, the distance will be `0`.
   *
   * @param {Vector3} point - The point to compute the distance to.
   * @return {number} The euclidean distance.
   */
  distanceToPoint(e) {
    return this.clampPoint(e, na).distanceTo(e);
  }
  /**
   * Returns a bounding sphere that encloses this bounding box.
   *
   * @param {Sphere} target - The target sphere that is used to store the method's result.
   * @return {Sphere} The bounding sphere that encloses this bounding box.
   */
  getBoundingSphere(e) {
    return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center), e.radius = this.getSize(na).length() * 0.5), e;
  }
  /**
   * Computes the intersection of this bounding box and the given one, setting the upper
   * bound of this box to the lesser of the two boxes' upper bounds and the
   * lower bound of this box to the greater of the two boxes' lower bounds. If
   * there's no overlap, makes this box empty.
   *
   * @param {Box3} box - The bounding box to intersect with.
   * @return {Box3} A reference to this bounding box.
   */
  intersect(e) {
    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
  }
  /**
   * Computes the union of this box and another and the given one, setting the upper
   * bound of this box to the greater of the two boxes' upper bounds and the
   * lower bound of this box to the lesser of the two boxes' lower bounds.
   *
   * @param {Box3} box - The bounding box that will be unioned with this instance.
   * @return {Box3} A reference to this bounding box.
   */
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  /**
   * Transforms this bounding box by the given 4x4 transformation matrix.
   *
   * @param {Matrix4} matrix - The transformation matrix.
   * @return {Box3} A reference to this bounding box.
   */
  applyMatrix4(e) {
    return this.isEmpty() ? this : (Al[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), Al[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), Al[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), Al[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), Al[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), Al[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), Al[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), Al[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(Al), this);
  }
  /**
   * Adds the given offset to both the upper and lower bounds of this bounding box,
   * effectively moving it in 3D space.
   *
   * @param {Vector3} offset - The offset that should be used to translate the bounding box.
   * @return {Box3} A reference to this bounding box.
   */
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  /**
   * Returns `true` if this bounding box is equal with the given one.
   *
   * @param {Box3} box - The box to test for equality.
   * @return {boolean} Whether this bounding box is equal with the given one.
   */
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
  /**
   * Returns a serialized structure of the bounding box.
   *
   * @return {Object} Serialized structure with fields representing the object state.
   */
  toJSON() {
    return {
      min: this.min.toArray(),
      max: this.max.toArray()
    };
  }
  /**
   * Returns a serialized structure of the bounding box.
   *
   * @param {Object} json - The serialized json to set the box from.
   * @return {Box3} A reference to this bounding box.
   */
  fromJSON(e) {
    return this.min.fromArray(e.min), this.max.fromArray(e.max), this;
  }
}
const Al = [
  /* @__PURE__ */ new j(),
  /* @__PURE__ */ new j(),
  /* @__PURE__ */ new j(),
  /* @__PURE__ */ new j(),
  /* @__PURE__ */ new j(),
  /* @__PURE__ */ new j(),
  /* @__PURE__ */ new j(),
  /* @__PURE__ */ new j()
], na = /* @__PURE__ */ new j(), rm = /* @__PURE__ */ new dr(), _d = /* @__PURE__ */ new j(), xd = /* @__PURE__ */ new j(), yd = /* @__PURE__ */ new j(), uu = /* @__PURE__ */ new j(), cu = /* @__PURE__ */ new j(), gc = /* @__PURE__ */ new j(), wA = /* @__PURE__ */ new j(), sm = /* @__PURE__ */ new j(), om = /* @__PURE__ */ new j(), _c = /* @__PURE__ */ new j();
function Hx(i, e, t, n, r) {
  for (let s = 0, o = i.length - 3; s <= o; s += 3) {
    _c.fromArray(i, s);
    const a = r.x * Math.abs(_c.x) + r.y * Math.abs(_c.y) + r.z * Math.abs(_c.z), l = e.dot(_c), u = t.dot(_c), c = n.dot(_c);
    if (Math.max(-Math.max(l, u, c), Math.min(l, u, c)) > a)
      return !1;
  }
  return !0;
}
const cU = /* @__PURE__ */ new dr(), MA = /* @__PURE__ */ new j(), Wx = /* @__PURE__ */ new j();
class fr {
  /**
   * Constructs a new sphere.
   *
   * @param {Vector3} [center=(0,0,0)] - The center of the sphere
   * @param {number} [radius=-1] - The radius of the sphere.
   */
  constructor(e = new j(), t = -1) {
    this.isSphere = !0, this.center = e, this.radius = t;
  }
  /**
   * Sets the sphere's components by copying the given values.
   *
   * @param {Vector3} center - The center.
   * @param {number} radius - The radius.
   * @return {Sphere} A reference to this sphere.
   */
  set(e, t) {
    return this.center.copy(e), this.radius = t, this;
  }
  /**
   * Computes the minimum bounding sphere for list of points.
   * If the optional center point is given, it is used as the sphere's
   * center. Otherwise, the center of the axis-aligned bounding box
   * encompassing the points is calculated.
   *
   * @param {Array<Vector3>} points - A list of points in 3D space.
   * @param {Vector3} [optionalCenter] - The center of the sphere.
   * @return {Sphere} A reference to this sphere.
   */
  setFromPoints(e, t) {
    const n = this.center;
    t !== void 0 ? n.copy(t) : cU.setFromPoints(e).getCenter(n);
    let r = 0;
    for (let s = 0, o = e.length; s < o; s++)
      r = Math.max(r, n.distanceToSquared(e[s]));
    return this.radius = Math.sqrt(r), this;
  }
  /**
   * Copies the values of the given sphere to this instance.
   *
   * @param {Sphere} sphere - The sphere to copy.
   * @return {Sphere} A reference to this sphere.
   */
  copy(e) {
    return this.center.copy(e.center), this.radius = e.radius, this;
  }
  /**
   * Returns `true` if the sphere is empty (the radius set to a negative number).
   *
   * Spheres with a radius of `0` contain only their center point and are not
   * considered to be empty.
   *
   * @return {boolean} Whether this sphere is empty or not.
   */
  isEmpty() {
    return this.radius < 0;
  }
  /**
   * Makes this sphere empty which means in encloses a zero space in 3D.
   *
   * @return {Sphere} A reference to this sphere.
   */
  makeEmpty() {
    return this.center.set(0, 0, 0), this.radius = -1, this;
  }
  /**
   * Returns `true` if this sphere contains the given point inclusive of
   * the surface of the sphere.
   *
   * @param {Vector3} point - The point to check.
   * @return {boolean} Whether this sphere contains the given point or not.
   */
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  /**
   * Returns the closest distance from the boundary of the sphere to the
   * given point. If the sphere contains the point, the distance will
   * be negative.
   *
   * @param {Vector3} point - The point to compute the distance to.
   * @return {number} The distance to the point.
   */
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  /**
   * Returns `true` if this sphere intersects with the given one.
   *
   * @param {Sphere} sphere - The sphere to test.
   * @return {boolean} Whether this sphere intersects with the given one or not.
   */
  intersectsSphere(e) {
    const t = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= t * t;
  }
  /**
   * Returns `true` if this sphere intersects with the given box.
   *
   * @param {Box3} box - The box to test.
   * @return {boolean} Whether this sphere intersects with the given box or not.
   */
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  /**
   * Returns `true` if this sphere intersects with the given plane.
   *
   * @param {Plane} plane - The plane to test.
   * @return {boolean} Whether this sphere intersects with the given plane or not.
   */
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  /**
   * Clamps a point within the sphere. If the point is outside the sphere, it
   * will clamp it to the closest point on the edge of the sphere. Points
   * already inside the sphere will not be affected.
   *
   * @param {Vector3} point - The plane to clamp.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The clamped point.
   */
  clampPoint(e, t) {
    const n = this.center.distanceToSquared(e);
    return t.copy(e), n > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t;
  }
  /**
   * Returns a bounding box that encloses this sphere.
   *
   * @param {Box3} target - The target box that is used to store the method's result.
   * @return {Box3} The bounding box that encloses this sphere.
   */
  getBoundingBox(e) {
    return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  /**
   * Transforms this sphere with the given 4x4 transformation matrix.
   *
   * @param {Matrix4} matrix - The transformation matrix.
   * @return {Sphere} A reference to this sphere.
   */
  applyMatrix4(e) {
    return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this;
  }
  /**
   * Translates the sphere's center by the given offset.
   *
   * @param {Vector3} offset - The offset.
   * @return {Sphere} A reference to this sphere.
   */
  translate(e) {
    return this.center.add(e), this;
  }
  /**
   * Expands the boundaries of this sphere to include the given point.
   *
   * @param {Vector3} point - The point to include.
   * @return {Sphere} A reference to this sphere.
   */
  expandByPoint(e) {
    if (this.isEmpty())
      return this.center.copy(e), this.radius = 0, this;
    MA.subVectors(e, this.center);
    const t = MA.lengthSq();
    if (t > this.radius * this.radius) {
      const n = Math.sqrt(t), r = (n - this.radius) * 0.5;
      this.center.addScaledVector(MA, r / n), this.radius += r;
    }
    return this;
  }
  /**
   * Expands this sphere to enclose both the original sphere and the given sphere.
   *
   * @param {Sphere} sphere - The sphere to include.
   * @return {Sphere} A reference to this sphere.
   */
  union(e) {
    return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e), this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (Wx.subVectors(e.center, this.center).setLength(e.radius), this.expandByPoint(MA.copy(e.center).add(Wx)), this.expandByPoint(MA.copy(e.center).sub(Wx))), this);
  }
  /**
   * Returns `true` if this sphere is equal with the given one.
   *
   * @param {Sphere} sphere - The sphere to test for equality.
   * @return {boolean} Whether this bounding sphere is equal with the given one.
   */
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  /**
   * Returns a new sphere with copied values from this instance.
   *
   * @return {Sphere} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
  /**
   * Returns a serialized structure of the bounding sphere.
   *
   * @return {Object} Serialized structure with fields representing the object state.
   */
  toJSON() {
    return {
      radius: this.radius,
      center: this.center.toArray()
    };
  }
  /**
   * Returns a serialized structure of the bounding sphere.
   *
   * @param {Object} json - The serialized json to set the sphere from.
   * @return {Sphere} A reference to this bounding sphere.
   */
  fromJSON(e) {
    return this.radius = e.radius, this.center.fromArray(e.center), this;
  }
}
const pl = /* @__PURE__ */ new j(), $x = /* @__PURE__ */ new j(), am = /* @__PURE__ */ new j(), hu = /* @__PURE__ */ new j(), jx = /* @__PURE__ */ new j(), lm = /* @__PURE__ */ new j(), Xx = /* @__PURE__ */ new j();
class Zh {
  /**
   * Constructs a new ray.
   *
   * @param {Vector3} [origin=(0,0,0)] - The origin of the ray.
   * @param {Vector3} [direction=(0,0,-1)] - The (normalized) direction of the ray.
   */
  constructor(e = new j(), t = new j(0, 0, -1)) {
    this.origin = e, this.direction = t;
  }
  /**
   * Sets the ray's components by copying the given values.
   *
   * @param {Vector3} origin - The origin.
   * @param {Vector3} direction - The direction.
   * @return {Ray} A reference to this ray.
   */
  set(e, t) {
    return this.origin.copy(e), this.direction.copy(t), this;
  }
  /**
   * Copies the values of the given ray to this instance.
   *
   * @param {Ray} ray - The ray to copy.
   * @return {Ray} A reference to this ray.
   */
  copy(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
  }
  /**
   * Returns a vector that is located at a given distance along this ray.
   *
   * @param {number} t - The distance along the ray to retrieve a position for.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} A position on the ray.
   */
  at(e, t) {
    return t.copy(this.origin).addScaledVector(this.direction, e);
  }
  /**
   * Adjusts the direction of the ray to point at the given vector in world space.
   *
   * @param {Vector3} v - The target position.
   * @return {Ray} A reference to this ray.
   */
  lookAt(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this;
  }
  /**
   * Shift the origin of this ray along its direction by the given distance.
   *
   * @param {number} t - The distance along the ray to interpolate.
   * @return {Ray} A reference to this ray.
   */
  recast(e) {
    return this.origin.copy(this.at(e, pl)), this;
  }
  /**
   * Returns the point along this ray that is closest to the given point.
   *
   * @param {Vector3} point - A point in 3D space to get the closet location on the ray for.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The closest point on this ray.
   */
  closestPointToPoint(e, t) {
    t.subVectors(e, this.origin);
    const n = t.dot(this.direction);
    return n < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, n);
  }
  /**
   * Returns the distance of the closest approach between this ray and the given point.
   *
   * @param {Vector3} point - A point in 3D space to compute the distance to.
   * @return {number} The distance.
   */
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  }
  /**
   * Returns the squared distance of the closest approach between this ray and the given point.
   *
   * @param {Vector3} point - A point in 3D space to compute the distance to.
   * @return {number} The squared distance.
   */
  distanceSqToPoint(e) {
    const t = pl.subVectors(e, this.origin).dot(this.direction);
    return t < 0 ? this.origin.distanceToSquared(e) : (pl.copy(this.origin).addScaledVector(this.direction, t), pl.distanceToSquared(e));
  }
  /**
   * Returns the squared distance between this ray and the given line segment.
   *
   * @param {Vector3} v0 - The start point of the line segment.
   * @param {Vector3} v1 - The end point of the line segment.
   * @param {Vector3} [optionalPointOnRay] - When provided, it receives the point on this ray that is closest to the segment.
   * @param {Vector3} [optionalPointOnSegment] - When provided, it receives the point on the line segment that is closest to this ray.
   * @return {number} The squared distance.
   */
  distanceSqToSegment(e, t, n, r) {
    $x.copy(e).add(t).multiplyScalar(0.5), am.copy(t).sub(e).normalize(), hu.copy(this.origin).sub($x);
    const s = e.distanceTo(t) * 0.5, o = -this.direction.dot(am), a = hu.dot(this.direction), l = -hu.dot(am), u = hu.lengthSq(), c = Math.abs(1 - o * o);
    let A, m, _, y;
    if (c > 0)
      if (A = o * l - a, m = o * a - l, y = s * c, A >= 0)
        if (m >= -y)
          if (m <= y) {
            const T = 1 / c;
            A *= T, m *= T, _ = A * (A + o * m + 2 * a) + m * (o * A + m + 2 * l) + u;
          } else
            m = s, A = Math.max(0, -(o * m + a)), _ = -A * A + m * (m + 2 * l) + u;
        else
          m = -s, A = Math.max(0, -(o * m + a)), _ = -A * A + m * (m + 2 * l) + u;
      else
        m <= -y ? (A = Math.max(0, -(-o * s + a)), m = A > 0 ? -s : Math.min(Math.max(-s, -l), s), _ = -A * A + m * (m + 2 * l) + u) : m <= y ? (A = 0, m = Math.min(Math.max(-s, -l), s), _ = m * (m + 2 * l) + u) : (A = Math.max(0, -(o * s + a)), m = A > 0 ? s : Math.min(Math.max(-s, -l), s), _ = -A * A + m * (m + 2 * l) + u);
    else
      m = o > 0 ? -s : s, A = Math.max(0, -(o * m + a)), _ = -A * A + m * (m + 2 * l) + u;
    return n && n.copy(this.origin).addScaledVector(this.direction, A), r && r.copy($x).addScaledVector(am, m), _;
  }
  /**
   * Intersects this ray with the given sphere, returning the intersection
   * point or `null` if there is no intersection.
   *
   * @param {Sphere} sphere - The sphere to intersect.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {?Vector3} The intersection point.
   */
  intersectSphere(e, t) {
    pl.subVectors(e.center, this.origin);
    const n = pl.dot(this.direction), r = pl.dot(pl) - n * n, s = e.radius * e.radius;
    if (r > s) return null;
    const o = Math.sqrt(s - r), a = n - o, l = n + o;
    return l < 0 ? null : a < 0 ? this.at(l, t) : this.at(a, t);
  }
  /**
   * Returns `true` if this ray intersects with the given sphere.
   *
   * @param {Sphere} sphere - The sphere to intersect.
   * @return {boolean} Whether this ray intersects with the given sphere or not.
   */
  intersectsSphere(e) {
    return e.radius < 0 ? !1 : this.distanceSqToPoint(e.center) <= e.radius * e.radius;
  }
  /**
   * Computes the distance from the ray's origin to the given plane. Returns `null` if the ray
   * does not intersect with the plane.
   *
   * @param {Plane} plane - The plane to compute the distance to.
   * @return {?number} Whether this ray intersects with the given sphere or not.
   */
  distanceToPlane(e) {
    const t = e.normal.dot(this.direction);
    if (t === 0)
      return e.distanceToPoint(this.origin) === 0 ? 0 : null;
    const n = -(this.origin.dot(e.normal) + e.constant) / t;
    return n >= 0 ? n : null;
  }
  /**
   * Intersects this ray with the given plane, returning the intersection
   * point or `null` if there is no intersection.
   *
   * @param {Plane} plane - The plane to intersect.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {?Vector3} The intersection point.
   */
  intersectPlane(e, t) {
    const n = this.distanceToPlane(e);
    return n === null ? null : this.at(n, t);
  }
  /**
   * Returns `true` if this ray intersects with the given plane.
   *
   * @param {Plane} plane - The plane to intersect.
   * @return {boolean} Whether this ray intersects with the given plane or not.
   */
  intersectsPlane(e) {
    const t = e.distanceToPoint(this.origin);
    return t === 0 || e.normal.dot(this.direction) * t < 0;
  }
  /**
   * Intersects this ray with the given bounding box, returning the intersection
   * point or `null` if there is no intersection.
   *
   * @param {Box3} box - The box to intersect.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {?Vector3} The intersection point.
   */
  intersectBox(e, t) {
    let n, r, s, o, a, l;
    const u = 1 / this.direction.x, c = 1 / this.direction.y, A = 1 / this.direction.z, m = this.origin;
    return u >= 0 ? (n = (e.min.x - m.x) * u, r = (e.max.x - m.x) * u) : (n = (e.max.x - m.x) * u, r = (e.min.x - m.x) * u), c >= 0 ? (s = (e.min.y - m.y) * c, o = (e.max.y - m.y) * c) : (s = (e.max.y - m.y) * c, o = (e.min.y - m.y) * c), n > o || s > r || ((s > n || isNaN(n)) && (n = s), (o < r || isNaN(r)) && (r = o), A >= 0 ? (a = (e.min.z - m.z) * A, l = (e.max.z - m.z) * A) : (a = (e.max.z - m.z) * A, l = (e.min.z - m.z) * A), n > l || a > r) || ((a > n || n !== n) && (n = a), (l < r || r !== r) && (r = l), r < 0) ? null : this.at(n >= 0 ? n : r, t);
  }
  /**
   * Returns `true` if this ray intersects with the given box.
   *
   * @param {Box3} box - The box to intersect.
   * @return {boolean} Whether this ray intersects with the given box or not.
   */
  intersectsBox(e) {
    return this.intersectBox(e, pl) !== null;
  }
  /**
   * Intersects this ray with the given triangle, returning the intersection
   * point or `null` if there is no intersection.
   *
   * @param {Vector3} a - The first vertex of the triangle.
   * @param {Vector3} b - The second vertex of the triangle.
   * @param {Vector3} c - The third vertex of the triangle.
   * @param {boolean} backfaceCulling - Whether to use backface culling or not.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {?Vector3} The intersection point.
   */
  intersectTriangle(e, t, n, r, s) {
    jx.subVectors(t, e), lm.subVectors(n, e), Xx.crossVectors(jx, lm);
    let o = this.direction.dot(Xx), a;
    if (o > 0) {
      if (r) return null;
      a = 1;
    } else if (o < 0)
      a = -1, o = -o;
    else
      return null;
    hu.subVectors(this.origin, e);
    const l = a * this.direction.dot(lm.crossVectors(hu, lm));
    if (l < 0)
      return null;
    const u = a * this.direction.dot(jx.cross(hu));
    if (u < 0 || l + u > o)
      return null;
    const c = -a * hu.dot(Xx);
    return c < 0 ? null : this.at(c / o, s);
  }
  /**
   * Transforms this ray with the given 4x4 transformation matrix.
   *
   * @param {Matrix4} matrix4 - The transformation matrix.
   * @return {Ray} A reference to this ray.
   */
  applyMatrix4(e) {
    return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this;
  }
  /**
   * Returns `true` if this ray is equal with the given one.
   *
   * @param {Ray} ray - The ray to test for equality.
   * @return {boolean} Whether this ray is equal with the given one.
   */
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
  /**
   * Returns a new ray with copied values from this instance.
   *
   * @return {Ray} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
}
class Mt {
  /**
   * Constructs a new 4x4 matrix. The arguments are supposed to be
   * in row-major order. If no arguments are provided, the constructor
   * initializes the matrix as an identity matrix.
   *
   * @param {number} [n11] - 1-1 matrix element.
   * @param {number} [n12] - 1-2 matrix element.
   * @param {number} [n13] - 1-3 matrix element.
   * @param {number} [n14] - 1-4 matrix element.
   * @param {number} [n21] - 2-1 matrix element.
   * @param {number} [n22] - 2-2 matrix element.
   * @param {number} [n23] - 2-3 matrix element.
   * @param {number} [n24] - 2-4 matrix element.
   * @param {number} [n31] - 3-1 matrix element.
   * @param {number} [n32] - 3-2 matrix element.
   * @param {number} [n33] - 3-3 matrix element.
   * @param {number} [n34] - 3-4 matrix element.
   * @param {number} [n41] - 4-1 matrix element.
   * @param {number} [n42] - 4-2 matrix element.
   * @param {number} [n43] - 4-3 matrix element.
   * @param {number} [n44] - 4-4 matrix element.
   */
  constructor(e, t, n, r, s, o, a, l, u, c, A, m, _, y, T, b) {
    Mt.prototype.isMatrix4 = !0, this.elements = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, t, n, r, s, o, a, l, u, c, A, m, _, y, T, b);
  }
  /**
   * Sets the elements of the matrix.The arguments are supposed to be
   * in row-major order.
   *
   * @param {number} [n11] - 1-1 matrix element.
   * @param {number} [n12] - 1-2 matrix element.
   * @param {number} [n13] - 1-3 matrix element.
   * @param {number} [n14] - 1-4 matrix element.
   * @param {number} [n21] - 2-1 matrix element.
   * @param {number} [n22] - 2-2 matrix element.
   * @param {number} [n23] - 2-3 matrix element.
   * @param {number} [n24] - 2-4 matrix element.
   * @param {number} [n31] - 3-1 matrix element.
   * @param {number} [n32] - 3-2 matrix element.
   * @param {number} [n33] - 3-3 matrix element.
   * @param {number} [n34] - 3-4 matrix element.
   * @param {number} [n41] - 4-1 matrix element.
   * @param {number} [n42] - 4-2 matrix element.
   * @param {number} [n43] - 4-3 matrix element.
   * @param {number} [n44] - 4-4 matrix element.
   * @return {Matrix4} A reference to this matrix.
   */
  set(e, t, n, r, s, o, a, l, u, c, A, m, _, y, T, b) {
    const S = this.elements;
    return S[0] = e, S[4] = t, S[8] = n, S[12] = r, S[1] = s, S[5] = o, S[9] = a, S[13] = l, S[2] = u, S[6] = c, S[10] = A, S[14] = m, S[3] = _, S[7] = y, S[11] = T, S[15] = b, this;
  }
  /**
   * Sets this matrix to the 4x4 identity matrix.
   *
   * @return {Matrix4} A reference to this matrix.
   */
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  /**
   * Returns a matrix with copied values from this instance.
   *
   * @return {Matrix4} A clone of this instance.
   */
  clone() {
    return new Mt().fromArray(this.elements);
  }
  /**
   * Copies the values of the given matrix to this instance.
   *
   * @param {Matrix4} m - The matrix to copy.
   * @return {Matrix4} A reference to this matrix.
   */
  copy(e) {
    const t = this.elements, n = e.elements;
    return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], t[9] = n[9], t[10] = n[10], t[11] = n[11], t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15], this;
  }
  /**
   * Copies the translation component of the given matrix
   * into this matrix's translation component.
   *
   * @param {Matrix4} m - The matrix to copy the translation component.
   * @return {Matrix4} A reference to this matrix.
   */
  copyPosition(e) {
    const t = this.elements, n = e.elements;
    return t[12] = n[12], t[13] = n[13], t[14] = n[14], this;
  }
  /**
   * Set the upper 3x3 elements of this matrix to the values of given 3x3 matrix.
   *
   * @param {Matrix3} m - The 3x3 matrix.
   * @return {Matrix4} A reference to this matrix.
   */
  setFromMatrix3(e) {
    const t = e.elements;
    return this.set(
      t[0],
      t[3],
      t[6],
      0,
      t[1],
      t[4],
      t[7],
      0,
      t[2],
      t[5],
      t[8],
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  /**
   * Extracts the basis of this matrix into the three axis vectors provided.
   *
   * @param {Vector3} xAxis - The basis's x axis.
   * @param {Vector3} yAxis - The basis's y axis.
   * @param {Vector3} zAxis - The basis's z axis.
   * @return {Matrix4} A reference to this matrix.
   */
  extractBasis(e, t, n) {
    return this.determinant() === 0 ? (e.set(1, 0, 0), t.set(0, 1, 0), n.set(0, 0, 1), this) : (e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this);
  }
  /**
   * Sets the given basis vectors to this matrix.
   *
   * @param {Vector3} xAxis - The basis's x axis.
   * @param {Vector3} yAxis - The basis's y axis.
   * @param {Vector3} zAxis - The basis's z axis.
   * @return {Matrix4} A reference to this matrix.
   */
  makeBasis(e, t, n) {
    return this.set(
      e.x,
      t.x,
      n.x,
      0,
      e.y,
      t.y,
      n.y,
      0,
      e.z,
      t.z,
      n.z,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  /**
   * Extracts the rotation component of the given matrix
   * into this matrix's rotation component.
   *
   * Note: This method does not support reflection matrices.
   *
   * @param {Matrix4} m - The matrix.
   * @return {Matrix4} A reference to this matrix.
   */
  extractRotation(e) {
    if (e.determinant() === 0)
      return this.identity();
    const t = this.elements, n = e.elements, r = 1 / vd.setFromMatrixColumn(e, 0).length(), s = 1 / vd.setFromMatrixColumn(e, 1).length(), o = 1 / vd.setFromMatrixColumn(e, 2).length();
    return t[0] = n[0] * r, t[1] = n[1] * r, t[2] = n[2] * r, t[3] = 0, t[4] = n[4] * s, t[5] = n[5] * s, t[6] = n[6] * s, t[7] = 0, t[8] = n[8] * o, t[9] = n[9] * o, t[10] = n[10] * o, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
  }
  /**
   * Sets the rotation component (the upper left 3x3 matrix) of this matrix to
   * the rotation specified by the given Euler angles. The rest of
   * the matrix is set to the identity. Depending on the {@link Euler#order},
   * there are six possible outcomes. See [this page](https://en.wikipedia.org/wiki/Euler_angles#Rotation_matrix)
   * for a complete list.
   *
   * @param {Euler} euler - The Euler angles.
   * @return {Matrix4} A reference to this matrix.
   */
  makeRotationFromEuler(e) {
    const t = this.elements, n = e.x, r = e.y, s = e.z, o = Math.cos(n), a = Math.sin(n), l = Math.cos(r), u = Math.sin(r), c = Math.cos(s), A = Math.sin(s);
    if (e.order === "XYZ") {
      const m = o * c, _ = o * A, y = a * c, T = a * A;
      t[0] = l * c, t[4] = -l * A, t[8] = u, t[1] = _ + y * u, t[5] = m - T * u, t[9] = -a * l, t[2] = T - m * u, t[6] = y + _ * u, t[10] = o * l;
    } else if (e.order === "YXZ") {
      const m = l * c, _ = l * A, y = u * c, T = u * A;
      t[0] = m + T * a, t[4] = y * a - _, t[8] = o * u, t[1] = o * A, t[5] = o * c, t[9] = -a, t[2] = _ * a - y, t[6] = T + m * a, t[10] = o * l;
    } else if (e.order === "ZXY") {
      const m = l * c, _ = l * A, y = u * c, T = u * A;
      t[0] = m - T * a, t[4] = -o * A, t[8] = y + _ * a, t[1] = _ + y * a, t[5] = o * c, t[9] = T - m * a, t[2] = -o * u, t[6] = a, t[10] = o * l;
    } else if (e.order === "ZYX") {
      const m = o * c, _ = o * A, y = a * c, T = a * A;
      t[0] = l * c, t[4] = y * u - _, t[8] = m * u + T, t[1] = l * A, t[5] = T * u + m, t[9] = _ * u - y, t[2] = -u, t[6] = a * l, t[10] = o * l;
    } else if (e.order === "YZX") {
      const m = o * l, _ = o * u, y = a * l, T = a * u;
      t[0] = l * c, t[4] = T - m * A, t[8] = y * A + _, t[1] = A, t[5] = o * c, t[9] = -a * c, t[2] = -u * c, t[6] = _ * A + y, t[10] = m - T * A;
    } else if (e.order === "XZY") {
      const m = o * l, _ = o * u, y = a * l, T = a * u;
      t[0] = l * c, t[4] = -A, t[8] = u * c, t[1] = m * A + T, t[5] = o * c, t[9] = _ * A - y, t[2] = y * A - _, t[6] = a * c, t[10] = T * A + m;
    }
    return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
  }
  /**
   * Sets the rotation component of this matrix to the rotation specified by
   * the given Quaternion as outlined [here](https://en.wikipedia.org/wiki/Rotation_matrix#Quaternion)
   * The rest of the matrix is set to the identity.
   *
   * @param {Quaternion} q - The Quaternion.
   * @return {Matrix4} A reference to this matrix.
   */
  makeRotationFromQuaternion(e) {
    return this.compose(hU, e, dU);
  }
  /**
   * Sets the rotation component of the transformation matrix, looking from `eye` towards
   * `target`, and oriented by the up-direction.
   *
   * @param {Vector3} eye - The eye vector.
   * @param {Vector3} target - The target vector.
   * @param {Vector3} up - The up vector.
   * @return {Matrix4} A reference to this matrix.
   */
  lookAt(e, t, n) {
    const r = this.elements;
    return fo.subVectors(e, t), fo.lengthSq() === 0 && (fo.z = 1), fo.normalize(), du.crossVectors(n, fo), du.lengthSq() === 0 && (Math.abs(n.z) === 1 ? fo.x += 1e-4 : fo.z += 1e-4, fo.normalize(), du.crossVectors(n, fo)), du.normalize(), um.crossVectors(fo, du), r[0] = du.x, r[4] = um.x, r[8] = fo.x, r[1] = du.y, r[5] = um.y, r[9] = fo.y, r[2] = du.z, r[6] = um.z, r[10] = fo.z, this;
  }
  /**
   * Post-multiplies this matrix by the given 4x4 matrix.
   *
   * @param {Matrix4} m - The matrix to multiply with.
   * @return {Matrix4} A reference to this matrix.
   */
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  /**
   * Pre-multiplies this matrix by the given 4x4 matrix.
   *
   * @param {Matrix4} m - The matrix to multiply with.
   * @return {Matrix4} A reference to this matrix.
   */
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  /**
   * Multiples the given 4x4 matrices and stores the result
   * in this matrix.
   *
   * @param {Matrix4} a - The first matrix.
   * @param {Matrix4} b - The second matrix.
   * @return {Matrix4} A reference to this matrix.
   */
  multiplyMatrices(e, t) {
    const n = e.elements, r = t.elements, s = this.elements, o = n[0], a = n[4], l = n[8], u = n[12], c = n[1], A = n[5], m = n[9], _ = n[13], y = n[2], T = n[6], b = n[10], S = n[14], E = n[3], R = n[7], C = n[11], L = n[15], D = r[0], B = r[4], U = r[8], N = r[12], O = r[1], G = r[5], H = r[9], Y = r[13], K = r[2], X = r[6], ee = r[10], oe = r[14], fe = r[3], _e = r[7], Te = r[11], Ce = r[15];
    return s[0] = o * D + a * O + l * K + u * fe, s[4] = o * B + a * G + l * X + u * _e, s[8] = o * U + a * H + l * ee + u * Te, s[12] = o * N + a * Y + l * oe + u * Ce, s[1] = c * D + A * O + m * K + _ * fe, s[5] = c * B + A * G + m * X + _ * _e, s[9] = c * U + A * H + m * ee + _ * Te, s[13] = c * N + A * Y + m * oe + _ * Ce, s[2] = y * D + T * O + b * K + S * fe, s[6] = y * B + T * G + b * X + S * _e, s[10] = y * U + T * H + b * ee + S * Te, s[14] = y * N + T * Y + b * oe + S * Ce, s[3] = E * D + R * O + C * K + L * fe, s[7] = E * B + R * G + C * X + L * _e, s[11] = E * U + R * H + C * ee + L * Te, s[15] = E * N + R * Y + C * oe + L * Ce, this;
  }
  /**
   * Multiplies every component of the matrix by the given scalar.
   *
   * @param {number} s - The scalar.
   * @return {Matrix4} A reference to this matrix.
   */
  multiplyScalar(e) {
    const t = this.elements;
    return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this;
  }
  /**
   * Computes and returns the determinant of this matrix.
   *
   * Based on the method outlined [here](http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.html).
   *
   * @return {number} The determinant.
   */
  determinant() {
    const e = this.elements, t = e[0], n = e[4], r = e[8], s = e[12], o = e[1], a = e[5], l = e[9], u = e[13], c = e[2], A = e[6], m = e[10], _ = e[14], y = e[3], T = e[7], b = e[11], S = e[15], E = l * _ - u * m, R = a * _ - u * A, C = a * m - l * A, L = o * _ - u * c, D = o * m - l * c, B = o * A - a * c;
    return t * (T * E - b * R + S * C) - n * (y * E - b * L + S * D) + r * (y * R - T * L + S * B) - s * (y * C - T * D + b * B);
  }
  /**
   * Transposes this matrix in place.
   *
   * @return {Matrix4} A reference to this matrix.
   */
  transpose() {
    const e = this.elements;
    let t;
    return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this;
  }
  /**
   * Sets the position component for this matrix from the given vector,
   * without affecting the rest of the matrix.
   *
   * @param {number|Vector3} x - The x component of the vector or alternatively the vector object.
   * @param {number} y - The y component of the vector.
   * @param {number} z - The z component of the vector.
   * @return {Matrix4} A reference to this matrix.
   */
  setPosition(e, t, n) {
    const r = this.elements;
    return e.isVector3 ? (r[12] = e.x, r[13] = e.y, r[14] = e.z) : (r[12] = e, r[13] = t, r[14] = n), this;
  }
  /**
   * Inverts this matrix, using the [analytic method](https://en.wikipedia.org/wiki/Invertible_matrix#Analytic_solution).
   * You can not invert with a determinant of zero. If you attempt this, the method produces
   * a zero matrix instead.
   *
   * @return {Matrix4} A reference to this matrix.
   */
  invert() {
    const e = this.elements, t = e[0], n = e[1], r = e[2], s = e[3], o = e[4], a = e[5], l = e[6], u = e[7], c = e[8], A = e[9], m = e[10], _ = e[11], y = e[12], T = e[13], b = e[14], S = e[15], E = A * b * u - T * m * u + T * l * _ - a * b * _ - A * l * S + a * m * S, R = y * m * u - c * b * u - y * l * _ + o * b * _ + c * l * S - o * m * S, C = c * T * u - y * A * u + y * a * _ - o * T * _ - c * a * S + o * A * S, L = y * A * l - c * T * l - y * a * m + o * T * m + c * a * b - o * A * b, D = t * E + n * R + r * C + s * L;
    if (D === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const B = 1 / D;
    return e[0] = E * B, e[1] = (T * m * s - A * b * s - T * r * _ + n * b * _ + A * r * S - n * m * S) * B, e[2] = (a * b * s - T * l * s + T * r * u - n * b * u - a * r * S + n * l * S) * B, e[3] = (A * l * s - a * m * s - A * r * u + n * m * u + a * r * _ - n * l * _) * B, e[4] = R * B, e[5] = (c * b * s - y * m * s + y * r * _ - t * b * _ - c * r * S + t * m * S) * B, e[6] = (y * l * s - o * b * s - y * r * u + t * b * u + o * r * S - t * l * S) * B, e[7] = (o * m * s - c * l * s + c * r * u - t * m * u - o * r * _ + t * l * _) * B, e[8] = C * B, e[9] = (y * A * s - c * T * s - y * n * _ + t * T * _ + c * n * S - t * A * S) * B, e[10] = (o * T * s - y * a * s + y * n * u - t * T * u - o * n * S + t * a * S) * B, e[11] = (c * a * s - o * A * s - c * n * u + t * A * u + o * n * _ - t * a * _) * B, e[12] = L * B, e[13] = (c * T * r - y * A * r + y * n * m - t * T * m - c * n * b + t * A * b) * B, e[14] = (y * a * r - o * T * r - y * n * l + t * T * l + o * n * b - t * a * b) * B, e[15] = (o * A * r - c * a * r + c * n * l - t * A * l - o * n * m + t * a * m) * B, this;
  }
  /**
   * Multiplies the columns of this matrix by the given vector.
   *
   * @param {Vector3} v - The scale vector.
   * @return {Matrix4} A reference to this matrix.
   */
  scale(e) {
    const t = this.elements, n = e.x, r = e.y, s = e.z;
    return t[0] *= n, t[4] *= r, t[8] *= s, t[1] *= n, t[5] *= r, t[9] *= s, t[2] *= n, t[6] *= r, t[10] *= s, t[3] *= n, t[7] *= r, t[11] *= s, this;
  }
  /**
   * Gets the maximum scale value of the three axes.
   *
   * @return {number} The maximum scale.
   */
  getMaxScaleOnAxis() {
    const e = this.elements, t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], r = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(t, n, r));
  }
  /**
   * Sets this matrix as a translation transform from the given vector.
   *
   * @param {number|Vector3} x - The amount to translate in the X axis or alternatively a translation vector.
   * @param {number} y - The amount to translate in the Y axis.
   * @param {number} z - The amount to translate in the z axis.
   * @return {Matrix4} A reference to this matrix.
   */
  makeTranslation(e, t, n) {
    return e.isVector3 ? this.set(
      1,
      0,
      0,
      e.x,
      0,
      1,
      0,
      e.y,
      0,
      0,
      1,
      e.z,
      0,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      0,
      e,
      0,
      1,
      0,
      t,
      0,
      0,
      1,
      n,
      0,
      0,
      0,
      1
    ), this;
  }
  /**
   * Sets this matrix as a rotational transformation around the X axis by
   * the given angle.
   *
   * @param {number} theta - The rotation in radians.
   * @return {Matrix4} A reference to this matrix.
   */
  makeRotationX(e) {
    const t = Math.cos(e), n = Math.sin(e);
    return this.set(
      1,
      0,
      0,
      0,
      0,
      t,
      -n,
      0,
      0,
      n,
      t,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  /**
   * Sets this matrix as a rotational transformation around the Y axis by
   * the given angle.
   *
   * @param {number} theta - The rotation in radians.
   * @return {Matrix4} A reference to this matrix.
   */
  makeRotationY(e) {
    const t = Math.cos(e), n = Math.sin(e);
    return this.set(
      t,
      0,
      n,
      0,
      0,
      1,
      0,
      0,
      -n,
      0,
      t,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  /**
   * Sets this matrix as a rotational transformation around the Z axis by
   * the given angle.
   *
   * @param {number} theta - The rotation in radians.
   * @return {Matrix4} A reference to this matrix.
   */
  makeRotationZ(e) {
    const t = Math.cos(e), n = Math.sin(e);
    return this.set(
      t,
      -n,
      0,
      0,
      n,
      t,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  /**
   * Sets this matrix as a rotational transformation around the given axis by
   * the given angle.
   *
   * This is a somewhat controversial but mathematically sound alternative to
   * rotating via Quaternions. See the discussion [here](https://www.gamedev.net/articles/programming/math-and-physics/do-we-really-need-quaternions-r1199).
   *
   * @param {Vector3} axis - The normalized rotation axis.
   * @param {number} angle - The rotation in radians.
   * @return {Matrix4} A reference to this matrix.
   */
  makeRotationAxis(e, t) {
    const n = Math.cos(t), r = Math.sin(t), s = 1 - n, o = e.x, a = e.y, l = e.z, u = s * o, c = s * a;
    return this.set(
      u * o + n,
      u * a - r * l,
      u * l + r * a,
      0,
      u * a + r * l,
      c * a + n,
      c * l - r * o,
      0,
      u * l - r * a,
      c * l + r * o,
      s * l * l + n,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  /**
   * Sets this matrix as a scale transformation.
   *
   * @param {number} x - The amount to scale in the X axis.
   * @param {number} y - The amount to scale in the Y axis.
   * @param {number} z - The amount to scale in the Z axis.
   * @return {Matrix4} A reference to this matrix.
   */
  makeScale(e, t, n) {
    return this.set(
      e,
      0,
      0,
      0,
      0,
      t,
      0,
      0,
      0,
      0,
      n,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  /**
   * Sets this matrix as a shear transformation.
   *
   * @param {number} xy - The amount to shear X by Y.
   * @param {number} xz - The amount to shear X by Z.
   * @param {number} yx - The amount to shear Y by X.
   * @param {number} yz - The amount to shear Y by Z.
   * @param {number} zx - The amount to shear Z by X.
   * @param {number} zy - The amount to shear Z by Y.
   * @return {Matrix4} A reference to this matrix.
   */
  makeShear(e, t, n, r, s, o) {
    return this.set(
      1,
      n,
      s,
      0,
      e,
      1,
      o,
      0,
      t,
      r,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  /**
   * Sets this matrix to the transformation composed of the given position,
   * rotation (Quaternion) and scale.
   *
   * @param {Vector3} position - The position vector.
   * @param {Quaternion} quaternion - The rotation as a Quaternion.
   * @param {Vector3} scale - The scale vector.
   * @return {Matrix4} A reference to this matrix.
   */
  compose(e, t, n) {
    const r = this.elements, s = t._x, o = t._y, a = t._z, l = t._w, u = s + s, c = o + o, A = a + a, m = s * u, _ = s * c, y = s * A, T = o * c, b = o * A, S = a * A, E = l * u, R = l * c, C = l * A, L = n.x, D = n.y, B = n.z;
    return r[0] = (1 - (T + S)) * L, r[1] = (_ + C) * L, r[2] = (y - R) * L, r[3] = 0, r[4] = (_ - C) * D, r[5] = (1 - (m + S)) * D, r[6] = (b + E) * D, r[7] = 0, r[8] = (y + R) * B, r[9] = (b - E) * B, r[10] = (1 - (m + T)) * B, r[11] = 0, r[12] = e.x, r[13] = e.y, r[14] = e.z, r[15] = 1, this;
  }
  /**
   * Decomposes this matrix into its position, rotation and scale components
   * and provides the result in the given objects.
   *
   * Note: Not all matrices are decomposable in this way. For example, if an
   * object has a non-uniformly scaled parent, then the object's world matrix
   * may not be decomposable, and this method may not be appropriate.
   *
   * @param {Vector3} position - The position vector.
   * @param {Quaternion} quaternion - The rotation as a Quaternion.
   * @param {Vector3} scale - The scale vector.
   * @return {Matrix4} A reference to this matrix.
   */
  decompose(e, t, n) {
    const r = this.elements;
    if (e.x = r[12], e.y = r[13], e.z = r[14], this.determinant() === 0)
      return n.set(1, 1, 1), t.identity(), this;
    let s = vd.set(r[0], r[1], r[2]).length();
    const o = vd.set(r[4], r[5], r[6]).length(), a = vd.set(r[8], r[9], r[10]).length();
    this.determinant() < 0 && (s = -s), ia.copy(this);
    const u = 1 / s, c = 1 / o, A = 1 / a;
    return ia.elements[0] *= u, ia.elements[1] *= u, ia.elements[2] *= u, ia.elements[4] *= c, ia.elements[5] *= c, ia.elements[6] *= c, ia.elements[8] *= A, ia.elements[9] *= A, ia.elements[10] *= A, t.setFromRotationMatrix(ia), n.x = s, n.y = o, n.z = a, this;
  }
  /**
  	 * Creates a perspective projection matrix. This is used internally by
  	 * {@link PerspectiveCamera#updateProjectionMatrix}.

  	 * @param {number} left - Left boundary of the viewing frustum at the near plane.
  	 * @param {number} right - Right boundary of the viewing frustum at the near plane.
  	 * @param {number} top - Top boundary of the viewing frustum at the near plane.
  	 * @param {number} bottom - Bottom boundary of the viewing frustum at the near plane.
  	 * @param {number} near - The distance from the camera to the near plane.
  	 * @param {number} far - The distance from the camera to the far plane.
  	 * @param {(WebGLCoordinateSystem|WebGPUCoordinateSystem)} [coordinateSystem=WebGLCoordinateSystem] - The coordinate system.
  	 * @param {boolean} [reversedDepth=false] - Whether to use a reversed depth.
  	 * @return {Matrix4} A reference to this matrix.
  	 */
  makePerspective(e, t, n, r, s, o, a = jr, l = !1) {
    const u = this.elements, c = 2 * s / (t - e), A = 2 * s / (n - r), m = (t + e) / (t - e), _ = (n + r) / (n - r);
    let y, T;
    if (l)
      y = s / (o - s), T = o * s / (o - s);
    else if (a === jr)
      y = -(o + s) / (o - s), T = -2 * o * s / (o - s);
    else if (a === io)
      y = -o / (o - s), T = -o * s / (o - s);
    else
      throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + a);
    return u[0] = c, u[4] = 0, u[8] = m, u[12] = 0, u[1] = 0, u[5] = A, u[9] = _, u[13] = 0, u[2] = 0, u[6] = 0, u[10] = y, u[14] = T, u[3] = 0, u[7] = 0, u[11] = -1, u[15] = 0, this;
  }
  /**
  	 * Creates a orthographic projection matrix. This is used internally by
  	 * {@link OrthographicCamera#updateProjectionMatrix}.

  	 * @param {number} left - Left boundary of the viewing frustum at the near plane.
  	 * @param {number} right - Right boundary of the viewing frustum at the near plane.
  	 * @param {number} top - Top boundary of the viewing frustum at the near plane.
  	 * @param {number} bottom - Bottom boundary of the viewing frustum at the near plane.
  	 * @param {number} near - The distance from the camera to the near plane.
  	 * @param {number} far - The distance from the camera to the far plane.
  	 * @param {(WebGLCoordinateSystem|WebGPUCoordinateSystem)} [coordinateSystem=WebGLCoordinateSystem] - The coordinate system.
  	 * @param {boolean} [reversedDepth=false] - Whether to use a reversed depth.
  	 * @return {Matrix4} A reference to this matrix.
  	 */
  makeOrthographic(e, t, n, r, s, o, a = jr, l = !1) {
    const u = this.elements, c = 2 / (t - e), A = 2 / (n - r), m = -(t + e) / (t - e), _ = -(n + r) / (n - r);
    let y, T;
    if (l)
      y = 1 / (o - s), T = o / (o - s);
    else if (a === jr)
      y = -2 / (o - s), T = -(o + s) / (o - s);
    else if (a === io)
      y = -1 / (o - s), T = -s / (o - s);
    else
      throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + a);
    return u[0] = c, u[4] = 0, u[8] = 0, u[12] = m, u[1] = 0, u[5] = A, u[9] = 0, u[13] = _, u[2] = 0, u[6] = 0, u[10] = y, u[14] = T, u[3] = 0, u[7] = 0, u[11] = 0, u[15] = 1, this;
  }
  /**
   * Returns `true` if this matrix is equal with the given one.
   *
   * @param {Matrix4} matrix - The matrix to test for equality.
   * @return {boolean} Whether this matrix is equal with the given one.
   */
  equals(e) {
    const t = this.elements, n = e.elements;
    for (let r = 0; r < 16; r++)
      if (t[r] !== n[r]) return !1;
    return !0;
  }
  /**
   * Sets the elements of the matrix from the given array.
   *
   * @param {Array<number>} array - The matrix elements in column-major order.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Matrix4} A reference to this matrix.
   */
  fromArray(e, t = 0) {
    for (let n = 0; n < 16; n++)
      this.elements[n] = e[n + t];
    return this;
  }
  /**
   * Writes the elements of this matrix to the given array. If no array is provided,
   * the method returns a new instance.
   *
   * @param {Array<number>} [array=[]] - The target array holding the matrix elements in column-major order.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Array<number>} The matrix elements in column-major order.
   */
  toArray(e = [], t = 0) {
    const n = this.elements;
    return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e[t + 9] = n[9], e[t + 10] = n[10], e[t + 11] = n[11], e[t + 12] = n[12], e[t + 13] = n[13], e[t + 14] = n[14], e[t + 15] = n[15], e;
  }
}
const vd = /* @__PURE__ */ new j(), ia = /* @__PURE__ */ new Mt(), hU = /* @__PURE__ */ new j(0, 0, 0), dU = /* @__PURE__ */ new j(1, 1, 1), du = /* @__PURE__ */ new j(), um = /* @__PURE__ */ new j(), fo = /* @__PURE__ */ new j(), mM = /* @__PURE__ */ new Mt(), gM = /* @__PURE__ */ new hr();
class Ir {
  /**
   * Constructs a new euler instance.
   *
   * @param {number} [x=0] - The angle of the x axis in radians.
   * @param {number} [y=0] - The angle of the y axis in radians.
   * @param {number} [z=0] - The angle of the z axis in radians.
   * @param {string} [order=Euler.DEFAULT_ORDER] - A string representing the order that the rotations are applied.
   */
  constructor(e = 0, t = 0, n = 0, r = Ir.DEFAULT_ORDER) {
    this.isEuler = !0, this._x = e, this._y = t, this._z = n, this._order = r;
  }
  /**
   * The angle of the x axis in radians.
   *
   * @type {number}
   * @default 0
   */
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  /**
   * The angle of the y axis in radians.
   *
   * @type {number}
   * @default 0
   */
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  /**
   * The angle of the z axis in radians.
   *
   * @type {number}
   * @default 0
   */
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  /**
   * A string representing the order that the rotations are applied.
   *
   * @type {string}
   * @default 'XYZ'
   */
  get order() {
    return this._order;
  }
  set order(e) {
    this._order = e, this._onChangeCallback();
  }
  /**
   * Sets the Euler components.
   *
   * @param {number} x - The angle of the x axis in radians.
   * @param {number} y - The angle of the y axis in radians.
   * @param {number} z - The angle of the z axis in radians.
   * @param {string} [order] - A string representing the order that the rotations are applied.
   * @return {Euler} A reference to this Euler instance.
   */
  set(e, t, n, r = this._order) {
    return this._x = e, this._y = t, this._z = n, this._order = r, this._onChangeCallback(), this;
  }
  /**
   * Returns a new Euler instance with copied values from this instance.
   *
   * @return {Euler} A clone of this instance.
   */
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  /**
   * Copies the values of the given Euler instance to this instance.
   *
   * @param {Euler} euler - The Euler instance to copy.
   * @return {Euler} A reference to this Euler instance.
   */
  copy(e) {
    return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this;
  }
  /**
   * Sets the angles of this Euler instance from a pure rotation matrix.
   *
   * @param {Matrix4} m - A 4x4 matrix of which the upper 3x3 of matrix is a pure rotation matrix (i.e. unscaled).
   * @param {string} [order] - A string representing the order that the rotations are applied.
   * @param {boolean} [update=true] - Whether the internal `onChange` callback should be executed or not.
   * @return {Euler} A reference to this Euler instance.
   */
  setFromRotationMatrix(e, t = this._order, n = !0) {
    const r = e.elements, s = r[0], o = r[4], a = r[8], l = r[1], u = r[5], c = r[9], A = r[2], m = r[6], _ = r[10];
    switch (t) {
      case "XYZ":
        this._y = Math.asin(dn(a, -1, 1)), Math.abs(a) < 0.9999999 ? (this._x = Math.atan2(-c, _), this._z = Math.atan2(-o, s)) : (this._x = Math.atan2(m, u), this._z = 0);
        break;
      case "YXZ":
        this._x = Math.asin(-dn(c, -1, 1)), Math.abs(c) < 0.9999999 ? (this._y = Math.atan2(a, _), this._z = Math.atan2(l, u)) : (this._y = Math.atan2(-A, s), this._z = 0);
        break;
      case "ZXY":
        this._x = Math.asin(dn(m, -1, 1)), Math.abs(m) < 0.9999999 ? (this._y = Math.atan2(-A, _), this._z = Math.atan2(-o, u)) : (this._y = 0, this._z = Math.atan2(l, s));
        break;
      case "ZYX":
        this._y = Math.asin(-dn(A, -1, 1)), Math.abs(A) < 0.9999999 ? (this._x = Math.atan2(m, _), this._z = Math.atan2(l, s)) : (this._x = 0, this._z = Math.atan2(-o, u));
        break;
      case "YZX":
        this._z = Math.asin(dn(l, -1, 1)), Math.abs(l) < 0.9999999 ? (this._x = Math.atan2(-c, u), this._y = Math.atan2(-A, s)) : (this._x = 0, this._y = Math.atan2(a, _));
        break;
      case "XZY":
        this._z = Math.asin(-dn(o, -1, 1)), Math.abs(o) < 0.9999999 ? (this._x = Math.atan2(m, u), this._y = Math.atan2(a, s)) : (this._x = Math.atan2(-c, _), this._y = 0);
        break;
      default:
        Me("Euler: .setFromRotationMatrix() encountered an unknown order: " + t);
    }
    return this._order = t, n === !0 && this._onChangeCallback(), this;
  }
  /**
   * Sets the angles of this Euler instance from a normalized quaternion.
   *
   * @param {Quaternion} q - A normalized Quaternion.
   * @param {string} [order] - A string representing the order that the rotations are applied.
   * @param {boolean} [update=true] - Whether the internal `onChange` callback should be executed or not.
   * @return {Euler} A reference to this Euler instance.
   */
  setFromQuaternion(e, t, n) {
    return mM.makeRotationFromQuaternion(e), this.setFromRotationMatrix(mM, t, n);
  }
  /**
   * Sets the angles of this Euler instance from the given vector.
   *
   * @param {Vector3} v - The vector.
   * @param {string} [order] - A string representing the order that the rotations are applied.
   * @return {Euler} A reference to this Euler instance.
   */
  setFromVector3(e, t = this._order) {
    return this.set(e.x, e.y, e.z, t);
  }
  /**
   * Resets the euler angle with a new order by creating a quaternion from this
   * euler angle and then setting this euler angle with the quaternion and the
   * new order.
   *
   * Warning: This discards revolution information.
   *
   * @param {string} [newOrder] - A string representing the new order that the rotations are applied.
   * @return {Euler} A reference to this Euler instance.
   */
  reorder(e) {
    return gM.setFromEuler(this), this.setFromQuaternion(gM, e);
  }
  /**
   * Returns `true` if this Euler instance is equal with the given one.
   *
   * @param {Euler} euler - The Euler instance to test for equality.
   * @return {boolean} Whether this Euler instance is equal with the given one.
   */
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order;
  }
  /**
   * Sets this Euler instance's components to values from the given array. The first three
   * entries of the array are assign to the x,y and z components. An optional fourth entry
   * defines the Euler order.
   *
   * @param {Array<number,number,number,?string>} array - An array holding the Euler component values.
   * @return {Euler} A reference to this Euler instance.
   */
  fromArray(e) {
    return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this;
  }
  /**
   * Writes the components of this Euler instance to the given array. If no array is provided,
   * the method returns a new instance.
   *
   * @param {Array<number,number,number,string>} [array=[]] - The target array holding the Euler components.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Array<number,number,number,string>} The Euler components.
   */
  toArray(e = [], t = 0) {
    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e;
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
}
Ir.DEFAULT_ORDER = "XYZ";
class j_ {
  /**
   * Constructs a new layers instance, with membership
   * initially set to layer `0`.
   */
  constructor() {
    this.mask = 1;
  }
  /**
   * Sets membership to the given layer, and remove membership all other layers.
   *
   * @param {number} layer - The layer to set.
   */
  set(e) {
    this.mask = (1 << e | 0) >>> 0;
  }
  /**
   * Adds membership of the given layer.
   *
   * @param {number} layer - The layer to enable.
   */
  enable(e) {
    this.mask |= 1 << e | 0;
  }
  /**
   * Adds membership to all layers.
   */
  enableAll() {
    this.mask = -1;
  }
  /**
   * Toggles the membership of the given layer.
   *
   * @param {number} layer - The layer to toggle.
   */
  toggle(e) {
    this.mask ^= 1 << e | 0;
  }
  /**
   * Removes membership of the given layer.
   *
   * @param {number} layer - The layer to enable.
   */
  disable(e) {
    this.mask &= ~(1 << e | 0);
  }
  /**
   * Removes the membership from all layers.
   */
  disableAll() {
    this.mask = 0;
  }
  /**
   * Returns `true` if this and the given layers object have at least one
   * layer in common.
   *
   * @param {Layers} layers - The layers to test.
   * @return {boolean } Whether this and the given layers object have at least one layer in common or not.
   */
  test(e) {
    return (this.mask & e.mask) !== 0;
  }
  /**
   * Returns `true` if the given layer is enabled.
   *
   * @param {number} layer - The layer to test.
   * @return {boolean } Whether the given layer is enabled or not.
   */
  isEnabled(e) {
    return (this.mask & (1 << e | 0)) !== 0;
  }
}
let fU = 0;
const _M = /* @__PURE__ */ new j(), bd = /* @__PURE__ */ new hr(), ml = /* @__PURE__ */ new Mt(), cm = /* @__PURE__ */ new j(), EA = /* @__PURE__ */ new j(), AU = /* @__PURE__ */ new j(), pU = /* @__PURE__ */ new hr(), xM = /* @__PURE__ */ new j(1, 0, 0), yM = /* @__PURE__ */ new j(0, 1, 0), vM = /* @__PURE__ */ new j(0, 0, 1), bM = { type: "added" }, mU = { type: "removed" }, Sd = { type: "childadded", child: null }, Yx = { type: "childremoved", child: null };
class Vn extends lo {
  /**
   * Constructs a new 3D object.
   */
  constructor() {
    super(), this.isObject3D = !0, Object.defineProperty(this, "id", { value: fU++ }), this.uuid = To(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Vn.DEFAULT_UP.clone();
    const e = new j(), t = new Ir(), n = new hr(), r = new j(1, 1, 1);
    function s() {
      n.setFromEuler(t, !1);
    }
    function o() {
      t.setFromQuaternion(n, void 0, !1);
    }
    t._onChange(s), n._onChange(o), Object.defineProperties(this, {
      /**
       * Represents the object's local position.
       *
       * @name Object3D#position
       * @type {Vector3}
       * @default (0,0,0)
       */
      position: {
        configurable: !0,
        enumerable: !0,
        value: e
      },
      /**
       * Represents the object's local rotation as Euler angles, in radians.
       *
       * @name Object3D#rotation
       * @type {Euler}
       * @default (0,0,0)
       */
      rotation: {
        configurable: !0,
        enumerable: !0,
        value: t
      },
      /**
       * Represents the object's local rotation as Quaternions.
       *
       * @name Object3D#quaternion
       * @type {Quaternion}
       */
      quaternion: {
        configurable: !0,
        enumerable: !0,
        value: n
      },
      /**
       * Represents the object's local scale.
       *
       * @name Object3D#scale
       * @type {Vector3}
       * @default (1,1,1)
       */
      scale: {
        configurable: !0,
        enumerable: !0,
        value: r
      },
      /**
       * Represents the object's model-view matrix.
       *
       * @name Object3D#modelViewMatrix
       * @type {Matrix4}
       */
      modelViewMatrix: {
        value: new Mt()
      },
      /**
       * Represents the object's normal matrix.
       *
       * @name Object3D#normalMatrix
       * @type {Matrix3}
       */
      normalMatrix: {
        value: new fn()
      }
    }), this.matrix = new Mt(), this.matrixWorld = new Mt(), this.matrixAutoUpdate = Vn.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = Vn.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.layers = new j_(), this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.customDepthMaterial = void 0, this.customDistanceMaterial = void 0, this.userData = {};
  }
  /**
   * A callback that is executed immediately before a 3D object is rendered to a shadow map.
   *
   * @param {Renderer|WebGLRenderer} renderer - The renderer.
   * @param {Object3D} object - The 3D object.
   * @param {Camera} camera - The camera that is used to render the scene.
   * @param {Camera} shadowCamera - The shadow camera.
   * @param {BufferGeometry} geometry - The 3D object's geometry.
   * @param {Material} depthMaterial - The depth material.
   * @param {Object} group - The geometry group data.
   */
  onBeforeShadow() {
  }
  /**
   * A callback that is executed immediately after a 3D object is rendered to a shadow map.
   *
   * @param {Renderer|WebGLRenderer} renderer - The renderer.
   * @param {Object3D} object - The 3D object.
   * @param {Camera} camera - The camera that is used to render the scene.
   * @param {Camera} shadowCamera - The shadow camera.
   * @param {BufferGeometry} geometry - The 3D object's geometry.
   * @param {Material} depthMaterial - The depth material.
   * @param {Object} group - The geometry group data.
   */
  onAfterShadow() {
  }
  /**
   * A callback that is executed immediately before a 3D object is rendered.
   *
   * @param {Renderer|WebGLRenderer} renderer - The renderer.
   * @param {Object3D} object - The 3D object.
   * @param {Camera} camera - The camera that is used to render the scene.
   * @param {BufferGeometry} geometry - The 3D object's geometry.
   * @param {Material} material - The 3D object's material.
   * @param {Object} group - The geometry group data.
   */
  onBeforeRender() {
  }
  /**
   * A callback that is executed immediately after a 3D object is rendered.
   *
   * @param {Renderer|WebGLRenderer} renderer - The renderer.
   * @param {Object3D} object - The 3D object.
   * @param {Camera} camera - The camera that is used to render the scene.
   * @param {BufferGeometry} geometry - The 3D object's geometry.
   * @param {Material} material - The 3D object's material.
   * @param {Object} group - The geometry group data.
   */
  onAfterRender() {
  }
  /**
   * Applies the given transformation matrix to the object and updates the object's position,
   * rotation and scale.
   *
   * @param {Matrix4} matrix - The transformation matrix.
   */
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  /**
   * Applies a rotation represented by given the quaternion to the 3D object.
   *
   * @param {Quaternion} q - The quaternion.
   * @return {Object3D} A reference to this instance.
   */
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  /**
   * Sets the given rotation represented as an axis/angle couple to the 3D object.
   *
   * @param {Vector3} axis - The (normalized) axis vector.
   * @param {number} angle - The angle in radians.
   */
  setRotationFromAxisAngle(e, t) {
    this.quaternion.setFromAxisAngle(e, t);
  }
  /**
   * Sets the given rotation represented as Euler angles to the 3D object.
   *
   * @param {Euler} euler - The Euler angles.
   */
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  /**
   * Sets the given rotation represented as rotation matrix to the 3D object.
   *
   * @param {Matrix4} m - Although a 4x4 matrix is expected, the upper 3x3 portion must be
   * a pure rotation matrix (i.e, unscaled).
   */
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  /**
   * Sets the given rotation represented as a Quaternion to the 3D object.
   *
   * @param {Quaternion} q - The Quaternion
   */
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  /**
   * Rotates the 3D object along an axis in local space.
   *
   * @param {Vector3} axis - The (normalized) axis vector.
   * @param {number} angle - The angle in radians.
   * @return {Object3D} A reference to this instance.
   */
  rotateOnAxis(e, t) {
    return bd.setFromAxisAngle(e, t), this.quaternion.multiply(bd), this;
  }
  /**
   * Rotates the 3D object along an axis in world space.
   *
   * @param {Vector3} axis - The (normalized) axis vector.
   * @param {number} angle - The angle in radians.
   * @return {Object3D} A reference to this instance.
   */
  rotateOnWorldAxis(e, t) {
    return bd.setFromAxisAngle(e, t), this.quaternion.premultiply(bd), this;
  }
  /**
   * Rotates the 3D object around its X axis in local space.
   *
   * @param {number} angle - The angle in radians.
   * @return {Object3D} A reference to this instance.
   */
  rotateX(e) {
    return this.rotateOnAxis(xM, e);
  }
  /**
   * Rotates the 3D object around its Y axis in local space.
   *
   * @param {number} angle - The angle in radians.
   * @return {Object3D} A reference to this instance.
   */
  rotateY(e) {
    return this.rotateOnAxis(yM, e);
  }
  /**
   * Rotates the 3D object around its Z axis in local space.
   *
   * @param {number} angle - The angle in radians.
   * @return {Object3D} A reference to this instance.
   */
  rotateZ(e) {
    return this.rotateOnAxis(vM, e);
  }
  /**
   * Translate the 3D object by a distance along the given axis in local space.
   *
   * @param {Vector3} axis - The (normalized) axis vector.
   * @param {number} distance - The distance in world units.
   * @return {Object3D} A reference to this instance.
   */
  translateOnAxis(e, t) {
    return _M.copy(e).applyQuaternion(this.quaternion), this.position.add(_M.multiplyScalar(t)), this;
  }
  /**
   * Translate the 3D object by a distance along its X-axis in local space.
   *
   * @param {number} distance - The distance in world units.
   * @return {Object3D} A reference to this instance.
   */
  translateX(e) {
    return this.translateOnAxis(xM, e);
  }
  /**
   * Translate the 3D object by a distance along its Y-axis in local space.
   *
   * @param {number} distance - The distance in world units.
   * @return {Object3D} A reference to this instance.
   */
  translateY(e) {
    return this.translateOnAxis(yM, e);
  }
  /**
   * Translate the 3D object by a distance along its Z-axis in local space.
   *
   * @param {number} distance - The distance in world units.
   * @return {Object3D} A reference to this instance.
   */
  translateZ(e) {
    return this.translateOnAxis(vM, e);
  }
  /**
   * Converts the given vector from this 3D object's local space to world space.
   *
   * @param {Vector3} vector - The vector to convert.
   * @return {Vector3} The converted vector.
   */
  localToWorld(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld);
  }
  /**
   * Converts the given vector from this 3D object's word space to local space.
   *
   * @param {Vector3} vector - The vector to convert.
   * @return {Vector3} The converted vector.
   */
  worldToLocal(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(ml.copy(this.matrixWorld).invert());
  }
  /**
   * Rotates the object to face a point in world space.
   *
   * This method does not support objects having non-uniformly-scaled parent(s).
   *
   * @param {number|Vector3} x - The x coordinate in world space. Alternatively, a vector representing a position in world space
   * @param {number} [y] - The y coordinate in world space.
   * @param {number} [z] - The z coordinate in world space.
   */
  lookAt(e, t, n) {
    e.isVector3 ? cm.copy(e) : cm.set(e, t, n);
    const r = this.parent;
    this.updateWorldMatrix(!0, !1), EA.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? ml.lookAt(EA, cm, this.up) : ml.lookAt(cm, EA, this.up), this.quaternion.setFromRotationMatrix(ml), r && (ml.extractRotation(r.matrixWorld), bd.setFromRotationMatrix(ml), this.quaternion.premultiply(bd.invert()));
  }
  /**
   * Adds the given 3D object as a child to this 3D object. An arbitrary number of
   * objects may be added. Any current parent on an object passed in here will be
   * removed, since an object can have at most one parent.
   *
   * @fires Object3D#added
   * @fires Object3D#childadded
   * @param {Object3D} object - The 3D object to add.
   * @return {Object3D} A reference to this instance.
   */
  add(e) {
    if (arguments.length > 1) {
      for (let t = 0; t < arguments.length; t++)
        this.add(arguments[t]);
      return this;
    }
    return e === this ? (Ie("Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.removeFromParent(), e.parent = this, this.children.push(e), e.dispatchEvent(bM), Sd.child = e, this.dispatchEvent(Sd), Sd.child = null) : Ie("Object3D.add: object not an instance of THREE.Object3D.", e), this);
  }
  /**
   * Removes the given 3D object as child from this 3D object.
   * An arbitrary number of objects may be removed.
   *
   * @fires Object3D#removed
   * @fires Object3D#childremoved
   * @param {Object3D} object - The 3D object to remove.
   * @return {Object3D} A reference to this instance.
   */
  remove(e) {
    if (arguments.length > 1) {
      for (let n = 0; n < arguments.length; n++)
        this.remove(arguments[n]);
      return this;
    }
    const t = this.children.indexOf(e);
    return t !== -1 && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(mU), Yx.child = e, this.dispatchEvent(Yx), Yx.child = null), this;
  }
  /**
   * Removes this 3D object from its current parent.
   *
   * @fires Object3D#removed
   * @fires Object3D#childremoved
   * @return {Object3D} A reference to this instance.
   */
  removeFromParent() {
    const e = this.parent;
    return e !== null && e.remove(this), this;
  }
  /**
   * Removes all child objects.
   *
   * @fires Object3D#removed
   * @fires Object3D#childremoved
   * @return {Object3D} A reference to this instance.
   */
  clear() {
    return this.remove(...this.children);
  }
  /**
   * Adds the given 3D object as a child of this 3D object, while maintaining the object's world
   * transform. This method does not support scene graphs having non-uniformly-scaled nodes(s).
   *
   * @fires Object3D#added
   * @fires Object3D#childadded
   * @param {Object3D} object - The 3D object to attach.
   * @return {Object3D} A reference to this instance.
   */
  attach(e) {
    return this.updateWorldMatrix(!0, !1), ml.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(!0, !1), ml.multiply(e.parent.matrixWorld)), e.applyMatrix4(ml), e.removeFromParent(), e.parent = this, this.children.push(e), e.updateWorldMatrix(!1, !0), e.dispatchEvent(bM), Sd.child = e, this.dispatchEvent(Sd), Sd.child = null, this;
  }
  /**
   * Searches through the 3D object and its children, starting with the 3D object
   * itself, and returns the first with a matching ID.
   *
   * @param {number} id - The id.
   * @return {Object3D|undefined} The found 3D object. Returns `undefined` if no 3D object has been found.
   */
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  /**
   * Searches through the 3D object and its children, starting with the 3D object
   * itself, and returns the first with a matching name.
   *
   * @param {string} name - The name.
   * @return {Object3D|undefined} The found 3D object. Returns `undefined` if no 3D object has been found.
   */
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  /**
   * Searches through the 3D object and its children, starting with the 3D object
   * itself, and returns the first with a matching property value.
   *
   * @param {string} name - The name of the property.
   * @param {any} value - The value.
   * @return {Object3D|undefined} The found 3D object. Returns `undefined` if no 3D object has been found.
   */
  getObjectByProperty(e, t) {
    if (this[e] === t) return this;
    for (let n = 0, r = this.children.length; n < r; n++) {
      const o = this.children[n].getObjectByProperty(e, t);
      if (o !== void 0)
        return o;
    }
  }
  /**
   * Searches through the 3D object and its children, starting with the 3D object
   * itself, and returns all 3D objects with a matching property value.
   *
   * @param {string} name - The name of the property.
   * @param {any} value - The value.
   * @param {Array<Object3D>} result - The method stores the result in this array.
   * @return {Array<Object3D>} The found 3D objects.
   */
  getObjectsByProperty(e, t, n = []) {
    this[e] === t && n.push(this);
    const r = this.children;
    for (let s = 0, o = r.length; s < o; s++)
      r[s].getObjectsByProperty(e, t, n);
    return n;
  }
  /**
   * Returns a vector representing the position of the 3D object in world space.
   *
   * @param {Vector3} target - The target vector the result is stored to.
   * @return {Vector3} The 3D object's position in world space.
   */
  getWorldPosition(e) {
    return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld);
  }
  /**
   * Returns a Quaternion representing the position of the 3D object in world space.
   *
   * @param {Quaternion} target - The target Quaternion the result is stored to.
   * @return {Quaternion} The 3D object's rotation in world space.
   */
  getWorldQuaternion(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(EA, e, AU), e;
  }
  /**
   * Returns a vector representing the scale of the 3D object in world space.
   *
   * @param {Vector3} target - The target vector the result is stored to.
   * @return {Vector3} The 3D object's scale in world space.
   */
  getWorldScale(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(EA, pU, e), e;
  }
  /**
   * Returns a vector representing the ("look") direction of the 3D object in world space.
   *
   * @param {Vector3} target - The target vector the result is stored to.
   * @return {Vector3} The 3D object's direction in world space.
   */
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const t = this.matrixWorld.elements;
    return e.set(t[8], t[9], t[10]).normalize();
  }
  /**
   * Abstract method to get intersections between a casted ray and this
   * 3D object. Renderable 3D objects such as {@link Mesh}, {@link Line} or {@link Points}
   * implement this method in order to use raycasting.
   *
   * @abstract
   * @param {Raycaster} raycaster - The raycaster.
   * @param {Array<Object>} intersects - An array holding the result of the method.
   */
  raycast() {
  }
  /**
   * Executes the callback on this 3D object and all descendants.
   *
   * Note: Modifying the scene graph inside the callback is discouraged.
   *
   * @param {Function} callback - A callback function that allows to process the current 3D object.
   */
  traverse(e) {
    e(this);
    const t = this.children;
    for (let n = 0, r = t.length; n < r; n++)
      t[n].traverse(e);
  }
  /**
   * Like {@link Object3D#traverse}, but the callback will only be executed for visible 3D objects.
   * Descendants of invisible 3D objects are not traversed.
   *
   * Note: Modifying the scene graph inside the callback is discouraged.
   *
   * @param {Function} callback - A callback function that allows to process the current 3D object.
   */
  traverseVisible(e) {
    if (this.visible === !1) return;
    e(this);
    const t = this.children;
    for (let n = 0, r = t.length; n < r; n++)
      t[n].traverseVisible(e);
  }
  /**
   * Like {@link Object3D#traverse}, but the callback will only be executed for all ancestors.
   *
   * Note: Modifying the scene graph inside the callback is discouraged.
   *
   * @param {Function} callback - A callback function that allows to process the current 3D object.
   */
  traverseAncestors(e) {
    const t = this.parent;
    t !== null && (e(t), t.traverseAncestors(e));
  }
  /**
   * Updates the transformation matrix in local space by computing it from the current
   * position, rotation and scale values.
   */
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
  }
  /**
   * Updates the transformation matrix in world space of this 3D objects and its descendants.
   *
   * To ensure correct results, this method also recomputes the 3D object's transformation matrix in
   * local space. The computation of the local and world matrix can be controlled with the
   * {@link Object3D#matrixAutoUpdate} and {@link Object3D#matrixWorldAutoUpdate} flags which are both
   * `true` by default.  Set these flags to `false` if you need more control over the update matrix process.
   *
   * @param {boolean} [force=false] - When set to `true`, a recomputation of world matrices is forced even
   * when {@link Object3D#matrixWorldAutoUpdate} is set to `false`.
   */
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), this.matrixWorldNeedsUpdate = !1, e = !0);
    const t = this.children;
    for (let n = 0, r = t.length; n < r; n++)
      t[n].updateMatrixWorld(e);
  }
  /**
   * An alternative version of {@link Object3D#updateMatrixWorld} with more control over the
   * update of ancestor and descendant nodes.
   *
   * @param {boolean} [updateParents=false] Whether ancestor nodes should be updated or not.
   * @param {boolean} [updateChildren=false] Whether descendant nodes should be updated or not.
   */
  updateWorldMatrix(e, t) {
    const n = this.parent;
    if (e === !0 && n !== null && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), t === !0) {
      const r = this.children;
      for (let s = 0, o = r.length; s < o; s++)
        r[s].updateWorldMatrix(!1, !0);
    }
  }
  /**
   * Serializes the 3D object into JSON.
   *
   * @param {?(Object|string)} meta - An optional value holding meta information about the serialization.
   * @return {Object} A JSON object representing the serialized 3D object.
   * @see {@link ObjectLoader#parse}
   */
  toJSON(e) {
    const t = e === void 0 || typeof e == "string", n = {};
    t && (e = {
      geometries: {},
      materials: {},
      textures: {},
      images: {},
      shapes: {},
      skeletons: {},
      animations: {},
      nodes: {}
    }, n.metadata = {
      version: 4.7,
      type: "Object",
      generator: "Object3D.toJSON"
    });
    const r = {};
    r.uuid = this.uuid, r.type = this.type, this.name !== "" && (r.name = this.name), this.castShadow === !0 && (r.castShadow = !0), this.receiveShadow === !0 && (r.receiveShadow = !0), this.visible === !1 && (r.visible = !1), this.frustumCulled === !1 && (r.frustumCulled = !1), this.renderOrder !== 0 && (r.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (r.userData = this.userData), r.layers = this.layers.mask, r.matrix = this.matrix.toArray(), r.up = this.up.toArray(), this.matrixAutoUpdate === !1 && (r.matrixAutoUpdate = !1), this.isInstancedMesh && (r.type = "InstancedMesh", r.count = this.count, r.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (r.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (r.type = "BatchedMesh", r.perObjectFrustumCulled = this.perObjectFrustumCulled, r.sortObjects = this.sortObjects, r.drawRanges = this._drawRanges, r.reservedRanges = this._reservedRanges, r.geometryInfo = this._geometryInfo.map((a) => ({
      ...a,
      boundingBox: a.boundingBox ? a.boundingBox.toJSON() : void 0,
      boundingSphere: a.boundingSphere ? a.boundingSphere.toJSON() : void 0
    })), r.instanceInfo = this._instanceInfo.map((a) => ({ ...a })), r.availableInstanceIds = this._availableInstanceIds.slice(), r.availableGeometryIds = this._availableGeometryIds.slice(), r.nextIndexStart = this._nextIndexStart, r.nextVertexStart = this._nextVertexStart, r.geometryCount = this._geometryCount, r.maxInstanceCount = this._maxInstanceCount, r.maxVertexCount = this._maxVertexCount, r.maxIndexCount = this._maxIndexCount, r.geometryInitialized = this._geometryInitialized, r.matricesTexture = this._matricesTexture.toJSON(e), r.indirectTexture = this._indirectTexture.toJSON(e), this._colorsTexture !== null && (r.colorsTexture = this._colorsTexture.toJSON(e)), this.boundingSphere !== null && (r.boundingSphere = this.boundingSphere.toJSON()), this.boundingBox !== null && (r.boundingBox = this.boundingBox.toJSON()));
    function s(a, l) {
      return a[l.uuid] === void 0 && (a[l.uuid] = l.toJSON(e)), l.uuid;
    }
    if (this.isScene)
      this.background && (this.background.isColor ? r.background = this.background.toJSON() : this.background.isTexture && (r.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (r.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      r.geometry = s(e.geometries, this.geometry);
      const a = this.geometry.parameters;
      if (a !== void 0 && a.shapes !== void 0) {
        const l = a.shapes;
        if (Array.isArray(l))
          for (let u = 0, c = l.length; u < c; u++) {
            const A = l[u];
            s(e.shapes, A);
          }
        else
          s(e.shapes, l);
      }
    }
    if (this.isSkinnedMesh && (r.bindMode = this.bindMode, r.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (s(e.skeletons, this.skeleton), r.skeleton = this.skeleton.uuid)), this.material !== void 0)
      if (Array.isArray(this.material)) {
        const a = [];
        for (let l = 0, u = this.material.length; l < u; l++)
          a.push(s(e.materials, this.material[l]));
        r.material = a;
      } else
        r.material = s(e.materials, this.material);
    if (this.children.length > 0) {
      r.children = [];
      for (let a = 0; a < this.children.length; a++)
        r.children.push(this.children[a].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      r.animations = [];
      for (let a = 0; a < this.animations.length; a++) {
        const l = this.animations[a];
        r.animations.push(s(e.animations, l));
      }
    }
    if (t) {
      const a = o(e.geometries), l = o(e.materials), u = o(e.textures), c = o(e.images), A = o(e.shapes), m = o(e.skeletons), _ = o(e.animations), y = o(e.nodes);
      a.length > 0 && (n.geometries = a), l.length > 0 && (n.materials = l), u.length > 0 && (n.textures = u), c.length > 0 && (n.images = c), A.length > 0 && (n.shapes = A), m.length > 0 && (n.skeletons = m), _.length > 0 && (n.animations = _), y.length > 0 && (n.nodes = y);
    }
    return n.object = r, n;
    function o(a) {
      const l = [];
      for (const u in a) {
        const c = a[u];
        delete c.metadata, l.push(c);
      }
      return l;
    }
  }
  /**
   * Returns a new 3D object with copied values from this instance.
   *
   * @param {boolean} [recursive=true] - When set to `true`, descendants of the 3D object are also cloned.
   * @return {Object3D} A clone of this instance.
   */
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  /**
   * Copies the values of the given 3D object to this instance.
   *
   * @param {Object3D} source - The 3D object to copy.
   * @param {boolean} [recursive=true] - When set to `true`, descendants of the 3D object are cloned.
   * @return {Object3D} A reference to this instance.
   */
  copy(e, t = !0) {
    if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.animations = e.animations.slice(), this.userData = JSON.parse(JSON.stringify(e.userData)), t === !0)
      for (let n = 0; n < e.children.length; n++) {
        const r = e.children[n];
        this.add(r.clone());
      }
    return this;
  }
}
Vn.DEFAULT_UP = /* @__PURE__ */ new j(0, 1, 0);
Vn.DEFAULT_MATRIX_AUTO_UPDATE = !0;
Vn.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const ra = /* @__PURE__ */ new j(), gl = /* @__PURE__ */ new j(), Qx = /* @__PURE__ */ new j(), _l = /* @__PURE__ */ new j(), Td = /* @__PURE__ */ new j(), wd = /* @__PURE__ */ new j(), SM = /* @__PURE__ */ new j(), Kx = /* @__PURE__ */ new j(), Zx = /* @__PURE__ */ new j(), Jx = /* @__PURE__ */ new j(), ey = /* @__PURE__ */ new Kt(), ty = /* @__PURE__ */ new Kt(), ny = /* @__PURE__ */ new Kt();
class $s {
  /**
   * Constructs a new triangle.
   *
   * @param {Vector3} [a=(0,0,0)] - The first corner of the triangle.
   * @param {Vector3} [b=(0,0,0)] - The second corner of the triangle.
   * @param {Vector3} [c=(0,0,0)] - The third corner of the triangle.
   */
  constructor(e = new j(), t = new j(), n = new j()) {
    this.a = e, this.b = t, this.c = n;
  }
  /**
   * Computes the normal vector of a triangle.
   *
   * @param {Vector3} a - The first corner of the triangle.
   * @param {Vector3} b - The second corner of the triangle.
   * @param {Vector3} c - The third corner of the triangle.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The triangle's normal.
   */
  static getNormal(e, t, n, r) {
    r.subVectors(n, t), ra.subVectors(e, t), r.cross(ra);
    const s = r.lengthSq();
    return s > 0 ? r.multiplyScalar(1 / Math.sqrt(s)) : r.set(0, 0, 0);
  }
  /**
   * Computes a barycentric coordinates from the given vector.
   * Returns `null` if the triangle is degenerate.
   *
   * @param {Vector3} point - A point in 3D space.
   * @param {Vector3} a - The first corner of the triangle.
   * @param {Vector3} b - The second corner of the triangle.
   * @param {Vector3} c - The third corner of the triangle.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {?Vector3} The barycentric coordinates for the given point
   */
  static getBarycoord(e, t, n, r, s) {
    ra.subVectors(r, t), gl.subVectors(n, t), Qx.subVectors(e, t);
    const o = ra.dot(ra), a = ra.dot(gl), l = ra.dot(Qx), u = gl.dot(gl), c = gl.dot(Qx), A = o * u - a * a;
    if (A === 0)
      return s.set(0, 0, 0), null;
    const m = 1 / A, _ = (u * l - a * c) * m, y = (o * c - a * l) * m;
    return s.set(1 - _ - y, y, _);
  }
  /**
   * Returns `true` if the given point, when projected onto the plane of the
   * triangle, lies within the triangle.
   *
   * @param {Vector3} point - The point in 3D space to test.
   * @param {Vector3} a - The first corner of the triangle.
   * @param {Vector3} b - The second corner of the triangle.
   * @param {Vector3} c - The third corner of the triangle.
   * @return {boolean} Whether the given point, when projected onto the plane of the
   * triangle, lies within the triangle or not.
   */
  static containsPoint(e, t, n, r) {
    return this.getBarycoord(e, t, n, r, _l) === null ? !1 : _l.x >= 0 && _l.y >= 0 && _l.x + _l.y <= 1;
  }
  /**
   * Computes the value barycentrically interpolated for the given point on the
   * triangle. Returns `null` if the triangle is degenerate.
   *
   * @param {Vector3} point - Position of interpolated point.
   * @param {Vector3} p1 - The first corner of the triangle.
   * @param {Vector3} p2 - The second corner of the triangle.
   * @param {Vector3} p3 - The third corner of the triangle.
   * @param {Vector3} v1 - Value to interpolate of first vertex.
   * @param {Vector3} v2 - Value to interpolate of second vertex.
   * @param {Vector3} v3 - Value to interpolate of third vertex.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {?Vector3} The interpolated value.
   */
  static getInterpolation(e, t, n, r, s, o, a, l) {
    return this.getBarycoord(e, t, n, r, _l) === null ? (l.x = 0, l.y = 0, "z" in l && (l.z = 0), "w" in l && (l.w = 0), null) : (l.setScalar(0), l.addScaledVector(s, _l.x), l.addScaledVector(o, _l.y), l.addScaledVector(a, _l.z), l);
  }
  /**
   * Computes the value barycentrically interpolated for the given attribute and indices.
   *
   * @param {BufferAttribute} attr - The attribute to interpolate.
   * @param {number} i1 - Index of first vertex.
   * @param {number} i2 - Index of second vertex.
   * @param {number} i3 - Index of third vertex.
   * @param {Vector3} barycoord - The barycoordinate value to use to interpolate.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The interpolated attribute value.
   */
  static getInterpolatedAttribute(e, t, n, r, s, o) {
    return ey.setScalar(0), ty.setScalar(0), ny.setScalar(0), ey.fromBufferAttribute(e, t), ty.fromBufferAttribute(e, n), ny.fromBufferAttribute(e, r), o.setScalar(0), o.addScaledVector(ey, s.x), o.addScaledVector(ty, s.y), o.addScaledVector(ny, s.z), o;
  }
  /**
   * Returns `true` if the triangle is oriented towards the given direction.
   *
   * @param {Vector3} a - The first corner of the triangle.
   * @param {Vector3} b - The second corner of the triangle.
   * @param {Vector3} c - The third corner of the triangle.
   * @param {Vector3} direction - The (normalized) direction vector.
   * @return {boolean} Whether the triangle is oriented towards the given direction or not.
   */
  static isFrontFacing(e, t, n, r) {
    return ra.subVectors(n, t), gl.subVectors(e, t), ra.cross(gl).dot(r) < 0;
  }
  /**
   * Sets the triangle's vertices by copying the given values.
   *
   * @param {Vector3} a - The first corner of the triangle.
   * @param {Vector3} b - The second corner of the triangle.
   * @param {Vector3} c - The third corner of the triangle.
   * @return {Triangle} A reference to this triangle.
   */
  set(e, t, n) {
    return this.a.copy(e), this.b.copy(t), this.c.copy(n), this;
  }
  /**
   * Sets the triangle's vertices by copying the given array values.
   *
   * @param {Array<Vector3>} points - An array with 3D points.
   * @param {number} i0 - The array index representing the first corner of the triangle.
   * @param {number} i1 - The array index representing the second corner of the triangle.
   * @param {number} i2 - The array index representing the third corner of the triangle.
   * @return {Triangle} A reference to this triangle.
   */
  setFromPointsAndIndices(e, t, n, r) {
    return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[r]), this;
  }
  /**
   * Sets the triangle's vertices by copying the given attribute values.
   *
   * @param {BufferAttribute} attribute - A buffer attribute with 3D points data.
   * @param {number} i0 - The attribute index representing the first corner of the triangle.
   * @param {number} i1 - The attribute index representing the second corner of the triangle.
   * @param {number} i2 - The attribute index representing the third corner of the triangle.
   * @return {Triangle} A reference to this triangle.
   */
  setFromAttributeAndIndices(e, t, n, r) {
    return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, n), this.c.fromBufferAttribute(e, r), this;
  }
  /**
   * Returns a new triangle with copied values from this instance.
   *
   * @return {Triangle} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
  /**
   * Copies the values of the given triangle to this instance.
   *
   * @param {Triangle} triangle - The triangle to copy.
   * @return {Triangle} A reference to this triangle.
   */
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  /**
   * Computes the area of the triangle.
   *
   * @return {number} The triangle's area.
   */
  getArea() {
    return ra.subVectors(this.c, this.b), gl.subVectors(this.a, this.b), ra.cross(gl).length() * 0.5;
  }
  /**
   * Computes the midpoint of the triangle.
   *
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The triangle's midpoint.
   */
  getMidpoint(e) {
    return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  /**
   * Computes the normal of the triangle.
   *
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The triangle's normal.
   */
  getNormal(e) {
    return $s.getNormal(this.a, this.b, this.c, e);
  }
  /**
   * Computes a plane the triangle lies within.
   *
   * @param {Plane} target - The target vector that is used to store the method's result.
   * @return {Plane} The plane the triangle lies within.
   */
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  /**
   * Computes a barycentric coordinates from the given vector.
   * Returns `null` if the triangle is degenerate.
   *
   * @param {Vector3} point - A point in 3D space.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {?Vector3} The barycentric coordinates for the given point
   */
  getBarycoord(e, t) {
    return $s.getBarycoord(e, this.a, this.b, this.c, t);
  }
  /**
   * Computes the value barycentrically interpolated for the given point on the
   * triangle. Returns `null` if the triangle is degenerate.
   *
   * @param {Vector3} point - Position of interpolated point.
   * @param {Vector3} v1 - Value to interpolate of first vertex.
   * @param {Vector3} v2 - Value to interpolate of second vertex.
   * @param {Vector3} v3 - Value to interpolate of third vertex.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {?Vector3} The interpolated value.
   */
  getInterpolation(e, t, n, r, s) {
    return $s.getInterpolation(e, this.a, this.b, this.c, t, n, r, s);
  }
  /**
   * Returns `true` if the given point, when projected onto the plane of the
   * triangle, lies within the triangle.
   *
   * @param {Vector3} point - The point in 3D space to test.
   * @return {boolean} Whether the given point, when projected onto the plane of the
   * triangle, lies within the triangle or not.
   */
  containsPoint(e) {
    return $s.containsPoint(e, this.a, this.b, this.c);
  }
  /**
   * Returns `true` if the triangle is oriented towards the given direction.
   *
   * @param {Vector3} direction - The (normalized) direction vector.
   * @return {boolean} Whether the triangle is oriented towards the given direction or not.
   */
  isFrontFacing(e) {
    return $s.isFrontFacing(this.a, this.b, this.c, e);
  }
  /**
   * Returns `true` if this triangle intersects with the given box.
   *
   * @param {Box3} box - The box to intersect.
   * @return {boolean} Whether this triangle intersects with the given box or not.
   */
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  /**
   * Returns the closest point on the triangle to the given point.
   *
   * @param {Vector3} p - The point to compute the closest point for.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The closest point on the triangle.
   */
  closestPointToPoint(e, t) {
    const n = this.a, r = this.b, s = this.c;
    let o, a;
    Td.subVectors(r, n), wd.subVectors(s, n), Kx.subVectors(e, n);
    const l = Td.dot(Kx), u = wd.dot(Kx);
    if (l <= 0 && u <= 0)
      return t.copy(n);
    Zx.subVectors(e, r);
    const c = Td.dot(Zx), A = wd.dot(Zx);
    if (c >= 0 && A <= c)
      return t.copy(r);
    const m = l * A - c * u;
    if (m <= 0 && l >= 0 && c <= 0)
      return o = l / (l - c), t.copy(n).addScaledVector(Td, o);
    Jx.subVectors(e, s);
    const _ = Td.dot(Jx), y = wd.dot(Jx);
    if (y >= 0 && _ <= y)
      return t.copy(s);
    const T = _ * u - l * y;
    if (T <= 0 && u >= 0 && y <= 0)
      return a = u / (u - y), t.copy(n).addScaledVector(wd, a);
    const b = c * y - _ * A;
    if (b <= 0 && A - c >= 0 && _ - y >= 0)
      return SM.subVectors(s, r), a = (A - c) / (A - c + (_ - y)), t.copy(r).addScaledVector(SM, a);
    const S = 1 / (b + T + m);
    return o = T * S, a = m * S, t.copy(n).addScaledVector(Td, o).addScaledVector(wd, a);
  }
  /**
   * Returns `true` if this triangle is equal with the given one.
   *
   * @param {Triangle} triangle - The triangle to test for equality.
   * @return {boolean} Whether this triangle is equal with the given one.
   */
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}
const W5 = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
}, fu = { h: 0, s: 0, l: 0 }, hm = { h: 0, s: 0, l: 0 };
function iy(i, e, t) {
  return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? i + (e - i) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? i + (e - i) * 6 * (2 / 3 - t) : i;
}
let ct = class {
  /**
   * Constructs a new color.
   *
   * Note that standard method of specifying color in three.js is with a hexadecimal triplet,
   * and that method is used throughout the rest of the documentation.
   *
   * @param {(number|string|Color)} [r] - The red component of the color. If `g` and `b` are
   * not provided, it can be hexadecimal triplet, a CSS-style string or another `Color` instance.
   * @param {number} [g] - The green component.
   * @param {number} [b] - The blue component.
   */
  constructor(e, t, n) {
    return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(e, t, n);
  }
  /**
   * Sets the colors's components from the given values.
   *
   * @param {(number|string|Color)} [r] - The red component of the color. If `g` and `b` are
   * not provided, it can be hexadecimal triplet, a CSS-style string or another `Color` instance.
   * @param {number} [g] - The green component.
   * @param {number} [b] - The blue component.
   * @return {Color} A reference to this color.
   */
  set(e, t, n) {
    if (t === void 0 && n === void 0) {
      const r = e;
      r && r.isColor ? this.copy(r) : typeof r == "number" ? this.setHex(r) : typeof r == "string" && this.setStyle(r);
    } else
      this.setRGB(e, t, n);
    return this;
  }
  /**
   * Sets the colors's components to the given scalar value.
   *
   * @param {number} scalar - The scalar value.
   * @return {Color} A reference to this color.
   */
  setScalar(e) {
    return this.r = e, this.g = e, this.b = e, this;
  }
  /**
   * Sets this color from a hexadecimal value.
   *
   * @param {number} hex - The hexadecimal value.
   * @param {string} [colorSpace=SRGBColorSpace] - The color space.
   * @return {Color} A reference to this color.
   */
  setHex(e, t = gr) {
    return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, Xt.colorSpaceToWorking(this, t), this;
  }
  /**
   * Sets this color from RGB values.
   *
   * @param {number} r - Red channel value between `0.0` and `1.0`.
   * @param {number} g - Green channel value between `0.0` and `1.0`.
   * @param {number} b - Blue channel value between `0.0` and `1.0`.
   * @param {string} [colorSpace=ColorManagement.workingColorSpace] - The color space.
   * @return {Color} A reference to this color.
   */
  setRGB(e, t, n, r = Xt.workingColorSpace) {
    return this.r = e, this.g = t, this.b = n, Xt.colorSpaceToWorking(this, r), this;
  }
  /**
   * Sets this color from RGB values.
   *
   * @param {number} h - Hue value between `0.0` and `1.0`.
   * @param {number} s - Saturation value between `0.0` and `1.0`.
   * @param {number} l - Lightness value between `0.0` and `1.0`.
   * @param {string} [colorSpace=ColorManagement.workingColorSpace] - The color space.
   * @return {Color} A reference to this color.
   */
  setHSL(e, t, n, r = Xt.workingColorSpace) {
    if (e = P3(e, 1), t = dn(t, 0, 1), n = dn(n, 0, 1), t === 0)
      this.r = this.g = this.b = n;
    else {
      const s = n <= 0.5 ? n * (1 + t) : n + t - n * t, o = 2 * n - s;
      this.r = iy(o, s, e + 1 / 3), this.g = iy(o, s, e), this.b = iy(o, s, e - 1 / 3);
    }
    return Xt.colorSpaceToWorking(this, r), this;
  }
  /**
   * Sets this color from a CSS-style string. For example, `rgb(250, 0,0)`,
   * `rgb(100%, 0%, 0%)`, `hsl(0, 100%, 50%)`, `#ff0000`, `#f00`, or `red` ( or
   * any [X11 color name](https://en.wikipedia.org/wiki/X11_color_names#Color_name_chart) -
   * all 140 color names are supported).
   *
   * @param {string} style - Color as a CSS-style string.
   * @param {string} [colorSpace=SRGBColorSpace] - The color space.
   * @return {Color} A reference to this color.
   */
  setStyle(e, t = gr) {
    function n(s) {
      s !== void 0 && parseFloat(s) < 1 && Me("Color: Alpha component of " + e + " will be ignored.");
    }
    let r;
    if (r = /^(\w+)\(([^\)]*)\)/.exec(e)) {
      let s;
      const o = r[1], a = r[2];
      switch (o) {
        case "rgb":
        case "rgba":
          if (s = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
            return n(s[4]), this.setRGB(
              Math.min(255, parseInt(s[1], 10)) / 255,
              Math.min(255, parseInt(s[2], 10)) / 255,
              Math.min(255, parseInt(s[3], 10)) / 255,
              t
            );
          if (s = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
            return n(s[4]), this.setRGB(
              Math.min(100, parseInt(s[1], 10)) / 100,
              Math.min(100, parseInt(s[2], 10)) / 100,
              Math.min(100, parseInt(s[3], 10)) / 100,
              t
            );
          break;
        case "hsl":
        case "hsla":
          if (s = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
            return n(s[4]), this.setHSL(
              parseFloat(s[1]) / 360,
              parseFloat(s[2]) / 100,
              parseFloat(s[3]) / 100,
              t
            );
          break;
        default:
          Me("Color: Unknown color model " + e);
      }
    } else if (r = /^\#([A-Fa-f\d]+)$/.exec(e)) {
      const s = r[1], o = s.length;
      if (o === 3)
        return this.setRGB(
          parseInt(s.charAt(0), 16) / 15,
          parseInt(s.charAt(1), 16) / 15,
          parseInt(s.charAt(2), 16) / 15,
          t
        );
      if (o === 6)
        return this.setHex(parseInt(s, 16), t);
      Me("Color: Invalid hex color " + e);
    } else if (e && e.length > 0)
      return this.setColorName(e, t);
    return this;
  }
  /**
   * Sets this color from a color name. Faster than {@link Color#setStyle} if
   * you don't need the other CSS-style formats.
   *
   * For convenience, the list of names is exposed in `Color.NAMES` as a hash.
   * ```js
   * Color.NAMES.aliceblue // returns 0xF0F8FF
   * ```
   *
   * @param {string} style - The color name.
   * @param {string} [colorSpace=SRGBColorSpace] - The color space.
   * @return {Color} A reference to this color.
   */
  setColorName(e, t = gr) {
    const n = W5[e.toLowerCase()];
    return n !== void 0 ? this.setHex(n, t) : Me("Color: Unknown color " + e), this;
  }
  /**
   * Returns a new color with copied values from this instance.
   *
   * @return {Color} A clone of this instance.
   */
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  /**
   * Copies the values of the given color to this instance.
   *
   * @param {Color} color - The color to copy.
   * @return {Color} A reference to this color.
   */
  copy(e) {
    return this.r = e.r, this.g = e.g, this.b = e.b, this;
  }
  /**
   * Copies the given color into this color, and then converts this color from
   * `SRGBColorSpace` to `LinearSRGBColorSpace`.
   *
   * @param {Color} color - The color to copy/convert.
   * @return {Color} A reference to this color.
   */
  copySRGBToLinear(e) {
    return this.r = Dl(e.r), this.g = Dl(e.g), this.b = Dl(e.b), this;
  }
  /**
   * Copies the given color into this color, and then converts this color from
   * `LinearSRGBColorSpace` to `SRGBColorSpace`.
   *
   * @param {Color} color - The color to copy/convert.
   * @return {Color} A reference to this color.
   */
  copyLinearToSRGB(e) {
    return this.r = pf(e.r), this.g = pf(e.g), this.b = pf(e.b), this;
  }
  /**
   * Converts this color from `SRGBColorSpace` to `LinearSRGBColorSpace`.
   *
   * @return {Color} A reference to this color.
   */
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  /**
   * Converts this color from `LinearSRGBColorSpace` to `SRGBColorSpace`.
   *
   * @return {Color} A reference to this color.
   */
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  /**
   * Returns the hexadecimal value of this color.
   *
   * @param {string} [colorSpace=SRGBColorSpace] - The color space.
   * @return {number} The hexadecimal value.
   */
  getHex(e = gr) {
    return Xt.workingToColorSpace(os.copy(this), e), Math.round(dn(os.r * 255, 0, 255)) * 65536 + Math.round(dn(os.g * 255, 0, 255)) * 256 + Math.round(dn(os.b * 255, 0, 255));
  }
  /**
   * Returns the hexadecimal value of this color as a string (for example, 'FFFFFF').
   *
   * @param {string} [colorSpace=SRGBColorSpace] - The color space.
   * @return {string} The hexadecimal value as a string.
   */
  getHexString(e = gr) {
    return ("000000" + this.getHex(e).toString(16)).slice(-6);
  }
  /**
   * Converts the colors RGB values into the HSL format and stores them into the
   * given target object.
   *
   * @param {{h:number,s:number,l:number}} target - The target object that is used to store the method's result.
   * @param {string} [colorSpace=ColorManagement.workingColorSpace] - The color space.
   * @return {{h:number,s:number,l:number}} The HSL representation of this color.
   */
  getHSL(e, t = Xt.workingColorSpace) {
    Xt.workingToColorSpace(os.copy(this), t);
    const n = os.r, r = os.g, s = os.b, o = Math.max(n, r, s), a = Math.min(n, r, s);
    let l, u;
    const c = (a + o) / 2;
    if (a === o)
      l = 0, u = 0;
    else {
      const A = o - a;
      switch (u = c <= 0.5 ? A / (o + a) : A / (2 - o - a), o) {
        case n:
          l = (r - s) / A + (r < s ? 6 : 0);
          break;
        case r:
          l = (s - n) / A + 2;
          break;
        case s:
          l = (n - r) / A + 4;
          break;
      }
      l /= 6;
    }
    return e.h = l, e.s = u, e.l = c, e;
  }
  /**
   * Returns the RGB values of this color and stores them into the given target object.
   *
   * @param {Color} target - The target color that is used to store the method's result.
   * @param {string} [colorSpace=ColorManagement.workingColorSpace] - The color space.
   * @return {Color} The RGB representation of this color.
   */
  getRGB(e, t = Xt.workingColorSpace) {
    return Xt.workingToColorSpace(os.copy(this), t), e.r = os.r, e.g = os.g, e.b = os.b, e;
  }
  /**
   * Returns the value of this color as a CSS style string. Example: `rgb(255,0,0)`.
   *
   * @param {string} [colorSpace=SRGBColorSpace] - The color space.
   * @return {string} The CSS representation of this color.
   */
  getStyle(e = gr) {
    Xt.workingToColorSpace(os.copy(this), e);
    const t = os.r, n = os.g, r = os.b;
    return e !== gr ? `color(${e} ${t.toFixed(3)} ${n.toFixed(3)} ${r.toFixed(3)})` : `rgb(${Math.round(t * 255)},${Math.round(n * 255)},${Math.round(r * 255)})`;
  }
  /**
   * Adds the given HSL values to this color's values.
   * Internally, this converts the color's RGB values to HSL, adds HSL
   * and then converts the color back to RGB.
   *
   * @param {number} h - Hue value between `0.0` and `1.0`.
   * @param {number} s - Saturation value between `0.0` and `1.0`.
   * @param {number} l - Lightness value between `0.0` and `1.0`.
   * @return {Color} A reference to this color.
   */
  offsetHSL(e, t, n) {
    return this.getHSL(fu), this.setHSL(fu.h + e, fu.s + t, fu.l + n);
  }
  /**
   * Adds the RGB values of the given color to the RGB values of this color.
   *
   * @param {Color} color - The color to add.
   * @return {Color} A reference to this color.
   */
  add(e) {
    return this.r += e.r, this.g += e.g, this.b += e.b, this;
  }
  /**
   * Adds the RGB values of the given colors and stores the result in this instance.
   *
   * @param {Color} color1 - The first color.
   * @param {Color} color2 - The second color.
   * @return {Color} A reference to this color.
   */
  addColors(e, t) {
    return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this;
  }
  /**
   * Adds the given scalar value to the RGB values of this color.
   *
   * @param {number} s - The scalar to add.
   * @return {Color} A reference to this color.
   */
  addScalar(e) {
    return this.r += e, this.g += e, this.b += e, this;
  }
  /**
   * Subtracts the RGB values of the given color from the RGB values of this color.
   *
   * @param {Color} color - The color to subtract.
   * @return {Color} A reference to this color.
   */
  sub(e) {
    return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this;
  }
  /**
   * Multiplies the RGB values of the given color with the RGB values of this color.
   *
   * @param {Color} color - The color to multiply.
   * @return {Color} A reference to this color.
   */
  multiply(e) {
    return this.r *= e.r, this.g *= e.g, this.b *= e.b, this;
  }
  /**
   * Multiplies the given scalar value with the RGB values of this color.
   *
   * @param {number} s - The scalar to multiply.
   * @return {Color} A reference to this color.
   */
  multiplyScalar(e) {
    return this.r *= e, this.g *= e, this.b *= e, this;
  }
  /**
   * Linearly interpolates this color's RGB values toward the RGB values of the
   * given color. The alpha argument can be thought of as the ratio between
   * the two colors, where `0.0` is this color and `1.0` is the first argument.
   *
   * @param {Color} color - The color to converge on.
   * @param {number} alpha - The interpolation factor in the closed interval `[0,1]`.
   * @return {Color} A reference to this color.
   */
  lerp(e, t) {
    return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this;
  }
  /**
   * Linearly interpolates between the given colors and stores the result in this instance.
   * The alpha argument can be thought of as the ratio between the two colors, where `0.0`
   * is the first and `1.0` is the second color.
   *
   * @param {Color} color1 - The first color.
   * @param {Color} color2 - The second color.
   * @param {number} alpha - The interpolation factor in the closed interval `[0,1]`.
   * @return {Color} A reference to this color.
   */
  lerpColors(e, t, n) {
    return this.r = e.r + (t.r - e.r) * n, this.g = e.g + (t.g - e.g) * n, this.b = e.b + (t.b - e.b) * n, this;
  }
  /**
   * Linearly interpolates this color's HSL values toward the HSL values of the
   * given color. It differs from {@link Color#lerp} by not interpolating straight
   * from one color to the other, but instead going through all the hues in between
   * those two colors. The alpha argument can be thought of as the ratio between
   * the two colors, where 0.0 is this color and 1.0 is the first argument.
   *
   * @param {Color} color - The color to converge on.
   * @param {number} alpha - The interpolation factor in the closed interval `[0,1]`.
   * @return {Color} A reference to this color.
   */
  lerpHSL(e, t) {
    this.getHSL(fu), e.getHSL(hm);
    const n = vp(fu.h, hm.h, t), r = vp(fu.s, hm.s, t), s = vp(fu.l, hm.l, t);
    return this.setHSL(n, r, s), this;
  }
  /**
   * Sets the color's RGB components from the given 3D vector.
   *
   * @param {Vector3} v - The vector to set.
   * @return {Color} A reference to this color.
   */
  setFromVector3(e) {
    return this.r = e.x, this.g = e.y, this.b = e.z, this;
  }
  /**
   * Transforms this color with the given 3x3 matrix.
   *
   * @param {Matrix3} m - The matrix.
   * @return {Color} A reference to this color.
   */
  applyMatrix3(e) {
    const t = this.r, n = this.g, r = this.b, s = e.elements;
    return this.r = s[0] * t + s[3] * n + s[6] * r, this.g = s[1] * t + s[4] * n + s[7] * r, this.b = s[2] * t + s[5] * n + s[8] * r, this;
  }
  /**
   * Returns `true` if this color is equal with the given one.
   *
   * @param {Color} c - The color to test for equality.
   * @return {boolean} Whether this bounding color is equal with the given one.
   */
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  /**
   * Sets this color's RGB components from the given array.
   *
   * @param {Array<number>} array - An array holding the RGB values.
   * @param {number} [offset=0] - The offset into the array.
   * @return {Color} A reference to this color.
   */
  fromArray(e, t = 0) {
    return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this;
  }
  /**
   * Writes the RGB components of this color to the given array. If no array is provided,
   * the method returns a new instance.
   *
   * @param {Array<number>} [array=[]] - The target array holding the color components.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Array<number>} The color components.
   */
  toArray(e = [], t = 0) {
    return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e;
  }
  /**
   * Sets the components of this color from the given buffer attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute holding color data.
   * @param {number} index - The index into the attribute.
   * @return {Color} A reference to this color.
   */
  fromBufferAttribute(e, t) {
    return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), this;
  }
  /**
   * This methods defines the serialization result of this class. Returns the color
   * as a hexadecimal value.
   *
   * @return {number} The hexadecimal value.
   */
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
};
const os = /* @__PURE__ */ new ct();
ct.NAMES = W5;
let gU = 0;
class Br extends lo {
  /**
   * Constructs a new material.
   */
  constructor() {
    super(), this.isMaterial = !0, Object.defineProperty(this, "id", { value: gU++ }), this.uuid = To(), this.name = "", this.type = "Material", this.blending = gs, this.side = Zs, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.alphaHash = !1, this.blendSrc = Tf, this.blendDst = wf, this.blendEquation = Wr, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new ct(0, 0, 0), this.blendAlpha = 0, this.depthFunc = Vl, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = p1, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = Tu, this.stencilZFail = Tu, this.stencilZPass = Tu, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.allowOverride = !0, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0;
  }
  /**
   * Sets the alpha value to be used when running an alpha test. The material
   * will not be rendered if the opacity is lower than this value.
   *
   * @type {number}
   * @readonly
   * @default 0
   */
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(e) {
    this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e;
  }
  /**
   * An optional callback that is executed immediately before the material is used to render a 3D object.
   *
   * This method can only be used when rendering with {@link WebGLRenderer}.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {Scene} scene - The scene.
   * @param {Camera} camera - The camera that is used to render the scene.
   * @param {BufferGeometry} geometry - The 3D object's geometry.
   * @param {Object3D} object - The 3D object.
   * @param {Object} group - The geometry group data.
   */
  onBeforeRender() {
  }
  /**
   * An optional callback that is executed immediately before the shader
   * program is compiled. This function is called with the shader source code
   * as a parameter. Useful for the modification of built-in materials.
   *
   * This method can only be used when rendering with {@link WebGLRenderer}. The
   * recommended approach when customizing materials is to use `WebGPURenderer` with the new
   * Node Material system and [TSL](https://github.com/mrdoob/three.js/wiki/Three.js-Shading-Language).
   *
   * @param {{vertexShader:string,fragmentShader:string,uniforms:Object}} shaderobject - The object holds the uniforms and the vertex and fragment shader source.
   * @param {WebGLRenderer} renderer - A reference to the renderer.
   */
  onBeforeCompile() {
  }
  /**
   * In case {@link Material#onBeforeCompile} is used, this callback can be used to identify
   * values of settings used in `onBeforeCompile()`, so three.js can reuse a cached
   * shader or recompile the shader for this material as needed.
   *
   * This method can only be used when rendering with {@link WebGLRenderer}.
   *
   * @return {string} The custom program cache key.
   */
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  /**
   * This method can be used to set default values from parameter objects.
   * It is a generic implementation so it can be used with different types
   * of materials.
   *
   * @param {Object} [values] - The material values to set.
   */
  setValues(e) {
    if (e !== void 0)
      for (const t in e) {
        const n = e[t];
        if (n === void 0) {
          Me(`Material: parameter '${t}' has value of undefined.`);
          continue;
        }
        const r = this[t];
        if (r === void 0) {
          Me(`Material: '${t}' is not a property of THREE.${this.type}.`);
          continue;
        }
        r && r.isColor ? r.set(n) : r && r.isVector3 && n && n.isVector3 ? r.copy(n) : this[t] = n;
      }
  }
  /**
   * Serializes the material into JSON.
   *
   * @param {?(Object|string)} meta - An optional value holding meta information about the serialization.
   * @return {Object} A JSON object representing the serialized material.
   * @see {@link ObjectLoader#parse}
   */
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    t && (e = {
      textures: {},
      images: {}
    });
    const n = {
      metadata: {
        version: 4.7,
        type: "Material",
        generator: "Material.toJSON"
      }
    };
    n.uuid = this.uuid, n.type = this.type, this.name !== "" && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), this.roughness !== void 0 && (n.roughness = this.roughness), this.metalness !== void 0 && (n.metalness = this.metalness), this.sheen !== void 0 && (n.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (n.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1 && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (n.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (n.shininess = this.shininess), this.clearcoat !== void 0 && (n.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.sheenColorMap && this.sheenColorMap.isTexture && (n.sheenColorMap = this.sheenColorMap.toJSON(e).uuid), this.sheenRoughnessMap && this.sheenRoughnessMap.isTexture && (n.sheenRoughnessMap = this.sheenRoughnessMap.toJSON(e).uuid), this.dispersion !== void 0 && (n.dispersion = this.dispersion), this.iridescence !== void 0 && (n.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (n.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (n.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (n.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), this.anisotropy !== void 0 && (n.anisotropy = this.anisotropy), this.anisotropyRotation !== void 0 && (n.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (n.anisotropyMap = this.anisotropyMap.toJSON(e).uuid), this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid, this.combine !== void 0 && (n.combine = this.combine)), this.envMapRotation !== void 0 && (n.envMapRotation = this.envMapRotation.toArray()), this.envMapIntensity !== void 0 && (n.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (n.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid), this.transmission !== void 0 && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(e).uuid), this.thickness !== void 0 && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(e).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (n.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (n.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (n.size = this.size), this.shadowSide !== null && (n.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== gs && (n.blending = this.blending), this.side !== Zs && (n.side = this.side), this.vertexColors === !0 && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), this.transparent === !0 && (n.transparent = !0), this.blendSrc !== Tf && (n.blendSrc = this.blendSrc), this.blendDst !== wf && (n.blendDst = this.blendDst), this.blendEquation !== Wr && (n.blendEquation = this.blendEquation), this.blendSrcAlpha !== null && (n.blendSrcAlpha = this.blendSrcAlpha), this.blendDstAlpha !== null && (n.blendDstAlpha = this.blendDstAlpha), this.blendEquationAlpha !== null && (n.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (n.blendColor = this.blendColor.getHex()), this.blendAlpha !== 0 && (n.blendAlpha = this.blendAlpha), this.depthFunc !== Vl && (n.depthFunc = this.depthFunc), this.depthTest === !1 && (n.depthTest = this.depthTest), this.depthWrite === !1 && (n.depthWrite = this.depthWrite), this.colorWrite === !1 && (n.colorWrite = this.colorWrite), this.stencilWriteMask !== 255 && (n.stencilWriteMask = this.stencilWriteMask), this.stencilFunc !== p1 && (n.stencilFunc = this.stencilFunc), this.stencilRef !== 0 && (n.stencilRef = this.stencilRef), this.stencilFuncMask !== 255 && (n.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== Tu && (n.stencilFail = this.stencilFail), this.stencilZFail !== Tu && (n.stencilZFail = this.stencilZFail), this.stencilZPass !== Tu && (n.stencilZPass = this.stencilZPass), this.stencilWrite === !0 && (n.stencilWrite = this.stencilWrite), this.rotation !== void 0 && this.rotation !== 0 && (n.rotation = this.rotation), this.polygonOffset === !0 && (n.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (n.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (n.linewidth = this.linewidth), this.dashSize !== void 0 && (n.dashSize = this.dashSize), this.gapSize !== void 0 && (n.gapSize = this.gapSize), this.scale !== void 0 && (n.scale = this.scale), this.dithering === !0 && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), this.alphaHash === !0 && (n.alphaHash = !0), this.alphaToCoverage === !0 && (n.alphaToCoverage = !0), this.premultipliedAlpha === !0 && (n.premultipliedAlpha = !0), this.forceSinglePass === !0 && (n.forceSinglePass = !0), this.allowOverride === !1 && (n.allowOverride = !1), this.wireframe === !0 && (n.wireframe = !0), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (n.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (n.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === !0 && (n.flatShading = !0), this.visible === !1 && (n.visible = !1), this.toneMapped === !1 && (n.toneMapped = !1), this.fog === !1 && (n.fog = !1), Object.keys(this.userData).length > 0 && (n.userData = this.userData);
    function r(s) {
      const o = [];
      for (const a in s) {
        const l = s[a];
        delete l.metadata, o.push(l);
      }
      return o;
    }
    if (t) {
      const s = r(e.textures), o = r(e.images);
      s.length > 0 && (n.textures = s), o.length > 0 && (n.images = o);
    }
    return n;
  }
  /**
   * Returns a new material with copied values from this instance.
   *
   * @return {Material} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
  /**
   * Copies the values of the given material to this instance.
   *
   * @param {Material} source - The material to copy.
   * @return {Material} A reference to this instance.
   */
  copy(e) {
    this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.blendColor.copy(e.blendColor), this.blendAlpha = e.blendAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
    const t = e.clippingPlanes;
    let n = null;
    if (t !== null) {
      const r = t.length;
      n = new Array(r);
      for (let s = 0; s !== r; ++s)
        n[s] = t[s].clone();
    }
    return this.clippingPlanes = n, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaHash = e.alphaHash, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.forceSinglePass = e.forceSinglePass, this.allowOverride = e.allowOverride, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this;
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   *
   * @fires Material#dispose
   */
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  /**
   * Setting this property to `true` indicates the engine the material
   * needs to be recompiled.
   *
   * @type {boolean}
   * @default false
   * @param {boolean} value
   */
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
}
class Nr extends Br {
  /**
   * Constructs a new mesh basic material.
   *
   * @param {Object} [parameters] - An object with one or more properties
   * defining the material's appearance. Any property of the material
   * (including any property from inherited materials) can be passed
   * in here. Color values can be passed any type of value accepted
   * by {@link Color#set}.
   */
  constructor(e) {
    super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new ct(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Ir(), this.combine = tA, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
  }
}
const Tl = /* @__PURE__ */ _U();
function _U() {
  const i = new ArrayBuffer(4), e = new Float32Array(i), t = new Uint32Array(i), n = new Uint32Array(512), r = new Uint32Array(512);
  for (let l = 0; l < 256; ++l) {
    const u = l - 127;
    u < -27 ? (n[l] = 0, n[l | 256] = 32768, r[l] = 24, r[l | 256] = 24) : u < -14 ? (n[l] = 1024 >> -u - 14, n[l | 256] = 1024 >> -u - 14 | 32768, r[l] = -u - 1, r[l | 256] = -u - 1) : u <= 15 ? (n[l] = u + 15 << 10, n[l | 256] = u + 15 << 10 | 32768, r[l] = 13, r[l | 256] = 13) : u < 128 ? (n[l] = 31744, n[l | 256] = 64512, r[l] = 24, r[l | 256] = 24) : (n[l] = 31744, n[l | 256] = 64512, r[l] = 13, r[l | 256] = 13);
  }
  const s = new Uint32Array(2048), o = new Uint32Array(64), a = new Uint32Array(64);
  for (let l = 1; l < 1024; ++l) {
    let u = l << 13, c = 0;
    for (; (u & 8388608) === 0; )
      u <<= 1, c -= 8388608;
    u &= -8388609, c += 947912704, s[l] = u | c;
  }
  for (let l = 1024; l < 2048; ++l)
    s[l] = 939524096 + (l - 1024 << 13);
  for (let l = 1; l < 31; ++l)
    o[l] = l << 23;
  o[31] = 1199570944, o[32] = 2147483648;
  for (let l = 33; l < 63; ++l)
    o[l] = 2147483648 + (l - 32 << 23);
  o[63] = 3347054592;
  for (let l = 1; l < 64; ++l)
    l !== 32 && (a[l] = 1024);
  return {
    floatView: e,
    uint32View: t,
    baseTable: n,
    shiftTable: r,
    mantissaTable: s,
    exponentTable: o,
    offsetTable: a
  };
}
function Hs(i) {
  Math.abs(i) > 65504 && Me("DataUtils.toHalfFloat(): Value out of range."), i = dn(i, -65504, 65504), Tl.floatView[0] = i;
  const e = Tl.uint32View[0], t = e >> 23 & 511;
  return Tl.baseTable[t] + ((e & 8388607) >> Tl.shiftTable[t]);
}
function lp(i) {
  const e = i >> 10;
  return Tl.uint32View[0] = Tl.mantissaTable[Tl.offsetTable[e] + (i & 1023)] + Tl.exponentTable[e], Tl.floatView[0];
}
class xU {
  /**
   * Returns a half precision floating point value (FP16) from the given single
   * precision floating point value (FP32).
   *
   * @param {number} val - A single precision floating point value.
   * @return {number} The FP16 value.
   */
  static toHalfFloat(e) {
    return Hs(e);
  }
  /**
   * Returns a single precision floating point value (FP32) from the given half
   * precision floating point value (FP16).
   *
   * @param {number} val - A half precision floating point value.
   * @return {number} The FP32 value.
   */
  static fromHalfFloat(e) {
    return lp(e);
  }
}
const lr = /* @__PURE__ */ new j(), dm = /* @__PURE__ */ new Le();
let yU = 0;
class Dn {
  /**
   * Constructs a new buffer attribute.
   *
   * @param {TypedArray} array - The array holding the attribute data.
   * @param {number} itemSize - The item size.
   * @param {boolean} [normalized=false] - Whether the data are normalized or not.
   */
  constructor(e, t, n = !1) {
    if (Array.isArray(e))
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    this.isBufferAttribute = !0, Object.defineProperty(this, "id", { value: yU++ }), this.name = "", this.array = e, this.itemSize = t, this.count = e !== void 0 ? e.length / t : 0, this.normalized = n, this.usage = Wu, this.updateRanges = [], this.gpuType = Ei, this.version = 0;
  }
  /**
   * A callback function that is executed after the renderer has transferred the attribute
   * array data to the GPU.
   */
  onUploadCallback() {
  }
  /**
   * Flag to indicate that this attribute has changed and should be re-sent to
   * the GPU. Set this to `true` when you modify the value of the array.
   *
   * @type {number}
   * @default false
   * @param {boolean} value
   */
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  /**
   * Sets the usage of this buffer attribute.
   *
   * @param {(StaticDrawUsage|DynamicDrawUsage|StreamDrawUsage|StaticReadUsage|DynamicReadUsage|StreamReadUsage|StaticCopyUsage|DynamicCopyUsage|StreamCopyUsage)} value - The usage to set.
   * @return {BufferAttribute} A reference to this buffer attribute.
   */
  setUsage(e) {
    return this.usage = e, this;
  }
  /**
   * Adds a range of data in the data array to be updated on the GPU.
   *
   * @param {number} start - Position at which to start update.
   * @param {number} count - The number of components to update.
   */
  addUpdateRange(e, t) {
    this.updateRanges.push({ start: e, count: t });
  }
  /**
   * Clears the update ranges.
   */
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  /**
   * Copies the values of the given buffer attribute to this instance.
   *
   * @param {BufferAttribute} source - The buffer attribute to copy.
   * @return {BufferAttribute} A reference to this instance.
   */
  copy(e) {
    return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this.gpuType = e.gpuType, this;
  }
  /**
   * Copies a vector from the given buffer attribute to this one. The start
   * and destination position in the attribute buffers are represented by the
   * given indices.
   *
   * @param {number} index1 - The destination index into this buffer attribute.
   * @param {BufferAttribute} attribute - The buffer attribute to copy from.
   * @param {number} index2 - The source index into the given buffer attribute.
   * @return {BufferAttribute} A reference to this instance.
   */
  copyAt(e, t, n) {
    e *= this.itemSize, n *= t.itemSize;
    for (let r = 0, s = this.itemSize; r < s; r++)
      this.array[e + r] = t.array[n + r];
    return this;
  }
  /**
   * Copies the given array data into this buffer attribute.
   *
   * @param {(TypedArray|Array)} array - The array to copy.
   * @return {BufferAttribute} A reference to this instance.
   */
  copyArray(e) {
    return this.array.set(e), this;
  }
  /**
   * Applies the given 3x3 matrix to the given attribute. Works with
   * item size `2` and `3`.
   *
   * @param {Matrix3} m - The matrix to apply.
   * @return {BufferAttribute} A reference to this instance.
   */
  applyMatrix3(e) {
    if (this.itemSize === 2)
      for (let t = 0, n = this.count; t < n; t++)
        dm.fromBufferAttribute(this, t), dm.applyMatrix3(e), this.setXY(t, dm.x, dm.y);
    else if (this.itemSize === 3)
      for (let t = 0, n = this.count; t < n; t++)
        lr.fromBufferAttribute(this, t), lr.applyMatrix3(e), this.setXYZ(t, lr.x, lr.y, lr.z);
    return this;
  }
  /**
   * Applies the given 4x4 matrix to the given attribute. Only works with
   * item size `3`.
   *
   * @param {Matrix4} m - The matrix to apply.
   * @return {BufferAttribute} A reference to this instance.
   */
  applyMatrix4(e) {
    for (let t = 0, n = this.count; t < n; t++)
      lr.fromBufferAttribute(this, t), lr.applyMatrix4(e), this.setXYZ(t, lr.x, lr.y, lr.z);
    return this;
  }
  /**
   * Applies the given 3x3 normal matrix to the given attribute. Only works with
   * item size `3`.
   *
   * @param {Matrix3} m - The normal matrix to apply.
   * @return {BufferAttribute} A reference to this instance.
   */
  applyNormalMatrix(e) {
    for (let t = 0, n = this.count; t < n; t++)
      lr.fromBufferAttribute(this, t), lr.applyNormalMatrix(e), this.setXYZ(t, lr.x, lr.y, lr.z);
    return this;
  }
  /**
   * Applies the given 4x4 matrix to the given attribute. Only works with
   * item size `3` and with direction vectors.
   *
   * @param {Matrix4} m - The matrix to apply.
   * @return {BufferAttribute} A reference to this instance.
   */
  transformDirection(e) {
    for (let t = 0, n = this.count; t < n; t++)
      lr.fromBufferAttribute(this, t), lr.transformDirection(e), this.setXYZ(t, lr.x, lr.y, lr.z);
    return this;
  }
  /**
   * Sets the given array data in the buffer attribute.
   *
   * @param {(TypedArray|Array)} value - The array data to set.
   * @param {number} [offset=0] - The offset in this buffer attribute's array.
   * @return {BufferAttribute} A reference to this instance.
   */
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  /**
   * Returns the given component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} component - The component index.
   * @return {number} The returned value.
   */
  getComponent(e, t) {
    let n = this.array[e * this.itemSize + t];
    return this.normalized && (n = Ls(n, this.array)), n;
  }
  /**
   * Sets the given value to the given component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} component - The component index.
   * @param {number} value - The value to set.
   * @return {BufferAttribute} A reference to this instance.
   */
  setComponent(e, t, n) {
    return this.normalized && (n = En(n, this.array)), this.array[e * this.itemSize + t] = n, this;
  }
  /**
   * Returns the x component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @return {number} The x component.
   */
  getX(e) {
    let t = this.array[e * this.itemSize];
    return this.normalized && (t = Ls(t, this.array)), t;
  }
  /**
   * Sets the x component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} x - The value to set.
   * @return {BufferAttribute} A reference to this instance.
   */
  setX(e, t) {
    return this.normalized && (t = En(t, this.array)), this.array[e * this.itemSize] = t, this;
  }
  /**
   * Returns the y component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @return {number} The y component.
   */
  getY(e) {
    let t = this.array[e * this.itemSize + 1];
    return this.normalized && (t = Ls(t, this.array)), t;
  }
  /**
   * Sets the y component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} y - The value to set.
   * @return {BufferAttribute} A reference to this instance.
   */
  setY(e, t) {
    return this.normalized && (t = En(t, this.array)), this.array[e * this.itemSize + 1] = t, this;
  }
  /**
   * Returns the z component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @return {number} The z component.
   */
  getZ(e) {
    let t = this.array[e * this.itemSize + 2];
    return this.normalized && (t = Ls(t, this.array)), t;
  }
  /**
   * Sets the z component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} z - The value to set.
   * @return {BufferAttribute} A reference to this instance.
   */
  setZ(e, t) {
    return this.normalized && (t = En(t, this.array)), this.array[e * this.itemSize + 2] = t, this;
  }
  /**
   * Returns the w component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @return {number} The w component.
   */
  getW(e) {
    let t = this.array[e * this.itemSize + 3];
    return this.normalized && (t = Ls(t, this.array)), t;
  }
  /**
   * Sets the w component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} w - The value to set.
   * @return {BufferAttribute} A reference to this instance.
   */
  setW(e, t) {
    return this.normalized && (t = En(t, this.array)), this.array[e * this.itemSize + 3] = t, this;
  }
  /**
   * Sets the x and y component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} x - The value for the x component to set.
   * @param {number} y - The value for the y component to set.
   * @return {BufferAttribute} A reference to this instance.
   */
  setXY(e, t, n) {
    return e *= this.itemSize, this.normalized && (t = En(t, this.array), n = En(n, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this;
  }
  /**
   * Sets the x, y and z component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} x - The value for the x component to set.
   * @param {number} y - The value for the y component to set.
   * @param {number} z - The value for the z component to set.
   * @return {BufferAttribute} A reference to this instance.
   */
  setXYZ(e, t, n, r) {
    return e *= this.itemSize, this.normalized && (t = En(t, this.array), n = En(n, this.array), r = En(r, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = r, this;
  }
  /**
   * Sets the x, y, z and w component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} x - The value for the x component to set.
   * @param {number} y - The value for the y component to set.
   * @param {number} z - The value for the z component to set.
   * @param {number} w - The value for the w component to set.
   * @return {BufferAttribute} A reference to this instance.
   */
  setXYZW(e, t, n, r, s) {
    return e *= this.itemSize, this.normalized && (t = En(t, this.array), n = En(n, this.array), r = En(r, this.array), s = En(s, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = r, this.array[e + 3] = s, this;
  }
  /**
   * Sets the given callback function that is executed after the Renderer has transferred
   * the attribute array data to the GPU. Can be used to perform clean-up operations after
   * the upload when attribute data are not needed anymore on the CPU side.
   *
   * @param {Function} callback - The `onUpload()` callback.
   * @return {BufferAttribute} A reference to this instance.
   */
  onUpload(e) {
    return this.onUploadCallback = e, this;
  }
  /**
   * Returns a new buffer attribute with copied values from this instance.
   *
   * @return {BufferAttribute} A clone of this instance.
   */
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  /**
   * Serializes the buffer attribute into JSON.
   *
   * @return {Object} A JSON object representing the serialized buffer attribute.
   */
  toJSON() {
    const e = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized
    };
    return this.name !== "" && (e.name = this.name), this.usage !== Wu && (e.usage = this.usage), e;
  }
}
class vU extends Dn {
  /**
   * Constructs a new buffer attribute.
   *
   * @param {(Array<number>|Int8Array)} array - The array holding the attribute data.
   * @param {number} itemSize - The item size.
   * @param {boolean} [normalized=false] - Whether the data are normalized or not.
   */
  constructor(e, t, n) {
    super(new Int8Array(e), t, n);
  }
}
class bU extends Dn {
  /**
   * Constructs a new buffer attribute.
   *
   * @param {(Array<number>|Uint8Array)} array - The array holding the attribute data.
   * @param {number} itemSize - The item size.
   * @param {boolean} [normalized=false] - Whether the data are normalized or not.
   */
  constructor(e, t, n) {
    super(new Uint8Array(e), t, n);
  }
}
class SU extends Dn {
  /**
   * Constructs a new buffer attribute.
   *
   * @param {(Array<number>|Uint8ClampedArray)} array - The array holding the attribute data.
   * @param {number} itemSize - The item size.
   * @param {boolean} [normalized=false] - Whether the data are normalized or not.
   */
  constructor(e, t, n) {
    super(new Uint8ClampedArray(e), t, n);
  }
}
class TU extends Dn {
  /**
   * Constructs a new buffer attribute.
   *
   * @param {(Array<number>|Int16Array)} array - The array holding the attribute data.
   * @param {number} itemSize - The item size.
   * @param {boolean} [normalized=false] - Whether the data are normalized or not.
   */
  constructor(e, t, n) {
    super(new Int16Array(e), t, n);
  }
}
class X_ extends Dn {
  /**
   * Constructs a new buffer attribute.
   *
   * @param {(Array<number>|Uint16Array)} array - The array holding the attribute data.
   * @param {number} itemSize - The item size.
   * @param {boolean} [normalized=false] - Whether the data are normalized or not.
   */
  constructor(e, t, n) {
    super(new Uint16Array(e), t, n);
  }
}
class wU extends Dn {
  /**
   * Constructs a new buffer attribute.
   *
   * @param {(Array<number>|Int32Array)} array - The array holding the attribute data.
   * @param {number} itemSize - The item size.
   * @param {boolean} [normalized=false] - Whether the data are normalized or not.
   */
  constructor(e, t, n) {
    super(new Int32Array(e), t, n);
  }
}
class Y_ extends Dn {
  /**
   * Constructs a new buffer attribute.
   *
   * @param {(Array<number>|Uint32Array)} array - The array holding the attribute data.
   * @param {number} itemSize - The item size.
   * @param {boolean} [normalized=false] - Whether the data are normalized or not.
   */
  constructor(e, t, n) {
    super(new Uint32Array(e), t, n);
  }
}
class N3 extends Dn {
  /**
   * Constructs a new buffer attribute.
   *
   * @param {(Array<number>|Uint16Array)} array - The array holding the attribute data.
   * @param {number} itemSize - The item size.
   * @param {boolean} [normalized=false] - Whether the data are normalized or not.
   */
  constructor(e, t, n) {
    super(new Uint16Array(e), t, n), this.isFloat16BufferAttribute = !0;
  }
  getX(e) {
    let t = lp(this.array[e * this.itemSize]);
    return this.normalized && (t = Ls(t, this.array)), t;
  }
  setX(e, t) {
    return this.normalized && (t = En(t, this.array)), this.array[e * this.itemSize] = Hs(t), this;
  }
  getY(e) {
    let t = lp(this.array[e * this.itemSize + 1]);
    return this.normalized && (t = Ls(t, this.array)), t;
  }
  setY(e, t) {
    return this.normalized && (t = En(t, this.array)), this.array[e * this.itemSize + 1] = Hs(t), this;
  }
  getZ(e) {
    let t = lp(this.array[e * this.itemSize + 2]);
    return this.normalized && (t = Ls(t, this.array)), t;
  }
  setZ(e, t) {
    return this.normalized && (t = En(t, this.array)), this.array[e * this.itemSize + 2] = Hs(t), this;
  }
  getW(e) {
    let t = lp(this.array[e * this.itemSize + 3]);
    return this.normalized && (t = Ls(t, this.array)), t;
  }
  setW(e, t) {
    return this.normalized && (t = En(t, this.array)), this.array[e * this.itemSize + 3] = Hs(t), this;
  }
  setXY(e, t, n) {
    return e *= this.itemSize, this.normalized && (t = En(t, this.array), n = En(n, this.array)), this.array[e + 0] = Hs(t), this.array[e + 1] = Hs(n), this;
  }
  setXYZ(e, t, n, r) {
    return e *= this.itemSize, this.normalized && (t = En(t, this.array), n = En(n, this.array), r = En(r, this.array)), this.array[e + 0] = Hs(t), this.array[e + 1] = Hs(n), this.array[e + 2] = Hs(r), this;
  }
  setXYZW(e, t, n, r, s) {
    return e *= this.itemSize, this.normalized && (t = En(t, this.array), n = En(n, this.array), r = En(r, this.array), s = En(s, this.array)), this.array[e + 0] = Hs(t), this.array[e + 1] = Hs(n), this.array[e + 2] = Hs(r), this.array[e + 3] = Hs(s), this;
  }
}
class xt extends Dn {
  /**
   * Constructs a new buffer attribute.
   *
   * @param {(Array<number>|Float32Array)} array - The array holding the attribute data.
   * @param {number} itemSize - The item size.
   * @param {boolean} [normalized=false] - Whether the data are normalized or not.
   */
  constructor(e, t, n) {
    super(new Float32Array(e), t, n);
  }
}
let MU = 0;
const Io = /* @__PURE__ */ new Mt(), ry = /* @__PURE__ */ new Vn(), Md = /* @__PURE__ */ new j(), Ao = /* @__PURE__ */ new dr(), RA = /* @__PURE__ */ new dr(), Er = /* @__PURE__ */ new j();
class Yt extends lo {
  /**
   * Constructs a new geometry.
   */
  constructor() {
    super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", { value: MU++ }), this.uuid = To(), this.name = "", this.type = "BufferGeometry", this.index = null, this.indirect = null, this.indirectOffset = 0, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
  }
  /**
   * Returns the index of this geometry.
   *
   * @return {?BufferAttribute} The index. Returns `null` if no index is defined.
   */
  getIndex() {
    return this.index;
  }
  /**
   * Sets the given index to this geometry.
   *
   * @param {Array<number>|BufferAttribute} index - The index to set.
   * @return {BufferGeometry} A reference to this instance.
   */
  setIndex(e) {
    return Array.isArray(e) ? this.index = new (R3(e) ? Y_ : X_)(e, 1) : this.index = e, this;
  }
  /**
   * Sets the given indirect attribute to this geometry.
   *
   * @param {BufferAttribute} indirect - The attribute holding indirect draw calls.
   * @param {number|Array<number>} [indirectOffset=0] - The offset, in bytes, into the indirect drawing buffer where the value data begins. If an array is provided, multiple indirect draw calls will be made for each offset.
   * @return {BufferGeometry} A reference to this instance.
   */
  setIndirect(e, t = 0) {
    return this.indirect = e, this.indirectOffset = t, this;
  }
  /**
   * Returns the indirect attribute of this geometry.
   *
   * @return {?BufferAttribute} The indirect attribute. Returns `null` if no indirect attribute is defined.
   */
  getIndirect() {
    return this.indirect;
  }
  /**
   * Returns the buffer attribute for the given name.
   *
   * @param {string} name - The attribute name.
   * @return {BufferAttribute|InterleavedBufferAttribute|undefined} The buffer attribute.
   * Returns `undefined` if not attribute has been found.
   */
  getAttribute(e) {
    return this.attributes[e];
  }
  /**
   * Sets the given attribute for the given name.
   *
   * @param {string} name - The attribute name.
   * @param {BufferAttribute|InterleavedBufferAttribute} attribute - The attribute to set.
   * @return {BufferGeometry} A reference to this instance.
   */
  setAttribute(e, t) {
    return this.attributes[e] = t, this;
  }
  /**
   * Deletes the attribute for the given name.
   *
   * @param {string} name - The attribute name to delete.
   * @return {BufferGeometry} A reference to this instance.
   */
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  /**
   * Returns `true` if this geometry has an attribute for the given name.
   *
   * @param {string} name - The attribute name.
   * @return {boolean} Whether this geometry has an attribute for the given name or not.
   */
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  /**
   * Adds a group to this geometry.
   *
   * @param {number} start - The first element in this draw call. That is the first
   * vertex for non-indexed geometry, otherwise the first triangle index.
   * @param {number} count - Specifies how many vertices (or indices) are part of this group.
   * @param {number} [materialIndex=0] - The material array index to use.
   */
  addGroup(e, t, n = 0) {
    this.groups.push({
      start: e,
      count: t,
      materialIndex: n
    });
  }
  /**
   * Clears all groups.
   */
  clearGroups() {
    this.groups = [];
  }
  /**
   * Sets the draw range for this geometry.
   *
   * @param {number} start - The first vertex for non-indexed geometry, otherwise the first triangle index.
   * @param {number} count - For non-indexed BufferGeometry, `count` is the number of vertices to render.
   * For indexed BufferGeometry, `count` is the number of indices to render.
   */
  setDrawRange(e, t) {
    this.drawRange.start = e, this.drawRange.count = t;
  }
  /**
   * Applies the given 4x4 transformation matrix to the geometry.
   *
   * @param {Matrix4} matrix - The matrix to apply.
   * @return {BufferGeometry} A reference to this instance.
   */
  applyMatrix4(e) {
    const t = this.attributes.position;
    t !== void 0 && (t.applyMatrix4(e), t.needsUpdate = !0);
    const n = this.attributes.normal;
    if (n !== void 0) {
      const s = new fn().getNormalMatrix(e);
      n.applyNormalMatrix(s), n.needsUpdate = !0;
    }
    const r = this.attributes.tangent;
    return r !== void 0 && (r.transformDirection(e), r.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  /**
   * Applies the rotation represented by the Quaternion to the geometry.
   *
   * @param {Quaternion} q - The Quaternion to apply.
   * @return {BufferGeometry} A reference to this instance.
   */
  applyQuaternion(e) {
    return Io.makeRotationFromQuaternion(e), this.applyMatrix4(Io), this;
  }
  /**
   * Rotates the geometry about the X axis. This is typically done as a one time
   * operation, and not during a loop. Use {@link Object3D#rotation} for typical
   * real-time mesh rotation.
   *
   * @param {number} angle - The angle in radians.
   * @return {BufferGeometry} A reference to this instance.
   */
  rotateX(e) {
    return Io.makeRotationX(e), this.applyMatrix4(Io), this;
  }
  /**
   * Rotates the geometry about the Y axis. This is typically done as a one time
   * operation, and not during a loop. Use {@link Object3D#rotation} for typical
   * real-time mesh rotation.
   *
   * @param {number} angle - The angle in radians.
   * @return {BufferGeometry} A reference to this instance.
   */
  rotateY(e) {
    return Io.makeRotationY(e), this.applyMatrix4(Io), this;
  }
  /**
   * Rotates the geometry about the Z axis. This is typically done as a one time
   * operation, and not during a loop. Use {@link Object3D#rotation} for typical
   * real-time mesh rotation.
   *
   * @param {number} angle - The angle in radians.
   * @return {BufferGeometry} A reference to this instance.
   */
  rotateZ(e) {
    return Io.makeRotationZ(e), this.applyMatrix4(Io), this;
  }
  /**
   * Translates the geometry. This is typically done as a one time
   * operation, and not during a loop. Use {@link Object3D#position} for typical
   * real-time mesh rotation.
   *
   * @param {number} x - The x offset.
   * @param {number} y - The y offset.
   * @param {number} z - The z offset.
   * @return {BufferGeometry} A reference to this instance.
   */
  translate(e, t, n) {
    return Io.makeTranslation(e, t, n), this.applyMatrix4(Io), this;
  }
  /**
   * Scales the geometry. This is typically done as a one time
   * operation, and not during a loop. Use {@link Object3D#scale} for typical
   * real-time mesh rotation.
   *
   * @param {number} x - The x scale.
   * @param {number} y - The y scale.
   * @param {number} z - The z scale.
   * @return {BufferGeometry} A reference to this instance.
   */
  scale(e, t, n) {
    return Io.makeScale(e, t, n), this.applyMatrix4(Io), this;
  }
  /**
   * Rotates the geometry to face a point in 3D space. This is typically done as a one time
   * operation, and not during a loop. Use {@link Object3D#lookAt} for typical
   * real-time mesh rotation.
   *
   * @param {Vector3} vector - The target point.
   * @return {BufferGeometry} A reference to this instance.
   */
  lookAt(e) {
    return ry.lookAt(e), ry.updateMatrix(), this.applyMatrix4(ry.matrix), this;
  }
  /**
   * Center the geometry based on its bounding box.
   *
   * @return {BufferGeometry} A reference to this instance.
   */
  center() {
    return this.computeBoundingBox(), this.boundingBox.getCenter(Md).negate(), this.translate(Md.x, Md.y, Md.z), this;
  }
  /**
   * Defines a geometry by creating a `position` attribute based on the given array of points. The array
   * can hold 2D or 3D vectors. When using two-dimensional data, the `z` coordinate for all vertices is
   * set to `0`.
   *
   * If the method is used with an existing `position` attribute, the vertex data are overwritten with the
   * data from the array. The length of the array must match the vertex count.
   *
   * @param {Array<Vector2>|Array<Vector3>} points - The points.
   * @return {BufferGeometry} A reference to this instance.
   */
  setFromPoints(e) {
    const t = this.getAttribute("position");
    if (t === void 0) {
      const n = [];
      for (let r = 0, s = e.length; r < s; r++) {
        const o = e[r];
        n.push(o.x, o.y, o.z || 0);
      }
      this.setAttribute("position", new xt(n, 3));
    } else {
      const n = Math.min(e.length, t.count);
      for (let r = 0; r < n; r++) {
        const s = e[r];
        t.setXYZ(r, s.x, s.y, s.z || 0);
      }
      e.length > t.count && Me("BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."), t.needsUpdate = !0;
    }
    return this;
  }
  /**
   * Computes the bounding box of the geometry, and updates the `boundingBox` member.
   * The bounding box is not computed by the engine; it must be computed by your app.
   * You may need to recompute the bounding box if the geometry vertices are modified.
   */
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new dr());
    const e = this.attributes.position, t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      Ie("BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this), this.boundingBox.set(
        new j(-1 / 0, -1 / 0, -1 / 0),
        new j(1 / 0, 1 / 0, 1 / 0)
      );
      return;
    }
    if (e !== void 0) {
      if (this.boundingBox.setFromBufferAttribute(e), t)
        for (let n = 0, r = t.length; n < r; n++) {
          const s = t[n];
          Ao.setFromBufferAttribute(s), this.morphTargetsRelative ? (Er.addVectors(this.boundingBox.min, Ao.min), this.boundingBox.expandByPoint(Er), Er.addVectors(this.boundingBox.max, Ao.max), this.boundingBox.expandByPoint(Er)) : (this.boundingBox.expandByPoint(Ao.min), this.boundingBox.expandByPoint(Ao.max));
        }
    } else
      this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && Ie('BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
  }
  /**
   * Computes the bounding sphere of the geometry, and updates the `boundingSphere` member.
   * The engine automatically computes the bounding sphere when it is needed, e.g., for ray casting or view frustum culling.
   * You may need to recompute the bounding sphere if the geometry vertices are modified.
   */
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new fr());
    const e = this.attributes.position, t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      Ie("BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this), this.boundingSphere.set(new j(), 1 / 0);
      return;
    }
    if (e) {
      const n = this.boundingSphere.center;
      if (Ao.setFromBufferAttribute(e), t)
        for (let s = 0, o = t.length; s < o; s++) {
          const a = t[s];
          RA.setFromBufferAttribute(a), this.morphTargetsRelative ? (Er.addVectors(Ao.min, RA.min), Ao.expandByPoint(Er), Er.addVectors(Ao.max, RA.max), Ao.expandByPoint(Er)) : (Ao.expandByPoint(RA.min), Ao.expandByPoint(RA.max));
        }
      Ao.getCenter(n);
      let r = 0;
      for (let s = 0, o = e.count; s < o; s++)
        Er.fromBufferAttribute(e, s), r = Math.max(r, n.distanceToSquared(Er));
      if (t)
        for (let s = 0, o = t.length; s < o; s++) {
          const a = t[s], l = this.morphTargetsRelative;
          for (let u = 0, c = a.count; u < c; u++)
            Er.fromBufferAttribute(a, u), l && (Md.fromBufferAttribute(e, u), Er.add(Md)), r = Math.max(r, n.distanceToSquared(Er));
        }
      this.boundingSphere.radius = Math.sqrt(r), isNaN(this.boundingSphere.radius) && Ie('BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
    }
  }
  /**
   * Calculates and adds a tangent attribute to this geometry.
   *
   * The computation is only supported for indexed geometries and if position, normal, and uv attributes
   * are defined. When using a tangent space normal map, prefer the MikkTSpace algorithm provided by
   * {@link BufferGeometryUtils#computeMikkTSpaceTangents} instead.
   */
  computeTangents() {
    const e = this.index, t = this.attributes;
    if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) {
      Ie("BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      return;
    }
    const n = t.position, r = t.normal, s = t.uv;
    this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new Dn(new Float32Array(4 * n.count), 4));
    const o = this.getAttribute("tangent"), a = [], l = [];
    for (let U = 0; U < n.count; U++)
      a[U] = new j(), l[U] = new j();
    const u = new j(), c = new j(), A = new j(), m = new Le(), _ = new Le(), y = new Le(), T = new j(), b = new j();
    function S(U, N, O) {
      u.fromBufferAttribute(n, U), c.fromBufferAttribute(n, N), A.fromBufferAttribute(n, O), m.fromBufferAttribute(s, U), _.fromBufferAttribute(s, N), y.fromBufferAttribute(s, O), c.sub(u), A.sub(u), _.sub(m), y.sub(m);
      const G = 1 / (_.x * y.y - y.x * _.y);
      isFinite(G) && (T.copy(c).multiplyScalar(y.y).addScaledVector(A, -_.y).multiplyScalar(G), b.copy(A).multiplyScalar(_.x).addScaledVector(c, -y.x).multiplyScalar(G), a[U].add(T), a[N].add(T), a[O].add(T), l[U].add(b), l[N].add(b), l[O].add(b));
    }
    let E = this.groups;
    E.length === 0 && (E = [{
      start: 0,
      count: e.count
    }]);
    for (let U = 0, N = E.length; U < N; ++U) {
      const O = E[U], G = O.start, H = O.count;
      for (let Y = G, K = G + H; Y < K; Y += 3)
        S(
          e.getX(Y + 0),
          e.getX(Y + 1),
          e.getX(Y + 2)
        );
    }
    const R = new j(), C = new j(), L = new j(), D = new j();
    function B(U) {
      L.fromBufferAttribute(r, U), D.copy(L);
      const N = a[U];
      R.copy(N), R.sub(L.multiplyScalar(L.dot(N))).normalize(), C.crossVectors(D, N);
      const G = C.dot(l[U]) < 0 ? -1 : 1;
      o.setXYZW(U, R.x, R.y, R.z, G);
    }
    for (let U = 0, N = E.length; U < N; ++U) {
      const O = E[U], G = O.start, H = O.count;
      for (let Y = G, K = G + H; Y < K; Y += 3)
        B(e.getX(Y + 0)), B(e.getX(Y + 1)), B(e.getX(Y + 2));
    }
  }
  /**
   * Computes vertex normals for the given vertex data. For indexed geometries, the method sets
   * each vertex normal to be the average of the face normals of the faces that share that vertex.
   * For non-indexed geometries, vertices are not shared, and the method sets each vertex normal
   * to be the same as the face normal.
   */
  computeVertexNormals() {
    const e = this.index, t = this.getAttribute("position");
    if (t !== void 0) {
      let n = this.getAttribute("normal");
      if (n === void 0)
        n = new Dn(new Float32Array(t.count * 3), 3), this.setAttribute("normal", n);
      else
        for (let m = 0, _ = n.count; m < _; m++)
          n.setXYZ(m, 0, 0, 0);
      const r = new j(), s = new j(), o = new j(), a = new j(), l = new j(), u = new j(), c = new j(), A = new j();
      if (e)
        for (let m = 0, _ = e.count; m < _; m += 3) {
          const y = e.getX(m + 0), T = e.getX(m + 1), b = e.getX(m + 2);
          r.fromBufferAttribute(t, y), s.fromBufferAttribute(t, T), o.fromBufferAttribute(t, b), c.subVectors(o, s), A.subVectors(r, s), c.cross(A), a.fromBufferAttribute(n, y), l.fromBufferAttribute(n, T), u.fromBufferAttribute(n, b), a.add(c), l.add(c), u.add(c), n.setXYZ(y, a.x, a.y, a.z), n.setXYZ(T, l.x, l.y, l.z), n.setXYZ(b, u.x, u.y, u.z);
        }
      else
        for (let m = 0, _ = t.count; m < _; m += 3)
          r.fromBufferAttribute(t, m + 0), s.fromBufferAttribute(t, m + 1), o.fromBufferAttribute(t, m + 2), c.subVectors(o, s), A.subVectors(r, s), c.cross(A), n.setXYZ(m + 0, c.x, c.y, c.z), n.setXYZ(m + 1, c.x, c.y, c.z), n.setXYZ(m + 2, c.x, c.y, c.z);
      this.normalizeNormals(), n.needsUpdate = !0;
    }
  }
  /**
   * Ensures every normal vector in a geometry will have a magnitude of `1`. This will
   * correct lighting on the geometry surfaces.
   */
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let t = 0, n = e.count; t < n; t++)
      Er.fromBufferAttribute(e, t), Er.normalize(), e.setXYZ(t, Er.x, Er.y, Er.z);
  }
  /**
   * Return a new non-index version of this indexed geometry. If the geometry
   * is already non-indexed, the method is a NOOP.
   *
   * @return {BufferGeometry} The non-indexed version of this indexed geometry.
   */
  toNonIndexed() {
    function e(a, l) {
      const u = a.array, c = a.itemSize, A = a.normalized, m = new u.constructor(l.length * c);
      let _ = 0, y = 0;
      for (let T = 0, b = l.length; T < b; T++) {
        a.isInterleavedBufferAttribute ? _ = l[T] * a.data.stride + a.offset : _ = l[T] * c;
        for (let S = 0; S < c; S++)
          m[y++] = u[_++];
      }
      return new Dn(m, c, A);
    }
    if (this.index === null)
      return Me("BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
    const t = new Yt(), n = this.index.array, r = this.attributes;
    for (const a in r) {
      const l = r[a], u = e(l, n);
      t.setAttribute(a, u);
    }
    const s = this.morphAttributes;
    for (const a in s) {
      const l = [], u = s[a];
      for (let c = 0, A = u.length; c < A; c++) {
        const m = u[c], _ = e(m, n);
        l.push(_);
      }
      t.morphAttributes[a] = l;
    }
    t.morphTargetsRelative = this.morphTargetsRelative;
    const o = this.groups;
    for (let a = 0, l = o.length; a < l; a++) {
      const u = o[a];
      t.addGroup(u.start, u.count, u.materialIndex);
    }
    return t;
  }
  /**
   * Serializes the geometry into JSON.
   *
   * @return {Object} A JSON object representing the serialized geometry.
   */
  toJSON() {
    const e = {
      metadata: {
        version: 4.7,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0) {
      const l = this.parameters;
      for (const u in l)
        l[u] !== void 0 && (e[u] = l[u]);
      return e;
    }
    e.data = { attributes: {} };
    const t = this.index;
    t !== null && (e.data.index = {
      type: t.array.constructor.name,
      array: Array.prototype.slice.call(t.array)
    });
    const n = this.attributes;
    for (const l in n) {
      const u = n[l];
      e.data.attributes[l] = u.toJSON(e.data);
    }
    const r = {};
    let s = !1;
    for (const l in this.morphAttributes) {
      const u = this.morphAttributes[l], c = [];
      for (let A = 0, m = u.length; A < m; A++) {
        const _ = u[A];
        c.push(_.toJSON(e.data));
      }
      c.length > 0 && (r[l] = c, s = !0);
    }
    s && (e.data.morphAttributes = r, e.data.morphTargetsRelative = this.morphTargetsRelative);
    const o = this.groups;
    o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
    const a = this.boundingSphere;
    return a !== null && (e.data.boundingSphere = a.toJSON()), e;
  }
  /**
   * Returns a new geometry with copied values from this instance.
   *
   * @return {BufferGeometry} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
  /**
   * Copies the values of the given geometry to this instance.
   *
   * @param {BufferGeometry} source - The geometry to copy.
   * @return {BufferGeometry} A reference to this instance.
   */
  copy(e) {
    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
    const t = {};
    this.name = e.name;
    const n = e.index;
    n !== null && this.setIndex(n.clone());
    const r = e.attributes;
    for (const u in r) {
      const c = r[u];
      this.setAttribute(u, c.clone(t));
    }
    const s = e.morphAttributes;
    for (const u in s) {
      const c = [], A = s[u];
      for (let m = 0, _ = A.length; m < _; m++)
        c.push(A[m].clone(t));
      this.morphAttributes[u] = c;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const o = e.groups;
    for (let u = 0, c = o.length; u < c; u++) {
      const A = o[u];
      this.addGroup(A.start, A.count, A.materialIndex);
    }
    const a = e.boundingBox;
    a !== null && (this.boundingBox = a.clone());
    const l = e.boundingSphere;
    return l !== null && (this.boundingSphere = l.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this;
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   *
   * @fires BufferGeometry#dispose
   */
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const TM = /* @__PURE__ */ new Mt(), xc = /* @__PURE__ */ new Zh(), fm = /* @__PURE__ */ new fr(), wM = /* @__PURE__ */ new j(), Am = /* @__PURE__ */ new j(), pm = /* @__PURE__ */ new j(), mm = /* @__PURE__ */ new j(), sy = /* @__PURE__ */ new j(), gm = /* @__PURE__ */ new j(), MM = /* @__PURE__ */ new j(), _m = /* @__PURE__ */ new j();
class Tn extends Vn {
  /**
   * Constructs a new mesh.
   *
   * @param {BufferGeometry} [geometry] - The mesh geometry.
   * @param {Material|Array<Material>} [material] - The mesh material.
   */
  constructor(e = new Yt(), t = new Nr()) {
    super(), this.isMesh = !0, this.type = "Mesh", this.geometry = e, this.material = t, this.morphTargetDictionary = void 0, this.morphTargetInfluences = void 0, this.count = 1, this.updateMorphTargets();
  }
  copy(e, t) {
    return super.copy(e, t), e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
  }
  /**
   * Sets the values of {@link Mesh#morphTargetDictionary} and {@link Mesh#morphTargetInfluences}
   * to make sure existing morph targets can influence this 3D object.
   */
  updateMorphTargets() {
    const t = this.geometry.morphAttributes, n = Object.keys(t);
    if (n.length > 0) {
      const r = t[n[0]];
      if (r !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let s = 0, o = r.length; s < o; s++) {
          const a = r[s].name || String(s);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = s;
        }
      }
    }
  }
  /**
   * Returns the local-space position of the vertex at the given index, taking into
   * account the current animation state of both morph targets and skinning.
   *
   * @param {number} index - The vertex index.
   * @param {Vector3} target - The target object that is used to store the method's result.
   * @return {Vector3} The vertex position in local space.
   */
  getVertexPosition(e, t) {
    const n = this.geometry, r = n.attributes.position, s = n.morphAttributes.position, o = n.morphTargetsRelative;
    t.fromBufferAttribute(r, e);
    const a = this.morphTargetInfluences;
    if (s && a) {
      gm.set(0, 0, 0);
      for (let l = 0, u = s.length; l < u; l++) {
        const c = a[l], A = s[l];
        c !== 0 && (sy.fromBufferAttribute(A, e), o ? gm.addScaledVector(sy, c) : gm.addScaledVector(sy.sub(t), c));
      }
      t.add(gm);
    }
    return t;
  }
  /**
   * Computes intersection points between a casted ray and this line.
   *
   * @param {Raycaster} raycaster - The raycaster.
   * @param {Array<Object>} intersects - The target array that holds the intersection points.
   */
  raycast(e, t) {
    const n = this.geometry, r = this.material, s = this.matrixWorld;
    r !== void 0 && (n.boundingSphere === null && n.computeBoundingSphere(), fm.copy(n.boundingSphere), fm.applyMatrix4(s), xc.copy(e.ray).recast(e.near), !(fm.containsPoint(xc.origin) === !1 && (xc.intersectSphere(fm, wM) === null || xc.origin.distanceToSquared(wM) > (e.far - e.near) ** 2)) && (TM.copy(s).invert(), xc.copy(e.ray).applyMatrix4(TM), !(n.boundingBox !== null && xc.intersectsBox(n.boundingBox) === !1) && this._computeIntersections(e, t, xc)));
  }
  _computeIntersections(e, t, n) {
    let r;
    const s = this.geometry, o = this.material, a = s.index, l = s.attributes.position, u = s.attributes.uv, c = s.attributes.uv1, A = s.attributes.normal, m = s.groups, _ = s.drawRange;
    if (a !== null)
      if (Array.isArray(o))
        for (let y = 0, T = m.length; y < T; y++) {
          const b = m[y], S = o[b.materialIndex], E = Math.max(b.start, _.start), R = Math.min(a.count, Math.min(b.start + b.count, _.start + _.count));
          for (let C = E, L = R; C < L; C += 3) {
            const D = a.getX(C), B = a.getX(C + 1), U = a.getX(C + 2);
            r = xm(this, S, e, n, u, c, A, D, B, U), r && (r.faceIndex = Math.floor(C / 3), r.face.materialIndex = b.materialIndex, t.push(r));
          }
        }
      else {
        const y = Math.max(0, _.start), T = Math.min(a.count, _.start + _.count);
        for (let b = y, S = T; b < S; b += 3) {
          const E = a.getX(b), R = a.getX(b + 1), C = a.getX(b + 2);
          r = xm(this, o, e, n, u, c, A, E, R, C), r && (r.faceIndex = Math.floor(b / 3), t.push(r));
        }
      }
    else if (l !== void 0)
      if (Array.isArray(o))
        for (let y = 0, T = m.length; y < T; y++) {
          const b = m[y], S = o[b.materialIndex], E = Math.max(b.start, _.start), R = Math.min(l.count, Math.min(b.start + b.count, _.start + _.count));
          for (let C = E, L = R; C < L; C += 3) {
            const D = C, B = C + 1, U = C + 2;
            r = xm(this, S, e, n, u, c, A, D, B, U), r && (r.faceIndex = Math.floor(C / 3), r.face.materialIndex = b.materialIndex, t.push(r));
          }
        }
      else {
        const y = Math.max(0, _.start), T = Math.min(l.count, _.start + _.count);
        for (let b = y, S = T; b < S; b += 3) {
          const E = b, R = b + 1, C = b + 2;
          r = xm(this, o, e, n, u, c, A, E, R, C), r && (r.faceIndex = Math.floor(b / 3), t.push(r));
        }
      }
  }
}
function EU(i, e, t, n, r, s, o, a) {
  let l;
  if (e.side === si ? l = n.intersectTriangle(o, s, r, !0, a) : l = n.intersectTriangle(r, s, o, e.side === Zs, a), l === null) return null;
  _m.copy(a), _m.applyMatrix4(i.matrixWorld);
  const u = t.ray.origin.distanceTo(_m);
  return u < t.near || u > t.far ? null : {
    distance: u,
    point: _m.clone(),
    object: i
  };
}
function xm(i, e, t, n, r, s, o, a, l, u) {
  i.getVertexPosition(a, Am), i.getVertexPosition(l, pm), i.getVertexPosition(u, mm);
  const c = EU(i, e, t, n, Am, pm, mm, MM);
  if (c) {
    const A = new j();
    $s.getBarycoord(MM, Am, pm, mm, A), r && (c.uv = $s.getInterpolatedAttribute(r, a, l, u, A, new Le())), s && (c.uv1 = $s.getInterpolatedAttribute(s, a, l, u, A, new Le())), o && (c.normal = $s.getInterpolatedAttribute(o, a, l, u, A, new j()), c.normal.dot(n.direction) > 0 && c.normal.multiplyScalar(-1));
    const m = {
      a,
      b: l,
      c: u,
      normal: new j(),
      materialIndex: 0
    };
    $s.getNormal(Am, pm, mm, m.normal), c.face = m, c.barycoord = A;
  }
  return c;
}
class ul extends Yt {
  /**
   * Constructs a new box geometry.
   *
   * @param {number} [width=1] - The width. That is, the length of the edges parallel to the X axis.
   * @param {number} [height=1] - The height. That is, the length of the edges parallel to the Y axis.
   * @param {number} [depth=1] - The depth. That is, the length of the edges parallel to the Z axis.
   * @param {number} [widthSegments=1] - Number of segmented rectangular faces along the width of the sides.
   * @param {number} [heightSegments=1] - Number of segmented rectangular faces along the height of the sides.
   * @param {number} [depthSegments=1] - Number of segmented rectangular faces along the depth of the sides.
   */
  constructor(e = 1, t = 1, n = 1, r = 1, s = 1, o = 1) {
    super(), this.type = "BoxGeometry", this.parameters = {
      width: e,
      height: t,
      depth: n,
      widthSegments: r,
      heightSegments: s,
      depthSegments: o
    };
    const a = this;
    r = Math.floor(r), s = Math.floor(s), o = Math.floor(o);
    const l = [], u = [], c = [], A = [];
    let m = 0, _ = 0;
    y("z", "y", "x", -1, -1, n, t, e, o, s, 0), y("z", "y", "x", 1, -1, n, t, -e, o, s, 1), y("x", "z", "y", 1, 1, e, n, t, r, o, 2), y("x", "z", "y", 1, -1, e, n, -t, r, o, 3), y("x", "y", "z", 1, -1, e, t, n, r, s, 4), y("x", "y", "z", -1, -1, e, t, -n, r, s, 5), this.setIndex(l), this.setAttribute("position", new xt(u, 3)), this.setAttribute("normal", new xt(c, 3)), this.setAttribute("uv", new xt(A, 2));
    function y(T, b, S, E, R, C, L, D, B, U, N) {
      const O = C / B, G = L / U, H = C / 2, Y = L / 2, K = D / 2, X = B + 1, ee = U + 1;
      let oe = 0, fe = 0;
      const _e = new j();
      for (let Te = 0; Te < ee; Te++) {
        const Ce = Te * G - Y;
        for (let Je = 0; Je < X; Je++) {
          const Qe = Je * O - H;
          _e[T] = Qe * E, _e[b] = Ce * R, _e[S] = K, u.push(_e.x, _e.y, _e.z), _e[T] = 0, _e[b] = 0, _e[S] = D > 0 ? 1 : -1, c.push(_e.x, _e.y, _e.z), A.push(Je / B), A.push(1 - Te / U), oe += 1;
        }
      }
      for (let Te = 0; Te < U; Te++)
        for (let Ce = 0; Ce < B; Ce++) {
          const Je = m + Ce + X * Te, Qe = m + Ce + X * (Te + 1), zt = m + (Ce + 1) + X * (Te + 1), Tt = m + (Ce + 1) + X * Te;
          l.push(Je, Qe, Tt), l.push(Qe, zt, Tt), fe += 6;
        }
      a.addGroup(_, fe, N), _ += fe, m += oe;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {BoxGeometry} A new instance.
   */
  static fromJSON(e) {
    return new ul(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments);
  }
}
function kf(i) {
  const e = {};
  for (const t in i) {
    e[t] = {};
    for (const n in i[t]) {
      const r = i[t][n];
      r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? r.isRenderTargetTexture ? (Me("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), e[t][n] = null) : e[t][n] = r.clone() : Array.isArray(r) ? e[t][n] = r.slice() : e[t][n] = r;
    }
  }
  return e;
}
function ws(i) {
  const e = {};
  for (let t = 0; t < i.length; t++) {
    const n = kf(i[t]);
    for (const r in n)
      e[r] = n[r];
  }
  return e;
}
function RU(i) {
  const e = [];
  for (let t = 0; t < i.length; t++)
    e.push(i[t].clone());
  return e;
}
function $5(i) {
  const e = i.getRenderTarget();
  return e === null ? i.outputColorSpace : e.isXRRenderTarget === !0 ? e.texture.colorSpace : Xt.workingColorSpace;
}
const v0 = { clone: kf, merge: ws };
var CU = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, PU = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class Fr extends Br {
  /**
   * Constructs a new shader material.
   *
   * @param {Object} [parameters] - An object with one or more properties
   * defining the material's appearance. Any property of the material
   * (including any property from inherited materials) can be passed
   * in here. Color values can be passed any type of value accepted
   * by {@link Color#set}.
   */
  constructor(e) {
    super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = CU, this.fragmentShader = PU, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.forceSinglePass = !0, this.extensions = {
      clipCullDistance: !1,
      // set to use vertex shader clipping
      multiDraw: !1
      // set to use vertex shader multi_draw / enable gl_DrawID
    }, this.defaultAttributeValues = {
      color: [1, 1, 1],
      uv: [0, 0],
      uv1: [0, 0]
    }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, e !== void 0 && this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = kf(e.uniforms), this.uniformsGroups = RU(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this.defaultAttributeValues = Object.assign({}, e.defaultAttributeValues), this.index0AttributeName = e.index0AttributeName, this.uniformsNeedUpdate = e.uniformsNeedUpdate, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    t.glslVersion = this.glslVersion, t.uniforms = {};
    for (const r in this.uniforms) {
      const o = this.uniforms[r].value;
      o && o.isTexture ? t.uniforms[r] = {
        type: "t",
        value: o.toJSON(e).uuid
      } : o && o.isColor ? t.uniforms[r] = {
        type: "c",
        value: o.getHex()
      } : o && o.isVector2 ? t.uniforms[r] = {
        type: "v2",
        value: o.toArray()
      } : o && o.isVector3 ? t.uniforms[r] = {
        type: "v3",
        value: o.toArray()
      } : o && o.isVector4 ? t.uniforms[r] = {
        type: "v4",
        value: o.toArray()
      } : o && o.isMatrix3 ? t.uniforms[r] = {
        type: "m3",
        value: o.toArray()
      } : o && o.isMatrix4 ? t.uniforms[r] = {
        type: "m4",
        value: o.toArray()
      } : t.uniforms[r] = {
        value: o
      };
    }
    Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader, t.lights = this.lights, t.clipping = this.clipping;
    const n = {};
    for (const r in this.extensions)
      this.extensions[r] === !0 && (n[r] = !0);
    return Object.keys(n).length > 0 && (t.extensions = n), t;
  }
}
class Jh extends Vn {
  /**
   * Constructs a new camera.
   */
  constructor() {
    super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new Mt(), this.projectionMatrix = new Mt(), this.projectionMatrixInverse = new Mt(), this.coordinateSystem = jr, this._reversedDepth = !1;
  }
  /**
   * The flag that indicates whether the camera uses a reversed depth buffer.
   *
   * @type {boolean}
   * @default false
   */
  get reversedDepth() {
    return this._reversedDepth;
  }
  copy(e, t) {
    return super.copy(e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this.coordinateSystem = e.coordinateSystem, this;
  }
  /**
   * Returns a vector representing the ("look") direction of the 3D object in world space.
   *
   * This method is overwritten since cameras have a different forward vector compared to other
   * 3D objects. A camera looks down its local, negative z-axis by default.
   *
   * @param {Vector3} target - The target vector the result is stored to.
   * @return {Vector3} The 3D object's direction in world space.
   */
  getWorldDirection(e) {
    return super.getWorldDirection(e).negate();
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(e, t) {
    super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Au = /* @__PURE__ */ new j(), EM = /* @__PURE__ */ new Le(), RM = /* @__PURE__ */ new Le();
class Ji extends Jh {
  /**
   * Constructs a new perspective camera.
   *
   * @param {number} [fov=50] - The vertical field of view.
   * @param {number} [aspect=1] - The aspect ratio.
   * @param {number} [near=0.1] - The camera's near plane.
   * @param {number} [far=2000] - The camera's far plane.
   */
  constructor(e = 50, t = 1, n = 0.1, r = 2e3) {
    super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = n, this.far = r, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
  }
  copy(e, t) {
    return super.copy(e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = e.view === null ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this;
  }
  /**
   * Sets the FOV by focal length in respect to the current {@link PerspectiveCamera#filmGauge}.
   *
   * The default film gauge is 35, so that the focal length can be specified for
   * a 35mm (full frame) camera.
   *
   * @param {number} focalLength - Values for focal length and film gauge must have the same unit.
   */
  setFocalLength(e) {
    const t = 0.5 * this.getFilmHeight() / e;
    this.fov = Gh * 2 * Math.atan(t), this.updateProjectionMatrix();
  }
  /**
   * Returns the focal length from the current {@link PerspectiveCamera#fov} and
   * {@link PerspectiveCamera#filmGauge}.
   *
   * @return {number} The computed focal length.
   */
  getFocalLength() {
    const e = Math.tan(ah * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / e;
  }
  /**
   * Returns the current vertical field of view angle in degrees considering {@link PerspectiveCamera#zoom}.
   *
   * @return {number} The effective FOV.
   */
  getEffectiveFOV() {
    return Gh * 2 * Math.atan(
      Math.tan(ah * 0.5 * this.fov) / this.zoom
    );
  }
  /**
   * Returns the width of the image on the film. If {@link PerspectiveCamera#aspect} is greater than or
   * equal to one (landscape format), the result equals {@link PerspectiveCamera#filmGauge}.
   *
   * @return {number} The film width.
   */
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  /**
   * Returns the height of the image on the film. If {@link PerspectiveCamera#aspect} is greater than or
   * equal to one (landscape format), the result equals {@link PerspectiveCamera#filmGauge}.
   *
   * @return {number} The film width.
   */
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  /**
   * Computes the 2D bounds of the camera's viewable rectangle at a given distance along the viewing direction.
   * Sets `minTarget` and `maxTarget` to the coordinates of the lower-left and upper-right corners of the view rectangle.
   *
   * @param {number} distance - The viewing distance.
   * @param {Vector2} minTarget - The lower-left corner of the view rectangle is written into this vector.
   * @param {Vector2} maxTarget - The upper-right corner of the view rectangle is written into this vector.
   */
  getViewBounds(e, t, n) {
    Au.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse), t.set(Au.x, Au.y).multiplyScalar(-e / Au.z), Au.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse), n.set(Au.x, Au.y).multiplyScalar(-e / Au.z);
  }
  /**
   * Computes the width and height of the camera's viewable rectangle at a given distance along the viewing direction.
   *
   * @param {number} distance - The viewing distance.
   * @param {Vector2} target - The target vector that is used to store result where x is width and y is height.
   * @returns {Vector2} The view size.
   */
  getViewSize(e, t) {
    return this.getViewBounds(e, EM, RM), t.subVectors(RM, EM);
  }
  /**
   * Sets an offset in a larger frustum. This is useful for multi-window or
   * multi-monitor/multi-machine setups.
   *
   * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
   * the monitors are in grid like this
   *```
   *   +---+---+---+
   *   | A | B | C |
   *   +---+---+---+
   *   | D | E | F |
   *   +---+---+---+
   *```
   * then for each monitor you would call it like this:
   *```js
   * const w = 1920;
   * const h = 1080;
   * const fullWidth = w * 3;
   * const fullHeight = h * 2;
   *
   * // --A--
   * camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
   * // --B--
   * camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
   * // --C--
   * camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
   * // --D--
   * camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
   * // --E--
   * camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
   * // --F--
   * camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
   * ```
   *
   * Note there is no reason monitors have to be the same size or in a grid.
   *
   * @param {number} fullWidth - The full width of multiview setup.
   * @param {number} fullHeight - The full height of multiview setup.
   * @param {number} x - The horizontal offset of the subcamera.
   * @param {number} y - The vertical offset of the subcamera.
   * @param {number} width - The width of subcamera.
   * @param {number} height - The height of subcamera.
   */
  setViewOffset(e, t, n, r, s, o) {
    this.aspect = e / t, this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = r, this.view.width = s, this.view.height = o, this.updateProjectionMatrix();
  }
  /**
   * Removes the view offset from the projection matrix.
   */
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  /**
   * Updates the camera's projection matrix. Must be called after any change of
   * camera properties.
   */
  updateProjectionMatrix() {
    const e = this.near;
    let t = e * Math.tan(ah * 0.5 * this.fov) / this.zoom, n = 2 * t, r = this.aspect * n, s = -0.5 * r;
    const o = this.view;
    if (this.view !== null && this.view.enabled) {
      const l = o.fullWidth, u = o.fullHeight;
      s += o.offsetX * r / l, t -= o.offsetY * n / u, r *= o.width / l, n *= o.height / u;
    }
    const a = this.filmOffset;
    a !== 0 && (s += e * a / this.getFilmWidth()), this.projectionMatrix.makePerspective(s, s + r, t, t - n, e, this.far, this.coordinateSystem, this.reversedDepth), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, this.view !== null && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t;
  }
}
const Ed = -90, Rd = 1;
class D3 extends Vn {
  /**
   * Constructs a new cube camera.
   *
   * @param {number} near - The camera's near plane.
   * @param {number} far - The camera's far plane.
   * @param {WebGLCubeRenderTarget} renderTarget - The cube render target.
   */
  constructor(e, t, n) {
    super(), this.type = "CubeCamera", this.renderTarget = n, this.coordinateSystem = null, this.activeMipmapLevel = 0;
    const r = new Ji(Ed, Rd, e, t);
    r.layers = this.layers, this.add(r);
    const s = new Ji(Ed, Rd, e, t);
    s.layers = this.layers, this.add(s);
    const o = new Ji(Ed, Rd, e, t);
    o.layers = this.layers, this.add(o);
    const a = new Ji(Ed, Rd, e, t);
    a.layers = this.layers, this.add(a);
    const l = new Ji(Ed, Rd, e, t);
    l.layers = this.layers, this.add(l);
    const u = new Ji(Ed, Rd, e, t);
    u.layers = this.layers, this.add(u);
  }
  /**
   * Must be called when the coordinate system of the cube camera is changed.
   */
  updateCoordinateSystem() {
    const e = this.coordinateSystem, t = this.children.concat(), [n, r, s, o, a, l] = t;
    for (const u of t) this.remove(u);
    if (e === jr)
      n.up.set(0, 1, 0), n.lookAt(1, 0, 0), r.up.set(0, 1, 0), r.lookAt(-1, 0, 0), s.up.set(0, 0, -1), s.lookAt(0, 1, 0), o.up.set(0, 0, 1), o.lookAt(0, -1, 0), a.up.set(0, 1, 0), a.lookAt(0, 0, 1), l.up.set(0, 1, 0), l.lookAt(0, 0, -1);
    else if (e === io)
      n.up.set(0, -1, 0), n.lookAt(-1, 0, 0), r.up.set(0, -1, 0), r.lookAt(1, 0, 0), s.up.set(0, 0, 1), s.lookAt(0, 1, 0), o.up.set(0, 0, -1), o.lookAt(0, -1, 0), a.up.set(0, -1, 0), a.lookAt(0, 0, 1), l.up.set(0, -1, 0), l.lookAt(0, 0, -1);
    else
      throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
    for (const u of t)
      this.add(u), u.updateMatrixWorld();
  }
  /**
   * Calling this method will render the given scene with the given renderer
   * into the cube render target of the camera.
   *
   * @param {(Renderer|WebGLRenderer)} renderer - The renderer.
   * @param {Scene} scene - The scene to render.
   */
  update(e, t) {
    this.parent === null && this.updateMatrixWorld();
    const { renderTarget: n, activeMipmapLevel: r } = this;
    this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem, this.updateCoordinateSystem());
    const [s, o, a, l, u, c] = this.children, A = e.getRenderTarget(), m = e.getActiveCubeFace(), _ = e.getActiveMipmapLevel(), y = e.xr.enabled;
    e.xr.enabled = !1;
    const T = n.texture.generateMipmaps;
    n.texture.generateMipmaps = !1, e.setRenderTarget(n, 0, r), e.render(t, s), e.setRenderTarget(n, 1, r), e.render(t, o), e.setRenderTarget(n, 2, r), e.render(t, a), e.setRenderTarget(n, 3, r), e.render(t, l), e.setRenderTarget(n, 4, r), e.render(t, u), n.texture.generateMipmaps = T, e.setRenderTarget(n, 5, r), e.render(t, c), e.setRenderTarget(A, m, _), e.xr.enabled = y, n.texture.needsPMREMUpdate = !0;
  }
}
class Ju extends Ii {
  /**
   * Constructs a new cube texture.
   *
   * @param {Array<Image>} [images=[]] - An array holding a image for each side of a cube.
   * @param {number} [mapping=CubeReflectionMapping] - The texture mapping.
   * @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.
   * @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.
   * @param {number} [magFilter=LinearFilter] - The mag filter value.
   * @param {number} [minFilter=LinearMipmapLinearFilter] - The min filter value.
   * @param {number} [format=RGBAFormat] - The texture format.
   * @param {number} [type=UnsignedByteType] - The texture type.
   * @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.
   * @param {string} [colorSpace=NoColorSpace] - The color space value.
   */
  constructor(e = [], t = no, n, r, s, o, a, l, u, c) {
    super(e, t, n, r, s, o, a, l, u, c), this.isCubeTexture = !0, this.flipY = !1;
  }
  /**
   * Alias for {@link CubeTexture#image}.
   *
   * @type {Array<Image>}
   */
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
}
class Q_ extends eo {
  /**
   * Constructs a new cube render target.
   *
   * @param {number} [size=1] - The size of the render target.
   * @param {RenderTarget~Options} [options] - The configuration object.
   */
  constructor(e = 1, t = {}) {
    super(e, e, t), this.isWebGLCubeRenderTarget = !0;
    const n = { width: e, height: e, depth: 1 }, r = [n, n, n, n, n, n];
    this.texture = new Ju(r), this._setTextureOptions(t), this.texture.isRenderTargetTexture = !0;
  }
  /**
   * Converts the given equirectangular texture to a cube map.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {Texture} texture - The equirectangular texture.
   * @return {WebGLCubeRenderTarget} A reference to this cube render target.
   */
  fromEquirectangularTexture(e, t) {
    this.texture.type = t.type, this.texture.colorSpace = t.colorSpace, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter;
    const n = {
      uniforms: {
        tEquirect: { value: null }
      },
      vertexShader: (
        /* glsl */
        `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`
      ),
      fragmentShader: (
        /* glsl */
        `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
      )
    }, r = new ul(5, 5, 5), s = new Fr({
      name: "CubemapFromEquirect",
      uniforms: kf(n.uniforms),
      vertexShader: n.vertexShader,
      fragmentShader: n.fragmentShader,
      side: si,
      blending: ms
    });
    s.uniforms.tEquirect.value = t;
    const o = new Tn(r, s), a = t.minFilter;
    return t.minFilter === $r && (t.minFilter = qn), new D3(1, 10, this).update(e, o), t.minFilter = a, o.geometry.dispose(), o.material.dispose(), this;
  }
  /**
   * Clears this cube render target.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {boolean} [color=true] - Whether the color buffer should be cleared or not.
   * @param {boolean} [depth=true] - Whether the depth buffer should be cleared or not.
   * @param {boolean} [stencil=true] - Whether the stencil buffer should be cleared or not.
   */
  clear(e, t = !0, n = !0, r = !0) {
    const s = e.getRenderTarget();
    for (let o = 0; o < 6; o++)
      e.setRenderTarget(this, o), e.clear(t, n, r);
    e.setRenderTarget(s);
  }
}
let As = class extends Vn {
  constructor() {
    super(), this.isGroup = !0, this.type = "Group";
  }
};
const NU = { type: "move" };
class bp {
  /**
   * Constructs a new XR controller.
   */
  constructor() {
    this._targetRay = null, this._grip = null, this._hand = null;
  }
  /**
   * Returns a group representing the hand space of the XR controller.
   *
   * @return {Group} A group representing the hand space of the XR controller.
   */
  getHandSpace() {
    return this._hand === null && (this._hand = new As(), this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = { pinching: !1 }), this._hand;
  }
  /**
   * Returns a group representing the target ray space of the XR controller.
   *
   * @return {Group} A group representing the target ray space of the XR controller.
   */
  getTargetRaySpace() {
    return this._targetRay === null && (this._targetRay = new As(), this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new j(), this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new j()), this._targetRay;
  }
  /**
   * Returns a group representing the grip space of the XR controller.
   *
   * @return {Group} A group representing the grip space of the XR controller.
   */
  getGripSpace() {
    return this._grip === null && (this._grip = new As(), this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new j(), this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new j()), this._grip;
  }
  /**
   * Dispatches the given event to the groups representing
   * the different coordinate spaces of the XR controller.
   *
   * @param {Object} event - The event to dispatch.
   * @return {WebXRController} A reference to this instance.
   */
  dispatchEvent(e) {
    return this._targetRay !== null && this._targetRay.dispatchEvent(e), this._grip !== null && this._grip.dispatchEvent(e), this._hand !== null && this._hand.dispatchEvent(e), this;
  }
  /**
   * Connects the controller with the given XR input source.
   *
   * @param {XRInputSource} inputSource - The input source.
   * @return {WebXRController} A reference to this instance.
   */
  connect(e) {
    if (e && e.hand) {
      const t = this._hand;
      if (t)
        for (const n of e.hand.values())
          this._getHandJoint(t, n);
    }
    return this.dispatchEvent({ type: "connected", data: e }), this;
  }
  /**
   * Disconnects the controller from the given XR input source.
   *
   * @param {XRInputSource} inputSource - The input source.
   * @return {WebXRController} A reference to this instance.
   */
  disconnect(e) {
    return this.dispatchEvent({ type: "disconnected", data: e }), this._targetRay !== null && (this._targetRay.visible = !1), this._grip !== null && (this._grip.visible = !1), this._hand !== null && (this._hand.visible = !1), this;
  }
  /**
   * Updates the controller with the given input source, XR frame and reference space.
   * This updates the transformations of the groups that represent the different
   * coordinate systems of the controller.
   *
   * @param {XRInputSource} inputSource - The input source.
   * @param {XRFrame} frame - The XR frame.
   * @param {XRReferenceSpace} referenceSpace - The reference space.
   * @return {WebXRController} A reference to this instance.
   */
  update(e, t, n) {
    let r = null, s = null, o = null;
    const a = this._targetRay, l = this._grip, u = this._hand;
    if (e && t.session.visibilityState !== "visible-blurred") {
      if (u && e.hand) {
        o = !0;
        for (const T of e.hand.values()) {
          const b = t.getJointPose(T, n), S = this._getHandJoint(u, T);
          b !== null && (S.matrix.fromArray(b.transform.matrix), S.matrix.decompose(S.position, S.rotation, S.scale), S.matrixWorldNeedsUpdate = !0, S.jointRadius = b.radius), S.visible = b !== null;
        }
        const c = u.joints["index-finger-tip"], A = u.joints["thumb-tip"], m = c.position.distanceTo(A.position), _ = 0.02, y = 5e-3;
        u.inputState.pinching && m > _ + y ? (u.inputState.pinching = !1, this.dispatchEvent({
          type: "pinchend",
          handedness: e.handedness,
          target: this
        })) : !u.inputState.pinching && m <= _ - y && (u.inputState.pinching = !0, this.dispatchEvent({
          type: "pinchstart",
          handedness: e.handedness,
          target: this
        }));
      } else
        l !== null && e.gripSpace && (s = t.getPose(e.gripSpace, n), s !== null && (l.matrix.fromArray(s.transform.matrix), l.matrix.decompose(l.position, l.rotation, l.scale), l.matrixWorldNeedsUpdate = !0, s.linearVelocity ? (l.hasLinearVelocity = !0, l.linearVelocity.copy(s.linearVelocity)) : l.hasLinearVelocity = !1, s.angularVelocity ? (l.hasAngularVelocity = !0, l.angularVelocity.copy(s.angularVelocity)) : l.hasAngularVelocity = !1));
      a !== null && (r = t.getPose(e.targetRaySpace, n), r === null && s !== null && (r = s), r !== null && (a.matrix.fromArray(r.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), a.matrixWorldNeedsUpdate = !0, r.linearVelocity ? (a.hasLinearVelocity = !0, a.linearVelocity.copy(r.linearVelocity)) : a.hasLinearVelocity = !1, r.angularVelocity ? (a.hasAngularVelocity = !0, a.angularVelocity.copy(r.angularVelocity)) : a.hasAngularVelocity = !1, this.dispatchEvent(NU)));
    }
    return a !== null && (a.visible = r !== null), l !== null && (l.visible = s !== null), u !== null && (u.visible = o !== null), this;
  }
  /**
   * Returns a group representing the hand joint for the given input joint.
   *
   * @private
   * @param {Group} hand - The group representing the hand space.
   * @param {XRJointSpace} inputjoint - The hand joint data.
   * @return {Group} A group representing the hand joint for the given input joint.
   */
  _getHandJoint(e, t) {
    if (e.joints[t.jointName] === void 0) {
      const n = new As();
      n.matrixAutoUpdate = !1, n.visible = !1, e.joints[t.jointName] = n, e.add(n);
    }
    return e.joints[t.jointName];
  }
}
class K_ {
  /**
   * Constructs a new fog.
   *
   * @param {number|Color} color - The fog's color.
   * @param {number} [density=0.00025] - Defines how fast the fog will grow dense.
   */
  constructor(e, t = 25e-5) {
    this.isFogExp2 = !0, this.name = "", this.color = new ct(e), this.density = t;
  }
  /**
   * Returns a new fog with copied values from this instance.
   *
   * @return {FogExp2} A clone of this instance.
   */
  clone() {
    return new K_(this.color, this.density);
  }
  /**
   * Serializes the fog into JSON.
   *
   * @param {?(Object|string)} meta - An optional value holding meta information about the serialization.
   * @return {Object} A JSON object representing the serialized fog
   */
  toJSON() {
    return {
      type: "FogExp2",
      name: this.name,
      color: this.color.getHex(),
      density: this.density
    };
  }
}
class Z_ {
  /**
   * Constructs a new fog.
   *
   * @param {number|Color} color - The fog's color.
   * @param {number} [near=1] - The minimum distance to start applying fog.
   * @param {number} [far=1000] - The maximum distance at which fog stops being calculated and applied.
   */
  constructor(e, t = 1, n = 1e3) {
    this.isFog = !0, this.name = "", this.color = new ct(e), this.near = t, this.far = n;
  }
  /**
   * Returns a new fog with copied values from this instance.
   *
   * @return {Fog} A clone of this instance.
   */
  clone() {
    return new Z_(this.color, this.near, this.far);
  }
  /**
   * Serializes the fog into JSON.
   *
   * @param {?(Object|string)} meta - An optional value holding meta information about the serialization.
   * @return {Object} A JSON object representing the serialized fog
   */
  toJSON() {
    return {
      type: "Fog",
      name: this.name,
      color: this.color.getHex(),
      near: this.near,
      far: this.far
    };
  }
}
class oA extends Vn {
  /**
   * Constructs a new scene.
   */
  constructor() {
    super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.backgroundRotation = new Ir(), this.environmentIntensity = 1, this.environmentRotation = new Ir(), this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  copy(e, t) {
    return super.copy(e, t), e.background !== null && (this.background = e.background.clone()), e.environment !== null && (this.environment = e.environment.clone()), e.fog !== null && (this.fog = e.fog.clone()), this.backgroundBlurriness = e.backgroundBlurriness, this.backgroundIntensity = e.backgroundIntensity, this.backgroundRotation.copy(e.backgroundRotation), this.environmentIntensity = e.environmentIntensity, this.environmentRotation.copy(e.environmentRotation), e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()), this.matrixAutoUpdate = e.matrixAutoUpdate, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return this.fog !== null && (t.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (t.object.backgroundIntensity = this.backgroundIntensity), t.object.backgroundRotation = this.backgroundRotation.toArray(), this.environmentIntensity !== 1 && (t.object.environmentIntensity = this.environmentIntensity), t.object.environmentRotation = this.environmentRotation.toArray(), t;
  }
}
class aA {
  /**
   * Constructs a new interleaved buffer.
   *
   * @param {TypedArray} array - A typed array with a shared buffer storing attribute data.
   * @param {number} stride - The number of typed-array elements per vertex.
   */
  constructor(e, t) {
    this.isInterleavedBuffer = !0, this.array = e, this.stride = t, this.count = e !== void 0 ? e.length / t : 0, this.usage = Wu, this.updateRanges = [], this.version = 0, this.uuid = To();
  }
  /**
   * A callback function that is executed after the renderer has transferred the attribute array
   * data to the GPU.
   */
  onUploadCallback() {
  }
  /**
   * Flag to indicate that this attribute has changed and should be re-sent to
   * the GPU. Set this to `true` when you modify the value of the array.
   *
   * @type {number}
   * @default false
   * @param {boolean} value
   */
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  /**
   * Sets the usage of this interleaved buffer.
   *
   * @param {(StaticDrawUsage|DynamicDrawUsage|StreamDrawUsage|StaticReadUsage|DynamicReadUsage|StreamReadUsage|StaticCopyUsage|DynamicCopyUsage|StreamCopyUsage)} value - The usage to set.
   * @return {InterleavedBuffer} A reference to this interleaved buffer.
   */
  setUsage(e) {
    return this.usage = e, this;
  }
  /**
   * Adds a range of data in the data array to be updated on the GPU.
   *
   * @param {number} start - Position at which to start update.
   * @param {number} count - The number of components to update.
   */
  addUpdateRange(e, t) {
    this.updateRanges.push({ start: e, count: t });
  }
  /**
   * Clears the update ranges.
   */
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  /**
   * Copies the values of the given interleaved buffer to this instance.
   *
   * @param {InterleavedBuffer} source - The interleaved buffer to copy.
   * @return {InterleavedBuffer} A reference to this instance.
   */
  copy(e) {
    return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this;
  }
  /**
   * Copies a vector from the given interleaved buffer to this one. The start
   * and destination position in the attribute buffers are represented by the
   * given indices.
   *
   * @param {number} index1 - The destination index into this interleaved buffer.
   * @param {InterleavedBuffer} interleavedBuffer - The interleaved buffer to copy from.
   * @param {number} index2 - The source index into the given interleaved buffer.
   * @return {InterleavedBuffer} A reference to this instance.
   */
  copyAt(e, t, n) {
    e *= this.stride, n *= t.stride;
    for (let r = 0, s = this.stride; r < s; r++)
      this.array[e + r] = t.array[n + r];
    return this;
  }
  /**
   * Sets the given array data in the interleaved buffer.
   *
   * @param {(TypedArray|Array)} value - The array data to set.
   * @param {number} [offset=0] - The offset in this interleaved buffer's array.
   * @return {InterleavedBuffer} A reference to this instance.
   */
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  /**
   * Returns a new interleaved buffer with copied values from this instance.
   *
   * @param {Object} [data] - An object with shared array buffers that allows to retain shared structures.
   * @return {InterleavedBuffer} A clone of this instance.
   */
  clone(e) {
    e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = To()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]), n = new this.constructor(t, this.stride);
    return n.setUsage(this.usage), n;
  }
  /**
   * Sets the given callback function that is executed after the Renderer has transferred
   * the array data to the GPU. Can be used to perform clean-up operations after
   * the upload when data are not needed anymore on the CPU side.
   *
   * @param {Function} callback - The `onUpload()` callback.
   * @return {InterleavedBuffer} A reference to this instance.
   */
  onUpload(e) {
    return this.onUploadCallback = e, this;
  }
  /**
   * Serializes the interleaved buffer into JSON.
   *
   * @param {Object} [data] - An optional value holding meta information about the serialization.
   * @return {Object} A JSON object representing the serialized interleaved buffer.
   */
  toJSON(e) {
    return e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = To()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), {
      uuid: this.uuid,
      buffer: this.array.buffer._uuid,
      type: this.array.constructor.name,
      stride: this.stride
    };
  }
}
const Ss = /* @__PURE__ */ new j();
class Bs {
  /**
   * Constructs a new interleaved buffer attribute.
   *
   * @param {InterleavedBuffer} interleavedBuffer - The buffer holding the interleaved data.
   * @param {number} itemSize - The item size.
   * @param {number} offset - The attribute offset into the buffer.
   * @param {boolean} [normalized=false] - Whether the data are normalized or not.
   */
  constructor(e, t, n, r = !1) {
    this.isInterleavedBufferAttribute = !0, this.name = "", this.data = e, this.itemSize = t, this.offset = n, this.normalized = r;
  }
  /**
   * The item count of this buffer attribute.
   *
   * @type {number}
   * @readonly
   */
  get count() {
    return this.data.count;
  }
  /**
   * The array holding the interleaved buffer attribute data.
   *
   * @type {TypedArray}
   */
  get array() {
    return this.data.array;
  }
  /**
   * Flag to indicate that this attribute has changed and should be re-sent to
   * the GPU. Set this to `true` when you modify the value of the array.
   *
   * @type {number}
   * @default false
   * @param {boolean} value
   */
  set needsUpdate(e) {
    this.data.needsUpdate = e;
  }
  /**
   * Applies the given 4x4 matrix to the given attribute. Only works with
   * item size `3`.
   *
   * @param {Matrix4} m - The matrix to apply.
   * @return {InterleavedBufferAttribute} A reference to this instance.
   */
  applyMatrix4(e) {
    for (let t = 0, n = this.data.count; t < n; t++)
      Ss.fromBufferAttribute(this, t), Ss.applyMatrix4(e), this.setXYZ(t, Ss.x, Ss.y, Ss.z);
    return this;
  }
  /**
   * Applies the given 3x3 normal matrix to the given attribute. Only works with
   * item size `3`.
   *
   * @param {Matrix3} m - The normal matrix to apply.
   * @return {InterleavedBufferAttribute} A reference to this instance.
   */
  applyNormalMatrix(e) {
    for (let t = 0, n = this.count; t < n; t++)
      Ss.fromBufferAttribute(this, t), Ss.applyNormalMatrix(e), this.setXYZ(t, Ss.x, Ss.y, Ss.z);
    return this;
  }
  /**
   * Applies the given 4x4 matrix to the given attribute. Only works with
   * item size `3` and with direction vectors.
   *
   * @param {Matrix4} m - The matrix to apply.
   * @return {InterleavedBufferAttribute} A reference to this instance.
   */
  transformDirection(e) {
    for (let t = 0, n = this.count; t < n; t++)
      Ss.fromBufferAttribute(this, t), Ss.transformDirection(e), this.setXYZ(t, Ss.x, Ss.y, Ss.z);
    return this;
  }
  /**
   * Returns the given component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} component - The component index.
   * @return {number} The returned value.
   */
  getComponent(e, t) {
    let n = this.array[e * this.data.stride + this.offset + t];
    return this.normalized && (n = Ls(n, this.array)), n;
  }
  /**
   * Sets the given value to the given component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} component - The component index.
   * @param {number} value - The value to set.
   * @return {InterleavedBufferAttribute} A reference to this instance.
   */
  setComponent(e, t, n) {
    return this.normalized && (n = En(n, this.array)), this.data.array[e * this.data.stride + this.offset + t] = n, this;
  }
  /**
   * Sets the x component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} x - The value to set.
   * @return {InterleavedBufferAttribute} A reference to this instance.
   */
  setX(e, t) {
    return this.normalized && (t = En(t, this.array)), this.data.array[e * this.data.stride + this.offset] = t, this;
  }
  /**
   * Sets the y component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} y - The value to set.
   * @return {InterleavedBufferAttribute} A reference to this instance.
   */
  setY(e, t) {
    return this.normalized && (t = En(t, this.array)), this.data.array[e * this.data.stride + this.offset + 1] = t, this;
  }
  /**
   * Sets the z component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} z - The value to set.
   * @return {InterleavedBufferAttribute} A reference to this instance.
   */
  setZ(e, t) {
    return this.normalized && (t = En(t, this.array)), this.data.array[e * this.data.stride + this.offset + 2] = t, this;
  }
  /**
   * Sets the w component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} w - The value to set.
   * @return {InterleavedBufferAttribute} A reference to this instance.
   */
  setW(e, t) {
    return this.normalized && (t = En(t, this.array)), this.data.array[e * this.data.stride + this.offset + 3] = t, this;
  }
  /**
   * Returns the x component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @return {number} The x component.
   */
  getX(e) {
    let t = this.data.array[e * this.data.stride + this.offset];
    return this.normalized && (t = Ls(t, this.array)), t;
  }
  /**
   * Returns the y component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @return {number} The y component.
   */
  getY(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 1];
    return this.normalized && (t = Ls(t, this.array)), t;
  }
  /**
   * Returns the z component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @return {number} The z component.
   */
  getZ(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 2];
    return this.normalized && (t = Ls(t, this.array)), t;
  }
  /**
   * Returns the w component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @return {number} The w component.
   */
  getW(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 3];
    return this.normalized && (t = Ls(t, this.array)), t;
  }
  /**
   * Sets the x and y component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} x - The value for the x component to set.
   * @param {number} y - The value for the y component to set.
   * @return {InterleavedBufferAttribute} A reference to this instance.
   */
  setXY(e, t, n) {
    return e = e * this.data.stride + this.offset, this.normalized && (t = En(t, this.array), n = En(n, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this;
  }
  /**
   * Sets the x, y and z component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} x - The value for the x component to set.
   * @param {number} y - The value for the y component to set.
   * @param {number} z - The value for the z component to set.
   * @return {InterleavedBufferAttribute} A reference to this instance.
   */
  setXYZ(e, t, n, r) {
    return e = e * this.data.stride + this.offset, this.normalized && (t = En(t, this.array), n = En(n, this.array), r = En(r, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = r, this;
  }
  /**
   * Sets the x, y, z and w component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} x - The value for the x component to set.
   * @param {number} y - The value for the y component to set.
   * @param {number} z - The value for the z component to set.
   * @param {number} w - The value for the w component to set.
   * @return {InterleavedBufferAttribute} A reference to this instance.
   */
  setXYZW(e, t, n, r, s) {
    return e = e * this.data.stride + this.offset, this.normalized && (t = En(t, this.array), n = En(n, this.array), r = En(r, this.array), s = En(s, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = r, this.data.array[e + 3] = s, this;
  }
  /**
   * Returns a new buffer attribute with copied values from this instance.
   *
   * If no parameter is provided, cloning an interleaved buffer attribute will de-interleave buffer data.
   *
   * @param {Object} [data] - An object with interleaved buffers that allows to retain the interleaved property.
   * @return {BufferAttribute|InterleavedBufferAttribute} A clone of this instance.
   */
  clone(e) {
    if (e === void 0) {
      Of("InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
      const t = [];
      for (let n = 0; n < this.count; n++) {
        const r = n * this.data.stride + this.offset;
        for (let s = 0; s < this.itemSize; s++)
          t.push(this.data.array[r + s]);
      }
      return new Dn(new this.array.constructor(t), this.itemSize, this.normalized);
    } else
      return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new Bs(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
  }
  /**
   * Serializes the buffer attribute into JSON.
   *
   * If no parameter is provided, cloning an interleaved buffer attribute will de-interleave buffer data.
   *
   * @param {Object} [data] - An optional value holding meta information about the serialization.
   * @return {Object} A JSON object representing the serialized buffer attribute.
   */
  toJSON(e) {
    if (e === void 0) {
      Of("InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
      const t = [];
      for (let n = 0; n < this.count; n++) {
        const r = n * this.data.stride + this.offset;
        for (let s = 0; s < this.itemSize; s++)
          t.push(this.data.array[r + s]);
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: t,
        normalized: this.normalized
      };
    } else
      return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), {
        isInterleavedBufferAttribute: !0,
        itemSize: this.itemSize,
        data: this.data.uuid,
        offset: this.offset,
        normalized: this.normalized
      };
  }
}
class J_ extends Br {
  /**
   * Constructs a new sprite material.
   *
   * @param {Object} [parameters] - An object with one or more properties
   * defining the material's appearance. Any property of the material
   * (including any property from inherited materials) can be passed
   * in here. Color values can be passed any type of value accepted
   * by {@link Color#set}.
   */
  constructor(e) {
    super(), this.isSpriteMaterial = !0, this.type = "SpriteMaterial", this.color = new ct(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this;
  }
}
let Cd;
const CA = /* @__PURE__ */ new j(), Pd = /* @__PURE__ */ new j(), Nd = /* @__PURE__ */ new j(), Dd = /* @__PURE__ */ new Le(), PA = /* @__PURE__ */ new Le(), j5 = /* @__PURE__ */ new Mt(), ym = /* @__PURE__ */ new j(), NA = /* @__PURE__ */ new j(), vm = /* @__PURE__ */ new j(), CM = /* @__PURE__ */ new Le(), oy = /* @__PURE__ */ new Le(), PM = /* @__PURE__ */ new Le();
class X5 extends Vn {
  /**
   * Constructs a new sprite.
   *
   * @param {(SpriteMaterial|SpriteNodeMaterial)} [material] - The sprite material.
   */
  constructor(e = new J_()) {
    if (super(), this.isSprite = !0, this.type = "Sprite", Cd === void 0) {
      Cd = new Yt();
      const t = new Float32Array([
        -0.5,
        -0.5,
        0,
        0,
        0,
        0.5,
        -0.5,
        0,
        1,
        0,
        0.5,
        0.5,
        0,
        1,
        1,
        -0.5,
        0.5,
        0,
        0,
        1
      ]), n = new aA(t, 5);
      Cd.setIndex([0, 1, 2, 0, 2, 3]), Cd.setAttribute("position", new Bs(n, 3, 0, !1)), Cd.setAttribute("uv", new Bs(n, 2, 3, !1));
    }
    this.geometry = Cd, this.material = e, this.center = new Le(0.5, 0.5), this.count = 1;
  }
  /**
   * Computes intersection points between a casted ray and this sprite.
   *
   * @param {Raycaster} raycaster - The raycaster.
   * @param {Array<Object>} intersects - The target array that holds the intersection points.
   */
  raycast(e, t) {
    e.camera === null && Ie('Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), Pd.setFromMatrixScale(this.matrixWorld), j5.copy(e.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld), Nd.setFromMatrixPosition(this.modelViewMatrix), e.camera.isPerspectiveCamera && this.material.sizeAttenuation === !1 && Pd.multiplyScalar(-Nd.z);
    const n = this.material.rotation;
    let r, s;
    n !== 0 && (s = Math.cos(n), r = Math.sin(n));
    const o = this.center;
    bm(ym.set(-0.5, -0.5, 0), Nd, o, Pd, r, s), bm(NA.set(0.5, -0.5, 0), Nd, o, Pd, r, s), bm(vm.set(0.5, 0.5, 0), Nd, o, Pd, r, s), CM.set(0, 0), oy.set(1, 0), PM.set(1, 1);
    let a = e.ray.intersectTriangle(ym, NA, vm, !1, CA);
    if (a === null && (bm(NA.set(-0.5, 0.5, 0), Nd, o, Pd, r, s), oy.set(0, 1), a = e.ray.intersectTriangle(ym, vm, NA, !1, CA), a === null))
      return;
    const l = e.ray.origin.distanceTo(CA);
    l < e.near || l > e.far || t.push({
      distance: l,
      point: CA.clone(),
      uv: $s.getInterpolation(CA, ym, NA, vm, CM, oy, PM, new Le()),
      face: null,
      object: this
    });
  }
  copy(e, t) {
    return super.copy(e, t), e.center !== void 0 && this.center.copy(e.center), this.material = e.material, this;
  }
}
function bm(i, e, t, n, r, s) {
  Dd.subVectors(i, t).addScalar(0.5).multiply(n), r !== void 0 ? (PA.x = s * Dd.x - r * Dd.y, PA.y = r * Dd.x + s * Dd.y) : PA.copy(Dd), i.copy(e), i.x += PA.x, i.y += PA.y, i.applyMatrix4(j5);
}
const Sm = /* @__PURE__ */ new j(), NM = /* @__PURE__ */ new j();
class Y5 extends Vn {
  /**
   * Constructs a new LOD.
   */
  constructor() {
    super(), this.isLOD = !0, this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, {
      /**
       * This array holds the LOD levels.
       *
       * @name LOD#levels
       * @type {Array<{object:Object3D,distance:number,hysteresis:number}>}
       */
      levels: {
        enumerable: !0,
        value: []
      }
    }), this.autoUpdate = !0;
  }
  copy(e) {
    super.copy(e, !1);
    const t = e.levels;
    for (let n = 0, r = t.length; n < r; n++) {
      const s = t[n];
      this.addLevel(s.object.clone(), s.distance, s.hysteresis);
    }
    return this.autoUpdate = e.autoUpdate, this;
  }
  /**
   * Adds a mesh that will display at a certain distance and greater. Typically
   * the further away the distance, the lower the detail on the mesh.
   *
   * @param {Object3D} object - The 3D object to display at this level.
   * @param {number} [distance=0] - The distance at which to display this level of detail.
   * @param {number} [hysteresis=0] - Threshold used to avoid flickering at LOD boundaries, as a fraction of distance.
   * @return {LOD} A reference to this instance.
   */
  addLevel(e, t = 0, n = 0) {
    t = Math.abs(t);
    const r = this.levels;
    let s;
    for (s = 0; s < r.length && !(t < r[s].distance); s++)
      ;
    return r.splice(s, 0, { distance: t, hysteresis: n, object: e }), this.add(e), this;
  }
  /**
   * Removes an existing level, based on the distance from the camera.
   * Returns `true` when the level has been removed. Otherwise `false`.
   *
   * @param {number} distance - Distance of the level to remove.
   * @return {boolean} Whether the level has been removed or not.
   */
  removeLevel(e) {
    const t = this.levels;
    for (let n = 0; n < t.length; n++)
      if (t[n].distance === e) {
        const r = t.splice(n, 1);
        return this.remove(r[0].object), !0;
      }
    return !1;
  }
  /**
   * Returns the currently active LOD level index.
   *
   * @return {number} The current active LOD level index.
   */
  getCurrentLevel() {
    return this._currentLevel;
  }
  /**
   * Returns a reference to the first 3D object that is greater than
   * the given distance.
   *
   * @param {number} distance - The LOD distance.
   * @return {?Object3D} The found 3D object. `null` if no 3D object has been found.
   */
  getObjectForDistance(e) {
    const t = this.levels;
    if (t.length > 0) {
      let n, r;
      for (n = 1, r = t.length; n < r; n++) {
        let s = t[n].distance;
        if (t[n].object.visible && (s -= s * t[n].hysteresis), e < s)
          break;
      }
      return t[n - 1].object;
    }
    return null;
  }
  /**
   * Computes intersection points between a casted ray and this LOD.
   *
   * @param {Raycaster} raycaster - The raycaster.
   * @param {Array<Object>} intersects - The target array that holds the intersection points.
   */
  raycast(e, t) {
    if (this.levels.length > 0) {
      Sm.setFromMatrixPosition(this.matrixWorld);
      const r = e.ray.origin.distanceTo(Sm);
      this.getObjectForDistance(r).raycast(e, t);
    }
  }
  /**
   * Updates the LOD by computing which LOD level should be visible according
   * to the current distance of the given camera.
   *
   * @param {Camera} camera - The camera the scene is rendered with.
   */
  update(e) {
    const t = this.levels;
    if (t.length > 1) {
      Sm.setFromMatrixPosition(e.matrixWorld), NM.setFromMatrixPosition(this.matrixWorld);
      const n = Sm.distanceTo(NM) / e.zoom;
      t[0].object.visible = !0;
      let r, s;
      for (r = 1, s = t.length; r < s; r++) {
        let o = t[r].distance;
        if (t[r].object.visible && (o -= o * t[r].hysteresis), n >= o)
          t[r - 1].object.visible = !1, t[r].object.visible = !0;
        else
          break;
      }
      for (this._currentLevel = r - 1; r < s; r++)
        t[r].object.visible = !1;
    }
  }
  toJSON(e) {
    const t = super.toJSON(e);
    this.autoUpdate === !1 && (t.object.autoUpdate = !1), t.object.levels = [];
    const n = this.levels;
    for (let r = 0, s = n.length; r < s; r++) {
      const o = n[r];
      t.object.levels.push({
        object: o.object.uuid,
        distance: o.distance,
        hysteresis: o.hysteresis
      });
    }
    return t;
  }
}
const DM = /* @__PURE__ */ new j(), LM = /* @__PURE__ */ new Kt(), IM = /* @__PURE__ */ new Kt(), DU = /* @__PURE__ */ new j(), BM = /* @__PURE__ */ new Mt(), Tm = /* @__PURE__ */ new j(), ay = /* @__PURE__ */ new fr(), FM = /* @__PURE__ */ new Mt(), ly = /* @__PURE__ */ new Zh();
class Q5 extends Tn {
  /**
   * Constructs a new skinned mesh.
   *
   * @param {BufferGeometry} [geometry] - The mesh geometry.
   * @param {Material|Array<Material>} [material] - The mesh material.
   */
  constructor(e, t) {
    super(e, t), this.isSkinnedMesh = !0, this.type = "SkinnedMesh", this.bindMode = Bv, this.bindMatrix = new Mt(), this.bindMatrixInverse = new Mt(), this.boundingBox = null, this.boundingSphere = null;
  }
  /**
   * Computes the bounding box of the skinned mesh, and updates {@link SkinnedMesh#boundingBox}.
   * The bounding box is not automatically computed by the engine; this method must be called by your app.
   * If the skinned mesh is animated, the bounding box should be recomputed per frame in order to reflect
   * the current animation state.
   */
  computeBoundingBox() {
    const e = this.geometry;
    this.boundingBox === null && (this.boundingBox = new dr()), this.boundingBox.makeEmpty();
    const t = e.getAttribute("position");
    for (let n = 0; n < t.count; n++)
      this.getVertexPosition(n, Tm), this.boundingBox.expandByPoint(Tm);
  }
  /**
   * Computes the bounding sphere of the skinned mesh, and updates {@link SkinnedMesh#boundingSphere}.
   * The bounding sphere is automatically computed by the engine once when it is needed, e.g., for ray casting
   * and view frustum culling. If the skinned mesh is animated, the bounding sphere should be recomputed
   * per frame in order to reflect the current animation state.
   */
  computeBoundingSphere() {
    const e = this.geometry;
    this.boundingSphere === null && (this.boundingSphere = new fr()), this.boundingSphere.makeEmpty();
    const t = e.getAttribute("position");
    for (let n = 0; n < t.count; n++)
      this.getVertexPosition(n, Tm), this.boundingSphere.expandByPoint(Tm);
  }
  copy(e, t) {
    return super.copy(e, t), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this;
  }
  raycast(e, t) {
    const n = this.material, r = this.matrixWorld;
    n !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), ay.copy(this.boundingSphere), ay.applyMatrix4(r), e.ray.intersectsSphere(ay) !== !1 && (FM.copy(r).invert(), ly.copy(e.ray).applyMatrix4(FM), !(this.boundingBox !== null && ly.intersectsBox(this.boundingBox) === !1) && this._computeIntersections(e, t, ly)));
  }
  getVertexPosition(e, t) {
    return super.getVertexPosition(e, t), this.applyBoneTransform(e, t), t;
  }
  /**
   * Binds the given skeleton to the skinned mesh.
   *
   * @param {Skeleton} skeleton - The skeleton to bind.
   * @param {Matrix4} [bindMatrix] - The bind matrix. If no bind matrix is provided,
   * the skinned mesh's world matrix will be used instead.
   */
  bind(e, t) {
    this.skeleton = e, t === void 0 && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.copy(t).invert();
  }
  /**
   * This method sets the skinned mesh in the rest pose).
   */
  pose() {
    this.skeleton.pose();
  }
  /**
   * Normalizes the skin weights which are defined as a buffer attribute
   * in the skinned mesh's geometry.
   */
  normalizeSkinWeights() {
    const e = new Kt(), t = this.geometry.attributes.skinWeight;
    for (let n = 0, r = t.count; n < r; n++) {
      e.fromBufferAttribute(t, n);
      const s = 1 / e.manhattanLength();
      s !== 1 / 0 ? e.multiplyScalar(s) : e.set(1, 0, 0, 0), t.setXYZW(n, e.x, e.y, e.z, e.w);
    }
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.bindMode === Bv ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === y5 ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : Me("SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
  }
  /**
   * Applies the bone transform associated with the given index to the given
   * vertex position. Returns the updated vector.
   *
   * @param {number} index - The vertex index.
   * @param {Vector3} target - The target object that is used to store the method's result.
   * the skinned mesh's world matrix will be used instead.
   * @return {Vector3} The updated vertex position.
   */
  applyBoneTransform(e, t) {
    const n = this.skeleton, r = this.geometry;
    LM.fromBufferAttribute(r.attributes.skinIndex, e), IM.fromBufferAttribute(r.attributes.skinWeight, e), DM.copy(t).applyMatrix4(this.bindMatrix), t.set(0, 0, 0);
    for (let s = 0; s < 4; s++) {
      const o = IM.getComponent(s);
      if (o !== 0) {
        const a = LM.getComponent(s);
        BM.multiplyMatrices(n.bones[a].matrixWorld, n.boneInverses[a]), t.addScaledVector(DU.copy(DM).applyMatrix4(BM), o);
      }
    }
    return t.applyMatrix4(this.bindMatrixInverse);
  }
}
class L3 extends Vn {
  /**
   * Constructs a new bone.
   */
  constructor() {
    super(), this.isBone = !0, this.type = "Bone";
  }
}
class wo extends Ii {
  /**
   * Constructs a new data texture.
   *
   * @param {?TypedArray} [data=null] - The buffer data.
   * @param {number} [width=1] - The width of the texture.
   * @param {number} [height=1] - The height of the texture.
   * @param {number} [format=RGBAFormat] - The texture format.
   * @param {number} [type=UnsignedByteType] - The texture type.
   * @param {number} [mapping=Texture.DEFAULT_MAPPING] - The texture mapping.
   * @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.
   * @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.
   * @param {number} [magFilter=NearestFilter] - The mag filter value.
   * @param {number} [minFilter=NearestFilter] - The min filter value.
   * @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.
   * @param {string} [colorSpace=NoColorSpace] - The color space.
   */
  constructor(e = null, t = 1, n = 1, r, s, o, a, l, u = ei, c = ei, A, m) {
    super(null, o, a, l, u, c, r, s, A, m), this.isDataTexture = !0, this.image = { data: e, width: t, height: n }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
const UM = /* @__PURE__ */ new Mt(), LU = /* @__PURE__ */ new Mt();
class e2 {
  /**
   * Constructs a new skeleton.
   *
   * @param {Array<Bone>} [bones] - An array of bones.
   * @param {Array<Matrix4>} [boneInverses] - An array of bone inverse matrices.
   * If not provided, these matrices will be computed automatically via {@link Skeleton#calculateInverses}.
   */
  constructor(e = [], t = []) {
    this.uuid = To(), this.bones = e.slice(0), this.boneInverses = t, this.boneMatrices = null, this.previousBoneMatrices = null, this.boneTexture = null, this.init();
  }
  /**
   * Initializes the skeleton. This method gets automatically called by the constructor
   * but depending on how the skeleton is created it might be necessary to call this method
   * manually.
   */
  init() {
    const e = this.bones, t = this.boneInverses;
    if (this.boneMatrices = new Float32Array(e.length * 16), t.length === 0)
      this.calculateInverses();
    else if (e.length !== t.length) {
      Me("Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
      for (let n = 0, r = this.bones.length; n < r; n++)
        this.boneInverses.push(new Mt());
    }
  }
  /**
   * Computes the bone inverse matrices. This method resets {@link Skeleton#boneInverses}
   * and fills it with new matrices.
   */
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const n = new Mt();
      this.bones[e] && n.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(n);
    }
  }
  /**
   * Resets the skeleton to the base pose.
   */
  pose() {
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const n = this.bones[e];
      n && n.matrixWorld.copy(this.boneInverses[e]).invert();
    }
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const n = this.bones[e];
      n && (n.parent && n.parent.isBone ? (n.matrix.copy(n.parent.matrixWorld).invert(), n.matrix.multiply(n.matrixWorld)) : n.matrix.copy(n.matrixWorld), n.matrix.decompose(n.position, n.quaternion, n.scale));
    }
  }
  /**
   * Resets the skeleton to the base pose.
   */
  update() {
    const e = this.bones, t = this.boneInverses, n = this.boneMatrices, r = this.boneTexture;
    for (let s = 0, o = e.length; s < o; s++) {
      const a = e[s] ? e[s].matrixWorld : LU;
      UM.multiplyMatrices(a, t[s]), UM.toArray(n, s * 16);
    }
    r !== null && (r.needsUpdate = !0);
  }
  /**
   * Returns a new skeleton with copied values from this instance.
   *
   * @return {Skeleton} A clone of this instance.
   */
  clone() {
    return new e2(this.bones, this.boneInverses);
  }
  /**
   * Computes a data texture for passing bone data to the vertex shader.
   *
   * @return {Skeleton} A reference of this instance.
   */
  computeBoneTexture() {
    let e = Math.sqrt(this.bones.length * 4);
    e = Math.ceil(e / 4) * 4, e = Math.max(e, 4);
    const t = new Float32Array(e * e * 4);
    t.set(this.boneMatrices);
    const n = new wo(t, e, e, Pi, Ei);
    return n.needsUpdate = !0, this.boneMatrices = t, this.boneTexture = n, this;
  }
  /**
   * Searches through the skeleton's bone array and returns the first with a
   * matching name.
   *
   * @param {string} name - The name of the bone.
   * @return {Bone|undefined} The found bone. `undefined` if no bone has been found.
   */
  getBoneByName(e) {
    for (let t = 0, n = this.bones.length; t < n; t++) {
      const r = this.bones[t];
      if (r.name === e)
        return r;
    }
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   */
  dispose() {
    this.boneTexture !== null && (this.boneTexture.dispose(), this.boneTexture = null);
  }
  /**
   * Setups the skeleton by the given JSON and bones.
   *
   * @param {Object} json - The skeleton as serialized JSON.
   * @param {Object<string, Bone>} bones - An array of bones.
   * @return {Skeleton} A reference of this instance.
   */
  fromJSON(e, t) {
    this.uuid = e.uuid;
    for (let n = 0, r = e.bones.length; n < r; n++) {
      const s = e.bones[n];
      let o = t[s];
      o === void 0 && (Me("Skeleton: No bone found with UUID:", s), o = new L3()), this.bones.push(o), this.boneInverses.push(new Mt().fromArray(e.boneInverses[n]));
    }
    return this.init(), this;
  }
  /**
   * Serializes the skeleton into JSON.
   *
   * @return {Object} A JSON object representing the serialized skeleton.
   * @see {@link ObjectLoader#parse}
   */
  toJSON() {
    const e = {
      metadata: {
        version: 4.7,
        type: "Skeleton",
        generator: "Skeleton.toJSON"
      },
      bones: [],
      boneInverses: []
    };
    e.uuid = this.uuid;
    const t = this.bones, n = this.boneInverses;
    for (let r = 0, s = t.length; r < s; r++) {
      const o = t[r];
      e.bones.push(o.uuid);
      const a = n[r];
      e.boneInverses.push(a.toArray());
    }
    return e;
  }
}
class to extends Dn {
  /**
   * Constructs a new instanced buffer attribute.
   *
   * @param {TypedArray} array - The array holding the attribute data.
   * @param {number} itemSize - The item size.
   * @param {boolean} [normalized=false] - Whether the data are normalized or not.
   * @param {number} [meshPerAttribute=1] - How often a value of this buffer attribute should be repeated.
   */
  constructor(e, t, n, r = 1) {
    super(e, t, n), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = r;
  }
  copy(e) {
    return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e;
  }
}
const Ld = /* @__PURE__ */ new Mt(), OM = /* @__PURE__ */ new Mt(), wm = [], kM = /* @__PURE__ */ new dr(), IU = /* @__PURE__ */ new Mt(), DA = /* @__PURE__ */ new Tn(), LA = /* @__PURE__ */ new fr();
class K5 extends Tn {
  /**
   * Constructs a new instanced mesh.
   *
   * @param {BufferGeometry} [geometry] - The mesh geometry.
   * @param {Material|Array<Material>} [material] - The mesh material.
   * @param {number} count - The number of instances.
   */
  constructor(e, t, n) {
    super(e, t), this.isInstancedMesh = !0, this.instanceMatrix = new to(new Float32Array(n * 16), 16), this.instanceColor = null, this.morphTexture = null, this.count = n, this.boundingBox = null, this.boundingSphere = null;
    for (let r = 0; r < n; r++)
      this.setMatrixAt(r, IU);
  }
  /**
   * Computes the bounding box of the instanced mesh, and updates {@link InstancedMesh#boundingBox}.
   * The bounding box is not automatically computed by the engine; this method must be called by your app.
   * You may need to recompute the bounding box if an instance is transformed via {@link InstancedMesh#setMatrixAt}.
   */
  computeBoundingBox() {
    const e = this.geometry, t = this.count;
    this.boundingBox === null && (this.boundingBox = new dr()), e.boundingBox === null && e.computeBoundingBox(), this.boundingBox.makeEmpty();
    for (let n = 0; n < t; n++)
      this.getMatrixAt(n, Ld), kM.copy(e.boundingBox).applyMatrix4(Ld), this.boundingBox.union(kM);
  }
  /**
   * Computes the bounding sphere of the instanced mesh, and updates {@link InstancedMesh#boundingSphere}
   * The engine automatically computes the bounding sphere when it is needed, e.g., for ray casting or view frustum culling.
   * You may need to recompute the bounding sphere if an instance is transformed via {@link InstancedMesh#setMatrixAt}.
   */
  computeBoundingSphere() {
    const e = this.geometry, t = this.count;
    this.boundingSphere === null && (this.boundingSphere = new fr()), e.boundingSphere === null && e.computeBoundingSphere(), this.boundingSphere.makeEmpty();
    for (let n = 0; n < t; n++)
      this.getMatrixAt(n, Ld), LA.copy(e.boundingSphere).applyMatrix4(Ld), this.boundingSphere.union(LA);
  }
  copy(e, t) {
    return super.copy(e, t), this.instanceMatrix.copy(e.instanceMatrix), e.morphTexture !== null && (this.morphTexture = e.morphTexture.clone()), e.instanceColor !== null && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this;
  }
  /**
   * Gets the color of the defined instance.
   *
   * @param {number} index - The instance index.
   * @param {Color} color - The target object that is used to store the method's result.
   */
  getColorAt(e, t) {
    t.fromArray(this.instanceColor.array, e * 3);
  }
  /**
   * Gets the local transformation matrix of the defined instance.
   *
   * @param {number} index - The instance index.
   * @param {Matrix4} matrix - The target object that is used to store the method's result.
   */
  getMatrixAt(e, t) {
    t.fromArray(this.instanceMatrix.array, e * 16);
  }
  /**
   * Gets the morph target weights of the defined instance.
   *
   * @param {number} index - The instance index.
   * @param {Mesh} object - The target object that is used to store the method's result.
   */
  getMorphAt(e, t) {
    const n = t.morphTargetInfluences, r = this.morphTexture.source.data.data, s = n.length + 1, o = e * s + 1;
    for (let a = 0; a < n.length; a++)
      n[a] = r[o + a];
  }
  raycast(e, t) {
    const n = this.matrixWorld, r = this.count;
    if (DA.geometry = this.geometry, DA.material = this.material, DA.material !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), LA.copy(this.boundingSphere), LA.applyMatrix4(n), e.ray.intersectsSphere(LA) !== !1))
      for (let s = 0; s < r; s++) {
        this.getMatrixAt(s, Ld), OM.multiplyMatrices(n, Ld), DA.matrixWorld = OM, DA.raycast(e, wm);
        for (let o = 0, a = wm.length; o < a; o++) {
          const l = wm[o];
          l.instanceId = s, l.object = this, t.push(l);
        }
        wm.length = 0;
      }
  }
  /**
   * Sets the given color to the defined instance. Make sure you set the `needsUpdate` flag of
   * {@link InstancedMesh#instanceColor} to `true` after updating all the colors.
   *
   * @param {number} index - The instance index.
   * @param {Color} color - The instance color.
   */
  setColorAt(e, t) {
    this.instanceColor === null && (this.instanceColor = new to(new Float32Array(this.instanceMatrix.count * 3).fill(1), 3)), t.toArray(this.instanceColor.array, e * 3);
  }
  /**
   * Sets the given local transformation matrix to the defined instance. Make sure you set the `needsUpdate` flag of
   * {@link InstancedMesh#instanceMatrix} to `true` after updating all the colors.
   *
   * @param {number} index - The instance index.
   * @param {Matrix4} matrix - The local transformation.
   */
  setMatrixAt(e, t) {
    t.toArray(this.instanceMatrix.array, e * 16);
  }
  /**
   * Sets the morph target weights to the defined instance. Make sure you set the `needsUpdate` flag of
   * {@link InstancedMesh#morphTexture} to `true` after updating all the influences.
   *
   * @param {number} index - The instance index.
   * @param {Mesh} object -  A mesh which `morphTargetInfluences` property containing the morph target weights
   * of a single instance.
   */
  setMorphAt(e, t) {
    const n = t.morphTargetInfluences, r = n.length + 1;
    this.morphTexture === null && (this.morphTexture = new wo(new Float32Array(r * this.count), r, this.count, Yh, Ei));
    const s = this.morphTexture.source.data.data;
    let o = 0;
    for (let u = 0; u < n.length; u++)
      o += n[u];
    const a = this.geometry.morphTargetsRelative ? 1 : 1 - o, l = r * e;
    s[l] = a, s.set(n, l + 1);
  }
  updateMorphTargets() {
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   */
  dispose() {
    this.dispatchEvent({ type: "dispose" }), this.morphTexture !== null && (this.morphTexture.dispose(), this.morphTexture = null);
  }
}
const uy = /* @__PURE__ */ new j(), BU = /* @__PURE__ */ new j(), FU = /* @__PURE__ */ new fn();
class ca {
  /**
   * Constructs a new plane.
   *
   * @param {Vector3} [normal=(1,0,0)] - A unit length vector defining the normal of the plane.
   * @param {number} [constant=0] - The signed distance from the origin to the plane.
   */
  constructor(e = new j(1, 0, 0), t = 0) {
    this.isPlane = !0, this.normal = e, this.constant = t;
  }
  /**
   * Sets the plane components by copying the given values.
   *
   * @param {Vector3} normal - The normal.
   * @param {number} constant - The constant.
   * @return {Plane} A reference to this plane.
   */
  set(e, t) {
    return this.normal.copy(e), this.constant = t, this;
  }
  /**
   * Sets the plane components by defining `x`, `y`, `z` as the
   * plane normal and `w` as the constant.
   *
   * @param {number} x - The value for the normal's x component.
   * @param {number} y - The value for the normal's y component.
   * @param {number} z - The value for the normal's z component.
   * @param {number} w - The constant value.
   * @return {Plane} A reference to this plane.
   */
  setComponents(e, t, n, r) {
    return this.normal.set(e, t, n), this.constant = r, this;
  }
  /**
   * Sets the plane from the given normal and coplanar point (that is a point
   * that lies onto the plane).
   *
   * @param {Vector3} normal - The normal.
   * @param {Vector3} point - A coplanar point.
   * @return {Plane} A reference to this plane.
   */
  setFromNormalAndCoplanarPoint(e, t) {
    return this.normal.copy(e), this.constant = -t.dot(this.normal), this;
  }
  /**
   * Sets the plane from three coplanar points. The winding order is
   * assumed to be counter-clockwise, and determines the direction of
   * the plane normal.
   *
   * @param {Vector3} a - The first coplanar point.
   * @param {Vector3} b - The second coplanar point.
   * @param {Vector3} c - The third coplanar point.
   * @return {Plane} A reference to this plane.
   */
  setFromCoplanarPoints(e, t, n) {
    const r = uy.subVectors(n, t).cross(BU.subVectors(e, t)).normalize();
    return this.setFromNormalAndCoplanarPoint(r, e), this;
  }
  /**
   * Copies the values of the given plane to this instance.
   *
   * @param {Plane} plane - The plane to copy.
   * @return {Plane} A reference to this plane.
   */
  copy(e) {
    return this.normal.copy(e.normal), this.constant = e.constant, this;
  }
  /**
   * Normalizes the plane normal and adjusts the constant accordingly.
   *
   * @return {Plane} A reference to this plane.
   */
  normalize() {
    const e = 1 / this.normal.length();
    return this.normal.multiplyScalar(e), this.constant *= e, this;
  }
  /**
   * Negates both the plane normal and the constant.
   *
   * @return {Plane} A reference to this plane.
   */
  negate() {
    return this.constant *= -1, this.normal.negate(), this;
  }
  /**
   * Returns the signed distance from the given point to this plane.
   *
   * @param {Vector3} point - The point to compute the distance for.
   * @return {number} The signed distance.
   */
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant;
  }
  /**
   * Returns the signed distance from the given sphere to this plane.
   *
   * @param {Sphere} sphere - The sphere to compute the distance for.
   * @return {number} The signed distance.
   */
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius;
  }
  /**
   * Projects a the given point onto the plane.
   *
   * @param {Vector3} point - The point to project.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The projected point on the plane.
   */
  projectPoint(e, t) {
    return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e));
  }
  /**
   * Returns the intersection point of the passed line and the plane. Returns
   * `null` if the line does not intersect. Returns the line's starting point if
   * the line is coplanar with the plane.
   *
   * @param {Line3} line - The line to compute the intersection for.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {?Vector3} The intersection point.
   */
  intersectLine(e, t) {
    const n = e.delta(uy), r = this.normal.dot(n);
    if (r === 0)
      return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
    const s = -(e.start.dot(this.normal) + this.constant) / r;
    return s < 0 || s > 1 ? null : t.copy(e.start).addScaledVector(n, s);
  }
  /**
   * Returns `true` if the given line segment intersects with (passes through) the plane.
   *
   * @param {Line3} line - The line to test.
   * @return {boolean} Whether the given line segment intersects with the plane or not.
   */
  intersectsLine(e) {
    const t = this.distanceToPoint(e.start), n = this.distanceToPoint(e.end);
    return t < 0 && n > 0 || n < 0 && t > 0;
  }
  /**
   * Returns `true` if the given bounding box intersects with the plane.
   *
   * @param {Box3} box - The bounding box to test.
   * @return {boolean} Whether the given bounding box intersects with the plane or not.
   */
  intersectsBox(e) {
    return e.intersectsPlane(this);
  }
  /**
   * Returns `true` if the given bounding sphere intersects with the plane.
   *
   * @param {Sphere} sphere - The bounding sphere to test.
   * @return {boolean} Whether the given bounding sphere intersects with the plane or not.
   */
  intersectsSphere(e) {
    return e.intersectsPlane(this);
  }
  /**
   * Returns a coplanar vector to the plane, by calculating the
   * projection of the normal at the origin onto the plane.
   *
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The coplanar point.
   */
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant);
  }
  /**
   * Apply a 4x4 matrix to the plane. The matrix must be an affine, homogeneous transform.
   *
   * The optional normal matrix can be pre-computed like so:
   * ```js
   * const optionalNormalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );
   * ```
   *
   * @param {Matrix4} matrix - The transformation matrix.
   * @param {Matrix4} [optionalNormalMatrix] - A pre-computed normal matrix.
   * @return {Plane} A reference to this plane.
   */
  applyMatrix4(e, t) {
    const n = t || FU.getNormalMatrix(e), r = this.coplanarPoint(uy).applyMatrix4(e), s = this.normal.applyMatrix3(n).normalize();
    return this.constant = -r.dot(s), this;
  }
  /**
   * Translates the plane by the distance defined by the given offset vector.
   * Note that this only affects the plane constant and will not affect the normal vector.
   *
   * @param {Vector3} offset - The offset vector.
   * @return {Plane} A reference to this plane.
   */
  translate(e) {
    return this.constant -= e.dot(this.normal), this;
  }
  /**
   * Returns `true` if this plane is equal with the given one.
   *
   * @param {Plane} plane - The plane to test for equality.
   * @return {boolean} Whether this plane is equal with the given one.
   */
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
  /**
   * Returns a new plane with copied values from this instance.
   *
   * @return {Plane} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
}
const yc = /* @__PURE__ */ new fr(), UU = /* @__PURE__ */ new Le(0.5, 0.5), Mm = /* @__PURE__ */ new j();
class ec {
  /**
   * Constructs a new frustum.
   *
   * @param {Plane} [p0] - The first plane that encloses the frustum.
   * @param {Plane} [p1] - The second plane that encloses the frustum.
   * @param {Plane} [p2] - The third plane that encloses the frustum.
   * @param {Plane} [p3] - The fourth plane that encloses the frustum.
   * @param {Plane} [p4] - The fifth plane that encloses the frustum.
   * @param {Plane} [p5] - The sixth plane that encloses the frustum.
   */
  constructor(e = new ca(), t = new ca(), n = new ca(), r = new ca(), s = new ca(), o = new ca()) {
    this.planes = [e, t, n, r, s, o];
  }
  /**
   * Sets the frustum planes by copying the given planes.
   *
   * @param {Plane} [p0] - The first plane that encloses the frustum.
   * @param {Plane} [p1] - The second plane that encloses the frustum.
   * @param {Plane} [p2] - The third plane that encloses the frustum.
   * @param {Plane} [p3] - The fourth plane that encloses the frustum.
   * @param {Plane} [p4] - The fifth plane that encloses the frustum.
   * @param {Plane} [p5] - The sixth plane that encloses the frustum.
   * @return {Frustum} A reference to this frustum.
   */
  set(e, t, n, r, s, o) {
    const a = this.planes;
    return a[0].copy(e), a[1].copy(t), a[2].copy(n), a[3].copy(r), a[4].copy(s), a[5].copy(o), this;
  }
  /**
   * Copies the values of the given frustum to this instance.
   *
   * @param {Frustum} frustum - The frustum to copy.
   * @return {Frustum} A reference to this frustum.
   */
  copy(e) {
    const t = this.planes;
    for (let n = 0; n < 6; n++)
      t[n].copy(e.planes[n]);
    return this;
  }
  /**
   * Sets the frustum planes from the given projection matrix.
   *
   * @param {Matrix4} m - The projection matrix.
   * @param {(WebGLCoordinateSystem|WebGPUCoordinateSystem)} coordinateSystem - The coordinate system.
   * @param {boolean} [reversedDepth=false] - Whether to use a reversed depth.
   * @return {Frustum} A reference to this frustum.
   */
  setFromProjectionMatrix(e, t = jr, n = !1) {
    const r = this.planes, s = e.elements, o = s[0], a = s[1], l = s[2], u = s[3], c = s[4], A = s[5], m = s[6], _ = s[7], y = s[8], T = s[9], b = s[10], S = s[11], E = s[12], R = s[13], C = s[14], L = s[15];
    if (r[0].setComponents(u - o, _ - c, S - y, L - E).normalize(), r[1].setComponents(u + o, _ + c, S + y, L + E).normalize(), r[2].setComponents(u + a, _ + A, S + T, L + R).normalize(), r[3].setComponents(u - a, _ - A, S - T, L - R).normalize(), n)
      r[4].setComponents(l, m, b, C).normalize(), r[5].setComponents(u - l, _ - m, S - b, L - C).normalize();
    else if (r[4].setComponents(u - l, _ - m, S - b, L - C).normalize(), t === jr)
      r[5].setComponents(u + l, _ + m, S + b, L + C).normalize();
    else if (t === io)
      r[5].setComponents(l, m, b, C).normalize();
    else
      throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + t);
    return this;
  }
  /**
   * Returns `true` if the 3D object's bounding sphere is intersecting this frustum.
   *
   * Note that the 3D object must have a geometry so that the bounding sphere can be calculated.
   *
   * @param {Object3D} object - The 3D object to test.
   * @return {boolean} Whether the 3D object's bounding sphere is intersecting this frustum or not.
   */
  intersectsObject(e) {
    if (e.boundingSphere !== void 0)
      e.boundingSphere === null && e.computeBoundingSphere(), yc.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
    else {
      const t = e.geometry;
      t.boundingSphere === null && t.computeBoundingSphere(), yc.copy(t.boundingSphere).applyMatrix4(e.matrixWorld);
    }
    return this.intersectsSphere(yc);
  }
  /**
   * Returns `true` if the given sprite is intersecting this frustum.
   *
   * @param {Sprite} sprite - The sprite to test.
   * @return {boolean} Whether the sprite is intersecting this frustum or not.
   */
  intersectsSprite(e) {
    yc.center.set(0, 0, 0);
    const t = UU.distanceTo(e.center);
    return yc.radius = 0.7071067811865476 + t, yc.applyMatrix4(e.matrixWorld), this.intersectsSphere(yc);
  }
  /**
   * Returns `true` if the given bounding sphere is intersecting this frustum.
   *
   * @param {Sphere} sphere - The bounding sphere to test.
   * @return {boolean} Whether the bounding sphere is intersecting this frustum or not.
   */
  intersectsSphere(e) {
    const t = this.planes, n = e.center, r = -e.radius;
    for (let s = 0; s < 6; s++)
      if (t[s].distanceToPoint(n) < r)
        return !1;
    return !0;
  }
  /**
   * Returns `true` if the given bounding box is intersecting this frustum.
   *
   * @param {Box3} box - The bounding box to test.
   * @return {boolean} Whether the bounding box is intersecting this frustum or not.
   */
  intersectsBox(e) {
    const t = this.planes;
    for (let n = 0; n < 6; n++) {
      const r = t[n];
      if (Mm.x = r.normal.x > 0 ? e.max.x : e.min.x, Mm.y = r.normal.y > 0 ? e.max.y : e.min.y, Mm.z = r.normal.z > 0 ? e.max.z : e.min.z, r.distanceToPoint(Mm) < 0)
        return !1;
    }
    return !0;
  }
  /**
   * Returns `true` if the given point lies within the frustum.
   *
   * @param {Vector3} point - The point to test.
   * @return {boolean} Whether the point lies within this frustum or not.
   */
  containsPoint(e) {
    const t = this.planes;
    for (let n = 0; n < 6; n++)
      if (t[n].distanceToPoint(e) < 0)
        return !1;
    return !0;
  }
  /**
   * Returns a new frustum with copied values from this instance.
   *
   * @return {Frustum} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
}
const Ca = /* @__PURE__ */ new Mt(), Pa = /* @__PURE__ */ new ec();
class b0 {
  /**
   * Constructs a new frustum array.
   *
   */
  constructor() {
    this.coordinateSystem = jr;
  }
  /**
   * Returns `true` if the 3D object's bounding sphere is intersecting any frustum
   * from the camera array.
   *
   * @param {Object3D} object - The 3D object to test.
   * @param {Object} cameraArray - An object with a cameras property containing an array of cameras.
   * @return {boolean} Whether the 3D object is visible in any camera.
   */
  intersectsObject(e, t) {
    if (!t.isArrayCamera || t.cameras.length === 0)
      return !1;
    for (let n = 0; n < t.cameras.length; n++) {
      const r = t.cameras[n];
      if (Ca.multiplyMatrices(
        r.projectionMatrix,
        r.matrixWorldInverse
      ), Pa.setFromProjectionMatrix(
        Ca,
        r.coordinateSystem,
        r.reversedDepth
      ), Pa.intersectsObject(e))
        return !0;
    }
    return !1;
  }
  /**
   * Returns `true` if the given sprite is intersecting any frustum
   * from the camera array.
   *
   * @param {Sprite} sprite - The sprite to test.
   * @param {Object} cameraArray - An object with a cameras property containing an array of cameras.
   * @return {boolean} Whether the sprite is visible in any camera.
   */
  intersectsSprite(e, t) {
    if (!t || !t.cameras || t.cameras.length === 0)
      return !1;
    for (let n = 0; n < t.cameras.length; n++) {
      const r = t.cameras[n];
      if (Ca.multiplyMatrices(
        r.projectionMatrix,
        r.matrixWorldInverse
      ), Pa.setFromProjectionMatrix(
        Ca,
        r.coordinateSystem,
        r.reversedDepth
      ), Pa.intersectsSprite(e))
        return !0;
    }
    return !1;
  }
  /**
   * Returns `true` if the given bounding sphere is intersecting any frustum
   * from the camera array.
   *
   * @param {Sphere} sphere - The bounding sphere to test.
   * @param {Object} cameraArray - An object with a cameras property containing an array of cameras.
   * @return {boolean} Whether the sphere is visible in any camera.
   */
  intersectsSphere(e, t) {
    if (!t || !t.cameras || t.cameras.length === 0)
      return !1;
    for (let n = 0; n < t.cameras.length; n++) {
      const r = t.cameras[n];
      if (Ca.multiplyMatrices(
        r.projectionMatrix,
        r.matrixWorldInverse
      ), Pa.setFromProjectionMatrix(
        Ca,
        r.coordinateSystem,
        r.reversedDepth
      ), Pa.intersectsSphere(e))
        return !0;
    }
    return !1;
  }
  /**
   * Returns `true` if the given bounding box is intersecting any frustum
   * from the camera array.
   *
   * @param {Box3} box - The bounding box to test.
   * @param {Object} cameraArray - An object with a cameras property containing an array of cameras.
   * @return {boolean} Whether the box is visible in any camera.
   */
  intersectsBox(e, t) {
    if (!t || !t.cameras || t.cameras.length === 0)
      return !1;
    for (let n = 0; n < t.cameras.length; n++) {
      const r = t.cameras[n];
      if (Ca.multiplyMatrices(
        r.projectionMatrix,
        r.matrixWorldInverse
      ), Pa.setFromProjectionMatrix(
        Ca,
        r.coordinateSystem,
        r.reversedDepth
      ), Pa.intersectsBox(e))
        return !0;
    }
    return !1;
  }
  /**
   * Returns `true` if the given point lies within any frustum
   * from the camera array.
   *
   * @param {Vector3} point - The point to test.
   * @param {Object} cameraArray - An object with a cameras property containing an array of cameras.
   * @return {boolean} Whether the point is visible in any camera.
   */
  containsPoint(e, t) {
    if (!t || !t.cameras || t.cameras.length === 0)
      return !1;
    for (let n = 0; n < t.cameras.length; n++) {
      const r = t.cameras[n];
      if (Ca.multiplyMatrices(
        r.projectionMatrix,
        r.matrixWorldInverse
      ), Pa.setFromProjectionMatrix(
        Ca,
        r.coordinateSystem,
        r.reversedDepth
      ), Pa.containsPoint(e))
        return !0;
    }
    return !1;
  }
  /**
   * Returns a new frustum array with copied values from this instance.
   *
   * @return {FrustumArray} A clone of this instance.
   */
  clone() {
    return new b0();
  }
}
function cy(i, e) {
  return i - e;
}
function OU(i, e) {
  return i.z - e.z;
}
function kU(i, e) {
  return e.z - i.z;
}
class VU {
  constructor() {
    this.index = 0, this.pool = [], this.list = [];
  }
  push(e, t, n, r) {
    const s = this.pool, o = this.list;
    this.index >= s.length && s.push({
      start: -1,
      count: -1,
      z: -1,
      index: -1
    });
    const a = s[this.index];
    o.push(a), this.index++, a.start = e, a.count = t, a.z = n, a.index = r;
  }
  reset() {
    this.list.length = 0, this.index = 0;
  }
}
const zs = /* @__PURE__ */ new Mt(), GU = /* @__PURE__ */ new ct(1, 1, 1), VM = /* @__PURE__ */ new ec(), zU = /* @__PURE__ */ new b0(), Em = /* @__PURE__ */ new dr(), vc = /* @__PURE__ */ new fr(), IA = /* @__PURE__ */ new j(), GM = /* @__PURE__ */ new j(), qU = /* @__PURE__ */ new j(), hy = /* @__PURE__ */ new VU(), as = /* @__PURE__ */ new Tn(), Rm = [];
function HU(i, e, t = 0) {
  const n = e.itemSize;
  if (i.isInterleavedBufferAttribute || i.array.constructor !== e.array.constructor) {
    const r = i.count;
    for (let s = 0; s < r; s++)
      for (let o = 0; o < n; o++)
        e.setComponent(s + t, o, i.getComponent(s, o));
  } else
    e.array.set(i.array, t * n);
  e.needsUpdate = !0;
}
function bc(i, e) {
  if (i.constructor !== e.constructor) {
    const t = Math.min(i.length, e.length);
    for (let n = 0; n < t; n++)
      e[n] = i[n];
  } else {
    const t = Math.min(i.length, e.length);
    e.set(new i.constructor(i.buffer, 0, t));
  }
}
class Z5 extends Tn {
  /**
   * Constructs a new batched mesh.
   *
   * @param {number} maxInstanceCount - The maximum number of individual instances planned to be added and rendered.
   * @param {number} maxVertexCount - The maximum number of vertices to be used by all unique geometries.
   * @param {number} [maxIndexCount=maxVertexCount*2] - The maximum number of indices to be used by all unique geometries
   * @param {Material|Array<Material>} [material] - The mesh material.
   */
  constructor(e, t, n = t * 2, r) {
    super(new Yt(), r), this.isBatchedMesh = !0, this.perObjectFrustumCulled = !0, this.sortObjects = !0, this.boundingBox = null, this.boundingSphere = null, this.customSort = null, this._instanceInfo = [], this._geometryInfo = [], this._availableInstanceIds = [], this._availableGeometryIds = [], this._nextIndexStart = 0, this._nextVertexStart = 0, this._geometryCount = 0, this._visibilityChanged = !0, this._geometryInitialized = !1, this._maxInstanceCount = e, this._maxVertexCount = t, this._maxIndexCount = n, this._multiDrawCounts = new Int32Array(e), this._multiDrawStarts = new Int32Array(e), this._multiDrawCount = 0, this._multiDrawInstances = null, this._matricesTexture = null, this._indirectTexture = null, this._colorsTexture = null, this._initMatricesTexture(), this._initIndirectTexture();
  }
  /**
   * The maximum number of individual instances that can be stored in the batch.
   *
   * @type {number}
   * @readonly
   */
  get maxInstanceCount() {
    return this._maxInstanceCount;
  }
  /**
   * The instance count.
   *
   * @type {number}
   * @readonly
   */
  get instanceCount() {
    return this._instanceInfo.length - this._availableInstanceIds.length;
  }
  /**
   * The number of unused vertices.
   *
   * @type {number}
   * @readonly
   */
  get unusedVertexCount() {
    return this._maxVertexCount - this._nextVertexStart;
  }
  /**
   * The number of unused indices.
   *
   * @type {number}
   * @readonly
   */
  get unusedIndexCount() {
    return this._maxIndexCount - this._nextIndexStart;
  }
  _initMatricesTexture() {
    let e = Math.sqrt(this._maxInstanceCount * 4);
    e = Math.ceil(e / 4) * 4, e = Math.max(e, 4);
    const t = new Float32Array(e * e * 4), n = new wo(t, e, e, Pi, Ei);
    this._matricesTexture = n;
  }
  _initIndirectTexture() {
    let e = Math.sqrt(this._maxInstanceCount);
    e = Math.ceil(e);
    const t = new Uint32Array(e * e), n = new wo(t, e, e, Zu, Jn);
    this._indirectTexture = n;
  }
  _initColorsTexture() {
    let e = Math.sqrt(this._maxInstanceCount);
    e = Math.ceil(e);
    const t = new Float32Array(e * e * 4).fill(1), n = new wo(t, e, e, Pi, Ei);
    n.colorSpace = Xt.workingColorSpace, this._colorsTexture = n;
  }
  _initializeGeometry(e) {
    const t = this.geometry, n = this._maxVertexCount, r = this._maxIndexCount;
    if (this._geometryInitialized === !1) {
      for (const s in e.attributes) {
        const o = e.getAttribute(s), { array: a, itemSize: l, normalized: u } = o, c = new a.constructor(n * l), A = new Dn(c, l, u);
        t.setAttribute(s, A);
      }
      if (e.getIndex() !== null) {
        const s = n > 65535 ? new Uint32Array(r) : new Uint16Array(r);
        t.setIndex(new Dn(s, 1));
      }
      this._geometryInitialized = !0;
    }
  }
  // Make sure the geometry is compatible with the existing combined geometry attributes
  _validateGeometry(e) {
    const t = this.geometry;
    if (!!e.getIndex() != !!t.getIndex())
      throw new Error('THREE.BatchedMesh: All geometries must consistently have "index".');
    for (const n in t.attributes) {
      if (!e.hasAttribute(n))
        throw new Error(`THREE.BatchedMesh: Added geometry missing "${n}". All geometries must have consistent attributes.`);
      const r = e.getAttribute(n), s = t.getAttribute(n);
      if (r.itemSize !== s.itemSize || r.normalized !== s.normalized)
        throw new Error("THREE.BatchedMesh: All attributes must have a consistent itemSize and normalized value.");
    }
  }
  /**
   * Validates the instance defined by the given ID.
   *
   * @param {number} instanceId - The instance to validate.
   */
  validateInstanceId(e) {
    const t = this._instanceInfo;
    if (e < 0 || e >= t.length || t[e].active === !1)
      throw new Error(`THREE.BatchedMesh: Invalid instanceId ${e}. Instance is either out of range or has been deleted.`);
  }
  /**
   * Validates the geometry defined by the given ID.
   *
   * @param {number} geometryId - The geometry to validate.
   */
  validateGeometryId(e) {
    const t = this._geometryInfo;
    if (e < 0 || e >= t.length || t[e].active === !1)
      throw new Error(`THREE.BatchedMesh: Invalid geometryId ${e}. Geometry is either out of range or has been deleted.`);
  }
  /**
   * Takes a sort a function that is run before render. The function takes a list of instances to
   * sort and a camera. The objects in the list include a "z" field to perform a depth-ordered sort with.
   *
   * @param {Function} func - The custom sort function.
   * @return {BatchedMesh} A reference to this batched mesh.
   */
  setCustomSort(e) {
    return this.customSort = e, this;
  }
  /**
   * Computes the bounding box, updating {@link BatchedMesh#boundingBox}.
   * Bounding boxes aren't computed by default. They need to be explicitly computed,
   * otherwise they are `null`.
   */
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new dr());
    const e = this.boundingBox, t = this._instanceInfo;
    e.makeEmpty();
    for (let n = 0, r = t.length; n < r; n++) {
      if (t[n].active === !1) continue;
      const s = t[n].geometryIndex;
      this.getMatrixAt(n, zs), this.getBoundingBoxAt(s, Em).applyMatrix4(zs), e.union(Em);
    }
  }
  /**
   * Computes the bounding sphere, updating {@link BatchedMesh#boundingSphere}.
   * Bounding spheres aren't computed by default. They need to be explicitly computed,
   * otherwise they are `null`.
   */
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new fr());
    const e = this.boundingSphere, t = this._instanceInfo;
    e.makeEmpty();
    for (let n = 0, r = t.length; n < r; n++) {
      if (t[n].active === !1) continue;
      const s = t[n].geometryIndex;
      this.getMatrixAt(n, zs), this.getBoundingSphereAt(s, vc).applyMatrix4(zs), e.union(vc);
    }
  }
  /**
   * Adds a new instance to the batch using the geometry of the given ID and returns
   * a new id referring to the new instance to be used by other functions.
   *
   * @param {number} geometryId - The ID of a previously added geometry via {@link BatchedMesh#addGeometry}.
   * @return {number} The instance ID.
   */
  addInstance(e) {
    if (this._instanceInfo.length >= this.maxInstanceCount && this._availableInstanceIds.length === 0)
      throw new Error("THREE.BatchedMesh: Maximum item count reached.");
    const n = {
      visible: !0,
      active: !0,
      geometryIndex: e
    };
    let r = null;
    this._availableInstanceIds.length > 0 ? (this._availableInstanceIds.sort(cy), r = this._availableInstanceIds.shift(), this._instanceInfo[r] = n) : (r = this._instanceInfo.length, this._instanceInfo.push(n));
    const s = this._matricesTexture;
    zs.identity().toArray(s.image.data, r * 16), s.needsUpdate = !0;
    const o = this._colorsTexture;
    return o && (GU.toArray(o.image.data, r * 4), o.needsUpdate = !0), this._visibilityChanged = !0, r;
  }
  /**
   * Adds the given geometry to the batch and returns the associated
   * geometry id referring to it to be used in other functions.
   *
   * @param {BufferGeometry} geometry - The geometry to add.
   * @param {number} [reservedVertexCount=-1] - Optional parameter specifying the amount of
   * vertex buffer space to reserve for the added geometry. This is necessary if it is planned
   * to set a new geometry at this index at a later time that is larger than the original geometry.
   * Defaults to the length of the given geometry vertex buffer.
   * @param {number} [reservedIndexCount=-1] - Optional parameter specifying the amount of index
   * buffer space to reserve for the added geometry. This is necessary if it is planned to set a
   * new geometry at this index at a later time that is larger than the original geometry. Defaults to
   * the length of the given geometry index buffer.
   * @return {number} The geometry ID.
   */
  addGeometry(e, t = -1, n = -1) {
    this._initializeGeometry(e), this._validateGeometry(e);
    const r = {
      // geometry information
      vertexStart: -1,
      vertexCount: -1,
      reservedVertexCount: -1,
      indexStart: -1,
      indexCount: -1,
      reservedIndexCount: -1,
      // draw range information
      start: -1,
      count: -1,
      // state
      boundingBox: null,
      boundingSphere: null,
      active: !0
    }, s = this._geometryInfo;
    r.vertexStart = this._nextVertexStart, r.reservedVertexCount = t === -1 ? e.getAttribute("position").count : t;
    const o = e.getIndex();
    if (o !== null && (r.indexStart = this._nextIndexStart, r.reservedIndexCount = n === -1 ? o.count : n), r.indexStart !== -1 && r.indexStart + r.reservedIndexCount > this._maxIndexCount || r.vertexStart + r.reservedVertexCount > this._maxVertexCount)
      throw new Error("THREE.BatchedMesh: Reserved space request exceeds the maximum buffer size.");
    let l;
    return this._availableGeometryIds.length > 0 ? (this._availableGeometryIds.sort(cy), l = this._availableGeometryIds.shift(), s[l] = r) : (l = this._geometryCount, this._geometryCount++, s.push(r)), this.setGeometryAt(l, e), this._nextIndexStart = r.indexStart + r.reservedIndexCount, this._nextVertexStart = r.vertexStart + r.reservedVertexCount, l;
  }
  /**
   * Replaces the geometry at the given ID with the provided geometry. Throws an error if there
   * is not enough space reserved for geometry. Calling this will change all instances that are
   * rendering that geometry.
   *
   * @param {number} geometryId - The ID of the geometry that should be replaced with the given geometry.
   * @param {BufferGeometry} geometry - The new geometry.
   * @return {number} The geometry ID.
   */
  setGeometryAt(e, t) {
    if (e >= this._geometryCount)
      throw new Error("THREE.BatchedMesh: Maximum geometry count reached.");
    this._validateGeometry(t);
    const n = this.geometry, r = n.getIndex() !== null, s = n.getIndex(), o = t.getIndex(), a = this._geometryInfo[e];
    if (r && o.count > a.reservedIndexCount || t.attributes.position.count > a.reservedVertexCount)
      throw new Error("THREE.BatchedMesh: Reserved space not large enough for provided geometry.");
    const l = a.vertexStart, u = a.reservedVertexCount;
    a.vertexCount = t.getAttribute("position").count;
    for (const c in n.attributes) {
      const A = t.getAttribute(c), m = n.getAttribute(c);
      HU(A, m, l);
      const _ = A.itemSize;
      for (let y = A.count, T = u; y < T; y++) {
        const b = l + y;
        for (let S = 0; S < _; S++)
          m.setComponent(b, S, 0);
      }
      m.needsUpdate = !0, m.addUpdateRange(l * _, u * _);
    }
    if (r) {
      const c = a.indexStart, A = a.reservedIndexCount;
      a.indexCount = t.getIndex().count;
      for (let m = 0; m < o.count; m++)
        s.setX(c + m, l + o.getX(m));
      for (let m = o.count, _ = A; m < _; m++)
        s.setX(c + m, l);
      s.needsUpdate = !0, s.addUpdateRange(c, a.reservedIndexCount);
    }
    return a.start = r ? a.indexStart : a.vertexStart, a.count = r ? a.indexCount : a.vertexCount, a.boundingBox = null, t.boundingBox !== null && (a.boundingBox = t.boundingBox.clone()), a.boundingSphere = null, t.boundingSphere !== null && (a.boundingSphere = t.boundingSphere.clone()), this._visibilityChanged = !0, e;
  }
  /**
   * Deletes the geometry defined by the given ID from this batch. Any instances referencing
   * this geometry will also be removed as a side effect.
   *
   * @param {number} geometryId - The ID of the geometry to remove from the batch.
   * @return {BatchedMesh} A reference to this batched mesh.
   */
  deleteGeometry(e) {
    const t = this._geometryInfo;
    if (e >= t.length || t[e].active === !1)
      return this;
    const n = this._instanceInfo;
    for (let r = 0, s = n.length; r < s; r++)
      n[r].active && n[r].geometryIndex === e && this.deleteInstance(r);
    return t[e].active = !1, this._availableGeometryIds.push(e), this._visibilityChanged = !0, this;
  }
  /**
   * Deletes an existing instance from the batch using the given ID.
   *
   * @param {number} instanceId - The ID of the instance to remove from the batch.
   * @return {BatchedMesh} A reference to this batched mesh.
   */
  deleteInstance(e) {
    return this.validateInstanceId(e), this._instanceInfo[e].active = !1, this._availableInstanceIds.push(e), this._visibilityChanged = !0, this;
  }
  /**
   * Repacks the sub geometries in BatchedMesh to remove any unused space remaining from
   * previously deleted geometry, freeing up space to add new geometry.
   *
   * @return {BatchedMesh} A reference to this batched mesh.
   */
  optimize() {
    let e = 0, t = 0;
    const n = this._geometryInfo, r = n.map((o, a) => a).sort((o, a) => n[o].vertexStart - n[a].vertexStart), s = this.geometry;
    for (let o = 0, a = n.length; o < a; o++) {
      const l = r[o], u = n[l];
      if (u.active !== !1) {
        if (s.index !== null) {
          if (u.indexStart !== t) {
            const { indexStart: c, vertexStart: A, reservedIndexCount: m } = u, _ = s.index, y = _.array, T = e - A;
            for (let b = c; b < c + m; b++)
              y[b] = y[b] + T;
            _.array.copyWithin(t, c, c + m), _.addUpdateRange(t, m), _.needsUpdate = !0, u.indexStart = t;
          }
          t += u.reservedIndexCount;
        }
        if (u.vertexStart !== e) {
          const { vertexStart: c, reservedVertexCount: A } = u, m = s.attributes;
          for (const _ in m) {
            const y = m[_], { array: T, itemSize: b } = y;
            T.copyWithin(e * b, c * b, (c + A) * b), y.addUpdateRange(e * b, A * b), y.needsUpdate = !0;
          }
          u.vertexStart = e;
        }
        e += u.reservedVertexCount, u.start = s.index ? u.indexStart : u.vertexStart, this._nextIndexStart = s.index ? u.indexStart + u.reservedIndexCount : 0, this._nextVertexStart = u.vertexStart + u.reservedVertexCount;
      }
    }
    return this._visibilityChanged = !0, this;
  }
  /**
   * Returns the bounding box for the given geometry.
   *
   * @param {number} geometryId - The ID of the geometry to return the bounding box for.
   * @param {Box3} target - The target object that is used to store the method's result.
   * @return {?Box3} The geometry's bounding box. Returns `null` if no geometry has been found for the given ID.
   */
  getBoundingBoxAt(e, t) {
    if (e >= this._geometryCount)
      return null;
    const n = this.geometry, r = this._geometryInfo[e];
    if (r.boundingBox === null) {
      const s = new dr(), o = n.index, a = n.attributes.position;
      for (let l = r.start, u = r.start + r.count; l < u; l++) {
        let c = l;
        o && (c = o.getX(c)), s.expandByPoint(IA.fromBufferAttribute(a, c));
      }
      r.boundingBox = s;
    }
    return t.copy(r.boundingBox), t;
  }
  /**
   * Returns the bounding sphere for the given geometry.
   *
   * @param {number} geometryId - The ID of the geometry to return the bounding sphere for.
   * @param {Sphere} target - The target object that is used to store the method's result.
   * @return {?Sphere} The geometry's bounding sphere. Returns `null` if no geometry has been found for the given ID.
   */
  getBoundingSphereAt(e, t) {
    if (e >= this._geometryCount)
      return null;
    const n = this.geometry, r = this._geometryInfo[e];
    if (r.boundingSphere === null) {
      const s = new fr();
      this.getBoundingBoxAt(e, Em), Em.getCenter(s.center);
      const o = n.index, a = n.attributes.position;
      let l = 0;
      for (let u = r.start, c = r.start + r.count; u < c; u++) {
        let A = u;
        o && (A = o.getX(A)), IA.fromBufferAttribute(a, A), l = Math.max(l, s.center.distanceToSquared(IA));
      }
      s.radius = Math.sqrt(l), r.boundingSphere = s;
    }
    return t.copy(r.boundingSphere), t;
  }
  /**
   * Sets the given local transformation matrix to the defined instance.
   * Negatively scaled matrices are not supported.
   *
   * @param {number} instanceId - The ID of an instance to set the matrix of.
   * @param {Matrix4} matrix - A 4x4 matrix representing the local transformation of a single instance.
   * @return {BatchedMesh} A reference to this batched mesh.
   */
  setMatrixAt(e, t) {
    this.validateInstanceId(e);
    const n = this._matricesTexture, r = this._matricesTexture.image.data;
    return t.toArray(r, e * 16), n.needsUpdate = !0, this;
  }
  /**
   * Returns the local transformation matrix of the defined instance.
   *
   * @param {number} instanceId - The ID of an instance to get the matrix of.
   * @param {Matrix4} matrix - The target object that is used to store the method's result.
   * @return {Matrix4} The instance's local transformation matrix.
   */
  getMatrixAt(e, t) {
    return this.validateInstanceId(e), t.fromArray(this._matricesTexture.image.data, e * 16);
  }
  /**
   * Sets the given color to the defined instance.
   *
   * @param {number} instanceId - The ID of an instance to set the color of.
   * @param {Color} color - The color to set the instance to.
   * @return {BatchedMesh} A reference to this batched mesh.
   */
  setColorAt(e, t) {
    return this.validateInstanceId(e), this._colorsTexture === null && this._initColorsTexture(), t.toArray(this._colorsTexture.image.data, e * 4), this._colorsTexture.needsUpdate = !0, this;
  }
  /**
   * Returns the color of the defined instance.
   *
   * @param {number} instanceId - The ID of an instance to get the color of.
   * @param {Color} color - The target object that is used to store the method's result.
   * @return {Color} The instance's color.
   */
  getColorAt(e, t) {
    return this.validateInstanceId(e), t.fromArray(this._colorsTexture.image.data, e * 4);
  }
  /**
   * Sets the visibility of the instance.
   *
   * @param {number} instanceId - The id of the instance to set the visibility of.
   * @param {boolean} visible - Whether the instance is visible or not.
   * @return {BatchedMesh} A reference to this batched mesh.
   */
  setVisibleAt(e, t) {
    return this.validateInstanceId(e), this._instanceInfo[e].visible === t ? this : (this._instanceInfo[e].visible = t, this._visibilityChanged = !0, this);
  }
  /**
   * Returns the visibility state of the defined instance.
   *
   * @param {number} instanceId - The ID of an instance to get the visibility state of.
   * @return {boolean} Whether the instance is visible or not.
   */
  getVisibleAt(e) {
    return this.validateInstanceId(e), this._instanceInfo[e].visible;
  }
  /**
   * Sets the geometry ID of the instance at the given index.
   *
   * @param {number} instanceId - The ID of the instance to set the geometry ID of.
   * @param {number} geometryId - The geometry ID to be use by the instance.
   * @return {BatchedMesh} A reference to this batched mesh.
   */
  setGeometryIdAt(e, t) {
    return this.validateInstanceId(e), this.validateGeometryId(t), this._instanceInfo[e].geometryIndex = t, this;
  }
  /**
   * Returns the geometry ID of the defined instance.
   *
   * @param {number} instanceId - The ID of an instance to get the geometry ID of.
   * @return {number} The instance's geometry ID.
   */
  getGeometryIdAt(e) {
    return this.validateInstanceId(e), this._instanceInfo[e].geometryIndex;
  }
  /**
   * Get the range representing the subset of triangles related to the attached geometry,
   * indicating the starting offset and count, or `null` if invalid.
   *
   * @param {number} geometryId - The id of the geometry to get the range of.
   * @param {Object} [target] - The target object that is used to store the method's result.
   * @return {{
   * 	vertexStart:number,vertexCount:number,reservedVertexCount:number,
   * 	indexStart:number,indexCount:number,reservedIndexCount:number,
   * 	start:number,count:number
   * }} The result object with range data.
   */
  getGeometryRangeAt(e, t = {}) {
    this.validateGeometryId(e);
    const n = this._geometryInfo[e];
    return t.vertexStart = n.vertexStart, t.vertexCount = n.vertexCount, t.reservedVertexCount = n.reservedVertexCount, t.indexStart = n.indexStart, t.indexCount = n.indexCount, t.reservedIndexCount = n.reservedIndexCount, t.start = n.start, t.count = n.count, t;
  }
  /**
   * Resizes the necessary buffers to support the provided number of instances.
   * If the provided arguments shrink the number of instances but there are not enough
   * unused Ids at the end of the list then an error is thrown.
   *
   * @param {number} maxInstanceCount - The max number of individual instances that can be added and rendered by the batch.
  */
  setInstanceCount(e) {
    const t = this._availableInstanceIds, n = this._instanceInfo;
    for (t.sort(cy); t[t.length - 1] === n.length - 1; )
      n.pop(), t.pop();
    if (e < n.length)
      throw new Error(`BatchedMesh: Instance ids outside the range ${e} are being used. Cannot shrink instance count.`);
    const r = new Int32Array(e), s = new Int32Array(e);
    bc(this._multiDrawCounts, r), bc(this._multiDrawStarts, s), this._multiDrawCounts = r, this._multiDrawStarts = s, this._maxInstanceCount = e;
    const o = this._indirectTexture, a = this._matricesTexture, l = this._colorsTexture;
    o.dispose(), this._initIndirectTexture(), bc(o.image.data, this._indirectTexture.image.data), a.dispose(), this._initMatricesTexture(), bc(a.image.data, this._matricesTexture.image.data), l && (l.dispose(), this._initColorsTexture(), bc(l.image.data, this._colorsTexture.image.data));
  }
  /**
   * Resizes the available space in the batch's vertex and index buffer attributes to the provided sizes.
   * If the provided arguments shrink the geometry buffers but there is not enough unused space at the
   * end of the geometry attributes then an error is thrown.
   *
   * @param {number} maxVertexCount - The maximum number of vertices to be used by all unique geometries to resize to.
   * @param {number} maxIndexCount - The maximum number of indices to be used by all unique geometries to resize to.
  */
  setGeometrySize(e, t) {
    const n = [...this._geometryInfo].filter((a) => a.active);
    if (Math.max(...n.map((a) => a.vertexStart + a.reservedVertexCount)) > e)
      throw new Error(`BatchedMesh: Geometry vertex values are being used outside the range ${t}. Cannot shrink further.`);
    if (this.geometry.index && Math.max(...n.map((l) => l.indexStart + l.reservedIndexCount)) > t)
      throw new Error(`BatchedMesh: Geometry index values are being used outside the range ${t}. Cannot shrink further.`);
    const s = this.geometry;
    s.dispose(), this._maxVertexCount = e, this._maxIndexCount = t, this._geometryInitialized && (this._geometryInitialized = !1, this.geometry = new Yt(), this._initializeGeometry(s));
    const o = this.geometry;
    s.index && bc(s.index.array, o.index.array);
    for (const a in s.attributes)
      bc(s.attributes[a].array, o.attributes[a].array);
  }
  raycast(e, t) {
    const n = this._instanceInfo, r = this._geometryInfo, s = this.matrixWorld, o = this.geometry;
    as.material = this.material, as.geometry.index = o.index, as.geometry.attributes = o.attributes, as.geometry.boundingBox === null && (as.geometry.boundingBox = new dr()), as.geometry.boundingSphere === null && (as.geometry.boundingSphere = new fr());
    for (let a = 0, l = n.length; a < l; a++) {
      if (!n[a].visible || !n[a].active)
        continue;
      const u = n[a].geometryIndex, c = r[u];
      as.geometry.setDrawRange(c.start, c.count), this.getMatrixAt(a, as.matrixWorld).premultiply(s), this.getBoundingBoxAt(u, as.geometry.boundingBox), this.getBoundingSphereAt(u, as.geometry.boundingSphere), as.raycast(e, Rm);
      for (let A = 0, m = Rm.length; A < m; A++) {
        const _ = Rm[A];
        _.object = this, _.batchId = a, t.push(_);
      }
      Rm.length = 0;
    }
    as.material = null, as.geometry.index = null, as.geometry.attributes = {}, as.geometry.setDrawRange(0, 1 / 0);
  }
  copy(e) {
    return super.copy(e), this.geometry = e.geometry.clone(), this.perObjectFrustumCulled = e.perObjectFrustumCulled, this.sortObjects = e.sortObjects, this.boundingBox = e.boundingBox !== null ? e.boundingBox.clone() : null, this.boundingSphere = e.boundingSphere !== null ? e.boundingSphere.clone() : null, this._geometryInfo = e._geometryInfo.map((t) => ({
      ...t,
      boundingBox: t.boundingBox !== null ? t.boundingBox.clone() : null,
      boundingSphere: t.boundingSphere !== null ? t.boundingSphere.clone() : null
    })), this._instanceInfo = e._instanceInfo.map((t) => ({ ...t })), this._availableInstanceIds = e._availableInstanceIds.slice(), this._availableGeometryIds = e._availableGeometryIds.slice(), this._nextIndexStart = e._nextIndexStart, this._nextVertexStart = e._nextVertexStart, this._geometryCount = e._geometryCount, this._maxInstanceCount = e._maxInstanceCount, this._maxVertexCount = e._maxVertexCount, this._maxIndexCount = e._maxIndexCount, this._geometryInitialized = e._geometryInitialized, this._multiDrawCounts = e._multiDrawCounts.slice(), this._multiDrawStarts = e._multiDrawStarts.slice(), this._indirectTexture = e._indirectTexture.clone(), this._indirectTexture.image.data = this._indirectTexture.image.data.slice(), this._matricesTexture = e._matricesTexture.clone(), this._matricesTexture.image.data = this._matricesTexture.image.data.slice(), this._colorsTexture !== null && (this._colorsTexture = e._colorsTexture.clone(), this._colorsTexture.image.data = this._colorsTexture.image.data.slice()), this;
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   */
  dispose() {
    this.geometry.dispose(), this._matricesTexture.dispose(), this._matricesTexture = null, this._indirectTexture.dispose(), this._indirectTexture = null, this._colorsTexture !== null && (this._colorsTexture.dispose(), this._colorsTexture = null);
  }
  onBeforeRender(e, t, n, r, s) {
    if (!this._visibilityChanged && !this.perObjectFrustumCulled && !this.sortObjects)
      return;
    const o = r.getIndex(), a = o === null ? 1 : o.array.BYTES_PER_ELEMENT, l = this._instanceInfo, u = this._multiDrawStarts, c = this._multiDrawCounts, A = this._geometryInfo, m = this.perObjectFrustumCulled, _ = this._indirectTexture, y = _.image.data, T = n.isArrayCamera ? zU : VM;
    m && !n.isArrayCamera && (zs.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse).multiply(this.matrixWorld), VM.setFromProjectionMatrix(
      zs,
      n.coordinateSystem,
      n.reversedDepth
    ));
    let b = 0;
    if (this.sortObjects) {
      zs.copy(this.matrixWorld).invert(), IA.setFromMatrixPosition(n.matrixWorld).applyMatrix4(zs), GM.set(0, 0, -1).transformDirection(n.matrixWorld).transformDirection(zs);
      for (let R = 0, C = l.length; R < C; R++)
        if (l[R].visible && l[R].active) {
          const L = l[R].geometryIndex;
          this.getMatrixAt(R, zs), this.getBoundingSphereAt(L, vc).applyMatrix4(zs);
          let D = !1;
          if (m && (D = !T.intersectsSphere(vc, n)), !D) {
            const B = A[L], U = qU.subVectors(vc.center, IA).dot(GM);
            hy.push(B.start, B.count, U, R);
          }
        }
      const S = hy.list, E = this.customSort;
      E === null ? S.sort(s.transparent ? kU : OU) : E.call(this, S, n);
      for (let R = 0, C = S.length; R < C; R++) {
        const L = S[R];
        u[b] = L.start * a, c[b] = L.count, y[b] = L.index, b++;
      }
      hy.reset();
    } else
      for (let S = 0, E = l.length; S < E; S++)
        if (l[S].visible && l[S].active) {
          const R = l[S].geometryIndex;
          let C = !1;
          if (m && (this.getMatrixAt(S, zs), this.getBoundingSphereAt(R, vc).applyMatrix4(zs), C = !T.intersectsSphere(vc, n)), !C) {
            const L = A[R];
            u[b] = L.start * a, c[b] = L.count, y[b] = S, b++;
          }
        }
    _.needsUpdate = !0, this._multiDrawCount = b, this._visibilityChanged = !1;
  }
  onBeforeShadow(e, t, n, r, s, o) {
    this.onBeforeRender(e, null, r, s, o);
  }
}
class br extends Br {
  /**
   * Constructs a new line basic material.
   *
   * @param {Object} [parameters] - An object with one or more properties
   * defining the material's appearance. Any property of the material
   * (including any property from inherited materials) can be passed
   * in here. Color values can be passed any type of value accepted
   * by {@link Color#set}.
   */
  constructor(e) {
    super(), this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new ct(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this;
  }
}
const m1 = /* @__PURE__ */ new j(), g1 = /* @__PURE__ */ new j(), zM = /* @__PURE__ */ new Mt(), BA = /* @__PURE__ */ new Zh(), Cm = /* @__PURE__ */ new fr(), dy = /* @__PURE__ */ new j(), qM = /* @__PURE__ */ new j();
class va extends Vn {
  /**
   * Constructs a new line.
   *
   * @param {BufferGeometry} [geometry] - The line geometry.
   * @param {Material|Array<Material>} [material] - The line material.
   */
  constructor(e = new Yt(), t = new br()) {
    super(), this.isLine = !0, this.type = "Line", this.geometry = e, this.material = t, this.morphTargetDictionary = void 0, this.morphTargetInfluences = void 0, this.updateMorphTargets();
  }
  copy(e, t) {
    return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
  }
  /**
   * Computes an array of distance values which are necessary for rendering dashed lines.
   * For each vertex in the geometry, the method calculates the cumulative length from the
   * current point to the very beginning of the line.
   *
   * @return {Line} A reference to this line.
   */
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position, n = [0];
      for (let r = 1, s = t.count; r < s; r++)
        m1.fromBufferAttribute(t, r - 1), g1.fromBufferAttribute(t, r), n[r] = n[r - 1], n[r] += m1.distanceTo(g1);
      e.setAttribute("lineDistance", new xt(n, 1));
    } else
      Me("Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    return this;
  }
  /**
   * Computes intersection points between a casted ray and this line.
   *
   * @param {Raycaster} raycaster - The raycaster.
   * @param {Array<Object>} intersects - The target array that holds the intersection points.
   */
  raycast(e, t) {
    const n = this.geometry, r = this.matrixWorld, s = e.params.Line.threshold, o = n.drawRange;
    if (n.boundingSphere === null && n.computeBoundingSphere(), Cm.copy(n.boundingSphere), Cm.applyMatrix4(r), Cm.radius += s, e.ray.intersectsSphere(Cm) === !1) return;
    zM.copy(r).invert(), BA.copy(e.ray).applyMatrix4(zM);
    const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3), l = a * a, u = this.isLineSegments ? 2 : 1, c = n.index, m = n.attributes.position;
    if (c !== null) {
      const _ = Math.max(0, o.start), y = Math.min(c.count, o.start + o.count);
      for (let T = _, b = y - 1; T < b; T += u) {
        const S = c.getX(T), E = c.getX(T + 1), R = Pm(this, e, BA, l, S, E, T);
        R && t.push(R);
      }
      if (this.isLineLoop) {
        const T = c.getX(y - 1), b = c.getX(_), S = Pm(this, e, BA, l, T, b, y - 1);
        S && t.push(S);
      }
    } else {
      const _ = Math.max(0, o.start), y = Math.min(m.count, o.start + o.count);
      for (let T = _, b = y - 1; T < b; T += u) {
        const S = Pm(this, e, BA, l, T, T + 1, T);
        S && t.push(S);
      }
      if (this.isLineLoop) {
        const T = Pm(this, e, BA, l, y - 1, _, y - 1);
        T && t.push(T);
      }
    }
  }
  /**
   * Sets the values of {@link Line#morphTargetDictionary} and {@link Line#morphTargetInfluences}
   * to make sure existing morph targets can influence this 3D object.
   */
  updateMorphTargets() {
    const t = this.geometry.morphAttributes, n = Object.keys(t);
    if (n.length > 0) {
      const r = t[n[0]];
      if (r !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let s = 0, o = r.length; s < o; s++) {
          const a = r[s].name || String(s);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = s;
        }
      }
    }
  }
}
function Pm(i, e, t, n, r, s, o) {
  const a = i.geometry.attributes.position;
  if (m1.fromBufferAttribute(a, r), g1.fromBufferAttribute(a, s), t.distanceSqToSegment(m1, g1, dy, qM) > n) return;
  dy.applyMatrix4(i.matrixWorld);
  const u = e.ray.origin.distanceTo(dy);
  if (!(u < e.near || u > e.far))
    return {
      distance: u,
      // What do we want? intersection point on the ray or on the segment??
      // point: raycaster.ray.at( distance ),
      point: qM.clone().applyMatrix4(i.matrixWorld),
      index: o,
      face: null,
      faceIndex: null,
      barycoord: null,
      object: i
    };
}
const HM = /* @__PURE__ */ new j(), WM = /* @__PURE__ */ new j();
class Qo extends va {
  /**
   * Constructs a new line segments.
   *
   * @param {BufferGeometry} [geometry] - The line geometry.
   * @param {Material|Array<Material>} [material] - The line material.
   */
  constructor(e, t) {
    super(e, t), this.isLineSegments = !0, this.type = "LineSegments";
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position, n = [];
      for (let r = 0, s = t.count; r < s; r += 2)
        HM.fromBufferAttribute(t, r), WM.fromBufferAttribute(t, r + 1), n[r] = r === 0 ? 0 : n[r - 1], n[r + 1] = n[r] + HM.distanceTo(WM);
      e.setAttribute("lineDistance", new xt(n, 1));
    } else
      Me("LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    return this;
  }
}
class J5 extends va {
  /**
   * Constructs a new line loop.
   *
   * @param {BufferGeometry} [geometry] - The line geometry.
   * @param {Material|Array<Material>} [material] - The line material.
   */
  constructor(e, t) {
    super(e, t), this.isLineLoop = !0, this.type = "LineLoop";
  }
}
class S0 extends Br {
  /**
   * Constructs a new points material.
   *
   * @param {Object} [parameters] - An object with one or more properties
   * defining the material's appearance. Any property of the material
   * (including any property from inherited materials) can be passed
   * in here. Color values can be passed any type of value accepted
   * by {@link Color#set}.
   */
  constructor(e) {
    super(), this.isPointsMaterial = !0, this.type = "PointsMaterial", this.color = new ct(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this;
  }
}
const $M = /* @__PURE__ */ new Mt(), Ov = /* @__PURE__ */ new Zh(), Nm = /* @__PURE__ */ new fr(), Dm = /* @__PURE__ */ new j();
class I3 extends Vn {
  /**
   * Constructs a new point cloud.
   *
   * @param {BufferGeometry} [geometry] - The points geometry.
   * @param {Material|Array<Material>} [material] - The points material.
   */
  constructor(e = new Yt(), t = new S0()) {
    super(), this.isPoints = !0, this.type = "Points", this.geometry = e, this.material = t, this.morphTargetDictionary = void 0, this.morphTargetInfluences = void 0, this.updateMorphTargets();
  }
  copy(e, t) {
    return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
  }
  /**
   * Computes intersection points between a casted ray and this point cloud.
   *
   * @param {Raycaster} raycaster - The raycaster.
   * @param {Array<Object>} intersects - The target array that holds the intersection points.
   */
  raycast(e, t) {
    const n = this.geometry, r = this.matrixWorld, s = e.params.Points.threshold, o = n.drawRange;
    if (n.boundingSphere === null && n.computeBoundingSphere(), Nm.copy(n.boundingSphere), Nm.applyMatrix4(r), Nm.radius += s, e.ray.intersectsSphere(Nm) === !1) return;
    $M.copy(r).invert(), Ov.copy(e.ray).applyMatrix4($M);
    const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3), l = a * a, u = n.index, A = n.attributes.position;
    if (u !== null) {
      const m = Math.max(0, o.start), _ = Math.min(u.count, o.start + o.count);
      for (let y = m, T = _; y < T; y++) {
        const b = u.getX(y);
        Dm.fromBufferAttribute(A, b), jM(Dm, b, l, r, e, t, this);
      }
    } else {
      const m = Math.max(0, o.start), _ = Math.min(A.count, o.start + o.count);
      for (let y = m, T = _; y < T; y++)
        Dm.fromBufferAttribute(A, y), jM(Dm, y, l, r, e, t, this);
    }
  }
  /**
   * Sets the values of {@link Points#morphTargetDictionary} and {@link Points#morphTargetInfluences}
   * to make sure existing morph targets can influence this 3D object.
   */
  updateMorphTargets() {
    const t = this.geometry.morphAttributes, n = Object.keys(t);
    if (n.length > 0) {
      const r = t[n[0]];
      if (r !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let s = 0, o = r.length; s < o; s++) {
          const a = r[s].name || String(s);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = s;
        }
      }
    }
  }
}
function jM(i, e, t, n, r, s, o) {
  const a = Ov.distanceSqToPoint(i);
  if (a < t) {
    const l = new j();
    Ov.closestPointToPoint(i, l), l.applyMatrix4(n);
    const u = r.ray.origin.distanceTo(l);
    if (u < r.near || u > r.far) return;
    s.push({
      distance: u,
      distanceToRay: Math.sqrt(a),
      point: l,
      index: e,
      face: null,
      faceIndex: null,
      barycoord: null,
      object: o
    });
  }
}
class e8 extends Ii {
  /**
   * Constructs a new video texture.
   *
   * @param {HTMLVideoElement} video - The video element to use as a data source for the texture.
   * @param {number} [mapping=Texture.DEFAULT_MAPPING] - The texture mapping.
   * @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.
   * @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.
   * @param {number} [magFilter=LinearFilter] - The mag filter value.
   * @param {number} [minFilter=LinearFilter] - The min filter value.
   * @param {number} [format=RGBAFormat] - The texture format.
   * @param {number} [type=UnsignedByteType] - The texture type.
   * @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.
   */
  constructor(e, t, n, r, s = qn, o = qn, a, l, u) {
    super(e, t, n, r, s, o, a, l, u), this.isVideoTexture = !0, this.generateMipmaps = !1, this._requestVideoFrameCallbackId = 0;
    const c = this;
    function A() {
      c.needsUpdate = !0, c._requestVideoFrameCallbackId = e.requestVideoFrameCallback(A);
    }
    "requestVideoFrameCallback" in e && (this._requestVideoFrameCallbackId = e.requestVideoFrameCallback(A));
  }
  clone() {
    return new this.constructor(this.image).copy(this);
  }
  /**
   * This method is called automatically by the renderer and sets {@link Texture#needsUpdate}
   * to `true` every time a new frame is available.
   *
   * Only relevant if `requestVideoFrameCallback` is not supported in the browser.
   */
  update() {
    const e = this.image;
    "requestVideoFrameCallback" in e === !1 && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0);
  }
  dispose() {
    this._requestVideoFrameCallbackId !== 0 && (this.source.data.cancelVideoFrameCallback(this._requestVideoFrameCallbackId), this._requestVideoFrameCallbackId = 0), super.dispose();
  }
}
class WU extends e8 {
  /**
   * Constructs a new video frame texture.
   *
   * @param {number} [mapping=Texture.DEFAULT_MAPPING] - The texture mapping.
   * @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.
   * @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.
   * @param {number} [magFilter=LinearFilter] - The mag filter value.
   * @param {number} [minFilter=LinearFilter] - The min filter value.
   * @param {number} [format=RGBAFormat] - The texture format.
   * @param {number} [type=UnsignedByteType] - The texture type.
   * @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.
   */
  constructor(e, t, n, r, s, o, a, l) {
    super({}, e, t, n, r, s, o, a, l), this.isVideoFrameTexture = !0;
  }
  /**
   * This method overwritten with an empty implementation since
   * this type of texture is updated via `setFrame()`.
   */
  update() {
  }
  clone() {
    return new this.constructor().copy(this);
  }
  /**
   * Sets the current frame of the video. This will automatically update the texture
   * so the data can be used for rendering.
   *
   * @param {VideoFrame} frame - The video frame.
   */
  setFrame(e) {
    this.image = e, this.needsUpdate = !0;
  }
}
class t2 extends Ii {
  /**
   * Constructs a new framebuffer texture.
   *
   * @param {number} [width] - The width of the texture.
   * @param {number} [height] - The height of the texture.
   */
  constructor(e, t) {
    super({ width: e, height: t }), this.isFramebufferTexture = !0, this.magFilter = ei, this.minFilter = ei, this.generateMipmaps = !1, this.needsUpdate = !0;
  }
}
class n2 extends Ii {
  /**
   * Constructs a new compressed texture.
   *
   * @param {Array<Object>} mipmaps - This array holds for all mipmaps (including the bases mip)
   * the data and dimensions.
   * @param {number} width - The width of the texture.
   * @param {number} height - The height of the texture.
   * @param {number} [format=RGBAFormat] - The texture format.
   * @param {number} [type=UnsignedByteType] - The texture type.
   * @param {number} [mapping=Texture.DEFAULT_MAPPING] - The texture mapping.
   * @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.
   * @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.
   * @param {number} [magFilter=LinearFilter] - The mag filter value.
   * @param {number} [minFilter=LinearMipmapLinearFilter] - The min filter value.
   * @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.
   * @param {string} [colorSpace=NoColorSpace] - The color space.
   */
  constructor(e, t, n, r, s, o, a, l, u, c, A, m) {
    super(null, o, a, l, u, c, r, s, A, m), this.isCompressedTexture = !0, this.image = { width: t, height: n }, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1;
  }
}
class $U extends n2 {
  /**
   * Constructs a new compressed array texture.
   *
   * @param {Array<Object>} mipmaps - This array holds for all mipmaps (including the bases mip)
   * the data and dimensions.
   * @param {number} width - The width of the texture.
   * @param {number} height - The height of the texture.
   * @param {number} depth - The depth of the texture.
   * @param {number} [format=RGBAFormat] - The min filter value.
   * @param {number} [type=UnsignedByteType] - The min filter value.
   */
  constructor(e, t, n, r, s, o) {
    super(e, t, n, s, o), this.isCompressedArrayTexture = !0, this.image.depth = r, this.wrapR = xr, this.layerUpdates = /* @__PURE__ */ new Set();
  }
  /**
   * Describes that a specific layer of the texture needs to be updated.
   * Normally when {@link Texture#needsUpdate} is set to `true`, the
   * entire compressed texture array is sent to the GPU. Marking specific
   * layers will only transmit subsets of all mipmaps associated with a
   * specific depth in the array which is often much more performant.
   *
   * @param {number} layerIndex - The layer index that should be updated.
   */
  addLayerUpdate(e) {
    this.layerUpdates.add(e);
  }
  /**
   * Resets the layer updates registry.
   */
  clearLayerUpdates() {
    this.layerUpdates.clear();
  }
}
class jU extends n2 {
  /**
   * Constructs a new compressed texture.
   *
   * @param {Array<CompressedTexture>} images - An array of compressed textures.
   * @param {number} [format=RGBAFormat] - The texture format.
   * @param {number} [type=UnsignedByteType] - The texture type.
   */
  constructor(e, t, n) {
    super(void 0, e[0].width, e[0].height, t, n, no), this.isCompressedCubeTexture = !0, this.isCubeTexture = !0, this.image = e;
  }
}
class XU extends Ii {
  /**
   * Constructs a new texture.
   *
   * @param {HTMLCanvasElement} [canvas] - The HTML canvas element.
   * @param {number} [mapping=Texture.DEFAULT_MAPPING] - The texture mapping.
   * @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.
   * @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.
   * @param {number} [magFilter=LinearFilter] - The mag filter value.
   * @param {number} [minFilter=LinearMipmapLinearFilter] - The min filter value.
   * @param {number} [format=RGBAFormat] - The texture format.
   * @param {number} [type=UnsignedByteType] - The texture type.
   * @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.
   */
  constructor(e, t, n, r, s, o, a, l, u) {
    super(e, t, n, r, s, o, a, l, u), this.isCanvasTexture = !0, this.needsUpdate = !0;
  }
}
class Qr extends Ii {
  /**
   * Constructs a new depth texture.
   *
   * @param {number} width - The width of the texture.
   * @param {number} height - The height of the texture.
   * @param {number} [type=UnsignedIntType] - The texture type.
   * @param {number} [mapping=Texture.DEFAULT_MAPPING] - The texture mapping.
   * @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.
   * @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.
   * @param {number} [magFilter=LinearFilter] - The mag filter value.
   * @param {number} [minFilter=LinearFilter] - The min filter value.
   * @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.
   * @param {number} [format=DepthFormat] - The texture format.
   * @param {number} [depth=1] - The depth of the texture.
   */
  constructor(e, t, n = Jn, r, s, o, a = ei, l = ei, u, c = Lr, A = 1) {
    if (c !== Lr && c !== ds)
      throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    const m = { width: e, height: t, depth: A };
    super(m, r, s, o, a, l, c, n, u), this.isDepthTexture = !0, this.flipY = !1, this.generateMipmaps = !1, this.compareFunction = null;
  }
  copy(e) {
    return super.copy(e), this.source = new Lu(Object.assign({}, e.image)), this.compareFunction = e.compareFunction, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return this.compareFunction !== null && (t.compareFunction = this.compareFunction), t;
  }
}
class B3 extends Qr {
  /**
   * Constructs a new cube depth texture.
   *
   * @param {number} size - The size (width and height) of each cube face.
   * @param {number} [type=UnsignedIntType] - The texture type.
   * @param {number} [mapping=CubeReflectionMapping] - The texture mapping.
   * @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.
   * @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.
   * @param {number} [magFilter=NearestFilter] - The mag filter value.
   * @param {number} [minFilter=NearestFilter] - The min filter value.
   * @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.
   * @param {number} [format=DepthFormat] - The texture format.
   */
  constructor(e, t = Jn, n = no, r, s, o = ei, a = ei, l, u = Lr) {
    const c = { width: e, height: e, depth: 1 }, A = [c, c, c, c, c, c];
    super(e, e, t, n, r, s, o, a, l, u), this.image = A, this.isCubeDepthTexture = !0, this.isCubeTexture = !0;
  }
  /**
   * Alias for {@link CubeDepthTexture#image}.
   *
   * @type {Array<Image>}
   */
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
}
class F3 extends Ii {
  /**
   * Creates a new raw texture.
   *
   * @param {?(WebGLTexture|GPUTexture)} [sourceTexture=null] - The external texture.
   */
  constructor(e = null) {
    super(), this.sourceTexture = e, this.isExternalTexture = !0;
  }
  copy(e) {
    return super.copy(e), this.sourceTexture = e.sourceTexture, this;
  }
}
class i2 extends Yt {
  /**
   * Constructs a new capsule geometry.
   *
   * @param {number} [radius=1] - Radius of the capsule.
   * @param {number} [height=1] - Height of the middle section.
   * @param {number} [capSegments=4] - Number of curve segments used to build each cap.
   * @param {number} [radialSegments=8] - Number of segmented faces around the circumference of the capsule. Must be an integer >= 3.
   * @param {number} [heightSegments=1] - Number of rows of faces along the height of the middle section. Must be an integer >= 1.
   */
  constructor(e = 1, t = 1, n = 4, r = 8, s = 1) {
    super(), this.type = "CapsuleGeometry", this.parameters = {
      radius: e,
      height: t,
      capSegments: n,
      radialSegments: r,
      heightSegments: s
    }, t = Math.max(0, t), n = Math.max(1, Math.floor(n)), r = Math.max(3, Math.floor(r)), s = Math.max(1, Math.floor(s));
    const o = [], a = [], l = [], u = [], c = t / 2, A = Math.PI / 2 * e, m = t, _ = 2 * A + m, y = n * 2 + s, T = r + 1, b = new j(), S = new j();
    for (let E = 0; E <= y; E++) {
      let R = 0, C = 0, L = 0, D = 0;
      if (E <= n) {
        const N = E / n, O = N * Math.PI / 2;
        C = -c - e * Math.cos(O), L = e * Math.sin(O), D = -e * Math.cos(O), R = N * A;
      } else if (E <= n + s) {
        const N = (E - n) / s;
        C = -c + N * t, L = e, D = 0, R = A + N * m;
      } else {
        const N = (E - n - s) / n, O = N * Math.PI / 2;
        C = c + e * Math.sin(O), L = e * Math.cos(O), D = e * Math.sin(O), R = A + m + N * A;
      }
      const B = Math.max(0, Math.min(1, R / _));
      let U = 0;
      E === 0 ? U = 0.5 / r : E === y && (U = -0.5 / r);
      for (let N = 0; N <= r; N++) {
        const O = N / r, G = O * Math.PI * 2, H = Math.sin(G), Y = Math.cos(G);
        S.x = -L * Y, S.y = C, S.z = L * H, a.push(S.x, S.y, S.z), b.set(
          -L * Y,
          D,
          L * H
        ), b.normalize(), l.push(b.x, b.y, b.z), u.push(O + U, B);
      }
      if (E > 0) {
        const N = (E - 1) * T;
        for (let O = 0; O < r; O++) {
          const G = N + O, H = N + O + 1, Y = E * T + O, K = E * T + O + 1;
          o.push(G, H, Y), o.push(H, K, Y);
        }
      }
    }
    this.setIndex(o), this.setAttribute("position", new xt(a, 3)), this.setAttribute("normal", new xt(l, 3)), this.setAttribute("uv", new xt(u, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {CapsuleGeometry} A new instance.
   */
  static fromJSON(e) {
    return new i2(e.radius, e.height, e.capSegments, e.radialSegments, e.heightSegments);
  }
}
class lA extends Yt {
  /**
   * Constructs a new circle geometry.
   *
   * @param {number} [radius=1] - Radius of the circle.
   * @param {number} [segments=32] - Number of segments (triangles), minimum = `3`.
   * @param {number} [thetaStart=0] - Start angle for first segment in radians.
   * @param {number} [thetaLength=Math.PI*2] - The central angle, often called theta,
   * of the circular sector in radians. The default value results in a complete circle.
   */
  constructor(e = 1, t = 32, n = 0, r = Math.PI * 2) {
    super(), this.type = "CircleGeometry", this.parameters = {
      radius: e,
      segments: t,
      thetaStart: n,
      thetaLength: r
    }, t = Math.max(3, t);
    const s = [], o = [], a = [], l = [], u = new j(), c = new Le();
    o.push(0, 0, 0), a.push(0, 0, 1), l.push(0.5, 0.5);
    for (let A = 0, m = 3; A <= t; A++, m += 3) {
      const _ = n + A / t * r;
      u.x = e * Math.cos(_), u.y = e * Math.sin(_), o.push(u.x, u.y, u.z), a.push(0, 0, 1), c.x = (o[m] / e + 1) / 2, c.y = (o[m + 1] / e + 1) / 2, l.push(c.x, c.y);
    }
    for (let A = 1; A <= t; A++)
      s.push(A, A + 1, 0);
    this.setIndex(s), this.setAttribute("position", new xt(o, 3)), this.setAttribute("normal", new xt(a, 3)), this.setAttribute("uv", new xt(l, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {CircleGeometry} A new instance.
   */
  static fromJSON(e) {
    return new lA(e.radius, e.segments, e.thetaStart, e.thetaLength);
  }
}
class ed extends Yt {
  /**
   * Constructs a new cylinder geometry.
   *
   * @param {number} [radiusTop=1] - Radius of the cylinder at the top.
   * @param {number} [radiusBottom=1] - Radius of the cylinder at the bottom.
   * @param {number} [height=1] - Height of the cylinder.
   * @param {number} [radialSegments=32] - Number of segmented faces around the circumference of the cylinder.
   * @param {number} [heightSegments=1] - Number of rows of faces along the height of the cylinder.
   * @param {boolean} [openEnded=false] - Whether the base of the cylinder is open or capped.
   * @param {number} [thetaStart=0] - Start angle for first segment, in radians.
   * @param {number} [thetaLength=Math.PI*2] - The central angle, often called theta, of the circular sector, in radians.
   * The default value results in a complete cylinder.
   */
  constructor(e = 1, t = 1, n = 1, r = 32, s = 1, o = !1, a = 0, l = Math.PI * 2) {
    super(), this.type = "CylinderGeometry", this.parameters = {
      radiusTop: e,
      radiusBottom: t,
      height: n,
      radialSegments: r,
      heightSegments: s,
      openEnded: o,
      thetaStart: a,
      thetaLength: l
    };
    const u = this;
    r = Math.floor(r), s = Math.floor(s);
    const c = [], A = [], m = [], _ = [];
    let y = 0;
    const T = [], b = n / 2;
    let S = 0;
    E(), o === !1 && (e > 0 && R(!0), t > 0 && R(!1)), this.setIndex(c), this.setAttribute("position", new xt(A, 3)), this.setAttribute("normal", new xt(m, 3)), this.setAttribute("uv", new xt(_, 2));
    function E() {
      const C = new j(), L = new j();
      let D = 0;
      const B = (t - e) / n;
      for (let U = 0; U <= s; U++) {
        const N = [], O = U / s, G = O * (t - e) + e;
        for (let H = 0; H <= r; H++) {
          const Y = H / r, K = Y * l + a, X = Math.sin(K), ee = Math.cos(K);
          L.x = G * X, L.y = -O * n + b, L.z = G * ee, A.push(L.x, L.y, L.z), C.set(X, B, ee).normalize(), m.push(C.x, C.y, C.z), _.push(Y, 1 - O), N.push(y++);
        }
        T.push(N);
      }
      for (let U = 0; U < r; U++)
        for (let N = 0; N < s; N++) {
          const O = T[N][U], G = T[N + 1][U], H = T[N + 1][U + 1], Y = T[N][U + 1];
          (e > 0 || N !== 0) && (c.push(O, G, Y), D += 3), (t > 0 || N !== s - 1) && (c.push(G, H, Y), D += 3);
        }
      u.addGroup(S, D, 0), S += D;
    }
    function R(C) {
      const L = y, D = new Le(), B = new j();
      let U = 0;
      const N = C === !0 ? e : t, O = C === !0 ? 1 : -1;
      for (let H = 1; H <= r; H++)
        A.push(0, b * O, 0), m.push(0, O, 0), _.push(0.5, 0.5), y++;
      const G = y;
      for (let H = 0; H <= r; H++) {
        const K = H / r * l + a, X = Math.cos(K), ee = Math.sin(K);
        B.x = N * ee, B.y = b * O, B.z = N * X, A.push(B.x, B.y, B.z), m.push(0, O, 0), D.x = X * 0.5 + 0.5, D.y = ee * 0.5 * O + 0.5, _.push(D.x, D.y), y++;
      }
      for (let H = 0; H < r; H++) {
        const Y = L + H, K = G + H;
        C === !0 ? c.push(K, K + 1, Y) : c.push(K + 1, K, Y), U += 3;
      }
      u.addGroup(S, U, C === !0 ? 1 : 2), S += U;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {CylinderGeometry} A new instance.
   */
  static fromJSON(e) {
    return new ed(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
class T0 extends ed {
  /**
   * Constructs a new cone geometry.
   *
   * @param {number} [radius=1] - Radius of the cone base.
   * @param {number} [height=1] - Height of the cone.
   * @param {number} [radialSegments=32] - Number of segmented faces around the circumference of the cone.
   * @param {number} [heightSegments=1] - Number of rows of faces along the height of the cone.
   * @param {boolean} [openEnded=false] - Whether the base of the cone is open or capped.
   * @param {number} [thetaStart=0] - Start angle for first segment, in radians.
   * @param {number} [thetaLength=Math.PI*2] - The central angle, often called theta, of the circular sector, in radians.
   * The default value results in a complete cone.
   */
  constructor(e = 1, t = 1, n = 32, r = 1, s = !1, o = 0, a = Math.PI * 2) {
    super(0, e, t, n, r, s, o, a), this.type = "ConeGeometry", this.parameters = {
      radius: e,
      height: t,
      radialSegments: n,
      heightSegments: r,
      openEnded: s,
      thetaStart: o,
      thetaLength: a
    };
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {ConeGeometry} A new instance.
   */
  static fromJSON(e) {
    return new T0(e.radius, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
class tc extends Yt {
  /**
   * Constructs a new polyhedron geometry.
   *
   * @param {Array<number>} [vertices] - A flat array of vertices describing the base shape.
   * @param {Array<number>} [indices] - A flat array of indices describing the base shape.
   * @param {number} [radius=1] - The radius of the shape.
   * @param {number} [detail=0] - How many levels to subdivide the geometry. The more detail, the smoother the shape.
   */
  constructor(e = [], t = [], n = 1, r = 0) {
    super(), this.type = "PolyhedronGeometry", this.parameters = {
      vertices: e,
      indices: t,
      radius: n,
      detail: r
    };
    const s = [], o = [];
    a(r), u(n), c(), this.setAttribute("position", new xt(s, 3)), this.setAttribute("normal", new xt(s.slice(), 3)), this.setAttribute("uv", new xt(o, 2)), r === 0 ? this.computeVertexNormals() : this.normalizeNormals();
    function a(E) {
      const R = new j(), C = new j(), L = new j();
      for (let D = 0; D < t.length; D += 3)
        _(t[D + 0], R), _(t[D + 1], C), _(t[D + 2], L), l(R, C, L, E);
    }
    function l(E, R, C, L) {
      const D = L + 1, B = [];
      for (let U = 0; U <= D; U++) {
        B[U] = [];
        const N = E.clone().lerp(C, U / D), O = R.clone().lerp(C, U / D), G = D - U;
        for (let H = 0; H <= G; H++)
          H === 0 && U === D ? B[U][H] = N : B[U][H] = N.clone().lerp(O, H / G);
      }
      for (let U = 0; U < D; U++)
        for (let N = 0; N < 2 * (D - U) - 1; N++) {
          const O = Math.floor(N / 2);
          N % 2 === 0 ? (m(B[U][O + 1]), m(B[U + 1][O]), m(B[U][O])) : (m(B[U][O + 1]), m(B[U + 1][O + 1]), m(B[U + 1][O]));
        }
    }
    function u(E) {
      const R = new j();
      for (let C = 0; C < s.length; C += 3)
        R.x = s[C + 0], R.y = s[C + 1], R.z = s[C + 2], R.normalize().multiplyScalar(E), s[C + 0] = R.x, s[C + 1] = R.y, s[C + 2] = R.z;
    }
    function c() {
      const E = new j();
      for (let R = 0; R < s.length; R += 3) {
        E.x = s[R + 0], E.y = s[R + 1], E.z = s[R + 2];
        const C = b(E) / 2 / Math.PI + 0.5, L = S(E) / Math.PI + 0.5;
        o.push(C, 1 - L);
      }
      y(), A();
    }
    function A() {
      for (let E = 0; E < o.length; E += 6) {
        const R = o[E + 0], C = o[E + 2], L = o[E + 4], D = Math.max(R, C, L), B = Math.min(R, C, L);
        D > 0.9 && B < 0.1 && (R < 0.2 && (o[E + 0] += 1), C < 0.2 && (o[E + 2] += 1), L < 0.2 && (o[E + 4] += 1));
      }
    }
    function m(E) {
      s.push(E.x, E.y, E.z);
    }
    function _(E, R) {
      const C = E * 3;
      R.x = e[C + 0], R.y = e[C + 1], R.z = e[C + 2];
    }
    function y() {
      const E = new j(), R = new j(), C = new j(), L = new j(), D = new Le(), B = new Le(), U = new Le();
      for (let N = 0, O = 0; N < s.length; N += 9, O += 6) {
        E.set(s[N + 0], s[N + 1], s[N + 2]), R.set(s[N + 3], s[N + 4], s[N + 5]), C.set(s[N + 6], s[N + 7], s[N + 8]), D.set(o[O + 0], o[O + 1]), B.set(o[O + 2], o[O + 3]), U.set(o[O + 4], o[O + 5]), L.copy(E).add(R).add(C).divideScalar(3);
        const G = b(L);
        T(D, O + 0, E, G), T(B, O + 2, R, G), T(U, O + 4, C, G);
      }
    }
    function T(E, R, C, L) {
      L < 0 && E.x === 1 && (o[R] = E.x - 1), C.x === 0 && C.z === 0 && (o[R] = L / 2 / Math.PI + 0.5);
    }
    function b(E) {
      return Math.atan2(E.z, -E.x);
    }
    function S(E) {
      return Math.atan2(-E.y, Math.sqrt(E.x * E.x + E.z * E.z));
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {PolyhedronGeometry} A new instance.
   */
  static fromJSON(e) {
    return new tc(e.vertices, e.indices, e.radius, e.detail);
  }
}
class r2 extends tc {
  /**
   * Constructs a new dodecahedron geometry.
   *
   * @param {number} [radius=1] - Radius of the dodecahedron.
   * @param {number} [detail=0] - Setting this to a value greater than `0` adds vertices making it no longer a dodecahedron.
   */
  constructor(e = 1, t = 0) {
    const n = (1 + Math.sqrt(5)) / 2, r = 1 / n, s = [
      // (1, 1, 1)
      -1,
      -1,
      -1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      -1,
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      1,
      1,
      -1,
      1,
      1,
      1,
      // (0, 1/, )
      0,
      -r,
      -n,
      0,
      -r,
      n,
      0,
      r,
      -n,
      0,
      r,
      n,
      // (1/, , 0)
      -r,
      -n,
      0,
      -r,
      n,
      0,
      r,
      -n,
      0,
      r,
      n,
      0,
      // (, 0, 1/)
      -n,
      0,
      -r,
      n,
      0,
      -r,
      -n,
      0,
      r,
      n,
      0,
      r
    ], o = [
      3,
      11,
      7,
      3,
      7,
      15,
      3,
      15,
      13,
      7,
      19,
      17,
      7,
      17,
      6,
      7,
      6,
      15,
      17,
      4,
      8,
      17,
      8,
      10,
      17,
      10,
      6,
      8,
      0,
      16,
      8,
      16,
      2,
      8,
      2,
      10,
      0,
      12,
      1,
      0,
      1,
      18,
      0,
      18,
      16,
      6,
      10,
      2,
      6,
      2,
      13,
      6,
      13,
      15,
      2,
      16,
      18,
      2,
      18,
      3,
      2,
      3,
      13,
      18,
      1,
      9,
      18,
      9,
      11,
      18,
      11,
      3,
      4,
      14,
      12,
      4,
      12,
      0,
      4,
      0,
      8,
      11,
      9,
      5,
      11,
      5,
      19,
      11,
      19,
      7,
      19,
      5,
      14,
      19,
      14,
      4,
      19,
      4,
      17,
      1,
      12,
      14,
      1,
      14,
      5,
      1,
      5,
      9
    ];
    super(s, o, e, t), this.type = "DodecahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {DodecahedronGeometry} A new instance.
   */
  static fromJSON(e) {
    return new r2(e.radius, e.detail);
  }
}
const Lm = /* @__PURE__ */ new j(), Im = /* @__PURE__ */ new j(), fy = /* @__PURE__ */ new j(), Bm = /* @__PURE__ */ new $s();
class t8 extends Yt {
  /**
   * Constructs a new edges geometry.
   *
   * @param {?BufferGeometry} [geometry=null] - The geometry.
   * @param {number} [thresholdAngle=1] - An edge is only rendered if the angle (in degrees)
   * between the face normals of the adjoining faces exceeds this value.
   */
  constructor(e = null, t = 1) {
    if (super(), this.type = "EdgesGeometry", this.parameters = {
      geometry: e,
      thresholdAngle: t
    }, e !== null) {
      const r = Math.pow(10, 4), s = Math.cos(ah * t), o = e.getIndex(), a = e.getAttribute("position"), l = o ? o.count : a.count, u = [0, 0, 0], c = ["a", "b", "c"], A = new Array(3), m = {}, _ = [];
      for (let y = 0; y < l; y += 3) {
        o ? (u[0] = o.getX(y), u[1] = o.getX(y + 1), u[2] = o.getX(y + 2)) : (u[0] = y, u[1] = y + 1, u[2] = y + 2);
        const { a: T, b, c: S } = Bm;
        if (T.fromBufferAttribute(a, u[0]), b.fromBufferAttribute(a, u[1]), S.fromBufferAttribute(a, u[2]), Bm.getNormal(fy), A[0] = `${Math.round(T.x * r)},${Math.round(T.y * r)},${Math.round(T.z * r)}`, A[1] = `${Math.round(b.x * r)},${Math.round(b.y * r)},${Math.round(b.z * r)}`, A[2] = `${Math.round(S.x * r)},${Math.round(S.y * r)},${Math.round(S.z * r)}`, !(A[0] === A[1] || A[1] === A[2] || A[2] === A[0]))
          for (let E = 0; E < 3; E++) {
            const R = (E + 1) % 3, C = A[E], L = A[R], D = Bm[c[E]], B = Bm[c[R]], U = `${C}_${L}`, N = `${L}_${C}`;
            N in m && m[N] ? (fy.dot(m[N].normal) <= s && (_.push(D.x, D.y, D.z), _.push(B.x, B.y, B.z)), m[N] = null) : U in m || (m[U] = {
              index0: u[E],
              index1: u[R],
              normal: fy.clone()
            });
          }
      }
      for (const y in m)
        if (m[y]) {
          const { index0: T, index1: b } = m[y];
          Lm.fromBufferAttribute(a, T), Im.fromBufferAttribute(a, b), _.push(Lm.x, Lm.y, Lm.z), _.push(Im.x, Im.y, Im.z);
        }
      this.setAttribute("position", new xt(_, 3));
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
}
class Ko {
  /**
   * Constructs a new curve.
   */
  constructor() {
    this.type = "Curve", this.arcLengthDivisions = 200, this.needsUpdate = !1, this.cacheArcLengths = null;
  }
  /**
   * This method returns a vector in 2D or 3D space (depending on the curve definition)
   * for the given interpolation factor.
   *
   * @abstract
   * @param {number} t - A interpolation factor representing a position on the curve. Must be in the range `[0,1]`.
   * @param {(Vector2|Vector3)} [optionalTarget] - The optional target vector the result is written to.
   * @return {(Vector2|Vector3)} The position on the curve. It can be a 2D or 3D vector depending on the curve definition.
   */
  getPoint() {
    Me("Curve: .getPoint() not implemented.");
  }
  /**
   * This method returns a vector in 2D or 3D space (depending on the curve definition)
   * for the given interpolation factor. Unlike {@link Curve#getPoint}, this method honors the length
   * of the curve which equidistant samples.
   *
   * @param {number} u - A interpolation factor representing a position on the curve. Must be in the range `[0,1]`.
   * @param {(Vector2|Vector3)} [optionalTarget] - The optional target vector the result is written to.
   * @return {(Vector2|Vector3)} The position on the curve. It can be a 2D or 3D vector depending on the curve definition.
   */
  getPointAt(e, t) {
    const n = this.getUtoTmapping(e);
    return this.getPoint(n, t);
  }
  /**
   * This method samples the curve via {@link Curve#getPoint} and returns an array of points representing
   * the curve shape.
   *
   * @param {number} [divisions=5] - The number of divisions.
   * @return {Array<(Vector2|Vector3)>} An array holding the sampled curve values. The number of points is `divisions + 1`.
   */
  getPoints(e = 5) {
    const t = [];
    for (let n = 0; n <= e; n++)
      t.push(this.getPoint(n / e));
    return t;
  }
  // Get sequence of points using getPointAt( u )
  /**
   * This method samples the curve via {@link Curve#getPointAt} and returns an array of points representing
   * the curve shape. Unlike {@link Curve#getPoints}, this method returns equi-spaced points across the entire
   * curve.
   *
   * @param {number} [divisions=5] - The number of divisions.
   * @return {Array<(Vector2|Vector3)>} An array holding the sampled curve values. The number of points is `divisions + 1`.
   */
  getSpacedPoints(e = 5) {
    const t = [];
    for (let n = 0; n <= e; n++)
      t.push(this.getPointAt(n / e));
    return t;
  }
  /**
   * Returns the total arc length of the curve.
   *
   * @return {number} The length of the curve.
   */
  getLength() {
    const e = this.getLengths();
    return e[e.length - 1];
  }
  /**
   * Returns an array of cumulative segment lengths of the curve.
   *
   * @param {number} [divisions=this.arcLengthDivisions] - The number of divisions.
   * @return {Array<number>} An array holding the cumulative segment lengths.
   */
  getLengths(e = this.arcLengthDivisions) {
    if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate)
      return this.cacheArcLengths;
    this.needsUpdate = !1;
    const t = [];
    let n, r = this.getPoint(0), s = 0;
    t.push(0);
    for (let o = 1; o <= e; o++)
      n = this.getPoint(o / e), s += n.distanceTo(r), t.push(s), r = n;
    return this.cacheArcLengths = t, t;
  }
  /**
   * Update the cumulative segment distance cache. The method must be called
   * every time curve parameters are changed. If an updated curve is part of a
   * composed curve like {@link CurvePath}, this method must be called on the
   * composed curve, too.
   */
  updateArcLengths() {
    this.needsUpdate = !0, this.getLengths();
  }
  /**
   * Given an interpolation factor in the range `[0,1]`, this method returns an updated
   * interpolation factor in the same range that can be ued to sample equidistant points
   * from a curve.
   *
   * @param {number} u - The interpolation factor.
   * @param {?number} distance - An optional distance on the curve.
   * @return {number} The updated interpolation factor.
   */
  getUtoTmapping(e, t = null) {
    const n = this.getLengths();
    let r = 0;
    const s = n.length;
    let o;
    t ? o = t : o = e * n[s - 1];
    let a = 0, l = s - 1, u;
    for (; a <= l; )
      if (r = Math.floor(a + (l - a) / 2), u = n[r] - o, u < 0)
        a = r + 1;
      else if (u > 0)
        l = r - 1;
      else {
        l = r;
        break;
      }
    if (r = l, n[r] === o)
      return r / (s - 1);
    const c = n[r], m = n[r + 1] - c, _ = (o - c) / m;
    return (r + _) / (s - 1);
  }
  /**
   * Returns a unit vector tangent for the given interpolation factor.
   * If the derived curve does not implement its tangent derivation,
   * two points a small delta apart will be used to find its gradient
   * which seems to give a reasonable approximation.
   *
   * @param {number} t - The interpolation factor.
   * @param {(Vector2|Vector3)} [optionalTarget] - The optional target vector the result is written to.
   * @return {(Vector2|Vector3)} The tangent vector.
   */
  getTangent(e, t) {
    let r = e - 1e-4, s = e + 1e-4;
    r < 0 && (r = 0), s > 1 && (s = 1);
    const o = this.getPoint(r), a = this.getPoint(s), l = t || (o.isVector2 ? new Le() : new j());
    return l.copy(a).sub(o).normalize(), l;
  }
  /**
   * Same as {@link Curve#getTangent} but with equidistant samples.
   *
   * @param {number} u - The interpolation factor.
   * @param {(Vector2|Vector3)} [optionalTarget] - The optional target vector the result is written to.
   * @return {(Vector2|Vector3)} The tangent vector.
   * @see {@link Curve#getPointAt}
   */
  getTangentAt(e, t) {
    const n = this.getUtoTmapping(e);
    return this.getTangent(n, t);
  }
  /**
   * Generates the Frenet Frames. Requires a curve definition in 3D space. Used
   * in geometries like {@link TubeGeometry} or {@link ExtrudeGeometry}.
   *
   * @param {number} segments - The number of segments.
   * @param {boolean} [closed=false] - Whether the curve is closed or not.
   * @return {{tangents: Array<Vector3>, normals: Array<Vector3>, binormals: Array<Vector3>}} The Frenet Frames.
   */
  computeFrenetFrames(e, t = !1) {
    const n = new j(), r = [], s = [], o = [], a = new j(), l = new Mt();
    for (let _ = 0; _ <= e; _++) {
      const y = _ / e;
      r[_] = this.getTangentAt(y, new j());
    }
    s[0] = new j(), o[0] = new j();
    let u = Number.MAX_VALUE;
    const c = Math.abs(r[0].x), A = Math.abs(r[0].y), m = Math.abs(r[0].z);
    c <= u && (u = c, n.set(1, 0, 0)), A <= u && (u = A, n.set(0, 1, 0)), m <= u && n.set(0, 0, 1), a.crossVectors(r[0], n).normalize(), s[0].crossVectors(r[0], a), o[0].crossVectors(r[0], s[0]);
    for (let _ = 1; _ <= e; _++) {
      if (s[_] = s[_ - 1].clone(), o[_] = o[_ - 1].clone(), a.crossVectors(r[_ - 1], r[_]), a.length() > Number.EPSILON) {
        a.normalize();
        const y = Math.acos(dn(r[_ - 1].dot(r[_]), -1, 1));
        s[_].applyMatrix4(l.makeRotationAxis(a, y));
      }
      o[_].crossVectors(r[_], s[_]);
    }
    if (t === !0) {
      let _ = Math.acos(dn(s[0].dot(s[e]), -1, 1));
      _ /= e, r[0].dot(a.crossVectors(s[0], s[e])) > 0 && (_ = -_);
      for (let y = 1; y <= e; y++)
        s[y].applyMatrix4(l.makeRotationAxis(r[y], _ * y)), o[y].crossVectors(r[y], s[y]);
    }
    return {
      tangents: r,
      normals: s,
      binormals: o
    };
  }
  /**
   * Returns a new curve with copied values from this instance.
   *
   * @return {Curve} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
  /**
   * Copies the values of the given curve to this instance.
   *
   * @param {Curve} source - The curve to copy.
   * @return {Curve} A reference to this curve.
   */
  copy(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
  /**
   * Serializes the curve into JSON.
   *
   * @return {Object} A JSON object representing the serialized curve.
   * @see {@link ObjectLoader#parse}
   */
  toJSON() {
    const e = {
      metadata: {
        version: 4.7,
        type: "Curve",
        generator: "Curve.toJSON"
      }
    };
    return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e;
  }
  /**
   * Deserializes the curve from the given JSON.
   *
   * @param {Object} json - The JSON holding the serialized curve.
   * @return {Curve} A reference to this curve.
   */
  fromJSON(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
}
class s2 extends Ko {
  /**
   * Constructs a new ellipse curve.
   *
   * @param {number} [aX=0] - The X center of the ellipse.
   * @param {number} [aY=0] - The Y center of the ellipse.
   * @param {number} [xRadius=1] - The radius of the ellipse in the x direction.
   * @param {number} [yRadius=1] - The radius of the ellipse in the y direction.
   * @param {number} [aStartAngle=0] - The start angle of the curve in radians starting from the positive X axis.
   * @param {number} [aEndAngle=Math.PI*2] - The end angle of the curve in radians starting from the positive X axis.
   * @param {boolean} [aClockwise=false] - Whether the ellipse is drawn clockwise or not.
   * @param {number} [aRotation=0] - The rotation angle of the ellipse in radians, counterclockwise from the positive X axis.
   */
  constructor(e = 0, t = 0, n = 1, r = 1, s = 0, o = Math.PI * 2, a = !1, l = 0) {
    super(), this.isEllipseCurve = !0, this.type = "EllipseCurve", this.aX = e, this.aY = t, this.xRadius = n, this.yRadius = r, this.aStartAngle = s, this.aEndAngle = o, this.aClockwise = a, this.aRotation = l;
  }
  /**
   * Returns a point on the curve.
   *
   * @param {number} t - A interpolation factor representing a position on the curve. Must be in the range `[0,1]`.
   * @param {Vector2} [optionalTarget] - The optional target vector the result is written to.
   * @return {Vector2} The position on the curve.
   */
  getPoint(e, t = new Le()) {
    const n = t, r = Math.PI * 2;
    let s = this.aEndAngle - this.aStartAngle;
    const o = Math.abs(s) < Number.EPSILON;
    for (; s < 0; ) s += r;
    for (; s > r; ) s -= r;
    s < Number.EPSILON && (o ? s = 0 : s = r), this.aClockwise === !0 && !o && (s === r ? s = -r : s = s - r);
    const a = this.aStartAngle + e * s;
    let l = this.aX + this.xRadius * Math.cos(a), u = this.aY + this.yRadius * Math.sin(a);
    if (this.aRotation !== 0) {
      const c = Math.cos(this.aRotation), A = Math.sin(this.aRotation), m = l - this.aX, _ = u - this.aY;
      l = m * c - _ * A + this.aX, u = m * A + _ * c + this.aY;
    }
    return n.set(l, u);
  }
  copy(e) {
    return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
  }
}
class n8 extends s2 {
  /**
   * Constructs a new arc curve.
   *
   * @param {number} [aX=0] - The X center of the ellipse.
   * @param {number} [aY=0] - The Y center of the ellipse.
   * @param {number} [aRadius=1] - The radius of the ellipse in the x direction.
   * @param {number} [aStartAngle=0] - The start angle of the curve in radians starting from the positive X axis.
   * @param {number} [aEndAngle=Math.PI*2] - The end angle of the curve in radians starting from the positive X axis.
   * @param {boolean} [aClockwise=false] - Whether the ellipse is drawn clockwise or not.
   */
  constructor(e, t, n, r, s, o) {
    super(e, t, n, n, r, s, o), this.isArcCurve = !0, this.type = "ArcCurve";
  }
}
function U3() {
  let i = 0, e = 0, t = 0, n = 0;
  function r(s, o, a, l) {
    i = s, e = a, t = -3 * s + 3 * o - 2 * a - l, n = 2 * s - 2 * o + a + l;
  }
  return {
    initCatmullRom: function(s, o, a, l, u) {
      r(o, a, u * (a - s), u * (l - o));
    },
    initNonuniformCatmullRom: function(s, o, a, l, u, c, A) {
      let m = (o - s) / u - (a - s) / (u + c) + (a - o) / c, _ = (a - o) / c - (l - o) / (c + A) + (l - a) / A;
      m *= c, _ *= c, r(o, a, m, _);
    },
    calc: function(s) {
      const o = s * s, a = o * s;
      return i + e * s + t * o + n * a;
    }
  };
}
const Fm = /* @__PURE__ */ new j(), Ay = /* @__PURE__ */ new U3(), py = /* @__PURE__ */ new U3(), my = /* @__PURE__ */ new U3();
class i8 extends Ko {
  /**
   * Constructs a new Catmull-Rom curve.
   *
   * @param {Array<Vector3>} [points] - An array of 3D points defining the curve.
   * @param {boolean} [closed=false] - Whether the curve is closed or not.
   * @param {('centripetal'|'chordal'|'catmullrom')} [curveType='centripetal'] - The curve type.
   * @param {number} [tension=0.5] - Tension of the curve.
   */
  constructor(e = [], t = !1, n = "centripetal", r = 0.5) {
    super(), this.isCatmullRomCurve3 = !0, this.type = "CatmullRomCurve3", this.points = e, this.closed = t, this.curveType = n, this.tension = r;
  }
  /**
   * Returns a point on the curve.
   *
   * @param {number} t - A interpolation factor representing a position on the curve. Must be in the range `[0,1]`.
   * @param {Vector3} [optionalTarget] - The optional target vector the result is written to.
   * @return {Vector3} The position on the curve.
   */
  getPoint(e, t = new j()) {
    const n = t, r = this.points, s = r.length, o = (s - (this.closed ? 0 : 1)) * e;
    let a = Math.floor(o), l = o - a;
    this.closed ? a += a > 0 ? 0 : (Math.floor(Math.abs(a) / s) + 1) * s : l === 0 && a === s - 1 && (a = s - 2, l = 1);
    let u, c;
    this.closed || a > 0 ? u = r[(a - 1) % s] : (Fm.subVectors(r[0], r[1]).add(r[0]), u = Fm);
    const A = r[a % s], m = r[(a + 1) % s];
    if (this.closed || a + 2 < s ? c = r[(a + 2) % s] : (Fm.subVectors(r[s - 1], r[s - 2]).add(r[s - 1]), c = Fm), this.curveType === "centripetal" || this.curveType === "chordal") {
      const _ = this.curveType === "chordal" ? 0.5 : 0.25;
      let y = Math.pow(u.distanceToSquared(A), _), T = Math.pow(A.distanceToSquared(m), _), b = Math.pow(m.distanceToSquared(c), _);
      T < 1e-4 && (T = 1), y < 1e-4 && (y = T), b < 1e-4 && (b = T), Ay.initNonuniformCatmullRom(u.x, A.x, m.x, c.x, y, T, b), py.initNonuniformCatmullRom(u.y, A.y, m.y, c.y, y, T, b), my.initNonuniformCatmullRom(u.z, A.z, m.z, c.z, y, T, b);
    } else this.curveType === "catmullrom" && (Ay.initCatmullRom(u.x, A.x, m.x, c.x, this.tension), py.initCatmullRom(u.y, A.y, m.y, c.y, this.tension), my.initCatmullRom(u.z, A.z, m.z, c.z, this.tension));
    return n.set(
      Ay.calc(l),
      py.calc(l),
      my.calc(l)
    ), n;
  }
  copy(e) {
    super.copy(e), this.points = [];
    for (let t = 0, n = e.points.length; t < n; t++) {
      const r = e.points[t];
      this.points.push(r.clone());
    }
    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, n = this.points.length; t < n; t++) {
      const r = this.points[t];
      e.points.push(r.toArray());
    }
    return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.points = [];
    for (let t = 0, n = e.points.length; t < n; t++) {
      const r = e.points[t];
      this.points.push(new j().fromArray(r));
    }
    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
  }
}
function XM(i, e, t, n, r) {
  const s = (n - e) * 0.5, o = (r - t) * 0.5, a = i * i, l = i * a;
  return (2 * t - 2 * n + s + o) * l + (-3 * t + 3 * n - 2 * s - o) * a + s * i + t;
}
function YU(i, e) {
  const t = 1 - i;
  return t * t * e;
}
function QU(i, e) {
  return 2 * (1 - i) * i * e;
}
function KU(i, e) {
  return i * i * e;
}
function Sp(i, e, t, n) {
  return YU(i, e) + QU(i, t) + KU(i, n);
}
function ZU(i, e) {
  const t = 1 - i;
  return t * t * t * e;
}
function JU(i, e) {
  const t = 1 - i;
  return 3 * t * t * i * e;
}
function eO(i, e) {
  return 3 * (1 - i) * i * i * e;
}
function tO(i, e) {
  return i * i * i * e;
}
function Tp(i, e, t, n, r) {
  return ZU(i, e) + JU(i, t) + eO(i, n) + tO(i, r);
}
class O3 extends Ko {
  /**
   * Constructs a new Cubic Bezier curve.
   *
   * @param {Vector2} [v0] - The start point.
   * @param {Vector2} [v1] - The first control point.
   * @param {Vector2} [v2] - The second control point.
   * @param {Vector2} [v3] - The end point.
   */
  constructor(e = new Le(), t = new Le(), n = new Le(), r = new Le()) {
    super(), this.isCubicBezierCurve = !0, this.type = "CubicBezierCurve", this.v0 = e, this.v1 = t, this.v2 = n, this.v3 = r;
  }
  /**
   * Returns a point on the curve.
   *
   * @param {number} t - A interpolation factor representing a position on the curve. Must be in the range `[0,1]`.
   * @param {Vector2} [optionalTarget] - The optional target vector the result is written to.
   * @return {Vector2} The position on the curve.
   */
  getPoint(e, t = new Le()) {
    const n = t, r = this.v0, s = this.v1, o = this.v2, a = this.v3;
    return n.set(
      Tp(e, r.x, s.x, o.x, a.x),
      Tp(e, r.y, s.y, o.y, a.y)
    ), n;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
  }
}
class k3 extends Ko {
  /**
   * Constructs a new Cubic Bezier curve.
   *
   * @param {Vector3} [v0] - The start point.
   * @param {Vector3} [v1] - The first control point.
   * @param {Vector3} [v2] - The second control point.
   * @param {Vector3} [v3] - The end point.
   */
  constructor(e = new j(), t = new j(), n = new j(), r = new j()) {
    super(), this.isCubicBezierCurve3 = !0, this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = n, this.v3 = r;
  }
  /**
   * Returns a point on the curve.
   *
   * @param {number} t - A interpolation factor representing a position on the curve. Must be in the range `[0,1]`.
   * @param {Vector3} [optionalTarget] - The optional target vector the result is written to.
   * @return {Vector3} The position on the curve.
   */
  getPoint(e, t = new j()) {
    const n = t, r = this.v0, s = this.v1, o = this.v2, a = this.v3;
    return n.set(
      Tp(e, r.x, s.x, o.x, a.x),
      Tp(e, r.y, s.y, o.y, a.y),
      Tp(e, r.z, s.z, o.z, a.z)
    ), n;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
  }
}
class V3 extends Ko {
  /**
   * Constructs a new line curve.
   *
   * @param {Vector2} [v1] - The start point.
   * @param {Vector2} [v2] - The end point.
   */
  constructor(e = new Le(), t = new Le()) {
    super(), this.isLineCurve = !0, this.type = "LineCurve", this.v1 = e, this.v2 = t;
  }
  /**
   * Returns a point on the line.
   *
   * @param {number} t - A interpolation factor representing a position on the line. Must be in the range `[0,1]`.
   * @param {Vector2} [optionalTarget] - The optional target vector the result is written to.
   * @return {Vector2} The position on the line.
   */
  getPoint(e, t = new Le()) {
    const n = t;
    return e === 1 ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new Le()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class r8 extends Ko {
  /**
   * Constructs a new line curve.
   *
   * @param {Vector3} [v1] - The start point.
   * @param {Vector3} [v2] - The end point.
   */
  constructor(e = new j(), t = new j()) {
    super(), this.isLineCurve3 = !0, this.type = "LineCurve3", this.v1 = e, this.v2 = t;
  }
  /**
   * Returns a point on the line.
   *
   * @param {number} t - A interpolation factor representing a position on the line. Must be in the range `[0,1]`.
   * @param {Vector3} [optionalTarget] - The optional target vector the result is written to.
   * @return {Vector3} The position on the line.
   */
  getPoint(e, t = new j()) {
    const n = t;
    return e === 1 ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new j()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class G3 extends Ko {
  /**
   * Constructs a new Quadratic Bezier curve.
   *
   * @param {Vector2} [v0] - The start point.
   * @param {Vector2} [v1] - The control point.
   * @param {Vector2} [v2] - The end point.
   */
  constructor(e = new Le(), t = new Le(), n = new Le()) {
    super(), this.isQuadraticBezierCurve = !0, this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = t, this.v2 = n;
  }
  /**
   * Returns a point on the curve.
   *
   * @param {number} t - A interpolation factor representing a position on the curve. Must be in the range `[0,1]`.
   * @param {Vector2} [optionalTarget] - The optional target vector the result is written to.
   * @return {Vector2} The position on the curve.
   */
  getPoint(e, t = new Le()) {
    const n = t, r = this.v0, s = this.v1, o = this.v2;
    return n.set(
      Sp(e, r.x, s.x, o.x),
      Sp(e, r.y, s.y, o.y)
    ), n;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class z3 extends Ko {
  /**
   * Constructs a new Quadratic Bezier curve.
   *
   * @param {Vector3} [v0] - The start point.
   * @param {Vector3} [v1] - The control point.
   * @param {Vector3} [v2] - The end point.
   */
  constructor(e = new j(), t = new j(), n = new j()) {
    super(), this.isQuadraticBezierCurve3 = !0, this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = n;
  }
  /**
   * Returns a point on the curve.
   *
   * @param {number} t - A interpolation factor representing a position on the curve. Must be in the range `[0,1]`.
   * @param {Vector3} [optionalTarget] - The optional target vector the result is written to.
   * @return {Vector3} The position on the curve.
   */
  getPoint(e, t = new j()) {
    const n = t, r = this.v0, s = this.v1, o = this.v2;
    return n.set(
      Sp(e, r.x, s.x, o.x),
      Sp(e, r.y, s.y, o.y),
      Sp(e, r.z, s.z, o.z)
    ), n;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class q3 extends Ko {
  /**
   * Constructs a new 2D spline curve.
   *
   * @param {Array<Vector2>} [points] -  An array of 2D points defining the curve.
   */
  constructor(e = []) {
    super(), this.isSplineCurve = !0, this.type = "SplineCurve", this.points = e;
  }
  /**
   * Returns a point on the curve.
   *
   * @param {number} t - A interpolation factor representing a position on the curve. Must be in the range `[0,1]`.
   * @param {Vector2} [optionalTarget] - The optional target vector the result is written to.
   * @return {Vector2} The position on the curve.
   */
  getPoint(e, t = new Le()) {
    const n = t, r = this.points, s = (r.length - 1) * e, o = Math.floor(s), a = s - o, l = r[o === 0 ? o : o - 1], u = r[o], c = r[o > r.length - 2 ? r.length - 1 : o + 1], A = r[o > r.length - 3 ? r.length - 1 : o + 2];
    return n.set(
      XM(a, l.x, u.x, c.x, A.x),
      XM(a, l.y, u.y, c.y, A.y)
    ), n;
  }
  copy(e) {
    super.copy(e), this.points = [];
    for (let t = 0, n = e.points.length; t < n; t++) {
      const r = e.points[t];
      this.points.push(r.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, n = this.points.length; t < n; t++) {
      const r = this.points[t];
      e.points.push(r.toArray());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.points = [];
    for (let t = 0, n = e.points.length; t < n; t++) {
      const r = e.points[t];
      this.points.push(new Le().fromArray(r));
    }
    return this;
  }
}
var _1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ArcCurve: n8,
  CatmullRomCurve3: i8,
  CubicBezierCurve: O3,
  CubicBezierCurve3: k3,
  EllipseCurve: s2,
  LineCurve: V3,
  LineCurve3: r8,
  QuadraticBezierCurve: G3,
  QuadraticBezierCurve3: z3,
  SplineCurve: q3
});
class s8 extends Ko {
  /**
   * Constructs a new curve path.
   */
  constructor() {
    super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1;
  }
  /**
   * Adds a curve to this curve path.
   *
   * @param {Curve} curve - The curve to add.
   */
  add(e) {
    this.curves.push(e);
  }
  /**
   * Adds a line curve to close the path.
   *
   * @return {CurvePath} A reference to this curve path.
   */
  closePath() {
    const e = this.curves[0].getPoint(0), t = this.curves[this.curves.length - 1].getPoint(1);
    if (!e.equals(t)) {
      const n = e.isVector2 === !0 ? "LineCurve" : "LineCurve3";
      this.curves.push(new _1[n](t, e));
    }
    return this;
  }
  /**
   * This method returns a vector in 2D or 3D space (depending on the curve definitions)
   * for the given interpolation factor.
   *
   * @param {number} t - A interpolation factor representing a position on the curve. Must be in the range `[0,1]`.
   * @param {(Vector2|Vector3)} [optionalTarget] - The optional target vector the result is written to.
   * @return {?(Vector2|Vector3)} The position on the curve. It can be a 2D or 3D vector depending on the curve definition.
   */
  getPoint(e, t) {
    const n = e * this.getLength(), r = this.getCurveLengths();
    let s = 0;
    for (; s < r.length; ) {
      if (r[s] >= n) {
        const o = r[s] - n, a = this.curves[s], l = a.getLength(), u = l === 0 ? 0 : 1 - o / l;
        return a.getPointAt(u, t);
      }
      s++;
    }
    return null;
  }
  getLength() {
    const e = this.getCurveLengths();
    return e[e.length - 1];
  }
  updateArcLengths() {
    this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths();
  }
  /**
   * Returns list of cumulative curve lengths of the defined curves.
   *
   * @return {Array<number>} The curve lengths.
   */
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
      return this.cacheLengths;
    const e = [];
    let t = 0;
    for (let n = 0, r = this.curves.length; n < r; n++)
      t += this.curves[n].getLength(), e.push(t);
    return this.cacheLengths = e, e;
  }
  getSpacedPoints(e = 40) {
    const t = [];
    for (let n = 0; n <= e; n++)
      t.push(this.getPoint(n / e));
    return this.autoClose && t.push(t[0]), t;
  }
  getPoints(e = 12) {
    const t = [];
    let n;
    for (let r = 0, s = this.curves; r < s.length; r++) {
      const o = s[r], a = o.isEllipseCurve ? e * 2 : o.isLineCurve || o.isLineCurve3 ? 1 : o.isSplineCurve ? e * o.points.length : e, l = o.getPoints(a);
      for (let u = 0; u < l.length; u++) {
        const c = l[u];
        n && n.equals(c) || (t.push(c), n = c);
      }
    }
    return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]), t;
  }
  copy(e) {
    super.copy(e), this.curves = [];
    for (let t = 0, n = e.curves.length; t < n; t++) {
      const r = e.curves[t];
      this.curves.push(r.clone());
    }
    return this.autoClose = e.autoClose, this;
  }
  toJSON() {
    const e = super.toJSON();
    e.autoClose = this.autoClose, e.curves = [];
    for (let t = 0, n = this.curves.length; t < n; t++) {
      const r = this.curves[t];
      e.curves.push(r.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.autoClose = e.autoClose, this.curves = [];
    for (let t = 0, n = e.curves.length; t < n; t++) {
      const r = e.curves[t];
      this.curves.push(new _1[r.type]().fromJSON(r));
    }
    return this;
  }
}
let x1 = class extends s8 {
  /**
   * Constructs a new path.
   *
   * @param {Array<Vector2>} [points] - An array of 2D points defining the path.
   */
  constructor(e) {
    super(), this.type = "Path", this.currentPoint = new Le(), e && this.setFromPoints(e);
  }
  /**
   * Creates a path from the given list of points. The points are added
   * to the path as instances of {@link LineCurve}.
   *
   * @param {Array<Vector2>} points - An array of 2D points.
   * @return {Path} A reference to this path.
   */
  setFromPoints(e) {
    this.moveTo(e[0].x, e[0].y);
    for (let t = 1, n = e.length; t < n; t++)
      this.lineTo(e[t].x, e[t].y);
    return this;
  }
  /**
   * Moves {@link Path#currentPoint} to the given point.
   *
   * @param {number} x - The x coordinate.
   * @param {number} y - The y coordinate.
   * @return {Path} A reference to this path.
   */
  moveTo(e, t) {
    return this.currentPoint.set(e, t), this;
  }
  /**
   * Adds an instance of {@link LineCurve} to the path by connecting
   * the current point with the given one.
   *
   * @param {number} x - The x coordinate of the end point.
   * @param {number} y - The y coordinate of the end point.
   * @return {Path} A reference to this path.
   */
  lineTo(e, t) {
    const n = new V3(this.currentPoint.clone(), new Le(e, t));
    return this.curves.push(n), this.currentPoint.set(e, t), this;
  }
  /**
   * Adds an instance of {@link QuadraticBezierCurve} to the path by connecting
   * the current point with the given one.
   *
   * @param {number} aCPx - The x coordinate of the control point.
   * @param {number} aCPy - The y coordinate of the control point.
   * @param {number} aX - The x coordinate of the end point.
   * @param {number} aY - The y coordinate of the end point.
   * @return {Path} A reference to this path.
   */
  quadraticCurveTo(e, t, n, r) {
    const s = new G3(
      this.currentPoint.clone(),
      new Le(e, t),
      new Le(n, r)
    );
    return this.curves.push(s), this.currentPoint.set(n, r), this;
  }
  /**
   * Adds an instance of {@link CubicBezierCurve} to the path by connecting
   * the current point with the given one.
   *
   * @param {number} aCP1x - The x coordinate of the first control point.
   * @param {number} aCP1y - The y coordinate of the first control point.
   * @param {number} aCP2x - The x coordinate of the second control point.
   * @param {number} aCP2y - The y coordinate of the second control point.
   * @param {number} aX - The x coordinate of the end point.
   * @param {number} aY - The y coordinate of the end point.
   * @return {Path} A reference to this path.
   */
  bezierCurveTo(e, t, n, r, s, o) {
    const a = new O3(
      this.currentPoint.clone(),
      new Le(e, t),
      new Le(n, r),
      new Le(s, o)
    );
    return this.curves.push(a), this.currentPoint.set(s, o), this;
  }
  /**
   * Adds an instance of {@link SplineCurve} to the path by connecting
   * the current point with the given list of points.
   *
   * @param {Array<Vector2>} pts - An array of points in 2D space.
   * @return {Path} A reference to this path.
   */
  splineThru(e) {
    const t = [this.currentPoint.clone()].concat(e), n = new q3(t);
    return this.curves.push(n), this.currentPoint.copy(e[e.length - 1]), this;
  }
  /**
   * Adds an arc as an instance of {@link EllipseCurve} to the path, positioned relative
   * to the current point.
   *
   * @param {number} [aX=0] - The x coordinate of the center of the arc offsetted from the previous curve.
   * @param {number} [aY=0] - The y coordinate of the center of the arc offsetted from the previous curve.
   * @param {number} [aRadius=1] - The radius of the arc.
   * @param {number} [aStartAngle=0] - The start angle in radians.
   * @param {number} [aEndAngle=Math.PI*2] - The end angle in radians.
   * @param {boolean} [aClockwise=false] - Whether to sweep the arc clockwise or not.
   * @return {Path} A reference to this path.
   */
  arc(e, t, n, r, s, o) {
    const a = this.currentPoint.x, l = this.currentPoint.y;
    return this.absarc(
      e + a,
      t + l,
      n,
      r,
      s,
      o
    ), this;
  }
  /**
   * Adds an absolutely positioned arc as an instance of {@link EllipseCurve} to the path.
   *
   * @param {number} [aX=0] - The x coordinate of the center of the arc.
   * @param {number} [aY=0] - The y coordinate of the center of the arc.
   * @param {number} [aRadius=1] - The radius of the arc.
   * @param {number} [aStartAngle=0] - The start angle in radians.
   * @param {number} [aEndAngle=Math.PI*2] - The end angle in radians.
   * @param {boolean} [aClockwise=false] - Whether to sweep the arc clockwise or not.
   * @return {Path} A reference to this path.
   */
  absarc(e, t, n, r, s, o) {
    return this.absellipse(e, t, n, n, r, s, o), this;
  }
  /**
   * Adds an ellipse as an instance of {@link EllipseCurve} to the path, positioned relative
   * to the current point
   *
   * @param {number} [aX=0] - The x coordinate of the center of the ellipse offsetted from the previous curve.
   * @param {number} [aY=0] - The y coordinate of the center of the ellipse offsetted from the previous curve.
   * @param {number} [xRadius=1] - The radius of the ellipse in the x axis.
   * @param {number} [yRadius=1] - The radius of the ellipse in the y axis.
   * @param {number} [aStartAngle=0] - The start angle in radians.
   * @param {number} [aEndAngle=Math.PI*2] - The end angle in radians.
   * @param {boolean} [aClockwise=false] - Whether to sweep the ellipse clockwise or not.
   * @param {number} [aRotation=0] - The rotation angle of the ellipse in radians, counterclockwise from the positive X axis.
   * @return {Path} A reference to this path.
   */
  ellipse(e, t, n, r, s, o, a, l) {
    const u = this.currentPoint.x, c = this.currentPoint.y;
    return this.absellipse(e + u, t + c, n, r, s, o, a, l), this;
  }
  /**
   * Adds an absolutely positioned ellipse as an instance of {@link EllipseCurve} to the path.
   *
   * @param {number} [aX=0] - The x coordinate of the absolute center of the ellipse.
   * @param {number} [aY=0] - The y coordinate of the absolute center of the ellipse.
   * @param {number} [xRadius=1] - The radius of the ellipse in the x axis.
   * @param {number} [yRadius=1] - The radius of the ellipse in the y axis.
   * @param {number} [aStartAngle=0] - The start angle in radians.
   * @param {number} [aEndAngle=Math.PI*2] - The end angle in radians.
   * @param {boolean} [aClockwise=false] - Whether to sweep the ellipse clockwise or not.
   * @param {number} [aRotation=0] - The rotation angle of the ellipse in radians, counterclockwise from the positive X axis.
   * @return {Path} A reference to this path.
   */
  absellipse(e, t, n, r, s, o, a, l) {
    const u = new s2(e, t, n, r, s, o, a, l);
    if (this.curves.length > 0) {
      const A = u.getPoint(0);
      A.equals(this.currentPoint) || this.lineTo(A.x, A.y);
    }
    this.curves.push(u);
    const c = u.getPoint(1);
    return this.currentPoint.copy(c), this;
  }
  copy(e) {
    return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.currentPoint = this.currentPoint.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this;
  }
};
class lh extends x1 {
  /**
   * Constructs a new shape.
   *
   * @param {Array<Vector2>} [points] - An array of 2D points defining the shape.
   */
  constructor(e) {
    super(e), this.uuid = To(), this.type = "Shape", this.holes = [];
  }
  /**
   * Returns an array representing each contour of the holes
   * as a list of 2D points.
   *
   * @param {number} divisions - The fineness of the result.
   * @return {Array<Array<Vector2>>} The holes as a series of 2D points.
   */
  getPointsHoles(e) {
    const t = [];
    for (let n = 0, r = this.holes.length; n < r; n++)
      t[n] = this.holes[n].getPoints(e);
    return t;
  }
  // get points of shape and holes (keypoints based on segments parameter)
  /**
   * Returns an object that holds contour data for the shape and its holes as
   * arrays of 2D points.
   *
   * @param {number} divisions - The fineness of the result.
   * @return {{shape:Array<Vector2>,holes:Array<Array<Vector2>>}} An object with contour data.
   */
  extractPoints(e) {
    return {
      shape: this.getPoints(e),
      holes: this.getPointsHoles(e)
    };
  }
  copy(e) {
    super.copy(e), this.holes = [];
    for (let t = 0, n = e.holes.length; t < n; t++) {
      const r = e.holes[t];
      this.holes.push(r.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.uuid = this.uuid, e.holes = [];
    for (let t = 0, n = this.holes.length; t < n; t++) {
      const r = this.holes[t];
      e.holes.push(r.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.uuid = e.uuid, this.holes = [];
    for (let t = 0, n = e.holes.length; t < n; t++) {
      const r = e.holes[t];
      this.holes.push(new x1().fromJSON(r));
    }
    return this;
  }
}
function nO(i, e, t = 2) {
  const n = e && e.length, r = n ? e[0] * t : i.length;
  let s = o8(i, 0, r, t, !0);
  const o = [];
  if (!s || s.next === s.prev) return o;
  let a, l, u;
  if (n && (s = aO(i, e, s, t)), i.length > 80 * t) {
    a = i[0], l = i[1];
    let c = a, A = l;
    for (let m = t; m < r; m += t) {
      const _ = i[m], y = i[m + 1];
      _ < a && (a = _), y < l && (l = y), _ > c && (c = _), y > A && (A = y);
    }
    u = Math.max(c - a, A - l), u = u !== 0 ? 32767 / u : 0;
  }
  return kp(s, o, t, a, l, u, 0), o;
}
function o8(i, e, t, n, r) {
  let s;
  if (r === _O(i, e, t, n) > 0)
    for (let o = e; o < t; o += n) s = YM(o / n | 0, i[o], i[o + 1], s);
  else
    for (let o = t - n; o >= e; o -= n) s = YM(o / n | 0, i[o], i[o + 1], s);
  return s && Vf(s, s.next) && (Gp(s), s = s.next), s;
}
function qh(i, e) {
  if (!i) return i;
  e || (e = i);
  let t = i, n;
  do
    if (n = !1, !t.steiner && (Vf(t, t.next) || ji(t.prev, t, t.next) === 0)) {
      if (Gp(t), t = e = t.prev, t === t.next) break;
      n = !0;
    } else
      t = t.next;
  while (n || t !== e);
  return e;
}
function kp(i, e, t, n, r, s, o) {
  if (!i) return;
  !o && s && dO(i, n, r, s);
  let a = i;
  for (; i.prev !== i.next; ) {
    const l = i.prev, u = i.next;
    if (s ? rO(i, n, r, s) : iO(i)) {
      e.push(l.i, i.i, u.i), Gp(i), i = u.next, a = u.next;
      continue;
    }
    if (i = u, i === a) {
      o ? o === 1 ? (i = sO(qh(i), e), kp(i, e, t, n, r, s, 2)) : o === 2 && oO(i, e, t, n, r, s) : kp(qh(i), e, t, n, r, s, 1);
      break;
    }
  }
}
function iO(i) {
  const e = i.prev, t = i, n = i.next;
  if (ji(e, t, n) >= 0) return !1;
  const r = e.x, s = t.x, o = n.x, a = e.y, l = t.y, u = n.y, c = Math.min(r, s, o), A = Math.min(a, l, u), m = Math.max(r, s, o), _ = Math.max(a, l, u);
  let y = n.next;
  for (; y !== e; ) {
    if (y.x >= c && y.x <= m && y.y >= A && y.y <= _ && up(r, a, s, l, o, u, y.x, y.y) && ji(y.prev, y, y.next) >= 0) return !1;
    y = y.next;
  }
  return !0;
}
function rO(i, e, t, n) {
  const r = i.prev, s = i, o = i.next;
  if (ji(r, s, o) >= 0) return !1;
  const a = r.x, l = s.x, u = o.x, c = r.y, A = s.y, m = o.y, _ = Math.min(a, l, u), y = Math.min(c, A, m), T = Math.max(a, l, u), b = Math.max(c, A, m), S = kv(_, y, e, t, n), E = kv(T, b, e, t, n);
  let R = i.prevZ, C = i.nextZ;
  for (; R && R.z >= S && C && C.z <= E; ) {
    if (R.x >= _ && R.x <= T && R.y >= y && R.y <= b && R !== r && R !== o && up(a, c, l, A, u, m, R.x, R.y) && ji(R.prev, R, R.next) >= 0 || (R = R.prevZ, C.x >= _ && C.x <= T && C.y >= y && C.y <= b && C !== r && C !== o && up(a, c, l, A, u, m, C.x, C.y) && ji(C.prev, C, C.next) >= 0)) return !1;
    C = C.nextZ;
  }
  for (; R && R.z >= S; ) {
    if (R.x >= _ && R.x <= T && R.y >= y && R.y <= b && R !== r && R !== o && up(a, c, l, A, u, m, R.x, R.y) && ji(R.prev, R, R.next) >= 0) return !1;
    R = R.prevZ;
  }
  for (; C && C.z <= E; ) {
    if (C.x >= _ && C.x <= T && C.y >= y && C.y <= b && C !== r && C !== o && up(a, c, l, A, u, m, C.x, C.y) && ji(C.prev, C, C.next) >= 0) return !1;
    C = C.nextZ;
  }
  return !0;
}
function sO(i, e) {
  let t = i;
  do {
    const n = t.prev, r = t.next.next;
    !Vf(n, r) && l8(n, t, t.next, r) && Vp(n, r) && Vp(r, n) && (e.push(n.i, t.i, r.i), Gp(t), Gp(t.next), t = i = r), t = t.next;
  } while (t !== i);
  return qh(t);
}
function oO(i, e, t, n, r, s) {
  let o = i;
  do {
    let a = o.next.next;
    for (; a !== o.prev; ) {
      if (o.i !== a.i && pO(o, a)) {
        let l = u8(o, a);
        o = qh(o, o.next), l = qh(l, l.next), kp(o, e, t, n, r, s, 0), kp(l, e, t, n, r, s, 0);
        return;
      }
      a = a.next;
    }
    o = o.next;
  } while (o !== i);
}
function aO(i, e, t, n) {
  const r = [];
  for (let s = 0, o = e.length; s < o; s++) {
    const a = e[s] * n, l = s < o - 1 ? e[s + 1] * n : i.length, u = o8(i, a, l, n, !1);
    u === u.next && (u.steiner = !0), r.push(AO(u));
  }
  r.sort(lO);
  for (let s = 0; s < r.length; s++)
    t = uO(r[s], t);
  return t;
}
function lO(i, e) {
  let t = i.x - e.x;
  if (t === 0 && (t = i.y - e.y, t === 0)) {
    const n = (i.next.y - i.y) / (i.next.x - i.x), r = (e.next.y - e.y) / (e.next.x - e.x);
    t = n - r;
  }
  return t;
}
function uO(i, e) {
  const t = cO(i, e);
  if (!t)
    return e;
  const n = u8(t, i);
  return qh(n, n.next), qh(t, t.next);
}
function cO(i, e) {
  let t = e;
  const n = i.x, r = i.y;
  let s = -1 / 0, o;
  if (Vf(i, t)) return t;
  do {
    if (Vf(i, t.next)) return t.next;
    if (r <= t.y && r >= t.next.y && t.next.y !== t.y) {
      const A = t.x + (r - t.y) * (t.next.x - t.x) / (t.next.y - t.y);
      if (A <= n && A > s && (s = A, o = t.x < t.next.x ? t : t.next, A === n))
        return o;
    }
    t = t.next;
  } while (t !== e);
  if (!o) return null;
  const a = o, l = o.x, u = o.y;
  let c = 1 / 0;
  t = o;
  do {
    if (n >= t.x && t.x >= l && n !== t.x && a8(r < u ? n : s, r, l, u, r < u ? s : n, r, t.x, t.y)) {
      const A = Math.abs(r - t.y) / (n - t.x);
      Vp(t, i) && (A < c || A === c && (t.x > o.x || t.x === o.x && hO(o, t))) && (o = t, c = A);
    }
    t = t.next;
  } while (t !== a);
  return o;
}
function hO(i, e) {
  return ji(i.prev, i, e.prev) < 0 && ji(e.next, i, i.next) < 0;
}
function dO(i, e, t, n) {
  let r = i;
  do
    r.z === 0 && (r.z = kv(r.x, r.y, e, t, n)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next;
  while (r !== i);
  r.prevZ.nextZ = null, r.prevZ = null, fO(r);
}
function fO(i) {
  let e, t = 1;
  do {
    let n = i, r;
    i = null;
    let s = null;
    for (e = 0; n; ) {
      e++;
      let o = n, a = 0;
      for (let u = 0; u < t && (a++, o = o.nextZ, !!o); u++)
        ;
      let l = t;
      for (; a > 0 || l > 0 && o; )
        a !== 0 && (l === 0 || !o || n.z <= o.z) ? (r = n, n = n.nextZ, a--) : (r = o, o = o.nextZ, l--), s ? s.nextZ = r : i = r, r.prevZ = s, s = r;
      n = o;
    }
    s.nextZ = null, t *= 2;
  } while (e > 1);
  return i;
}
function kv(i, e, t, n, r) {
  return i = (i - t) * r | 0, e = (e - n) * r | 0, i = (i | i << 8) & 16711935, i = (i | i << 4) & 252645135, i = (i | i << 2) & 858993459, i = (i | i << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, i | e << 1;
}
function AO(i) {
  let e = i, t = i;
  do
    (e.x < t.x || e.x === t.x && e.y < t.y) && (t = e), e = e.next;
  while (e !== i);
  return t;
}
function a8(i, e, t, n, r, s, o, a) {
  return (r - o) * (e - a) >= (i - o) * (s - a) && (i - o) * (n - a) >= (t - o) * (e - a) && (t - o) * (s - a) >= (r - o) * (n - a);
}
function up(i, e, t, n, r, s, o, a) {
  return !(i === o && e === a) && a8(i, e, t, n, r, s, o, a);
}
function pO(i, e) {
  return i.next.i !== e.i && i.prev.i !== e.i && !mO(i, e) && // doesn't intersect other edges
  (Vp(i, e) && Vp(e, i) && gO(i, e) && // locally visible
  (ji(i.prev, i, e.prev) || ji(i, e.prev, e)) || // does not create opposite-facing sectors
  Vf(i, e) && ji(i.prev, i, i.next) > 0 && ji(e.prev, e, e.next) > 0);
}
function ji(i, e, t) {
  return (e.y - i.y) * (t.x - e.x) - (e.x - i.x) * (t.y - e.y);
}
function Vf(i, e) {
  return i.x === e.x && i.y === e.y;
}
function l8(i, e, t, n) {
  const r = Om(ji(i, e, t)), s = Om(ji(i, e, n)), o = Om(ji(t, n, i)), a = Om(ji(t, n, e));
  return !!(r !== s && o !== a || r === 0 && Um(i, t, e) || s === 0 && Um(i, n, e) || o === 0 && Um(t, i, n) || a === 0 && Um(t, e, n));
}
function Um(i, e, t) {
  return e.x <= Math.max(i.x, t.x) && e.x >= Math.min(i.x, t.x) && e.y <= Math.max(i.y, t.y) && e.y >= Math.min(i.y, t.y);
}
function Om(i) {
  return i > 0 ? 1 : i < 0 ? -1 : 0;
}
function mO(i, e) {
  let t = i;
  do {
    if (t.i !== i.i && t.next.i !== i.i && t.i !== e.i && t.next.i !== e.i && l8(t, t.next, i, e)) return !0;
    t = t.next;
  } while (t !== i);
  return !1;
}
function Vp(i, e) {
  return ji(i.prev, i, i.next) < 0 ? ji(i, e, i.next) >= 0 && ji(i, i.prev, e) >= 0 : ji(i, e, i.prev) < 0 || ji(i, i.next, e) < 0;
}
function gO(i, e) {
  let t = i, n = !1;
  const r = (i.x + e.x) / 2, s = (i.y + e.y) / 2;
  do
    t.y > s != t.next.y > s && t.next.y !== t.y && r < (t.next.x - t.x) * (s - t.y) / (t.next.y - t.y) + t.x && (n = !n), t = t.next;
  while (t !== i);
  return n;
}
function u8(i, e) {
  const t = Vv(i.i, i.x, i.y), n = Vv(e.i, e.x, e.y), r = i.next, s = e.prev;
  return i.next = e, e.prev = i, t.next = r, r.prev = t, n.next = t, t.prev = n, s.next = n, n.prev = s, n;
}
function YM(i, e, t, n) {
  const r = Vv(i, e, t);
  return n ? (r.next = n.next, r.prev = n, n.next.prev = r, n.next = r) : (r.prev = r, r.next = r), r;
}
function Gp(i) {
  i.next.prev = i.prev, i.prev.next = i.next, i.prevZ && (i.prevZ.nextZ = i.nextZ), i.nextZ && (i.nextZ.prevZ = i.prevZ);
}
function Vv(i, e, t) {
  return {
    i,
    // vertex index in coordinates array
    x: e,
    y: t,
    // vertex coordinates
    prev: null,
    // previous and next vertex nodes in a polygon ring
    next: null,
    z: 0,
    // z-order curve value
    prevZ: null,
    // previous and next nodes in z-order
    nextZ: null,
    steiner: !1
    // indicates whether this is a steiner point
  };
}
function _O(i, e, t, n) {
  let r = 0;
  for (let s = e, o = t - n; s < t; s += n)
    r += (i[o] - i[s]) * (i[s + 1] + i[o + 1]), o = s;
  return r;
}
class xO {
  /**
   * Triangulates the given shape definition by returning an array of triangles.
   *
   * @param {Array<number>} data - An array with 2D points.
   * @param {Array<number>} holeIndices - An array with indices defining holes.
   * @param {number} [dim=2] - The number of coordinates per vertex in the input array.
   * @return {Array<number>} An array representing the triangulated faces. Each face is defined by three consecutive numbers
   * representing vertex indices.
   */
  static triangulate(e, t, n = 2) {
    return nO(e, t, n);
  }
}
class ma {
  /**
   * Calculate area of a ( 2D ) contour polygon.
   *
   * @param {Array<Vector2>} contour - An array of 2D points.
   * @return {number} The area.
   */
  static area(e) {
    const t = e.length;
    let n = 0;
    for (let r = t - 1, s = 0; s < t; r = s++)
      n += e[r].x * e[s].y - e[s].x * e[r].y;
    return n * 0.5;
  }
  /**
   * Returns `true` if the given contour uses a clockwise winding order.
   *
   * @param {Array<Vector2>} pts - An array of 2D points defining a polygon.
   * @return {boolean} Whether the given contour uses a clockwise winding order or not.
   */
  static isClockWise(e) {
    return ma.area(e) < 0;
  }
  /**
   * Triangulates the given shape definition.
   *
   * @param {Array<Vector2>} contour - An array of 2D points defining the contour.
   * @param {Array<Array<Vector2>>} holes - An array that holds arrays of 2D points defining the holes.
   * @return {Array<Array<number>>} An array that holds for each face definition an array with three indices.
   */
  static triangulateShape(e, t) {
    const n = [], r = [], s = [];
    QM(e), KM(n, e);
    let o = e.length;
    t.forEach(QM);
    for (let l = 0; l < t.length; l++)
      r.push(o), o += t[l].length, KM(n, t[l]);
    const a = xO.triangulate(n, r);
    for (let l = 0; l < a.length; l += 3)
      s.push(a.slice(l, l + 3));
    return s;
  }
}
function QM(i) {
  const e = i.length;
  e > 2 && i[e - 1].equals(i[0]) && i.pop();
}
function KM(i, e) {
  for (let t = 0; t < e.length; t++)
    i.push(e[t].x), i.push(e[t].y);
}
class w0 extends Yt {
  /**
   * Constructs a new extrude geometry.
   *
   * @param {Shape|Array<Shape>} [shapes] - A shape or an array of shapes.
   * @param {ExtrudeGeometry~Options} [options] - The extrude settings.
   */
  constructor(e = new lh([new Le(0.5, 0.5), new Le(-0.5, 0.5), new Le(-0.5, -0.5), new Le(0.5, -0.5)]), t = {}) {
    super(), this.type = "ExtrudeGeometry", this.parameters = {
      shapes: e,
      options: t
    }, e = Array.isArray(e) ? e : [e];
    const n = this, r = [], s = [];
    for (let a = 0, l = e.length; a < l; a++) {
      const u = e[a];
      o(u);
    }
    this.setAttribute("position", new xt(r, 3)), this.setAttribute("uv", new xt(s, 2)), this.computeVertexNormals();
    function o(a) {
      const l = [], u = t.curveSegments !== void 0 ? t.curveSegments : 12, c = t.steps !== void 0 ? t.steps : 1, A = t.depth !== void 0 ? t.depth : 1;
      let m = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0, _ = t.bevelThickness !== void 0 ? t.bevelThickness : 0.2, y = t.bevelSize !== void 0 ? t.bevelSize : _ - 0.1, T = t.bevelOffset !== void 0 ? t.bevelOffset : 0, b = t.bevelSegments !== void 0 ? t.bevelSegments : 3;
      const S = t.extrudePath, E = t.UVGenerator !== void 0 ? t.UVGenerator : yO;
      let R, C = !1, L, D, B, U;
      if (S) {
        R = S.getSpacedPoints(c), C = !0, m = !1;
        const ue = S.isCatmullRomCurve3 ? S.closed : !1;
        L = S.computeFrenetFrames(c, ue), D = new j(), B = new j(), U = new j();
      }
      m || (b = 0, _ = 0, y = 0, T = 0);
      const N = a.extractPoints(u);
      let O = N.shape;
      const G = N.holes;
      if (!ma.isClockWise(O)) {
        O = O.reverse();
        for (let ue = 0, he = G.length; ue < he; ue++) {
          const Ee = G[ue];
          ma.isClockWise(Ee) && (G[ue] = Ee.reverse());
        }
      }
      function Y(ue) {
        const Ee = 10000000000000001e-36;
        let Ye = ue[0];
        for (let te = 1; te <= ue.length; te++) {
          const Et = te % ue.length, dt = ue[Et], Nt = dt.x - Ye.x, rt = dt.y - Ye.y, ne = Nt * Nt + rt * rt, W = Math.max(
            Math.abs(dt.x),
            Math.abs(dt.y),
            Math.abs(Ye.x),
            Math.abs(Ye.y)
          ), ge = Ee * W * W;
          if (ne <= ge) {
            ue.splice(Et, 1), te--;
            continue;
          }
          Ye = dt;
        }
      }
      Y(O), G.forEach(Y);
      const K = G.length, X = O;
      for (let ue = 0; ue < K; ue++) {
        const he = G[ue];
        O = O.concat(he);
      }
      function ee(ue, he, Ee) {
        return he || Ie("ExtrudeGeometry: vec does not exist"), ue.clone().addScaledVector(he, Ee);
      }
      const oe = O.length;
      function fe(ue, he, Ee) {
        let Ye, te, Et;
        const dt = ue.x - he.x, Nt = ue.y - he.y, rt = Ee.x - ue.x, ne = Ee.y - ue.y, W = dt * dt + Nt * Nt, ge = dt * ne - Nt * rt;
        if (Math.abs(ge) > Number.EPSILON) {
          const Fe = Math.sqrt(W), We = Math.sqrt(rt * rt + ne * ne), Oe = he.x - Nt / Fe, kt = he.y + dt / Fe, ft = Ee.x - ne / We, Ft = Ee.y + rt / We, nn = ((ft - Oe) * ne - (Ft - kt) * rt) / (dt * ne - Nt * rt);
          Ye = Oe + dt * nn - ue.x, te = kt + Nt * nn - ue.y;
          const tt = Ye * Ye + te * te;
          if (tt <= 2)
            return new Le(Ye, te);
          Et = Math.sqrt(tt / 2);
        } else {
          let Fe = !1;
          dt > Number.EPSILON ? rt > Number.EPSILON && (Fe = !0) : dt < -Number.EPSILON ? rt < -Number.EPSILON && (Fe = !0) : Math.sign(Nt) === Math.sign(ne) && (Fe = !0), Fe ? (Ye = -Nt, te = dt, Et = Math.sqrt(W)) : (Ye = dt, te = Nt, Et = Math.sqrt(W / 2));
        }
        return new Le(Ye / Et, te / Et);
      }
      const _e = [];
      for (let ue = 0, he = X.length, Ee = he - 1, Ye = ue + 1; ue < he; ue++, Ee++, Ye++)
        Ee === he && (Ee = 0), Ye === he && (Ye = 0), _e[ue] = fe(X[ue], X[Ee], X[Ye]);
      const Te = [];
      let Ce, Je = _e.concat();
      for (let ue = 0, he = K; ue < he; ue++) {
        const Ee = G[ue];
        Ce = [];
        for (let Ye = 0, te = Ee.length, Et = te - 1, dt = Ye + 1; Ye < te; Ye++, Et++, dt++)
          Et === te && (Et = 0), dt === te && (dt = 0), Ce[Ye] = fe(Ee[Ye], Ee[Et], Ee[dt]);
        Te.push(Ce), Je = Je.concat(Ce);
      }
      let Qe;
      if (b === 0)
        Qe = ma.triangulateShape(X, G);
      else {
        const ue = [], he = [];
        for (let Ee = 0; Ee < b; Ee++) {
          const Ye = Ee / b, te = _ * Math.cos(Ye * Math.PI / 2), Et = y * Math.sin(Ye * Math.PI / 2) + T;
          for (let dt = 0, Nt = X.length; dt < Nt; dt++) {
            const rt = ee(X[dt], _e[dt], Et);
            wt(rt.x, rt.y, -te), Ye === 0 && ue.push(rt);
          }
          for (let dt = 0, Nt = K; dt < Nt; dt++) {
            const rt = G[dt];
            Ce = Te[dt];
            const ne = [];
            for (let W = 0, ge = rt.length; W < ge; W++) {
              const Fe = ee(rt[W], Ce[W], Et);
              wt(Fe.x, Fe.y, -te), Ye === 0 && ne.push(Fe);
            }
            Ye === 0 && he.push(ne);
          }
        }
        Qe = ma.triangulateShape(ue, he);
      }
      const zt = Qe.length, Tt = y + T;
      for (let ue = 0; ue < oe; ue++) {
        const he = m ? ee(O[ue], Je[ue], Tt) : O[ue];
        C ? (B.copy(L.normals[0]).multiplyScalar(he.x), D.copy(L.binormals[0]).multiplyScalar(he.y), U.copy(R[0]).add(B).add(D), wt(U.x, U.y, U.z)) : wt(he.x, he.y, 0);
      }
      for (let ue = 1; ue <= c; ue++)
        for (let he = 0; he < oe; he++) {
          const Ee = m ? ee(O[he], Je[he], Tt) : O[he];
          C ? (B.copy(L.normals[ue]).multiplyScalar(Ee.x), D.copy(L.binormals[ue]).multiplyScalar(Ee.y), U.copy(R[ue]).add(B).add(D), wt(U.x, U.y, U.z)) : wt(Ee.x, Ee.y, A / c * ue);
        }
      for (let ue = b - 1; ue >= 0; ue--) {
        const he = ue / b, Ee = _ * Math.cos(he * Math.PI / 2), Ye = y * Math.sin(he * Math.PI / 2) + T;
        for (let te = 0, Et = X.length; te < Et; te++) {
          const dt = ee(X[te], _e[te], Ye);
          wt(dt.x, dt.y, A + Ee);
        }
        for (let te = 0, Et = G.length; te < Et; te++) {
          const dt = G[te];
          Ce = Te[te];
          for (let Nt = 0, rt = dt.length; Nt < rt; Nt++) {
            const ne = ee(dt[Nt], Ce[Nt], Ye);
            C ? wt(ne.x, ne.y + R[c - 1].y, R[c - 1].x + Ee) : wt(ne.x, ne.y, A + Ee);
          }
        }
      }
      Pe(), ke();
      function Pe() {
        const ue = r.length / 3;
        if (m) {
          let he = 0, Ee = oe * he;
          for (let Ye = 0; Ye < zt; Ye++) {
            const te = Qe[Ye];
            ot(te[2] + Ee, te[1] + Ee, te[0] + Ee);
          }
          he = c + b * 2, Ee = oe * he;
          for (let Ye = 0; Ye < zt; Ye++) {
            const te = Qe[Ye];
            ot(te[0] + Ee, te[1] + Ee, te[2] + Ee);
          }
        } else {
          for (let he = 0; he < zt; he++) {
            const Ee = Qe[he];
            ot(Ee[2], Ee[1], Ee[0]);
          }
          for (let he = 0; he < zt; he++) {
            const Ee = Qe[he];
            ot(Ee[0] + oe * c, Ee[1] + oe * c, Ee[2] + oe * c);
          }
        }
        n.addGroup(ue, r.length / 3 - ue, 0);
      }
      function ke() {
        const ue = r.length / 3;
        let he = 0;
        at(X, he), he += X.length;
        for (let Ee = 0, Ye = G.length; Ee < Ye; Ee++) {
          const te = G[Ee];
          at(te, he), he += te.length;
        }
        n.addGroup(ue, r.length / 3 - ue, 1);
      }
      function at(ue, he) {
        let Ee = ue.length;
        for (; --Ee >= 0; ) {
          const Ye = Ee;
          let te = Ee - 1;
          te < 0 && (te = ue.length - 1);
          for (let Et = 0, dt = c + b * 2; Et < dt; Et++) {
            const Nt = oe * Et, rt = oe * (Et + 1), ne = he + Ye + Nt, W = he + te + Nt, ge = he + te + rt, Fe = he + Ye + rt;
            Wt(ne, W, ge, Fe);
          }
        }
      }
      function wt(ue, he, Ee) {
        l.push(ue), l.push(he), l.push(Ee);
      }
      function ot(ue, he, Ee) {
        en(ue), en(he), en(Ee);
        const Ye = r.length / 3, te = E.generateTopUV(n, r, Ye - 3, Ye - 2, Ye - 1);
        z(te[0]), z(te[1]), z(te[2]);
      }
      function Wt(ue, he, Ee, Ye) {
        en(ue), en(he), en(Ye), en(he), en(Ee), en(Ye);
        const te = r.length / 3, Et = E.generateSideWallUV(n, r, te - 6, te - 3, te - 2, te - 1);
        z(Et[0]), z(Et[1]), z(Et[3]), z(Et[1]), z(Et[2]), z(Et[3]);
      }
      function en(ue) {
        r.push(l[ue * 3 + 0]), r.push(l[ue * 3 + 1]), r.push(l[ue * 3 + 2]);
      }
      function z(ue) {
        s.push(ue.x), s.push(ue.y);
      }
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON(), t = this.parameters.shapes, n = this.parameters.options;
    return vO(t, n, e);
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @param {Array<Shape>} shapes - An array of shapes.
   * @return {ExtrudeGeometry} A new instance.
   */
  static fromJSON(e, t) {
    const n = [];
    for (let s = 0, o = e.shapes.length; s < o; s++) {
      const a = t[e.shapes[s]];
      n.push(a);
    }
    const r = e.options.extrudePath;
    return r !== void 0 && (e.options.extrudePath = new _1[r.type]().fromJSON(r)), new w0(n, e.options);
  }
}
const yO = {
  generateTopUV: function(i, e, t, n, r) {
    const s = e[t * 3], o = e[t * 3 + 1], a = e[n * 3], l = e[n * 3 + 1], u = e[r * 3], c = e[r * 3 + 1];
    return [
      new Le(s, o),
      new Le(a, l),
      new Le(u, c)
    ];
  },
  generateSideWallUV: function(i, e, t, n, r, s) {
    const o = e[t * 3], a = e[t * 3 + 1], l = e[t * 3 + 2], u = e[n * 3], c = e[n * 3 + 1], A = e[n * 3 + 2], m = e[r * 3], _ = e[r * 3 + 1], y = e[r * 3 + 2], T = e[s * 3], b = e[s * 3 + 1], S = e[s * 3 + 2];
    return Math.abs(a - c) < Math.abs(o - u) ? [
      new Le(o, 1 - l),
      new Le(u, 1 - A),
      new Le(m, 1 - y),
      new Le(T, 1 - S)
    ] : [
      new Le(a, 1 - l),
      new Le(c, 1 - A),
      new Le(_, 1 - y),
      new Le(b, 1 - S)
    ];
  }
};
function vO(i, e, t) {
  if (t.shapes = [], Array.isArray(i))
    for (let n = 0, r = i.length; n < r; n++) {
      const s = i[n];
      t.shapes.push(s.uuid);
    }
  else
    t.shapes.push(i.uuid);
  return t.options = Object.assign({}, e), e.extrudePath !== void 0 && (t.options.extrudePath = e.extrudePath.toJSON()), t;
}
class o2 extends tc {
  /**
   * Constructs a new icosahedron geometry.
   *
   * @param {number} [radius=1] - Radius of the icosahedron.
   * @param {number} [detail=0] - Setting this to a value greater than `0` adds vertices making it no longer a icosahedron.
   */
  constructor(e = 1, t = 0) {
    const n = (1 + Math.sqrt(5)) / 2, r = [
      -1,
      n,
      0,
      1,
      n,
      0,
      -1,
      -n,
      0,
      1,
      -n,
      0,
      0,
      -1,
      n,
      0,
      1,
      n,
      0,
      -1,
      -n,
      0,
      1,
      -n,
      n,
      0,
      -1,
      n,
      0,
      1,
      -n,
      0,
      -1,
      -n,
      0,
      1
    ], s = [
      0,
      11,
      5,
      0,
      5,
      1,
      0,
      1,
      7,
      0,
      7,
      10,
      0,
      10,
      11,
      1,
      5,
      9,
      5,
      11,
      4,
      11,
      10,
      2,
      10,
      7,
      6,
      7,
      1,
      8,
      3,
      9,
      4,
      3,
      4,
      2,
      3,
      2,
      6,
      3,
      6,
      8,
      3,
      8,
      9,
      4,
      9,
      5,
      2,
      4,
      11,
      6,
      2,
      10,
      8,
      6,
      7,
      9,
      8,
      1
    ];
    super(r, s, e, t), this.type = "IcosahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {IcosahedronGeometry} A new instance.
   */
  static fromJSON(e) {
    return new o2(e.radius, e.detail);
  }
}
class a2 extends Yt {
  /**
   * Constructs a new lathe geometry.
   *
   * @param {Array<Vector2|Vector3>} [points] - An array of points in 2D space. The x-coordinate of each point
   * must be greater than zero.
   * @param {number} [segments=12] - The number of circumference segments to generate.
   * @param {number} [phiStart=0] - The starting angle in radians.
   * @param {number} [phiLength=Math.PI*2] - The radian (0 to 2PI) range of the lathed section 2PI is a
   * closed lathe, less than 2PI is a portion.
   */
  constructor(e = [new Le(0, -0.5), new Le(0.5, 0), new Le(0, 0.5)], t = 12, n = 0, r = Math.PI * 2) {
    super(), this.type = "LatheGeometry", this.parameters = {
      points: e,
      segments: t,
      phiStart: n,
      phiLength: r
    }, t = Math.floor(t), r = dn(r, 0, Math.PI * 2);
    const s = [], o = [], a = [], l = [], u = [], c = 1 / t, A = new j(), m = new Le(), _ = new j(), y = new j(), T = new j();
    let b = 0, S = 0;
    for (let E = 0; E <= e.length - 1; E++)
      switch (E) {
        case 0:
          b = e[E + 1].x - e[E].x, S = e[E + 1].y - e[E].y, _.x = S * 1, _.y = -b, _.z = S * 0, T.copy(_), _.normalize(), l.push(_.x, _.y, _.z);
          break;
        case e.length - 1:
          l.push(T.x, T.y, T.z);
          break;
        default:
          b = e[E + 1].x - e[E].x, S = e[E + 1].y - e[E].y, _.x = S * 1, _.y = -b, _.z = S * 0, y.copy(_), _.x += T.x, _.y += T.y, _.z += T.z, _.normalize(), l.push(_.x, _.y, _.z), T.copy(y);
      }
    for (let E = 0; E <= t; E++) {
      const R = n + E * c * r, C = Math.sin(R), L = Math.cos(R);
      for (let D = 0; D <= e.length - 1; D++) {
        A.x = e[D].x * C, A.y = e[D].y, A.z = e[D].x * L, o.push(A.x, A.y, A.z), m.x = E / t, m.y = D / (e.length - 1), a.push(m.x, m.y);
        const B = l[3 * D + 0] * C, U = l[3 * D + 1], N = l[3 * D + 0] * L;
        u.push(B, U, N);
      }
    }
    for (let E = 0; E < t; E++)
      for (let R = 0; R < e.length - 1; R++) {
        const C = R + E * e.length, L = C, D = C + e.length, B = C + e.length + 1, U = C + 1;
        s.push(L, D, U), s.push(B, U, D);
      }
    this.setIndex(s), this.setAttribute("position", new xt(o, 3)), this.setAttribute("uv", new xt(a, 2)), this.setAttribute("normal", new xt(u, 3));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {LatheGeometry} A new instance.
   */
  static fromJSON(e) {
    return new a2(e.points, e.segments, e.phiStart, e.phiLength);
  }
}
class M0 extends tc {
  /**
   * Constructs a new octahedron geometry.
   *
   * @param {number} [radius=1] - Radius of the octahedron.
   * @param {number} [detail=0] - Setting this to a value greater than `0` adds vertices making it no longer a octahedron.
   */
  constructor(e = 1, t = 0) {
    const n = [
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1
    ], r = [
      0,
      2,
      4,
      0,
      4,
      3,
      0,
      3,
      5,
      0,
      5,
      2,
      1,
      2,
      5,
      1,
      5,
      3,
      1,
      3,
      4,
      1,
      4,
      2
    ];
    super(n, r, e, t), this.type = "OctahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {OctahedronGeometry} A new instance.
   */
  static fromJSON(e) {
    return new M0(e.radius, e.detail);
  }
}
class td extends Yt {
  /**
   * Constructs a new plane geometry.
   *
   * @param {number} [width=1] - The width along the X axis.
   * @param {number} [height=1] - The height along the Y axis
   * @param {number} [widthSegments=1] - The number of segments along the X axis.
   * @param {number} [heightSegments=1] - The number of segments along the Y axis.
   */
  constructor(e = 1, t = 1, n = 1, r = 1) {
    super(), this.type = "PlaneGeometry", this.parameters = {
      width: e,
      height: t,
      widthSegments: n,
      heightSegments: r
    };
    const s = e / 2, o = t / 2, a = Math.floor(n), l = Math.floor(r), u = a + 1, c = l + 1, A = e / a, m = t / l, _ = [], y = [], T = [], b = [];
    for (let S = 0; S < c; S++) {
      const E = S * m - o;
      for (let R = 0; R < u; R++) {
        const C = R * A - s;
        y.push(C, -E, 0), T.push(0, 0, 1), b.push(R / a), b.push(1 - S / l);
      }
    }
    for (let S = 0; S < l; S++)
      for (let E = 0; E < a; E++) {
        const R = E + u * S, C = E + u * (S + 1), L = E + 1 + u * (S + 1), D = E + 1 + u * S;
        _.push(R, C, D), _.push(C, L, D);
      }
    this.setIndex(_), this.setAttribute("position", new xt(y, 3)), this.setAttribute("normal", new xt(T, 3)), this.setAttribute("uv", new xt(b, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {PlaneGeometry} A new instance.
   */
  static fromJSON(e) {
    return new td(e.width, e.height, e.widthSegments, e.heightSegments);
  }
}
class l2 extends Yt {
  /**
   * Constructs a new ring geometry.
   *
   * @param {number} [innerRadius=0.5] - The inner radius of the ring.
   * @param {number} [outerRadius=1] - The outer radius of the ring.
   * @param {number} [thetaSegments=32] - Number of segments. A higher number means the ring will be more round. Minimum is `3`.
   * @param {number} [phiSegments=1] - Number of segments per ring segment. Minimum is `1`.
   * @param {number} [thetaStart=0] - Starting angle in radians.
   * @param {number} [thetaLength=Math.PI*2] - Central angle in radians.
   */
  constructor(e = 0.5, t = 1, n = 32, r = 1, s = 0, o = Math.PI * 2) {
    super(), this.type = "RingGeometry", this.parameters = {
      innerRadius: e,
      outerRadius: t,
      thetaSegments: n,
      phiSegments: r,
      thetaStart: s,
      thetaLength: o
    }, n = Math.max(3, n), r = Math.max(1, r);
    const a = [], l = [], u = [], c = [];
    let A = e;
    const m = (t - e) / r, _ = new j(), y = new Le();
    for (let T = 0; T <= r; T++) {
      for (let b = 0; b <= n; b++) {
        const S = s + b / n * o;
        _.x = A * Math.cos(S), _.y = A * Math.sin(S), l.push(_.x, _.y, _.z), u.push(0, 0, 1), y.x = (_.x / t + 1) / 2, y.y = (_.y / t + 1) / 2, c.push(y.x, y.y);
      }
      A += m;
    }
    for (let T = 0; T < r; T++) {
      const b = T * (n + 1);
      for (let S = 0; S < n; S++) {
        const E = S + b, R = E, C = E + n + 1, L = E + n + 2, D = E + 1;
        a.push(R, C, D), a.push(C, L, D);
      }
    }
    this.setIndex(a), this.setAttribute("position", new xt(l, 3)), this.setAttribute("normal", new xt(u, 3)), this.setAttribute("uv", new xt(c, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {RingGeometry} A new instance.
   */
  static fromJSON(e) {
    return new l2(e.innerRadius, e.outerRadius, e.thetaSegments, e.phiSegments, e.thetaStart, e.thetaLength);
  }
}
class u2 extends Yt {
  /**
   * Constructs a new shape geometry.
   *
   * @param {Shape|Array<Shape>} [shapes] - A shape or an array of shapes.
   * @param {number} [curveSegments=12] - Number of segments per shape.
   */
  constructor(e = new lh([new Le(0, 0.5), new Le(-0.5, -0.5), new Le(0.5, -0.5)]), t = 12) {
    super(), this.type = "ShapeGeometry", this.parameters = {
      shapes: e,
      curveSegments: t
    };
    const n = [], r = [], s = [], o = [];
    let a = 0, l = 0;
    if (Array.isArray(e) === !1)
      u(e);
    else
      for (let c = 0; c < e.length; c++)
        u(e[c]), this.addGroup(a, l, c), a += l, l = 0;
    this.setIndex(n), this.setAttribute("position", new xt(r, 3)), this.setAttribute("normal", new xt(s, 3)), this.setAttribute("uv", new xt(o, 2));
    function u(c) {
      const A = r.length / 3, m = c.extractPoints(t);
      let _ = m.shape;
      const y = m.holes;
      ma.isClockWise(_) === !1 && (_ = _.reverse());
      for (let b = 0, S = y.length; b < S; b++) {
        const E = y[b];
        ma.isClockWise(E) === !0 && (y[b] = E.reverse());
      }
      const T = ma.triangulateShape(_, y);
      for (let b = 0, S = y.length; b < S; b++) {
        const E = y[b];
        _ = _.concat(E);
      }
      for (let b = 0, S = _.length; b < S; b++) {
        const E = _[b];
        r.push(E.x, E.y, 0), s.push(0, 0, 1), o.push(E.x, E.y);
      }
      for (let b = 0, S = T.length; b < S; b++) {
        const E = T[b], R = E[0] + A, C = E[1] + A, L = E[2] + A;
        n.push(R, C, L), l += 3;
      }
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON(), t = this.parameters.shapes;
    return bO(t, e);
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @param {Array<Shape>} shapes - An array of shapes.
   * @return {ShapeGeometry} A new instance.
   */
  static fromJSON(e, t) {
    const n = [];
    for (let r = 0, s = e.shapes.length; r < s; r++) {
      const o = t[e.shapes[r]];
      n.push(o);
    }
    return new u2(n, e.curveSegments);
  }
}
function bO(i, e) {
  if (e.shapes = [], Array.isArray(i))
    for (let t = 0, n = i.length; t < n; t++) {
      const r = i[t];
      e.shapes.push(r.uuid);
    }
  else
    e.shapes.push(i.uuid);
  return e;
}
class Co extends Yt {
  /**
   * Constructs a new sphere geometry.
   *
   * @param {number} [radius=1] - The sphere radius.
   * @param {number} [widthSegments=32] - The number of horizontal segments. Minimum value is `3`.
   * @param {number} [heightSegments=16] - The number of vertical segments. Minimum value is `2`.
   * @param {number} [phiStart=0] - The horizontal starting angle in radians.
   * @param {number} [phiLength=Math.PI*2] - The horizontal sweep angle size.
   * @param {number} [thetaStart=0] - The vertical starting angle in radians.
   * @param {number} [thetaLength=Math.PI] - The vertical sweep angle size.
   */
  constructor(e = 1, t = 32, n = 16, r = 0, s = Math.PI * 2, o = 0, a = Math.PI) {
    super(), this.type = "SphereGeometry", this.parameters = {
      radius: e,
      widthSegments: t,
      heightSegments: n,
      phiStart: r,
      phiLength: s,
      thetaStart: o,
      thetaLength: a
    }, t = Math.max(3, Math.floor(t)), n = Math.max(2, Math.floor(n));
    const l = Math.min(o + a, Math.PI);
    let u = 0;
    const c = [], A = new j(), m = new j(), _ = [], y = [], T = [], b = [];
    for (let S = 0; S <= n; S++) {
      const E = [], R = S / n;
      let C = 0;
      S === 0 && o === 0 ? C = 0.5 / t : S === n && l === Math.PI && (C = -0.5 / t);
      for (let L = 0; L <= t; L++) {
        const D = L / t;
        A.x = -e * Math.cos(r + D * s) * Math.sin(o + R * a), A.y = e * Math.cos(o + R * a), A.z = e * Math.sin(r + D * s) * Math.sin(o + R * a), y.push(A.x, A.y, A.z), m.copy(A).normalize(), T.push(m.x, m.y, m.z), b.push(D + C, 1 - R), E.push(u++);
      }
      c.push(E);
    }
    for (let S = 0; S < n; S++)
      for (let E = 0; E < t; E++) {
        const R = c[S][E + 1], C = c[S][E], L = c[S + 1][E], D = c[S + 1][E + 1];
        (S !== 0 || o > 0) && _.push(R, C, D), (S !== n - 1 || l < Math.PI) && _.push(C, L, D);
      }
    this.setIndex(_), this.setAttribute("position", new xt(y, 3)), this.setAttribute("normal", new xt(T, 3)), this.setAttribute("uv", new xt(b, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {SphereGeometry} A new instance.
   */
  static fromJSON(e) {
    return new Co(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength);
  }
}
class c2 extends tc {
  /**
   * Constructs a new tetrahedron geometry.
   *
   * @param {number} [radius=1] - Radius of the tetrahedron.
   * @param {number} [detail=0] - Setting this to a value greater than `0` adds vertices making it no longer a tetrahedron.
   */
  constructor(e = 1, t = 0) {
    const n = [
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      1,
      -1,
      -1
    ], r = [
      2,
      1,
      0,
      0,
      3,
      2,
      1,
      3,
      0,
      2,
      3,
      1
    ];
    super(n, r, e, t), this.type = "TetrahedronGeometry", this.parameters = {
      radius: e,
      detail: t
    };
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {TetrahedronGeometry} A new instance.
   */
  static fromJSON(e) {
    return new c2(e.radius, e.detail);
  }
}
class h2 extends Yt {
  /**
   * Constructs a new torus geometry.
   *
   * @param {number} [radius=1] - Radius of the torus, from the center of the torus to the center of the tube.
   * @param {number} [tube=0.4] - Radius of the tube. Must be smaller than `radius`.
   * @param {number} [radialSegments=12] - The number of radial segments.
   * @param {number} [tubularSegments=48] - The number of tubular segments.
   * @param {number} [arc=Math.PI*2] - Central angle in radians.
   */
  constructor(e = 1, t = 0.4, n = 12, r = 48, s = Math.PI * 2) {
    super(), this.type = "TorusGeometry", this.parameters = {
      radius: e,
      tube: t,
      radialSegments: n,
      tubularSegments: r,
      arc: s
    }, n = Math.floor(n), r = Math.floor(r);
    const o = [], a = [], l = [], u = [], c = new j(), A = new j(), m = new j();
    for (let _ = 0; _ <= n; _++)
      for (let y = 0; y <= r; y++) {
        const T = y / r * s, b = _ / n * Math.PI * 2;
        A.x = (e + t * Math.cos(b)) * Math.cos(T), A.y = (e + t * Math.cos(b)) * Math.sin(T), A.z = t * Math.sin(b), a.push(A.x, A.y, A.z), c.x = e * Math.cos(T), c.y = e * Math.sin(T), m.subVectors(A, c).normalize(), l.push(m.x, m.y, m.z), u.push(y / r), u.push(_ / n);
      }
    for (let _ = 1; _ <= n; _++)
      for (let y = 1; y <= r; y++) {
        const T = (r + 1) * _ + y - 1, b = (r + 1) * (_ - 1) + y - 1, S = (r + 1) * (_ - 1) + y, E = (r + 1) * _ + y;
        o.push(T, b, E), o.push(b, S, E);
      }
    this.setIndex(o), this.setAttribute("position", new xt(a, 3)), this.setAttribute("normal", new xt(l, 3)), this.setAttribute("uv", new xt(u, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {TorusGeometry} A new instance.
   */
  static fromJSON(e) {
    return new h2(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc);
  }
}
class d2 extends Yt {
  /**
   * Constructs a new torus knot geometry.
   *
   * @param {number} [radius=1] - Radius of the torus knot.
   * @param {number} [tube=0.4] - Radius of the tube.
   * @param {number} [tubularSegments=64] - The number of tubular segments.
   * @param {number} [radialSegments=8] - The number of radial segments.
   * @param {number} [p=2] - This value determines, how many times the geometry winds around its axis of rotational symmetry.
   * @param {number} [q=3] - This value determines, how many times the geometry winds around a circle in the interior of the torus.
   */
  constructor(e = 1, t = 0.4, n = 64, r = 8, s = 2, o = 3) {
    super(), this.type = "TorusKnotGeometry", this.parameters = {
      radius: e,
      tube: t,
      tubularSegments: n,
      radialSegments: r,
      p: s,
      q: o
    }, n = Math.floor(n), r = Math.floor(r);
    const a = [], l = [], u = [], c = [], A = new j(), m = new j(), _ = new j(), y = new j(), T = new j(), b = new j(), S = new j();
    for (let R = 0; R <= n; ++R) {
      const C = R / n * s * Math.PI * 2;
      E(C, s, o, e, _), E(C + 0.01, s, o, e, y), b.subVectors(y, _), S.addVectors(y, _), T.crossVectors(b, S), S.crossVectors(T, b), T.normalize(), S.normalize();
      for (let L = 0; L <= r; ++L) {
        const D = L / r * Math.PI * 2, B = -t * Math.cos(D), U = t * Math.sin(D);
        A.x = _.x + (B * S.x + U * T.x), A.y = _.y + (B * S.y + U * T.y), A.z = _.z + (B * S.z + U * T.z), l.push(A.x, A.y, A.z), m.subVectors(A, _).normalize(), u.push(m.x, m.y, m.z), c.push(R / n), c.push(L / r);
      }
    }
    for (let R = 1; R <= n; R++)
      for (let C = 1; C <= r; C++) {
        const L = (r + 1) * (R - 1) + (C - 1), D = (r + 1) * R + (C - 1), B = (r + 1) * R + C, U = (r + 1) * (R - 1) + C;
        a.push(L, D, U), a.push(D, B, U);
      }
    this.setIndex(a), this.setAttribute("position", new xt(l, 3)), this.setAttribute("normal", new xt(u, 3)), this.setAttribute("uv", new xt(c, 2));
    function E(R, C, L, D, B) {
      const U = Math.cos(R), N = Math.sin(R), O = L / C * R, G = Math.cos(O);
      B.x = D * (2 + G) * 0.5 * U, B.y = D * (2 + G) * N * 0.5, B.z = D * Math.sin(O) * 0.5;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {TorusKnotGeometry} A new instance.
   */
  static fromJSON(e) {
    return new d2(e.radius, e.tube, e.tubularSegments, e.radialSegments, e.p, e.q);
  }
}
class E0 extends Yt {
  /**
   * Constructs a new tube geometry.
   *
   * @param {Curve} [path=QuadraticBezierCurve3] - A 3D curve defining the path of the tube.
   * @param {number} [tubularSegments=64] - The number of segments that make up the tube.
   * @param {number} [radius=1] -The radius of the tube.
   * @param {number} [radialSegments=8] - The number of segments that make up the cross-section.
   * @param {boolean} [closed=false] - Whether the tube is closed or not.
   */
  constructor(e = new z3(new j(-1, -1, 0), new j(-1, 1, 0), new j(1, 1, 0)), t = 64, n = 1, r = 8, s = !1) {
    super(), this.type = "TubeGeometry", this.parameters = {
      path: e,
      tubularSegments: t,
      radius: n,
      radialSegments: r,
      closed: s
    };
    const o = e.computeFrenetFrames(t, s);
    this.tangents = o.tangents, this.normals = o.normals, this.binormals = o.binormals;
    const a = new j(), l = new j(), u = new Le();
    let c = new j();
    const A = [], m = [], _ = [], y = [];
    T(), this.setIndex(y), this.setAttribute("position", new xt(A, 3)), this.setAttribute("normal", new xt(m, 3)), this.setAttribute("uv", new xt(_, 2));
    function T() {
      for (let R = 0; R < t; R++)
        b(R);
      b(s === !1 ? t : 0), E(), S();
    }
    function b(R) {
      c = e.getPointAt(R / t, c);
      const C = o.normals[R], L = o.binormals[R];
      for (let D = 0; D <= r; D++) {
        const B = D / r * Math.PI * 2, U = Math.sin(B), N = -Math.cos(B);
        l.x = N * C.x + U * L.x, l.y = N * C.y + U * L.y, l.z = N * C.z + U * L.z, l.normalize(), m.push(l.x, l.y, l.z), a.x = c.x + n * l.x, a.y = c.y + n * l.y, a.z = c.z + n * l.z, A.push(a.x, a.y, a.z);
      }
    }
    function S() {
      for (let R = 1; R <= t; R++)
        for (let C = 1; C <= r; C++) {
          const L = (r + 1) * (R - 1) + (C - 1), D = (r + 1) * R + (C - 1), B = (r + 1) * R + C, U = (r + 1) * (R - 1) + C;
          y.push(L, D, U), y.push(D, B, U);
        }
    }
    function E() {
      for (let R = 0; R <= t; R++)
        for (let C = 0; C <= r; C++)
          u.x = R / t, u.y = C / r, _.push(u.x, u.y);
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.path = this.parameters.path.toJSON(), e;
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {TubeGeometry} A new instance.
   */
  static fromJSON(e) {
    return new E0(
      new _1[e.path.type]().fromJSON(e.path),
      e.tubularSegments,
      e.radius,
      e.radialSegments,
      e.closed
    );
  }
}
class H3 extends Yt {
  /**
   * Constructs a new wireframe geometry.
   *
   * @param {?BufferGeometry} [geometry=null] - The geometry.
   */
  constructor(e = null) {
    if (super(), this.type = "WireframeGeometry", this.parameters = {
      geometry: e
    }, e !== null) {
      const t = [], n = /* @__PURE__ */ new Set(), r = new j(), s = new j();
      if (e.index !== null) {
        const o = e.attributes.position, a = e.index;
        let l = e.groups;
        l.length === 0 && (l = [{ start: 0, count: a.count, materialIndex: 0 }]);
        for (let u = 0, c = l.length; u < c; ++u) {
          const A = l[u], m = A.start, _ = A.count;
          for (let y = m, T = m + _; y < T; y += 3)
            for (let b = 0; b < 3; b++) {
              const S = a.getX(y + b), E = a.getX(y + (b + 1) % 3);
              r.fromBufferAttribute(o, S), s.fromBufferAttribute(o, E), ZM(r, s, n) === !0 && (t.push(r.x, r.y, r.z), t.push(s.x, s.y, s.z));
            }
        }
      } else {
        const o = e.attributes.position;
        for (let a = 0, l = o.count / 3; a < l; a++)
          for (let u = 0; u < 3; u++) {
            const c = 3 * a + u, A = 3 * a + (u + 1) % 3;
            r.fromBufferAttribute(o, c), s.fromBufferAttribute(o, A), ZM(r, s, n) === !0 && (t.push(r.x, r.y, r.z), t.push(s.x, s.y, s.z));
          }
      }
      this.setAttribute("position", new xt(t, 3));
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
}
function ZM(i, e, t) {
  const n = `${i.x},${i.y},${i.z}-${e.x},${e.y},${e.z}`, r = `${e.x},${e.y},${e.z}-${i.x},${i.y},${i.z}`;
  return t.has(n) === !0 || t.has(r) === !0 ? !1 : (t.add(n), t.add(r), !0);
}
var JM = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  BoxGeometry: ul,
  CapsuleGeometry: i2,
  CircleGeometry: lA,
  ConeGeometry: T0,
  CylinderGeometry: ed,
  DodecahedronGeometry: r2,
  EdgesGeometry: t8,
  ExtrudeGeometry: w0,
  IcosahedronGeometry: o2,
  LatheGeometry: a2,
  OctahedronGeometry: M0,
  PlaneGeometry: td,
  PolyhedronGeometry: tc,
  RingGeometry: l2,
  ShapeGeometry: u2,
  SphereGeometry: Co,
  TetrahedronGeometry: c2,
  TorusGeometry: h2,
  TorusKnotGeometry: d2,
  TubeGeometry: E0,
  WireframeGeometry: H3
});
class W3 extends Br {
  /**
   * Constructs a new shadow material.
   *
   * @param {Object} [parameters] - An object with one or more properties
   * defining the material's appearance. Any property of the material
   * (including any property from inherited materials) can be passed
   * in here. Color values can be passed any type of value accepted
   * by {@link Color#set}.
   */
  constructor(e) {
    super(), this.isShadowMaterial = !0, this.type = "ShadowMaterial", this.color = new ct(0), this.transparent = !0, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.fog = e.fog, this;
  }
}
class $3 extends Fr {
  /**
   * Constructs a new raw shader material.
   *
   * @param {Object} [parameters] - An object with one or more properties
   * defining the material's appearance. Any property of the material
   * (including any property from inherited materials) can be passed
   * in here. Color values can be passed any type of value accepted
   * by {@link Color#set}.
   */
  constructor(e) {
    super(e), this.isRawShaderMaterial = !0, this.type = "RawShaderMaterial";
  }
}
class f2 extends Br {
  /**
   * Constructs a new mesh standard material.
   *
   * @param {Object} [parameters] - An object with one or more properties
   * defining the material's appearance. Any property of the material
   * (including any property from inherited materials) can be passed
   * in here. Color values can be passed any type of value accepted
   * by {@link Color#set}.
   */
  constructor(e) {
    super(), this.isMeshStandardMaterial = !0, this.type = "MeshStandardMaterial", this.defines = { STANDARD: "" }, this.color = new ct(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new ct(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = xa, this.normalScale = new Le(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Ir(), this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.defines = { STANDARD: "" }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class j3 extends f2 {
  /**
   * Constructs a new mesh physical material.
   *
   * @param {Object} [parameters] - An object with one or more properties
   * defining the material's appearance. Any property of the material
   * (including any property from inherited materials) can be passed
   * in here. Color values can be passed any type of value accepted
   * by {@link Color#set}.
   */
  constructor(e) {
    super(), this.isMeshPhysicalMaterial = !0, this.defines = {
      STANDARD: "",
      PHYSICAL: ""
    }, this.type = "MeshPhysicalMaterial", this.anisotropyRotation = 0, this.anisotropyMap = null, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new Le(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
      get: function() {
        return dn(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
      },
      set: function(t) {
        this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
      }
    }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [100, 400], this.iridescenceThicknessMap = null, this.sheenColor = new ct(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new ct(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new ct(1, 1, 1), this.specularColorMap = null, this._anisotropy = 0, this._clearcoat = 0, this._dispersion = 0, this._iridescence = 0, this._sheen = 0, this._transmission = 0, this.setValues(e);
  }
  /**
   * The anisotropy strength, from `0.0` to `1.0`.
   *
   * @type {number}
   * @default 0
   */
  get anisotropy() {
    return this._anisotropy;
  }
  set anisotropy(e) {
    this._anisotropy > 0 != e > 0 && this.version++, this._anisotropy = e;
  }
  /**
   * Represents the intensity of the clear coat layer, from `0.0` to `1.0`. Use
   * clear coat related properties to enable multilayer materials that have a
   * thin translucent layer over the base layer.
   *
   * @type {number}
   * @default 0
   */
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(e) {
    this._clearcoat > 0 != e > 0 && this.version++, this._clearcoat = e;
  }
  /**
   * The intensity of the iridescence layer, simulating RGB color shift based on the angle between
   * the surface and the viewer, from `0.0` to `1.0`.
   *
   * @type {number}
   * @default 0
   */
  get iridescence() {
    return this._iridescence;
  }
  set iridescence(e) {
    this._iridescence > 0 != e > 0 && this.version++, this._iridescence = e;
  }
  /**
   * Defines the strength of the angular separation of colors (chromatic aberration) transmitting
   * through a relatively clear volume. Any value zero or larger is valid, the typical range of
   * realistic values is `[0, 1]`. This property can be only be used with transmissive objects.
   *
   * @type {number}
   * @default 0
   */
  get dispersion() {
    return this._dispersion;
  }
  set dispersion(e) {
    this._dispersion > 0 != e > 0 && this.version++, this._dispersion = e;
  }
  /**
   * The intensity of the sheen layer, from `0.0` to `1.0`.
   *
   * @type {number}
   * @default 0
   */
  get sheen() {
    return this._sheen;
  }
  set sheen(e) {
    this._sheen > 0 != e > 0 && this.version++, this._sheen = e;
  }
  /**
   * Degree of transmission (or optical transparency), from `0.0` to `1.0`.
   *
   * Thin, transparent or semitransparent, plastic or glass materials remain
   * largely reflective even if they are fully transmissive. The transmission
   * property can be used to model these materials.
   *
   * When transmission is non-zero, `opacity` should be  set to `1`.
   *
   * @type {number}
   * @default 0
   */
  get transmission() {
    return this._transmission;
  }
  set transmission(e) {
    this._transmission > 0 != e > 0 && this.version++, this._transmission = e;
  }
  copy(e) {
    return super.copy(e), this.defines = {
      STANDARD: "",
      PHYSICAL: ""
    }, this.anisotropy = e.anisotropy, this.anisotropyRotation = e.anisotropyRotation, this.anisotropyMap = e.anisotropyMap, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.dispersion = e.dispersion, this.ior = e.ior, this.iridescence = e.iridescence, this.iridescenceMap = e.iridescenceMap, this.iridescenceIOR = e.iridescenceIOR, this.iridescenceThicknessRange = [...e.iridescenceThicknessRange], this.iridescenceThicknessMap = e.iridescenceThicknessMap, this.sheen = e.sheen, this.sheenColor.copy(e.sheenColor), this.sheenColorMap = e.sheenColorMap, this.sheenRoughness = e.sheenRoughness, this.sheenRoughnessMap = e.sheenRoughnessMap, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularColor.copy(e.specularColor), this.specularColorMap = e.specularColorMap, this;
  }
}
class A2 extends Br {
  /**
   * Constructs a new mesh phong material.
   *
   * @param {Object} [parameters] - An object with one or more properties
   * defining the material's appearance. Any property of the material
   * (including any property from inherited materials) can be passed
   * in here. Color values can be passed any type of value accepted
   * by {@link Color#set}.
   */
  constructor(e) {
    super(), this.isMeshPhongMaterial = !0, this.type = "MeshPhongMaterial", this.color = new ct(16777215), this.specular = new ct(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new ct(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = xa, this.normalScale = new Le(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Ir(), this.combine = tA, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class X3 extends Br {
  /**
   * Constructs a new mesh toon material.
   *
   * @param {Object} [parameters] - An object with one or more properties
   * defining the material's appearance. Any property of the material
   * (including any property from inherited materials) can be passed
   * in here. Color values can be passed any type of value accepted
   * by {@link Color#set}.
   */
  constructor(e) {
    super(), this.isMeshToonMaterial = !0, this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.color = new ct(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new ct(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = xa, this.normalScale = new Le(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.gradientMap = e.gradientMap, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
  }
}
class Y3 extends Br {
  /**
   * Constructs a new mesh normal material.
   *
   * @param {Object} [parameters] - An object with one or more properties
   * defining the material's appearance. Any property of the material
   * (including any property from inherited materials) can be passed
   * in here. Color values can be passed any type of value accepted
   * by {@link Color#set}.
   */
  constructor(e) {
    super(), this.isMeshNormalMaterial = !0, this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = xa, this.normalScale = new Le(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.flatShading = !1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.flatShading = e.flatShading, this;
  }
}
class Ea extends Br {
  /**
   * Constructs a new mesh lambert material.
   *
   * @param {Object} [parameters] - An object with one or more properties
   * defining the material's appearance. Any property of the material
   * (including any property from inherited materials) can be passed
   * in here. Color values can be passed any type of value accepted
   * by {@link Color#set}.
   */
  constructor(e) {
    super(), this.isMeshLambertMaterial = !0, this.type = "MeshLambertMaterial", this.color = new ct(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new ct(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = xa, this.normalScale = new Le(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Ir(), this.combine = tA, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class Q3 extends Br {
  /**
   * Constructs a new mesh depth material.
   *
   * @param {Object} [parameters] - An object with one or more properties
   * defining the material's appearance. Any property of the material
   * (including any property from inherited materials) can be passed
   * in here. Color values can be passed any type of value accepted
   * by {@link Color#set}.
   */
  constructor(e) {
    super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = R5, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this;
  }
}
class K3 extends Br {
  /**
   * Constructs a new mesh distance material.
   *
   * @param {Object} [parameters] - An object with one or more properties
   * defining the material's appearance. Any property of the material
   * (including any property from inherited materials) can be passed
   * in here. Color values can be passed any type of value accepted
   * by {@link Color#set}.
   */
  constructor(e) {
    super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this;
  }
}
class Z3 extends Br {
  /**
   * Constructs a new mesh matcap material.
   *
   * @param {Object} [parameters] - An object with one or more properties
   * defining the material's appearance. Any property of the material
   * (including any property from inherited materials) can be passed
   * in here. Color values can be passed any type of value accepted
   * by {@link Color#set}.
   */
  constructor(e) {
    super(), this.isMeshMatcapMaterial = !0, this.defines = { MATCAP: "" }, this.type = "MeshMatcapMaterial", this.color = new ct(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = xa, this.normalScale = new Le(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.defines = { MATCAP: "" }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class J3 extends br {
  /**
   * Constructs a new line dashed material.
   *
   * @param {Object} [parameters] - An object with one or more properties
   * defining the material's appearance. Any property of the material
   * (including any property from inherited materials) can be passed
   * in here. Color values can be passed any type of value accepted
   * by {@link Color#set}.
   */
  constructor(e) {
    super(), this.isLineDashedMaterial = !0, this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this;
  }
}
function Jc(i, e) {
  return !i || i.constructor === e ? i : typeof e.BYTES_PER_ELEMENT == "number" ? new e(i) : Array.prototype.slice.call(i);
}
function c8(i) {
  function e(r, s) {
    return i[r] - i[s];
  }
  const t = i.length, n = new Array(t);
  for (let r = 0; r !== t; ++r) n[r] = r;
  return n.sort(e), n;
}
function Gv(i, e, t) {
  const n = i.length, r = new i.constructor(n);
  for (let s = 0, o = 0; o !== n; ++s) {
    const a = t[s] * e;
    for (let l = 0; l !== e; ++l)
      r[o++] = i[a + l];
  }
  return r;
}
function eS(i, e, t, n) {
  let r = 1, s = i[0];
  for (; s !== void 0 && s[n] === void 0; )
    s = i[r++];
  if (s === void 0) return;
  let o = s[n];
  if (o !== void 0)
    if (Array.isArray(o))
      do
        o = s[n], o !== void 0 && (e.push(s.time), t.push(...o)), s = i[r++];
      while (s !== void 0);
    else if (o.toArray !== void 0)
      do
        o = s[n], o !== void 0 && (e.push(s.time), o.toArray(t, t.length)), s = i[r++];
      while (s !== void 0);
    else
      do
        o = s[n], o !== void 0 && (e.push(s.time), t.push(o)), s = i[r++];
      while (s !== void 0);
}
function SO(i, e, t, n, r = 30) {
  const s = i.clone();
  s.name = e;
  const o = [];
  for (let l = 0; l < s.tracks.length; ++l) {
    const u = s.tracks[l], c = u.getValueSize(), A = [], m = [];
    for (let _ = 0; _ < u.times.length; ++_) {
      const y = u.times[_] * r;
      if (!(y < t || y >= n)) {
        A.push(u.times[_]);
        for (let T = 0; T < c; ++T)
          m.push(u.values[_ * c + T]);
      }
    }
    A.length !== 0 && (u.times = Jc(A, u.times.constructor), u.values = Jc(m, u.values.constructor), o.push(u));
  }
  s.tracks = o;
  let a = 1 / 0;
  for (let l = 0; l < s.tracks.length; ++l)
    a > s.tracks[l].times[0] && (a = s.tracks[l].times[0]);
  for (let l = 0; l < s.tracks.length; ++l)
    s.tracks[l].shift(-1 * a);
  return s.resetDuration(), s;
}
function TO(i, e = 0, t = i, n = 30) {
  n <= 0 && (n = 30);
  const r = t.tracks.length, s = e / n;
  for (let o = 0; o < r; ++o) {
    const a = t.tracks[o], l = a.ValueTypeName;
    if (l === "bool" || l === "string") continue;
    const u = i.tracks.find(function(S) {
      return S.name === a.name && S.ValueTypeName === l;
    });
    if (u === void 0) continue;
    let c = 0;
    const A = a.getValueSize();
    a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (c = A / 3);
    let m = 0;
    const _ = u.getValueSize();
    u.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (m = _ / 3);
    const y = a.times.length - 1;
    let T;
    if (s <= a.times[0]) {
      const S = c, E = A - c;
      T = a.values.slice(S, E);
    } else if (s >= a.times[y]) {
      const S = y * A + c, E = S + A - c;
      T = a.values.slice(S, E);
    } else {
      const S = a.createInterpolant(), E = c, R = A - c;
      S.evaluate(s), T = S.resultBuffer.slice(E, R);
    }
    l === "quaternion" && new hr().fromArray(T).normalize().conjugate().toArray(T);
    const b = u.times.length;
    for (let S = 0; S < b; ++S) {
      const E = S * _ + m;
      if (l === "quaternion")
        hr.multiplyQuaternionsFlat(
          u.values,
          E,
          T,
          0,
          u.values,
          E
        );
      else {
        const R = _ - m * 2;
        for (let C = 0; C < R; ++C)
          u.values[E + C] -= T[C];
      }
    }
  }
  return i.blendMode = w3, i;
}
class wO {
  /**
   * Converts an array to a specific type
   *
   * @static
   * @param {TypedArray|Array} array - The array to convert.
   * @param {TypedArray.constructor} type - The constructor of a type array.
   * @return {TypedArray} The converted array
   */
  static convertArray(e, t) {
    return Jc(e, t);
  }
  /**
   * Returns `true` if the given object is a typed array.
   *
   * @static
   * @param {any} object - The object to check.
   * @return {boolean} Whether the given object is a typed array.
   */
  static isTypedArray(e) {
    return Uf(e);
  }
  /**
   * Returns an array by which times and values can be sorted.
   *
   * @static
   * @param {Array<number>} times - The keyframe time values.
   * @return {Array<number>} The array.
   */
  static getKeyframeOrder(e) {
    return c8(e);
  }
  /**
   * Sorts the given array by the previously computed order via `getKeyframeOrder()`.
   *
   * @static
   * @param {Array<number>} values - The values to sort.
   * @param {number} stride - The stride.
   * @param {Array<number>} order - The sort order.
   * @return {Array<number>} The sorted values.
   */
  static sortedArray(e, t, n) {
    return Gv(e, t, n);
  }
  /**
   * Used for parsing AOS keyframe formats.
   *
   * @static
   * @param {Array<number>} jsonKeys - A list of JSON keyframes.
   * @param {Array<number>} times - This array will be filled with keyframe times by this method.
   * @param {Array<number>} values - This array will be filled with keyframe values by this method.
   * @param {string} valuePropertyName - The name of the property to use.
   */
  static flattenJSON(e, t, n, r) {
    eS(e, t, n, r);
  }
  /**
   * Creates a new clip, containing only the segment of the original clip between the given frames.
   *
   * @static
   * @param {AnimationClip} sourceClip - The values to sort.
   * @param {string} name - The name of the clip.
   * @param {number} startFrame - The start frame.
   * @param {number} endFrame - The end frame.
   * @param {number} [fps=30] - The FPS.
   * @return {AnimationClip} The new sub clip.
   */
  static subclip(e, t, n, r, s = 30) {
    return SO(e, t, n, r, s);
  }
  /**
   * Converts the keyframes of the given animation clip to an additive format.
   *
   * @static
   * @param {AnimationClip} targetClip - The clip to make additive.
   * @param {number} [referenceFrame=0] - The reference frame.
   * @param {AnimationClip} [referenceClip=targetClip] - The reference clip.
   * @param {number} [fps=30] - The FPS.
   * @return {AnimationClip} The updated clip which is now additive.
   */
  static makeClipAdditive(e, t = 0, n = e, r = 30) {
    return TO(e, t, n, r);
  }
}
class R0 {
  /**
   * Constructs a new interpolant.
   *
   * @param {TypedArray} parameterPositions - The parameter positions hold the interpolation factors.
   * @param {TypedArray} sampleValues - The sample values.
   * @param {number} sampleSize - The sample size
   * @param {TypedArray} [resultBuffer] - The result buffer.
   */
  constructor(e, t, n, r) {
    this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = r !== void 0 ? r : new t.constructor(n), this.sampleValues = t, this.valueSize = n, this.settings = null, this.DefaultSettings_ = {};
  }
  /**
   * Evaluate the interpolant at position `t`.
   *
   * @param {number} t - The interpolation factor.
   * @return {TypedArray} The result buffer.
   */
  evaluate(e) {
    const t = this.parameterPositions;
    let n = this._cachedIndex, r = t[n], s = t[n - 1];
    e: {
      t: {
        let o;
        n: {
          i: if (!(e < r)) {
            for (let a = n + 2; ; ) {
              if (r === void 0) {
                if (e < s) break i;
                return n = t.length, this._cachedIndex = n, this.copySampleValue_(n - 1);
              }
              if (n === a) break;
              if (s = r, r = t[++n], e < r)
                break t;
            }
            o = t.length;
            break n;
          }
          if (!(e >= s)) {
            const a = t[1];
            e < a && (n = 2, s = a);
            for (let l = n - 2; ; ) {
              if (s === void 0)
                return this._cachedIndex = 0, this.copySampleValue_(0);
              if (n === l) break;
              if (r = s, s = t[--n - 1], e >= s)
                break t;
            }
            o = n, n = 0;
            break n;
          }
          break e;
        }
        for (; n < o; ) {
          const a = n + o >>> 1;
          e < t[a] ? o = a : n = a + 1;
        }
        if (r = t[n], s = t[n - 1], s === void 0)
          return this._cachedIndex = 0, this.copySampleValue_(0);
        if (r === void 0)
          return n = t.length, this._cachedIndex = n, this.copySampleValue_(n - 1);
      }
      this._cachedIndex = n, this.intervalChanged_(n, s, r);
    }
    return this.interpolate_(n, s, e, r);
  }
  /**
   * Returns the interpolation settings.
   *
   * @return {Object} The interpolation settings.
   */
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  /**
   * Copies a sample value to the result buffer.
   *
   * @param {number} index - An index into the sample value buffer.
   * @return {TypedArray} The result buffer.
   */
  copySampleValue_(e) {
    const t = this.resultBuffer, n = this.sampleValues, r = this.valueSize, s = e * r;
    for (let o = 0; o !== r; ++o)
      t[o] = n[s + o];
    return t;
  }
  /**
   * Copies a sample value to the result buffer.
   *
   * @abstract
   * @param {number} i1 - An index into the sample value buffer.
   * @param {number} t0 - The previous interpolation factor.
   * @param {number} t - The current interpolation factor.
   * @param {number} t1 - The next interpolation factor.
   * @return {TypedArray} The result buffer.
   */
  interpolate_() {
    throw new Error("call to abstract method");
  }
  /**
   * Optional method that is executed when the interval has changed.
   *
   * @param {number} i1 - An index into the sample value buffer.
   * @param {number} t0 - The previous interpolation factor.
   * @param {number} t - The current interpolation factor.
   */
  intervalChanged_() {
  }
}
class h8 extends R0 {
  /**
   * Constructs a new cubic interpolant.
   *
   * @param {TypedArray} parameterPositions - The parameter positions hold the interpolation factors.
   * @param {TypedArray} sampleValues - The sample values.
   * @param {number} sampleSize - The sample size
   * @param {TypedArray} [resultBuffer] - The result buffer.
   */
  constructor(e, t, n, r) {
    super(e, t, n, r), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
      endingStart: Kc,
      endingEnd: Kc
    };
  }
  intervalChanged_(e, t, n) {
    const r = this.parameterPositions;
    let s = e - 2, o = e + 1, a = r[s], l = r[o];
    if (a === void 0)
      switch (this.getSettings_().endingStart) {
        case Zc:
          s = e, a = 2 * t - n;
          break;
        case Up:
          s = r.length - 2, a = t + r[s] - r[s + 1];
          break;
        default:
          s = e, a = n;
      }
    if (l === void 0)
      switch (this.getSettings_().endingEnd) {
        case Zc:
          o = e, l = 2 * n - t;
          break;
        case Up:
          o = 1, l = n + r[1] - r[0];
          break;
        default:
          o = e - 1, l = t;
      }
    const u = (n - t) * 0.5, c = this.valueSize;
    this._weightPrev = u / (t - a), this._weightNext = u / (l - n), this._offsetPrev = s * c, this._offsetNext = o * c;
  }
  interpolate_(e, t, n, r) {
    const s = this.resultBuffer, o = this.sampleValues, a = this.valueSize, l = e * a, u = l - a, c = this._offsetPrev, A = this._offsetNext, m = this._weightPrev, _ = this._weightNext, y = (n - t) / (r - t), T = y * y, b = T * y, S = -m * b + 2 * m * T - m * y, E = (1 + m) * b + (-1.5 - 2 * m) * T + (-0.5 + m) * y + 1, R = (-1 - _) * b + (1.5 + _) * T + 0.5 * y, C = _ * b - _ * T;
    for (let L = 0; L !== a; ++L)
      s[L] = S * o[c + L] + E * o[u + L] + R * o[l + L] + C * o[A + L];
    return s;
  }
}
class tS extends R0 {
  /**
   * Constructs a new linear interpolant.
   *
   * @param {TypedArray} parameterPositions - The parameter positions hold the interpolation factors.
   * @param {TypedArray} sampleValues - The sample values.
   * @param {number} sampleSize - The sample size
   * @param {TypedArray} [resultBuffer] - The result buffer.
   */
  constructor(e, t, n, r) {
    super(e, t, n, r);
  }
  interpolate_(e, t, n, r) {
    const s = this.resultBuffer, o = this.sampleValues, a = this.valueSize, l = e * a, u = l - a, c = (n - t) / (r - t), A = 1 - c;
    for (let m = 0; m !== a; ++m)
      s[m] = o[u + m] * A + o[l + m] * c;
    return s;
  }
}
class d8 extends R0 {
  /**
   * Constructs a new discrete interpolant.
   *
   * @param {TypedArray} parameterPositions - The parameter positions hold the interpolation factors.
   * @param {TypedArray} sampleValues - The sample values.
   * @param {number} sampleSize - The sample size
   * @param {TypedArray} [resultBuffer] - The result buffer.
   */
  constructor(e, t, n, r) {
    super(e, t, n, r);
  }
  interpolate_(e) {
    return this.copySampleValue_(e - 1);
  }
}
class Zo {
  /**
   * Constructs a new keyframe track.
   *
   * @param {string} name - The keyframe track's name.
   * @param {Array<number>} times - A list of keyframe times.
   * @param {Array<number|string|boolean>} values - A list of keyframe values.
   * @param {(InterpolateLinear|InterpolateDiscrete|InterpolateSmooth)} [interpolation] - The interpolation type.
   */
  constructor(e, t, n, r) {
    if (e === void 0) throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (t === void 0 || t.length === 0) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
    this.name = e, this.times = Jc(t, this.TimeBufferType), this.values = Jc(n, this.ValueBufferType), this.setInterpolation(r || this.DefaultInterpolation);
  }
  /**
   * Converts the keyframe track to JSON.
   *
   * @static
   * @param {KeyframeTrack} track - The keyframe track to serialize.
   * @return {Object} The serialized keyframe track as JSON.
   */
  static toJSON(e) {
    const t = e.constructor;
    let n;
    if (t.toJSON !== this.toJSON)
      n = t.toJSON(e);
    else {
      n = {
        name: e.name,
        times: Jc(e.times, Array),
        values: Jc(e.values, Array)
      };
      const r = e.getInterpolation();
      r !== e.DefaultInterpolation && (n.interpolation = r);
    }
    return n.type = e.ValueTypeName, n;
  }
  /**
   * Factory method for creating a new discrete interpolant.
   *
   * @static
   * @param {TypedArray} [result] - The result buffer.
   * @return {DiscreteInterpolant} The new interpolant.
   */
  InterpolantFactoryMethodDiscrete(e) {
    return new d8(this.times, this.values, this.getValueSize(), e);
  }
  /**
   * Factory method for creating a new linear interpolant.
   *
   * @static
   * @param {TypedArray} [result] - The result buffer.
   * @return {LinearInterpolant} The new interpolant.
   */
  InterpolantFactoryMethodLinear(e) {
    return new tS(this.times, this.values, this.getValueSize(), e);
  }
  /**
   * Factory method for creating a new smooth interpolant.
   *
   * @static
   * @param {TypedArray} [result] - The result buffer.
   * @return {CubicInterpolant} The new interpolant.
   */
  InterpolantFactoryMethodSmooth(e) {
    return new h8(this.times, this.values, this.getValueSize(), e);
  }
  /**
   * Defines the interpolation factor method for this keyframe track.
   *
   * @param {(InterpolateLinear|InterpolateDiscrete|InterpolateSmooth)} interpolation - The interpolation type.
   * @return {KeyframeTrack} A reference to this keyframe track.
   */
  setInterpolation(e) {
    let t;
    switch (e) {
      case Fp:
        t = this.InterpolantFactoryMethodDiscrete;
        break;
      case A1:
        t = this.InterpolantFactoryMethodLinear;
        break;
      case Wg:
        t = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (t === void 0) {
      const n = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
      if (this.createInterpolant === void 0)
        if (e !== this.DefaultInterpolation)
          this.setInterpolation(this.DefaultInterpolation);
        else
          throw new Error(n);
      return Me("KeyframeTrack:", n), this;
    }
    return this.createInterpolant = t, this;
  }
  /**
   * Returns the current interpolation type.
   *
   * @return {(InterpolateLinear|InterpolateDiscrete|InterpolateSmooth)} The interpolation type.
   */
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return Fp;
      case this.InterpolantFactoryMethodLinear:
        return A1;
      case this.InterpolantFactoryMethodSmooth:
        return Wg;
    }
  }
  /**
   * Returns the value size.
   *
   * @return {number} The value size.
   */
  getValueSize() {
    return this.values.length / this.times.length;
  }
  /**
   * Moves all keyframes either forward or backward in time.
   *
   * @param {number} timeOffset - The offset to move the time values.
   * @return {KeyframeTrack} A reference to this keyframe track.
   */
  shift(e) {
    if (e !== 0) {
      const t = this.times;
      for (let n = 0, r = t.length; n !== r; ++n)
        t[n] += e;
    }
    return this;
  }
  /**
   * Scale all keyframe times by a factor (useful for frame - seconds conversions).
   *
   * @param {number} timeScale - The time scale.
   * @return {KeyframeTrack} A reference to this keyframe track.
   */
  scale(e) {
    if (e !== 1) {
      const t = this.times;
      for (let n = 0, r = t.length; n !== r; ++n)
        t[n] *= e;
    }
    return this;
  }
  /**
   * Removes keyframes before and after animation without changing any values within the defined time range.
   *
   * Note: The method does not shift around keys to the start of the track time, because for interpolated
   * keys this will change their values
   *
   * @param {number} startTime - The start time.
   * @param {number} endTime - The end time.
   * @return {KeyframeTrack} A reference to this keyframe track.
   */
  trim(e, t) {
    const n = this.times, r = n.length;
    let s = 0, o = r - 1;
    for (; s !== r && n[s] < e; )
      ++s;
    for (; o !== -1 && n[o] > t; )
      --o;
    if (++o, s !== 0 || o !== r) {
      s >= o && (o = Math.max(o, 1), s = o - 1);
      const a = this.getValueSize();
      this.times = n.slice(s, o), this.values = this.values.slice(s * a, o * a);
    }
    return this;
  }
  /**
   * Performs minimal validation on the keyframe track. Returns `true` if the values
   * are valid.
   *
   * @return {boolean} Whether the keyframes are valid or not.
   */
  validate() {
    let e = !0;
    const t = this.getValueSize();
    t - Math.floor(t) !== 0 && (Ie("KeyframeTrack: Invalid value size in track.", this), e = !1);
    const n = this.times, r = this.values, s = n.length;
    s === 0 && (Ie("KeyframeTrack: Track is empty.", this), e = !1);
    let o = null;
    for (let a = 0; a !== s; a++) {
      const l = n[a];
      if (typeof l == "number" && isNaN(l)) {
        Ie("KeyframeTrack: Time is not a valid number.", this, a, l), e = !1;
        break;
      }
      if (o !== null && o > l) {
        Ie("KeyframeTrack: Out of order keys.", this, a, l, o), e = !1;
        break;
      }
      o = l;
    }
    if (r !== void 0 && Uf(r))
      for (let a = 0, l = r.length; a !== l; ++a) {
        const u = r[a];
        if (isNaN(u)) {
          Ie("KeyframeTrack: Value is not a valid number.", this, a, u), e = !1;
          break;
        }
      }
    return e;
  }
  /**
   * Optimizes this keyframe track by removing equivalent sequential keys (which are
   * common in morph target sequences).
   *
   * @return {AnimationClip} A reference to this animation clip.
   */
  optimize() {
    const e = this.times.slice(), t = this.values.slice(), n = this.getValueSize(), r = this.getInterpolation() === Wg, s = e.length - 1;
    let o = 1;
    for (let a = 1; a < s; ++a) {
      let l = !1;
      const u = e[a], c = e[a + 1];
      if (u !== c && (a !== 1 || u !== e[0]))
        if (r)
          l = !0;
        else {
          const A = a * n, m = A - n, _ = A + n;
          for (let y = 0; y !== n; ++y) {
            const T = t[A + y];
            if (T !== t[m + y] || T !== t[_ + y]) {
              l = !0;
              break;
            }
          }
        }
      if (l) {
        if (a !== o) {
          e[o] = e[a];
          const A = a * n, m = o * n;
          for (let _ = 0; _ !== n; ++_)
            t[m + _] = t[A + _];
        }
        ++o;
      }
    }
    if (s > 0) {
      e[o] = e[s];
      for (let a = s * n, l = o * n, u = 0; u !== n; ++u)
        t[l + u] = t[a + u];
      ++o;
    }
    return o !== e.length ? (this.times = e.slice(0, o), this.values = t.slice(0, o * n)) : (this.times = e, this.values = t), this;
  }
  /**
   * Returns a new keyframe track with copied values from this instance.
   *
   * @return {KeyframeTrack} A clone of this instance.
   */
  clone() {
    const e = this.times.slice(), t = this.values.slice(), n = this.constructor, r = new n(this.name, e, t);
    return r.createInterpolant = this.createInterpolant, r;
  }
}
Zo.prototype.ValueTypeName = "";
Zo.prototype.TimeBufferType = Float32Array;
Zo.prototype.ValueBufferType = Float32Array;
Zo.prototype.DefaultInterpolation = A1;
class nd extends Zo {
  /**
   * Constructs a new boolean keyframe track.
   *
   * This keyframe track type has no `interpolation` parameter because the
   * interpolation is always discrete.
   *
   * @param {string} name - The keyframe track's name.
   * @param {Array<number>} times - A list of keyframe times.
   * @param {Array<boolean>} values - A list of keyframe values.
   */
  constructor(e, t, n) {
    super(e, t, n);
  }
}
nd.prototype.ValueTypeName = "bool";
nd.prototype.ValueBufferType = Array;
nd.prototype.DefaultInterpolation = Fp;
nd.prototype.InterpolantFactoryMethodLinear = void 0;
nd.prototype.InterpolantFactoryMethodSmooth = void 0;
class nS extends Zo {
  /**
   * Constructs a new color keyframe track.
   *
   * @param {string} name - The keyframe track's name.
   * @param {Array<number>} times - A list of keyframe times.
   * @param {Array<number>} values - A list of keyframe values.
   * @param {(InterpolateLinear|InterpolateDiscrete|InterpolateSmooth)} [interpolation] - The interpolation type.
   */
  constructor(e, t, n, r) {
    super(e, t, n, r);
  }
}
nS.prototype.ValueTypeName = "color";
class zp extends Zo {
  /**
   * Constructs a new number keyframe track.
   *
   * @param {string} name - The keyframe track's name.
   * @param {Array<number>} times - A list of keyframe times.
   * @param {Array<number>} values - A list of keyframe values.
   * @param {(InterpolateLinear|InterpolateDiscrete|InterpolateSmooth)} [interpolation] - The interpolation type.
   */
  constructor(e, t, n, r) {
    super(e, t, n, r);
  }
}
zp.prototype.ValueTypeName = "number";
class f8 extends R0 {
  /**
   * Constructs a new SLERP interpolant.
   *
   * @param {TypedArray} parameterPositions - The parameter positions hold the interpolation factors.
   * @param {TypedArray} sampleValues - The sample values.
   * @param {number} sampleSize - The sample size
   * @param {TypedArray} [resultBuffer] - The result buffer.
   */
  constructor(e, t, n, r) {
    super(e, t, n, r);
  }
  interpolate_(e, t, n, r) {
    const s = this.resultBuffer, o = this.sampleValues, a = this.valueSize, l = (n - t) / (r - t);
    let u = e * a;
    for (let c = u + a; u !== c; u += 4)
      hr.slerpFlat(s, 0, o, u - a, o, u, l);
    return s;
  }
}
class C0 extends Zo {
  /**
   * Constructs a new Quaternion keyframe track.
   *
   * @param {string} name - The keyframe track's name.
   * @param {Array<number>} times - A list of keyframe times.
   * @param {Array<number>} values - A list of keyframe values.
   * @param {(InterpolateLinear|InterpolateDiscrete|InterpolateSmooth)} [interpolation] - The interpolation type.
   */
  constructor(e, t, n, r) {
    super(e, t, n, r);
  }
  /**
   * Overwritten so the method returns Quaternion based interpolant.
   *
   * @static
   * @param {TypedArray} [result] - The result buffer.
   * @return {QuaternionLinearInterpolant} The new interpolant.
   */
  InterpolantFactoryMethodLinear(e) {
    return new f8(this.times, this.values, this.getValueSize(), e);
  }
}
C0.prototype.ValueTypeName = "quaternion";
C0.prototype.InterpolantFactoryMethodSmooth = void 0;
class id extends Zo {
  /**
   * Constructs a new string keyframe track.
   *
   * This keyframe track type has no `interpolation` parameter because the
   * interpolation is always discrete.
   *
   * @param {string} name - The keyframe track's name.
   * @param {Array<number>} times - A list of keyframe times.
   * @param {Array<string>} values - A list of keyframe values.
   */
  constructor(e, t, n) {
    super(e, t, n);
  }
}
id.prototype.ValueTypeName = "string";
id.prototype.ValueBufferType = Array;
id.prototype.DefaultInterpolation = Fp;
id.prototype.InterpolantFactoryMethodLinear = void 0;
id.prototype.InterpolantFactoryMethodSmooth = void 0;
class qp extends Zo {
  /**
   * Constructs a new vector keyframe track.
   *
   * @param {string} name - The keyframe track's name.
   * @param {Array<number>} times - A list of keyframe times.
   * @param {Array<number>} values - A list of keyframe values.
   * @param {(InterpolateLinear|InterpolateDiscrete|InterpolateSmooth)} [interpolation] - The interpolation type.
   */
  constructor(e, t, n, r) {
    super(e, t, n, r);
  }
}
qp.prototype.ValueTypeName = "vector";
class Hp {
  /**
   * Constructs a new animation clip.
   *
   * Note: Instead of instantiating an AnimationClip directly with the constructor, you can
   * use the static interface of this class for creating clips. In most cases though, animation clips
   * will automatically be created by loaders when importing animated 3D assets.
   *
   * @param {string} [name=''] - The clip's name.
   * @param {number} [duration=-1] - The clip's duration in seconds. If a negative value is passed,
   * the duration will be calculated from the passed keyframes.
   * @param {Array<KeyframeTrack>} tracks - An array of keyframe tracks.
   * @param {(NormalAnimationBlendMode|AdditiveAnimationBlendMode)} [blendMode=NormalAnimationBlendMode] - Defines how the animation
   * is blended/combined when two or more animations are simultaneously played.
   */
  constructor(e = "", t = -1, n = [], r = V_) {
    this.name = e, this.tracks = n, this.duration = t, this.blendMode = r, this.uuid = To(), this.userData = {}, this.duration < 0 && this.resetDuration();
  }
  /**
   * Factory method for creating an animation clip from the given JSON.
   *
   * @static
   * @param {Object} json - The serialized animation clip.
   * @return {AnimationClip} The new animation clip.
   */
  static parse(e) {
    const t = [], n = e.tracks, r = 1 / (e.fps || 1);
    for (let o = 0, a = n.length; o !== a; ++o)
      t.push(EO(n[o]).scale(r));
    const s = new this(e.name, e.duration, t, e.blendMode);
    return s.uuid = e.uuid, s.userData = JSON.parse(e.userData || "{}"), s;
  }
  /**
   * Serializes the given animation clip into JSON.
   *
   * @static
   * @param {AnimationClip} clip - The animation clip to serialize.
   * @return {Object} The JSON object.
   */
  static toJSON(e) {
    const t = [], n = e.tracks, r = {
      name: e.name,
      duration: e.duration,
      tracks: t,
      uuid: e.uuid,
      blendMode: e.blendMode,
      userData: JSON.stringify(e.userData)
    };
    for (let s = 0, o = n.length; s !== o; ++s)
      t.push(Zo.toJSON(n[s]));
    return r;
  }
  /**
   * Returns a new animation clip from the passed morph targets array of a
   * geometry, taking a name and the number of frames per second.
   *
   * Note: The fps parameter is required, but the animation speed can be
   * overridden via {@link AnimationAction#setDuration}.
   *
   * @static
   * @param {string} name - The name of the animation clip.
   * @param {Array<Object>} morphTargetSequence - A sequence of morph targets.
   * @param {number} fps - The Frames-Per-Second value.
   * @param {boolean} noLoop - Whether the clip should be no loop or not.
   * @return {AnimationClip} The new animation clip.
   */
  static CreateFromMorphTargetSequence(e, t, n, r) {
    const s = t.length, o = [];
    for (let a = 0; a < s; a++) {
      let l = [], u = [];
      l.push(
        (a + s - 1) % s,
        a,
        (a + 1) % s
      ), u.push(0, 1, 0);
      const c = c8(l);
      l = Gv(l, 1, c), u = Gv(u, 1, c), !r && l[0] === 0 && (l.push(s), u.push(u[0])), o.push(
        new zp(
          ".morphTargetInfluences[" + t[a].name + "]",
          l,
          u
        ).scale(1 / n)
      );
    }
    return new this(e, -1, o);
  }
  /**
   * Searches for an animation clip by name, taking as its first parameter
   * either an array of clips, or a mesh or geometry that contains an
   * array named "animations" property.
   *
   * @static
   * @param {(Array<AnimationClip>|Object3D)} objectOrClipArray - The array or object to search through.
   * @param {string} name - The name to search for.
   * @return {?AnimationClip} The found animation clip. Returns `null` if no clip has been found.
   */
  static findByName(e, t) {
    let n = e;
    if (!Array.isArray(e)) {
      const r = e;
      n = r.geometry && r.geometry.animations || r.animations;
    }
    for (let r = 0; r < n.length; r++)
      if (n[r].name === t)
        return n[r];
    return null;
  }
  /**
   * Returns an array of new AnimationClips created from the morph target
   * sequences of a geometry, trying to sort morph target names into
   * animation-group-based patterns like "Walk_001, Walk_002, Run_001, Run_002...".
   *
   * See {@link MD2Loader#parse} as an example for how the method should be used.
   *
   * @static
   * @param {Array<Object>} morphTargets - A sequence of morph targets.
   * @param {number} fps - The Frames-Per-Second value.
   * @param {boolean} noLoop - Whether the clip should be no loop or not.
   * @return {Array<AnimationClip>} An array of new animation clips.
   */
  static CreateClipsFromMorphTargetSequences(e, t, n) {
    const r = {}, s = /^([\w-]*?)([\d]+)$/;
    for (let a = 0, l = e.length; a < l; a++) {
      const u = e[a], c = u.name.match(s);
      if (c && c.length > 1) {
        const A = c[1];
        let m = r[A];
        m || (r[A] = m = []), m.push(u);
      }
    }
    const o = [];
    for (const a in r)
      o.push(this.CreateFromMorphTargetSequence(a, r[a], t, n));
    return o;
  }
  /**
   * Parses the `animation.hierarchy` format and returns a new animation clip.
   *
   * @static
   * @deprecated since r175.
   * @param {Object} animation - A serialized animation clip as JSON.
   * @param {Array<Bones>} bones - An array of bones.
   * @return {?AnimationClip} The new animation clip.
   */
  static parseAnimation(e, t) {
    if (Me("AnimationClip: parseAnimation() is deprecated and will be removed with r185"), !e)
      return Ie("AnimationClip: No animation in JSONLoader data."), null;
    const n = function(A, m, _, y, T) {
      if (_.length !== 0) {
        const b = [], S = [];
        eS(_, b, S, y), b.length !== 0 && T.push(new A(m, b, S));
      }
    }, r = [], s = e.name || "default", o = e.fps || 30, a = e.blendMode;
    let l = e.length || -1;
    const u = e.hierarchy || [];
    for (let A = 0; A < u.length; A++) {
      const m = u[A].keys;
      if (!(!m || m.length === 0))
        if (m[0].morphTargets) {
          const _ = {};
          let y;
          for (y = 0; y < m.length; y++)
            if (m[y].morphTargets)
              for (let T = 0; T < m[y].morphTargets.length; T++)
                _[m[y].morphTargets[T]] = -1;
          for (const T in _) {
            const b = [], S = [];
            for (let E = 0; E !== m[y].morphTargets.length; ++E) {
              const R = m[y];
              b.push(R.time), S.push(R.morphTarget === T ? 1 : 0);
            }
            r.push(new zp(".morphTargetInfluence[" + T + "]", b, S));
          }
          l = _.length * o;
        } else {
          const _ = ".bones[" + t[A].name + "]";
          n(
            qp,
            _ + ".position",
            m,
            "pos",
            r
          ), n(
            C0,
            _ + ".quaternion",
            m,
            "rot",
            r
          ), n(
            qp,
            _ + ".scale",
            m,
            "scl",
            r
          );
        }
    }
    return r.length === 0 ? null : new this(s, l, r, a);
  }
  /**
   * Sets the duration of this clip to the duration of its longest keyframe track.
   *
   * @return {AnimationClip} A reference to this animation clip.
   */
  resetDuration() {
    const e = this.tracks;
    let t = 0;
    for (let n = 0, r = e.length; n !== r; ++n) {
      const s = this.tracks[n];
      t = Math.max(t, s.times[s.times.length - 1]);
    }
    return this.duration = t, this;
  }
  /**
   * Trims all tracks to the clip's duration.
   *
   * @return {AnimationClip} A reference to this animation clip.
   */
  trim() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].trim(0, this.duration);
    return this;
  }
  /**
   * Performs minimal validation on each track in the clip. Returns `true` if all
   * tracks are valid.
   *
   * @return {boolean} Whether the clip's keyframes are valid or not.
   */
  validate() {
    let e = !0;
    for (let t = 0; t < this.tracks.length; t++)
      e = e && this.tracks[t].validate();
    return e;
  }
  /**
   * Optimizes each track by removing equivalent sequential keys (which are
   * common in morph target sequences).
   *
   * @return {AnimationClip} A reference to this animation clip.
   */
  optimize() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].optimize();
    return this;
  }
  /**
   * Returns a new animation clip with copied values from this instance.
   *
   * @return {AnimationClip} A clone of this instance.
   */
  clone() {
    const e = [];
    for (let n = 0; n < this.tracks.length; n++)
      e.push(this.tracks[n].clone());
    const t = new this.constructor(this.name, this.duration, e, this.blendMode);
    return t.userData = JSON.parse(JSON.stringify(this.userData)), t;
  }
  /**
   * Serializes this animation clip into JSON.
   *
   * @return {Object} The JSON object.
   */
  toJSON() {
    return this.constructor.toJSON(this);
  }
}
function MO(i) {
  switch (i.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return zp;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return qp;
    case "color":
      return nS;
    case "quaternion":
      return C0;
    case "bool":
    case "boolean":
      return nd;
    case "string":
      return id;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + i);
}
function EO(i) {
  if (i.type === void 0)
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  const e = MO(i.type);
  if (i.times === void 0) {
    const t = [], n = [];
    eS(i.keys, t, n, "value"), i.times = t, i.values = n;
  }
  return e.parse !== void 0 ? e.parse(i) : new e(i.name, i.times, i.values, i.interpolation);
}
const ja = {
  /**
   * Whether caching is enabled or not.
   *
   * @static
   * @type {boolean}
   * @default false
   */
  enabled: !1,
  /**
   * A dictionary that holds cached files.
   *
   * @static
   * @type {Object<string,Object>}
   */
  files: {},
  /**
   * Adds a cache entry with a key to reference the file. If this key already
   * holds a file, it is overwritten.
   *
   * @static
   * @param {string} key - The key to reference the cached file.
   * @param {Object} file -  The file to be cached.
   */
  add: function(i, e) {
    this.enabled !== !1 && (this.files[i] = e);
  },
  /**
   * Gets the cached value for the given key.
   *
   * @static
   * @param {string} key - The key to reference the cached file.
   * @return {Object|undefined} The cached file. If the key does not exist `undefined` is returned.
   */
  get: function(i) {
    if (this.enabled !== !1)
      return this.files[i];
  },
  /**
   * Removes the cached file associated with the given key.
   *
   * @static
   * @param {string} key - The key to reference the cached file.
   */
  remove: function(i) {
    delete this.files[i];
  },
  /**
   * Remove all values from the cache.
   *
   * @static
   */
  clear: function() {
    this.files = {};
  }
};
class iS {
  /**
   * Constructs a new loading manager.
   *
   * @param {Function} [onLoad] - Executes when all items have been loaded.
   * @param {Function} [onProgress] - Executes when single items have been loaded.
   * @param {Function} [onError] - Executes when an error occurs.
   */
  constructor(e, t, n) {
    const r = this;
    let s = !1, o = 0, a = 0, l;
    const u = [];
    this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = n, this._abortController = null, this.itemStart = function(c) {
      a++, s === !1 && r.onStart !== void 0 && r.onStart(c, o, a), s = !0;
    }, this.itemEnd = function(c) {
      o++, r.onProgress !== void 0 && r.onProgress(c, o, a), o === a && (s = !1, r.onLoad !== void 0 && r.onLoad());
    }, this.itemError = function(c) {
      r.onError !== void 0 && r.onError(c);
    }, this.resolveURL = function(c) {
      return l ? l(c) : c;
    }, this.setURLModifier = function(c) {
      return l = c, this;
    }, this.addHandler = function(c, A) {
      return u.push(c, A), this;
    }, this.removeHandler = function(c) {
      const A = u.indexOf(c);
      return A !== -1 && u.splice(A, 2), this;
    }, this.getHandler = function(c) {
      for (let A = 0, m = u.length; A < m; A += 2) {
        const _ = u[A], y = u[A + 1];
        if (_.global && (_.lastIndex = 0), _.test(c))
          return y;
      }
      return null;
    }, this.abort = function() {
      return this.abortController.abort(), this._abortController = null, this;
    };
  }
  // TODO: Revert this back to a single member variable once this issue has been fixed
  // https://github.com/cloudflare/workerd/issues/3657
  /**
   * Used for aborting ongoing requests in loaders using this manager.
   *
   * @type {AbortController}
   */
  get abortController() {
    return this._abortController || (this._abortController = new AbortController()), this._abortController;
  }
}
const A8 = /* @__PURE__ */ new iS();
class uo {
  /**
   * Constructs a new loader.
   *
   * @param {LoadingManager} [manager] - The loading manager.
   */
  constructor(e) {
    this.manager = e !== void 0 ? e : A8, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {};
  }
  /**
   * This method needs to be implemented by all concrete loaders. It holds the
   * logic for loading assets from the backend.
   *
   * @abstract
   * @param {string} url - The path/URL of the file to be loaded.
   * @param {Function} onLoad - Executed when the loading process has been finished.
   * @param {onProgressCallback} [onProgress] - Executed while the loading is in progress.
   * @param {onErrorCallback} [onError] - Executed when errors occur.
   */
  load() {
  }
  /**
   * A async version of {@link Loader#load}.
   *
   * @param {string} url - The path/URL of the file to be loaded.
   * @param {onProgressCallback} [onProgress] - Executed while the loading is in progress.
   * @return {Promise} A Promise that resolves when the asset has been loaded.
   */
  loadAsync(e, t) {
    const n = this;
    return new Promise(function(r, s) {
      n.load(e, r, t, s);
    });
  }
  /**
   * This method needs to be implemented by all concrete loaders. It holds the
   * logic for parsing the asset into three.js entities.
   *
   * @abstract
   * @param {any} data - The data to parse.
   */
  parse() {
  }
  /**
   * Sets the `crossOrigin` String to implement CORS for loading the URL
   * from a different domain that allows CORS.
   *
   * @param {string} crossOrigin - The `crossOrigin` value.
   * @return {Loader} A reference to this instance.
   */
  setCrossOrigin(e) {
    return this.crossOrigin = e, this;
  }
  /**
   * Whether the XMLHttpRequest uses credentials such as cookies, authorization
   * headers or TLS client certificates, see [XMLHttpRequest.withCredentials](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials).
   *
   * Note: This setting has no effect if you are loading files locally or from the same domain.
   *
   * @param {boolean} value - The `withCredentials` value.
   * @return {Loader} A reference to this instance.
   */
  setWithCredentials(e) {
    return this.withCredentials = e, this;
  }
  /**
   * Sets the base path for the asset.
   *
   * @param {string} path - The base path.
   * @return {Loader} A reference to this instance.
   */
  setPath(e) {
    return this.path = e, this;
  }
  /**
   * Sets the base path for dependent resources like textures.
   *
   * @param {string} resourcePath - The resource path.
   * @return {Loader} A reference to this instance.
   */
  setResourcePath(e) {
    return this.resourcePath = e, this;
  }
  /**
   * Sets the given request header.
   *
   * @param {Object} requestHeader - A [request header](https://developer.mozilla.org/en-US/docs/Glossary/Request_header)
   * for configuring the HTTP request.
   * @return {Loader} A reference to this instance.
   */
  setRequestHeader(e) {
    return this.requestHeader = e, this;
  }
  /**
   * This method can be implemented in loaders for aborting ongoing requests.
   *
   * @abstract
   * @return {Loader} A reference to this instance.
   */
  abort() {
    return this;
  }
}
uo.DEFAULT_MATERIAL_NAME = "__DEFAULT";
const xl = {};
class RO extends Error {
  constructor(e, t) {
    super(e), this.response = t;
  }
}
class Wl extends uo {
  /**
   * Constructs a new file loader.
   *
   * @param {LoadingManager} [manager] - The loading manager.
   */
  constructor(e) {
    super(e), this.mimeType = "", this.responseType = "", this._abortController = new AbortController();
  }
  /**
   * Starts loading from the given URL and pass the loaded response to the `onLoad()` callback.
   *
   * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.
   * @param {function(any)} onLoad - Executed when the loading process has been finished.
   * @param {onProgressCallback} [onProgress] - Executed while the loading is in progress.
   * @param {onErrorCallback} [onError] - Executed when errors occur.
   * @return {any|undefined} The cached resource if available.
   */
  load(e, t, n, r) {
    e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const s = ja.get(`file:${e}`);
    if (s !== void 0)
      return this.manager.itemStart(e), setTimeout(() => {
        t && t(s), this.manager.itemEnd(e);
      }, 0), s;
    if (xl[e] !== void 0) {
      xl[e].push({
        onLoad: t,
        onProgress: n,
        onError: r
      });
      return;
    }
    xl[e] = [], xl[e].push({
      onLoad: t,
      onProgress: n,
      onError: r
    });
    const o = new Request(e, {
      headers: new Headers(this.requestHeader),
      credentials: this.withCredentials ? "include" : "same-origin",
      signal: typeof AbortSignal.any == "function" ? AbortSignal.any([this._abortController.signal, this.manager.abortController.signal]) : this._abortController.signal
    }), a = this.mimeType, l = this.responseType;
    fetch(o).then((u) => {
      if (u.status === 200 || u.status === 0) {
        if (u.status === 0 && Me("FileLoader: HTTP Status 0 received."), typeof ReadableStream > "u" || u.body === void 0 || u.body.getReader === void 0)
          return u;
        const c = xl[e], A = u.body.getReader(), m = u.headers.get("X-File-Size") || u.headers.get("Content-Length"), _ = m ? parseInt(m) : 0, y = _ !== 0;
        let T = 0;
        const b = new ReadableStream({
          start(S) {
            E();
            function E() {
              A.read().then(({ done: R, value: C }) => {
                if (R)
                  S.close();
                else {
                  T += C.byteLength;
                  const L = new ProgressEvent("progress", { lengthComputable: y, loaded: T, total: _ });
                  for (let D = 0, B = c.length; D < B; D++) {
                    const U = c[D];
                    U.onProgress && U.onProgress(L);
                  }
                  S.enqueue(C), E();
                }
              }, (R) => {
                S.error(R);
              });
            }
          }
        });
        return new Response(b);
      } else
        throw new RO(`fetch for "${u.url}" responded with ${u.status}: ${u.statusText}`, u);
    }).then((u) => {
      switch (l) {
        case "arraybuffer":
          return u.arrayBuffer();
        case "blob":
          return u.blob();
        case "document":
          return u.text().then((c) => new DOMParser().parseFromString(c, a));
        case "json":
          return u.json();
        default:
          if (a === "")
            return u.text();
          {
            const A = /charset="?([^;"\s]*)"?/i.exec(a), m = A && A[1] ? A[1].toLowerCase() : void 0, _ = new TextDecoder(m);
            return u.arrayBuffer().then((y) => _.decode(y));
          }
      }
    }).then((u) => {
      ja.add(`file:${e}`, u);
      const c = xl[e];
      delete xl[e];
      for (let A = 0, m = c.length; A < m; A++) {
        const _ = c[A];
        _.onLoad && _.onLoad(u);
      }
    }).catch((u) => {
      const c = xl[e];
      if (c === void 0)
        throw this.manager.itemError(e), u;
      delete xl[e];
      for (let A = 0, m = c.length; A < m; A++) {
        const _ = c[A];
        _.onError && _.onError(u);
      }
      this.manager.itemError(e);
    }).finally(() => {
      this.manager.itemEnd(e);
    }), this.manager.itemStart(e);
  }
  /**
   * Sets the expected response type.
   *
   * @param {('arraybuffer'|'blob'|'document'|'json'|'')} value - The response type.
   * @return {FileLoader} A reference to this file loader.
   */
  setResponseType(e) {
    return this.responseType = e, this;
  }
  /**
   * Sets the expected mime type of the loaded file.
   *
   * @param {string} value - The mime type.
   * @return {FileLoader} A reference to this file loader.
   */
  setMimeType(e) {
    return this.mimeType = e, this;
  }
  /**
   * Aborts ongoing fetch requests.
   *
   * @return {FileLoader} A reference to this instance.
   */
  abort() {
    return this._abortController.abort(), this._abortController = new AbortController(), this;
  }
}
class CO extends uo {
  /**
   * Constructs a new animation loader.
   *
   * @param {LoadingManager} [manager] - The loading manager.
   */
  constructor(e) {
    super(e);
  }
  /**
   * Starts loading from the given URL and pass the loaded animations as an array
   * holding instances of {@link AnimationClip} to the `onLoad()` callback.
   *
   * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.
   * @param {function(Array<AnimationClip>)} onLoad - Executed when the loading process has been finished.
   * @param {onProgressCallback} onProgress - Executed while the loading is in progress.
   * @param {onErrorCallback} onError - Executed when errors occur.
   */
  load(e, t, n, r) {
    const s = this, o = new Wl(this.manager);
    o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(e, function(a) {
      try {
        t(s.parse(JSON.parse(a)));
      } catch (l) {
        r ? r(l) : Ie(l), s.manager.itemError(e);
      }
    }, n, r);
  }
  /**
   * Parses the given JSON object and returns an array of animation clips.
   *
   * @param {Object} json - The serialized animation clips.
   * @return {Array<AnimationClip>} The parsed animation clips.
   */
  parse(e) {
    const t = [];
    for (let n = 0; n < e.length; n++) {
      const r = Hp.parse(e[n]);
      t.push(r);
    }
    return t;
  }
}
class PO extends uo {
  /**
   * Constructs a new compressed texture loader.
   *
   * @param {LoadingManager} [manager] - The loading manager.
   */
  constructor(e) {
    super(e);
  }
  /**
   * Starts loading from the given URL and passes the loaded compressed texture
   * to the `onLoad()` callback. The method also returns a new texture object which can
   * directly be used for material creation. If you do it this way, the texture
   * may pop up in your scene once the respective loading process is finished.
   *
   * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.
   * @param {function(CompressedTexture)} onLoad - Executed when the loading process has been finished.
   * @param {onProgressCallback} onProgress - Executed while the loading is in progress.
   * @param {onErrorCallback} onError - Executed when errors occur.
   * @return {CompressedTexture} The compressed texture.
   */
  load(e, t, n, r) {
    const s = this, o = [], a = new n2(), l = new Wl(this.manager);
    l.setPath(this.path), l.setResponseType("arraybuffer"), l.setRequestHeader(this.requestHeader), l.setWithCredentials(s.withCredentials);
    let u = 0;
    function c(A) {
      l.load(e[A], function(m) {
        const _ = s.parse(m, !0);
        o[A] = {
          width: _.width,
          height: _.height,
          format: _.format,
          mipmaps: _.mipmaps
        }, u += 1, u === 6 && (_.mipmapCount === 1 && (a.minFilter = qn), a.image = o, a.format = _.format, a.needsUpdate = !0, t && t(a));
      }, n, r);
    }
    if (Array.isArray(e))
      for (let A = 0, m = e.length; A < m; ++A)
        c(A);
    else
      l.load(e, function(A) {
        const m = s.parse(A, !0);
        if (m.isCubemap) {
          const _ = m.mipmaps.length / m.mipmapCount;
          for (let y = 0; y < _; y++) {
            o[y] = { mipmaps: [] };
            for (let T = 0; T < m.mipmapCount; T++)
              o[y].mipmaps.push(m.mipmaps[y * m.mipmapCount + T]), o[y].format = m.format, o[y].width = m.width, o[y].height = m.height;
          }
          a.image = o;
        } else
          a.image.width = m.width, a.image.height = m.height, a.mipmaps = m.mipmaps;
        m.mipmapCount === 1 && (a.minFilter = qn), a.format = m.format, a.needsUpdate = !0, t && t(a);
      }, n, r);
    return a;
  }
}
const Id = /* @__PURE__ */ new WeakMap();
class Wp extends uo {
  /**
   * Constructs a new image loader.
   *
   * @param {LoadingManager} [manager] - The loading manager.
   */
  constructor(e) {
    super(e);
  }
  /**
   * Starts loading from the given URL and passes the loaded image
   * to the `onLoad()` callback. The method also returns a new `Image` object which can
   * directly be used for texture creation. If you do it this way, the texture
   * may pop up in your scene once the respective loading process is finished.
   *
   * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.
   * @param {function(Image)} onLoad - Executed when the loading process has been finished.
   * @param {onProgressCallback} onProgress - Unsupported in this loader.
   * @param {onErrorCallback} onError - Executed when errors occur.
   * @return {Image} The image.
   */
  load(e, t, n, r) {
    this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const s = this, o = ja.get(`image:${e}`);
    if (o !== void 0) {
      if (o.complete === !0)
        s.manager.itemStart(e), setTimeout(function() {
          t && t(o), s.manager.itemEnd(e);
        }, 0);
      else {
        let A = Id.get(o);
        A === void 0 && (A = [], Id.set(o, A)), A.push({ onLoad: t, onError: r });
      }
      return o;
    }
    const a = Op("img");
    function l() {
      c(), t && t(this);
      const A = Id.get(this) || [];
      for (let m = 0; m < A.length; m++) {
        const _ = A[m];
        _.onLoad && _.onLoad(this);
      }
      Id.delete(this), s.manager.itemEnd(e);
    }
    function u(A) {
      c(), r && r(A), ja.remove(`image:${e}`);
      const m = Id.get(this) || [];
      for (let _ = 0; _ < m.length; _++) {
        const y = m[_];
        y.onError && y.onError(A);
      }
      Id.delete(this), s.manager.itemError(e), s.manager.itemEnd(e);
    }
    function c() {
      a.removeEventListener("load", l, !1), a.removeEventListener("error", u, !1);
    }
    return a.addEventListener("load", l, !1), a.addEventListener("error", u, !1), e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (a.crossOrigin = this.crossOrigin), ja.add(`image:${e}`, a), s.manager.itemStart(e), a.src = e, a;
  }
}
class NO extends uo {
  /**
   * Constructs a new cube texture loader.
   *
   * @param {LoadingManager} [manager] - The loading manager.
   */
  constructor(e) {
    super(e);
  }
  /**
   * Starts loading from the given URL and pass the fully loaded cube texture
   * to the `onLoad()` callback. The method also returns a new cube texture object which can
   * directly be used for material creation. If you do it this way, the cube texture
   * may pop up in your scene once the respective loading process is finished.
   *
   * @param {Array<string>} urls - Array of 6 URLs to images, one for each side of the
   * cube texture. The urls should be specified in the following order: pos-x,
   * neg-x, pos-y, neg-y, pos-z, neg-z. An array of data URIs are allowed as well.
   * @param {function(CubeTexture)} onLoad - Executed when the loading process has been finished.
   * @param {onProgressCallback} onProgress - Unsupported in this loader.
   * @param {onErrorCallback} onError - Executed when errors occur.
   * @return {CubeTexture} The cube texture.
   */
  load(e, t, n, r) {
    const s = new Ju();
    s.colorSpace = gr;
    const o = new Wp(this.manager);
    o.setCrossOrigin(this.crossOrigin), o.setPath(this.path);
    let a = 0;
    function l(u) {
      o.load(e[u], function(c) {
        s.images[u] = c, a++, a === 6 && (s.needsUpdate = !0, t && t(s));
      }, void 0, r);
    }
    for (let u = 0; u < e.length; ++u)
      l(u);
    return s;
  }
}
class DO extends uo {
  /**
   * Constructs a new data texture loader.
   *
   * @param {LoadingManager} [manager] - The loading manager.
   */
  constructor(e) {
    super(e);
  }
  /**
   * Starts loading from the given URL and passes the loaded data texture
   * to the `onLoad()` callback. The method also returns a new texture object which can
   * directly be used for material creation. If you do it this way, the texture
   * may pop up in your scene once the respective loading process is finished.
   *
   * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.
   * @param {function(DataTexture)} onLoad - Executed when the loading process has been finished.
   * @param {onProgressCallback} onProgress - Executed while the loading is in progress.
   * @param {onErrorCallback} onError - Executed when errors occur.
   * @return {DataTexture} The data texture.
   */
  load(e, t, n, r) {
    const s = this, o = new wo(), a = new Wl(this.manager);
    return a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader), a.setPath(this.path), a.setWithCredentials(s.withCredentials), a.load(e, function(l) {
      let u;
      try {
        u = s.parse(l);
      } catch (c) {
        if (r !== void 0)
          r(c);
        else {
          c(c);
          return;
        }
      }
      u.image !== void 0 ? o.image = u.image : u.data !== void 0 && (o.image.width = u.width, o.image.height = u.height, o.image.data = u.data), o.wrapS = u.wrapS !== void 0 ? u.wrapS : xr, o.wrapT = u.wrapT !== void 0 ? u.wrapT : xr, o.magFilter = u.magFilter !== void 0 ? u.magFilter : qn, o.minFilter = u.minFilter !== void 0 ? u.minFilter : qn, o.anisotropy = u.anisotropy !== void 0 ? u.anisotropy : 1, u.colorSpace !== void 0 && (o.colorSpace = u.colorSpace), u.flipY !== void 0 && (o.flipY = u.flipY), u.format !== void 0 && (o.format = u.format), u.type !== void 0 && (o.type = u.type), u.mipmaps !== void 0 && (o.mipmaps = u.mipmaps, o.minFilter = $r), u.mipmapCount === 1 && (o.minFilter = qn), u.generateMipmaps !== void 0 && (o.generateMipmaps = u.generateMipmaps), o.needsUpdate = !0, t && t(o, u);
    }, n, r), o;
  }
}
class P0 extends uo {
  /**
   * Constructs a new texture loader.
   *
   * @param {LoadingManager} [manager] - The loading manager.
   */
  constructor(e) {
    super(e);
  }
  /**
   * Starts loading from the given URL and pass the fully loaded texture
   * to the `onLoad()` callback. The method also returns a new texture object which can
   * directly be used for material creation. If you do it this way, the texture
   * may pop up in your scene once the respective loading process is finished.
   *
   * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.
   * @param {function(Texture)} onLoad - Executed when the loading process has been finished.
   * @param {onProgressCallback} onProgress - Unsupported in this loader.
   * @param {onErrorCallback} onError - Executed when errors occur.
   * @return {Texture} The texture.
   */
  load(e, t, n, r) {
    const s = new Ii(), o = new Wp(this.manager);
    return o.setCrossOrigin(this.crossOrigin), o.setPath(this.path), o.load(e, function(a) {
      s.image = a, s.needsUpdate = !0, t !== void 0 && t(s);
    }, n, r), s;
  }
}
class nc extends Vn {
  /**
   * Constructs a new light.
   *
   * @param {(number|Color|string)} [color=0xffffff] - The light's color.
   * @param {number} [intensity=1] - The light's strength/intensity.
   */
  constructor(e, t = 1) {
    super(), this.isLight = !0, this.type = "Light", this.color = new ct(e), this.intensity = t;
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   */
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  copy(e, t) {
    return super.copy(e, t), this.color.copy(e.color), this.intensity = e.intensity, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, t;
  }
}
class rS extends nc {
  /**
   * Constructs a new hemisphere light.
   *
   * @param {(number|Color|string)} [skyColor=0xffffff] - The light's sky color.
   * @param {(number|Color|string)} [groundColor=0xffffff] - The light's ground color.
   * @param {number} [intensity=1] - The light's strength/intensity.
   */
  constructor(e, t, n) {
    super(e, n), this.isHemisphereLight = !0, this.type = "HemisphereLight", this.position.copy(Vn.DEFAULT_UP), this.updateMatrix(), this.groundColor = new ct(t);
  }
  copy(e, t) {
    return super.copy(e, t), this.groundColor.copy(e.groundColor), this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.groundColor = this.groundColor.getHex(), t;
  }
}
const gy = /* @__PURE__ */ new Mt(), eE = /* @__PURE__ */ new j(), tE = /* @__PURE__ */ new j();
class sS {
  /**
   * Constructs a new light shadow.
   *
   * @param {Camera} camera - The light's view of the world.
   */
  constructor(e) {
    this.camera = e, this.intensity = 1, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new Le(512, 512), this.mapType = Mi, this.map = null, this.mapPass = null, this.matrix = new Mt(), this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new ec(), this._frameExtents = new Le(1, 1), this._viewportCount = 1, this._viewports = [
      new Kt(0, 0, 1, 1)
    ];
  }
  /**
   * Used internally by the renderer to get the number of viewports that need
   * to be rendered for this shadow.
   *
   * @return {number} The viewport count.
   */
  getViewportCount() {
    return this._viewportCount;
  }
  /**
   * Gets the shadow cameras frustum. Used internally by the renderer to cull objects.
   *
   * @return {Frustum} The shadow camera frustum.
   */
  getFrustum() {
    return this._frustum;
  }
  /**
   * Update the matrices for the camera and shadow, used internally by the renderer.
   *
   * @param {Light} light - The light for which the shadow is being rendered.
   */
  updateMatrices(e) {
    const t = this.camera, n = this.matrix;
    eE.setFromMatrixPosition(e.matrixWorld), t.position.copy(eE), tE.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(tE), t.updateMatrixWorld(), gy.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(gy, t.coordinateSystem, t.reversedDepth), t.reversedDepth ? n.set(
      0.5,
      0,
      0,
      0.5,
      0,
      0.5,
      0,
      0.5,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ) : n.set(
      0.5,
      0,
      0,
      0.5,
      0,
      0.5,
      0,
      0.5,
      0,
      0,
      0.5,
      0.5,
      0,
      0,
      0,
      1
    ), n.multiply(gy);
  }
  /**
   * Returns a viewport definition for the given viewport index.
   *
   * @param {number} viewportIndex - The viewport index.
   * @return {Vector4} The viewport.
   */
  getViewport(e) {
    return this._viewports[e];
  }
  /**
   * Returns the frame extends.
   *
   * @return {Vector2} The frame extends.
   */
  getFrameExtents() {
    return this._frameExtents;
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   */
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  /**
   * Copies the values of the given light shadow instance to this instance.
   *
   * @param {LightShadow} source - The light shadow to copy.
   * @return {LightShadow} A reference to this light shadow instance.
   */
  copy(e) {
    return this.camera = e.camera.clone(), this.intensity = e.intensity, this.bias = e.bias, this.radius = e.radius, this.autoUpdate = e.autoUpdate, this.needsUpdate = e.needsUpdate, this.normalBias = e.normalBias, this.blurSamples = e.blurSamples, this.mapSize.copy(e.mapSize), this;
  }
  /**
   * Returns a new light shadow instance with copied values from this instance.
   *
   * @return {LightShadow} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
  /**
   * Serializes the light shadow into JSON.
   *
   * @return {Object} A JSON object representing the serialized light shadow.
   * @see {@link ObjectLoader#parse}
   */
  toJSON() {
    const e = {};
    return this.intensity !== 1 && (e.intensity = this.intensity), this.bias !== 0 && (e.bias = this.bias), this.normalBias !== 0 && (e.normalBias = this.normalBias), this.radius !== 1 && (e.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e;
  }
}
class LO extends sS {
  /**
   * Constructs a new spot light shadow.
   */
  constructor() {
    super(new Ji(50, 1, 0.5, 500)), this.isSpotLightShadow = !0, this.focus = 1, this.aspect = 1;
  }
  updateMatrices(e) {
    const t = this.camera, n = Gh * 2 * e.angle * this.focus, r = this.mapSize.width / this.mapSize.height * this.aspect, s = e.distance || t.far;
    (n !== t.fov || r !== t.aspect || s !== t.far) && (t.fov = n, t.aspect = r, t.far = s, t.updateProjectionMatrix()), super.updateMatrices(e);
  }
  copy(e) {
    return super.copy(e), this.focus = e.focus, this;
  }
}
class N0 extends nc {
  /**
   * Constructs a new spot light.
   *
   * @param {(number|Color|string)} [color=0xffffff] - The light's color.
   * @param {number} [intensity=1] - The light's strength/intensity measured in candela (cd).
   * @param {number} [distance=0] - Maximum range of the light. `0` means no limit.
   * @param {number} [angle=Math.PI/3] - Maximum angle of light dispersion from its direction whose upper bound is `Math.PI/2`.
   * @param {number} [penumbra=0] - Percent of the spotlight cone that is attenuated due to penumbra. Value range is `[0,1]`.
   * @param {number} [decay=2] - The amount the light dims along the distance of the light.
   */
  constructor(e, t, n = 0, r = Math.PI / 3, s = 0, o = 2) {
    super(e, t), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(Vn.DEFAULT_UP), this.updateMatrix(), this.target = new Vn(), this.distance = n, this.angle = r, this.penumbra = s, this.decay = o, this.map = null, this.shadow = new LO();
  }
  /**
   * The light's power. Power is the luminous power of the light measured in lumens (lm).
   *  Changing the power will also change the light's intensity.
   *
   * @type {number}
   */
  get power() {
    return this.intensity * Math.PI;
  }
  set power(e) {
    this.intensity = e / Math.PI;
  }
  dispose() {
    super.dispose(), this.shadow.dispose();
  }
  copy(e, t) {
    return super.copy(e, t), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.map = e.map, this.shadow = e.shadow.clone(), this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.distance = this.distance, t.object.angle = this.angle, t.object.decay = this.decay, t.object.penumbra = this.penumbra, t.object.target = this.target.uuid, this.map && this.map.isTexture && (t.object.map = this.map.toJSON(e).uuid), t.object.shadow = this.shadow.toJSON(), t;
  }
}
class IO extends sS {
  /**
   * Constructs a new point light shadow.
   */
  constructor() {
    super(new Ji(90, 1, 0.5, 500)), this.isPointLightShadow = !0;
  }
}
class oS extends nc {
  /**
   * Constructs a new point light.
   *
   * @param {(number|Color|string)} [color=0xffffff] - The light's color.
   * @param {number} [intensity=1] - The light's strength/intensity measured in candela (cd).
   * @param {number} [distance=0] - Maximum range of the light. `0` means no limit.
   * @param {number} [decay=2] - The amount the light dims along the distance of the light.
   */
  constructor(e, t, n = 0, r = 2) {
    super(e, t), this.isPointLight = !0, this.type = "PointLight", this.distance = n, this.decay = r, this.shadow = new IO();
  }
  /**
   * The light's power. Power is the luminous power of the light measured in lumens (lm).
   * Changing the power will also change the light's intensity.
   *
   * @type {number}
   */
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(e) {
    this.intensity = e / (4 * Math.PI);
  }
  dispose() {
    super.dispose(), this.shadow.dispose();
  }
  copy(e, t) {
    return super.copy(e, t), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.distance = this.distance, t.object.decay = this.decay, t.object.shadow = this.shadow.toJSON(), t;
  }
}
class ic extends Jh {
  /**
   * Constructs a new orthographic camera.
   *
   * @param {number} [left=-1] - The left plane of the camera's frustum.
   * @param {number} [right=1] - The right plane of the camera's frustum.
   * @param {number} [top=1] - The top plane of the camera's frustum.
   * @param {number} [bottom=-1] - The bottom plane of the camera's frustum.
   * @param {number} [near=0.1] - The camera's near plane.
   * @param {number} [far=2000] - The camera's far plane.
   */
  constructor(e = -1, t = 1, n = 1, r = -1, s = 0.1, o = 2e3) {
    super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = n, this.bottom = r, this.near = s, this.far = o, this.updateProjectionMatrix();
  }
  copy(e, t) {
    return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = e.view === null ? null : Object.assign({}, e.view), this;
  }
  /**
   * Sets an offset in a larger frustum. This is useful for multi-window or
   * multi-monitor/multi-machine setups.
   *
   * @param {number} fullWidth - The full width of multiview setup.
   * @param {number} fullHeight - The full height of multiview setup.
   * @param {number} x - The horizontal offset of the subcamera.
   * @param {number} y - The vertical offset of the subcamera.
   * @param {number} width - The width of subcamera.
   * @param {number} height - The height of subcamera.
   * @see {@link PerspectiveCamera#setViewOffset}
   */
  setViewOffset(e, t, n, r, s, o) {
    this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = r, this.view.width = s, this.view.height = o, this.updateProjectionMatrix();
  }
  /**
   * Removes the view offset from the projection matrix.
   */
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  /**
   * Updates the camera's projection matrix. Must be called after any change of
   * camera properties.
   */
  updateProjectionMatrix() {
    const e = (this.right - this.left) / (2 * this.zoom), t = (this.top - this.bottom) / (2 * this.zoom), n = (this.right + this.left) / 2, r = (this.top + this.bottom) / 2;
    let s = n - e, o = n + e, a = r + t, l = r - t;
    if (this.view !== null && this.view.enabled) {
      const u = (this.right - this.left) / this.view.fullWidth / this.zoom, c = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      s += u * this.view.offsetX, o = s + u * this.view.width, a -= c * this.view.offsetY, l = a - c * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(s, o, a, l, this.near, this.far, this.coordinateSystem, this.reversedDepth), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, this.view !== null && (t.object.view = Object.assign({}, this.view)), t;
  }
}
class BO extends sS {
  /**
   * Constructs a new directional light shadow.
   */
  constructor() {
    super(new ic(-5, 5, 5, -5, 0.5, 500)), this.isDirectionalLightShadow = !0;
  }
}
class p2 extends nc {
  /**
   * Constructs a new directional light.
   *
   * @param {(number|Color|string)} [color=0xffffff] - The light's color.
   * @param {number} [intensity=1] - The light's strength/intensity.
   */
  constructor(e, t) {
    super(e, t), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(Vn.DEFAULT_UP), this.updateMatrix(), this.target = new Vn(), this.shadow = new BO();
  }
  dispose() {
    super.dispose(), this.shadow.dispose();
  }
  copy(e) {
    return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.shadow = this.shadow.toJSON(), t.object.target = this.target.uuid, t;
  }
}
class m2 extends nc {
  /**
   * Constructs a new ambient light.
   *
   * @param {(number|Color|string)} [color=0xffffff] - The light's color.
   * @param {number} [intensity=1] - The light's strength/intensity.
   */
  constructor(e, t) {
    super(e, t), this.isAmbientLight = !0, this.type = "AmbientLight";
  }
}
class aS extends nc {
  /**
   * Constructs a new area light.
   *
   * @param {(number|Color|string)} [color=0xffffff] - The light's color.
   * @param {number} [intensity=1] - The light's strength/intensity.
   * @param {number} [width=10] - The width of the light.
   * @param {number} [height=10] - The height of the light.
   */
  constructor(e, t, n = 10, r = 10) {
    super(e, t), this.isRectAreaLight = !0, this.type = "RectAreaLight", this.width = n, this.height = r;
  }
  /**
   * The light's power. Power is the luminous power of the light measured in lumens (lm).
   * Changing the power will also change the light's intensity.
   *
   * @type {number}
   */
  get power() {
    return this.intensity * this.width * this.height * Math.PI;
  }
  set power(e) {
    this.intensity = e / (this.width * this.height * Math.PI);
  }
  copy(e) {
    return super.copy(e), this.width = e.width, this.height = e.height, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.width = this.width, t.object.height = this.height, t;
  }
}
class lS {
  /**
   * Constructs a new spherical harmonics.
   */
  constructor() {
    this.isSphericalHarmonics3 = !0, this.coefficients = [];
    for (let e = 0; e < 9; e++)
      this.coefficients.push(new j());
  }
  /**
   * Sets the given SH coefficients to this instance by copying
   * the values.
   *
   * @param {Array<Vector3>} coefficients - The SH coefficients.
   * @return {SphericalHarmonics3} A reference to this spherical harmonics.
   */
  set(e) {
    for (let t = 0; t < 9; t++)
      this.coefficients[t].copy(e[t]);
    return this;
  }
  /**
   * Sets all SH coefficients to `0`.
   *
   * @return {SphericalHarmonics3} A reference to this spherical harmonics.
   */
  zero() {
    for (let e = 0; e < 9; e++)
      this.coefficients[e].set(0, 0, 0);
    return this;
  }
  /**
   * Returns the radiance in the direction of the given normal.
   *
   * @param {Vector3} normal - The normal vector (assumed to be unit length)
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The radiance.
   */
  getAt(e, t) {
    const n = e.x, r = e.y, s = e.z, o = this.coefficients;
    return t.copy(o[0]).multiplyScalar(0.282095), t.addScaledVector(o[1], 0.488603 * r), t.addScaledVector(o[2], 0.488603 * s), t.addScaledVector(o[3], 0.488603 * n), t.addScaledVector(o[4], 1.092548 * (n * r)), t.addScaledVector(o[5], 1.092548 * (r * s)), t.addScaledVector(o[6], 0.315392 * (3 * s * s - 1)), t.addScaledVector(o[7], 1.092548 * (n * s)), t.addScaledVector(o[8], 0.546274 * (n * n - r * r)), t;
  }
  /**
   * Returns the irradiance (radiance convolved with cosine lobe) in the
   * direction of the given normal.
   *
   * @param {Vector3} normal - The normal vector (assumed to be unit length)
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The irradiance.
   */
  getIrradianceAt(e, t) {
    const n = e.x, r = e.y, s = e.z, o = this.coefficients;
    return t.copy(o[0]).multiplyScalar(0.886227), t.addScaledVector(o[1], 2 * 0.511664 * r), t.addScaledVector(o[2], 2 * 0.511664 * s), t.addScaledVector(o[3], 2 * 0.511664 * n), t.addScaledVector(o[4], 2 * 0.429043 * n * r), t.addScaledVector(o[5], 2 * 0.429043 * r * s), t.addScaledVector(o[6], 0.743125 * s * s - 0.247708), t.addScaledVector(o[7], 2 * 0.429043 * n * s), t.addScaledVector(o[8], 0.429043 * (n * n - r * r)), t;
  }
  /**
   * Adds the given SH to this instance.
   *
   * @param {SphericalHarmonics3} sh - The SH to add.
   * @return {SphericalHarmonics3} A reference to this spherical harmonics.
   */
  add(e) {
    for (let t = 0; t < 9; t++)
      this.coefficients[t].add(e.coefficients[t]);
    return this;
  }
  /**
   * A convenience method for performing {@link SphericalHarmonics3#add} and
   * {@link SphericalHarmonics3#scale} at once.
   *
   * @param {SphericalHarmonics3} sh - The SH to add.
   * @param {number} s - The scale factor.
   * @return {SphericalHarmonics3} A reference to this spherical harmonics.
   */
  addScaledSH(e, t) {
    for (let n = 0; n < 9; n++)
      this.coefficients[n].addScaledVector(e.coefficients[n], t);
    return this;
  }
  /**
   * Scales this SH by the given scale factor.
   *
   * @param {number} s - The scale factor.
   * @return {SphericalHarmonics3} A reference to this spherical harmonics.
   */
  scale(e) {
    for (let t = 0; t < 9; t++)
      this.coefficients[t].multiplyScalar(e);
    return this;
  }
  /**
   * Linear interpolates between the given SH and this instance by the given
   * alpha factor.
   *
   * @param {SphericalHarmonics3} sh - The SH to interpolate with.
   * @param {number} alpha - The alpha factor.
   * @return {SphericalHarmonics3} A reference to this spherical harmonics.
   */
  lerp(e, t) {
    for (let n = 0; n < 9; n++)
      this.coefficients[n].lerp(e.coefficients[n], t);
    return this;
  }
  /**
   * Returns `true` if this spherical harmonics is equal with the given one.
   *
   * @param {SphericalHarmonics3} sh - The spherical harmonics to test for equality.
   * @return {boolean} Whether this spherical harmonics is equal with the given one.
   */
  equals(e) {
    for (let t = 0; t < 9; t++)
      if (!this.coefficients[t].equals(e.coefficients[t]))
        return !1;
    return !0;
  }
  /**
   * Copies the values of the given spherical harmonics to this instance.
   *
   * @param {SphericalHarmonics3} sh - The spherical harmonics to copy.
   * @return {SphericalHarmonics3} A reference to this spherical harmonics.
   */
  copy(e) {
    return this.set(e.coefficients);
  }
  /**
   * Returns a new spherical harmonics with copied values from this instance.
   *
   * @return {SphericalHarmonics3} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
  /**
   * Sets the SH coefficients of this instance from the given array.
   *
   * @param {Array<number>} array - An array holding the SH coefficients.
   * @param {number} [offset=0] - The array offset where to start copying.
   * @return {SphericalHarmonics3} A clone of this instance.
   */
  fromArray(e, t = 0) {
    const n = this.coefficients;
    for (let r = 0; r < 9; r++)
      n[r].fromArray(e, t + r * 3);
    return this;
  }
  /**
   * Returns an array with the SH coefficients, or copies them into the provided
   * array. The coefficients are represented as numbers.
   *
   * @param {Array<number>} [array=[]] - The target array.
   * @param {number} [offset=0] - The array offset where to start copying.
   * @return {Array<number>} An array with flat SH coefficients.
   */
  toArray(e = [], t = 0) {
    const n = this.coefficients;
    for (let r = 0; r < 9; r++)
      n[r].toArray(e, t + r * 3);
    return e;
  }
  /**
   * Computes the SH basis for the given normal vector.
   *
   * @param {Vector3} normal - The normal.
   * @param {Array<number>} shBasis - The target array holding the SH basis.
   */
  static getBasisAt(e, t) {
    const n = e.x, r = e.y, s = e.z;
    t[0] = 0.282095, t[1] = 0.488603 * r, t[2] = 0.488603 * s, t[3] = 0.488603 * n, t[4] = 1.092548 * n * r, t[5] = 1.092548 * r * s, t[6] = 0.315392 * (3 * s * s - 1), t[7] = 1.092548 * n * s, t[8] = 0.546274 * (n * n - r * r);
  }
}
class uS extends nc {
  /**
   * Constructs a new light probe.
   *
   * @param {SphericalHarmonics3} sh - The spherical harmonics which represents encoded lighting information.
   * @param {number} [intensity=1] - The light's strength/intensity.
   */
  constructor(e = new lS(), t = 1) {
    super(void 0, t), this.isLightProbe = !0, this.sh = e;
  }
  copy(e) {
    return super.copy(e), this.sh.copy(e.sh), this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.sh = this.sh.toArray(), t;
  }
}
class g2 extends uo {
  /**
   * Constructs a new material loader.
   *
   * @param {LoadingManager} [manager] - The loading manager.
   */
  constructor(e) {
    super(e), this.textures = {};
  }
  /**
   * Starts loading from the given URL and pass the loaded material to the `onLoad()` callback.
   *
   * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.
   * @param {function(Material)} onLoad - Executed when the loading process has been finished.
   * @param {onProgressCallback} onProgress - Executed while the loading is in progress.
   * @param {onErrorCallback} onError - Executed when errors occur.
   */
  load(e, t, n, r) {
    const s = this, o = new Wl(s.manager);
    o.setPath(s.path), o.setRequestHeader(s.requestHeader), o.setWithCredentials(s.withCredentials), o.load(e, function(a) {
      try {
        t(s.parse(JSON.parse(a)));
      } catch (l) {
        r ? r(l) : Ie(l), s.manager.itemError(e);
      }
    }, n, r);
  }
  /**
   * Parses the given JSON object and returns a material.
   *
   * @param {Object} json - The serialized material.
   * @return {Material} The parsed material.
   */
  parse(e) {
    const t = this.textures;
    function n(s) {
      return t[s] === void 0 && Me("MaterialLoader: Undefined texture", s), t[s];
    }
    const r = this.createMaterialFromType(e.type);
    if (e.uuid !== void 0 && (r.uuid = e.uuid), e.name !== void 0 && (r.name = e.name), e.color !== void 0 && r.color !== void 0 && r.color.setHex(e.color), e.roughness !== void 0 && (r.roughness = e.roughness), e.metalness !== void 0 && (r.metalness = e.metalness), e.sheen !== void 0 && (r.sheen = e.sheen), e.sheenColor !== void 0 && (r.sheenColor = new ct().setHex(e.sheenColor)), e.sheenRoughness !== void 0 && (r.sheenRoughness = e.sheenRoughness), e.emissive !== void 0 && r.emissive !== void 0 && r.emissive.setHex(e.emissive), e.specular !== void 0 && r.specular !== void 0 && r.specular.setHex(e.specular), e.specularIntensity !== void 0 && (r.specularIntensity = e.specularIntensity), e.specularColor !== void 0 && r.specularColor !== void 0 && r.specularColor.setHex(e.specularColor), e.shininess !== void 0 && (r.shininess = e.shininess), e.clearcoat !== void 0 && (r.clearcoat = e.clearcoat), e.clearcoatRoughness !== void 0 && (r.clearcoatRoughness = e.clearcoatRoughness), e.dispersion !== void 0 && (r.dispersion = e.dispersion), e.iridescence !== void 0 && (r.iridescence = e.iridescence), e.iridescenceIOR !== void 0 && (r.iridescenceIOR = e.iridescenceIOR), e.iridescenceThicknessRange !== void 0 && (r.iridescenceThicknessRange = e.iridescenceThicknessRange), e.transmission !== void 0 && (r.transmission = e.transmission), e.thickness !== void 0 && (r.thickness = e.thickness), e.attenuationDistance !== void 0 && (r.attenuationDistance = e.attenuationDistance), e.attenuationColor !== void 0 && r.attenuationColor !== void 0 && r.attenuationColor.setHex(e.attenuationColor), e.anisotropy !== void 0 && (r.anisotropy = e.anisotropy), e.anisotropyRotation !== void 0 && (r.anisotropyRotation = e.anisotropyRotation), e.fog !== void 0 && (r.fog = e.fog), e.flatShading !== void 0 && (r.flatShading = e.flatShading), e.blending !== void 0 && (r.blending = e.blending), e.combine !== void 0 && (r.combine = e.combine), e.side !== void 0 && (r.side = e.side), e.shadowSide !== void 0 && (r.shadowSide = e.shadowSide), e.opacity !== void 0 && (r.opacity = e.opacity), e.transparent !== void 0 && (r.transparent = e.transparent), e.alphaTest !== void 0 && (r.alphaTest = e.alphaTest), e.alphaHash !== void 0 && (r.alphaHash = e.alphaHash), e.depthFunc !== void 0 && (r.depthFunc = e.depthFunc), e.depthTest !== void 0 && (r.depthTest = e.depthTest), e.depthWrite !== void 0 && (r.depthWrite = e.depthWrite), e.colorWrite !== void 0 && (r.colorWrite = e.colorWrite), e.blendSrc !== void 0 && (r.blendSrc = e.blendSrc), e.blendDst !== void 0 && (r.blendDst = e.blendDst), e.blendEquation !== void 0 && (r.blendEquation = e.blendEquation), e.blendSrcAlpha !== void 0 && (r.blendSrcAlpha = e.blendSrcAlpha), e.blendDstAlpha !== void 0 && (r.blendDstAlpha = e.blendDstAlpha), e.blendEquationAlpha !== void 0 && (r.blendEquationAlpha = e.blendEquationAlpha), e.blendColor !== void 0 && r.blendColor !== void 0 && r.blendColor.setHex(e.blendColor), e.blendAlpha !== void 0 && (r.blendAlpha = e.blendAlpha), e.stencilWriteMask !== void 0 && (r.stencilWriteMask = e.stencilWriteMask), e.stencilFunc !== void 0 && (r.stencilFunc = e.stencilFunc), e.stencilRef !== void 0 && (r.stencilRef = e.stencilRef), e.stencilFuncMask !== void 0 && (r.stencilFuncMask = e.stencilFuncMask), e.stencilFail !== void 0 && (r.stencilFail = e.stencilFail), e.stencilZFail !== void 0 && (r.stencilZFail = e.stencilZFail), e.stencilZPass !== void 0 && (r.stencilZPass = e.stencilZPass), e.stencilWrite !== void 0 && (r.stencilWrite = e.stencilWrite), e.wireframe !== void 0 && (r.wireframe = e.wireframe), e.wireframeLinewidth !== void 0 && (r.wireframeLinewidth = e.wireframeLinewidth), e.wireframeLinecap !== void 0 && (r.wireframeLinecap = e.wireframeLinecap), e.wireframeLinejoin !== void 0 && (r.wireframeLinejoin = e.wireframeLinejoin), e.rotation !== void 0 && (r.rotation = e.rotation), e.linewidth !== void 0 && (r.linewidth = e.linewidth), e.dashSize !== void 0 && (r.dashSize = e.dashSize), e.gapSize !== void 0 && (r.gapSize = e.gapSize), e.scale !== void 0 && (r.scale = e.scale), e.polygonOffset !== void 0 && (r.polygonOffset = e.polygonOffset), e.polygonOffsetFactor !== void 0 && (r.polygonOffsetFactor = e.polygonOffsetFactor), e.polygonOffsetUnits !== void 0 && (r.polygonOffsetUnits = e.polygonOffsetUnits), e.dithering !== void 0 && (r.dithering = e.dithering), e.alphaToCoverage !== void 0 && (r.alphaToCoverage = e.alphaToCoverage), e.premultipliedAlpha !== void 0 && (r.premultipliedAlpha = e.premultipliedAlpha), e.forceSinglePass !== void 0 && (r.forceSinglePass = e.forceSinglePass), e.allowOverride !== void 0 && (r.allowOverride = e.allowOverride), e.visible !== void 0 && (r.visible = e.visible), e.toneMapped !== void 0 && (r.toneMapped = e.toneMapped), e.userData !== void 0 && (r.userData = e.userData), e.vertexColors !== void 0 && (typeof e.vertexColors == "number" ? r.vertexColors = e.vertexColors > 0 : r.vertexColors = e.vertexColors), e.uniforms !== void 0)
      for (const s in e.uniforms) {
        const o = e.uniforms[s];
        switch (r.uniforms[s] = {}, o.type) {
          case "t":
            r.uniforms[s].value = n(o.value);
            break;
          case "c":
            r.uniforms[s].value = new ct().setHex(o.value);
            break;
          case "v2":
            r.uniforms[s].value = new Le().fromArray(o.value);
            break;
          case "v3":
            r.uniforms[s].value = new j().fromArray(o.value);
            break;
          case "v4":
            r.uniforms[s].value = new Kt().fromArray(o.value);
            break;
          case "m3":
            r.uniforms[s].value = new fn().fromArray(o.value);
            break;
          case "m4":
            r.uniforms[s].value = new Mt().fromArray(o.value);
            break;
          default:
            r.uniforms[s].value = o.value;
        }
      }
    if (e.defines !== void 0 && (r.defines = e.defines), e.vertexShader !== void 0 && (r.vertexShader = e.vertexShader), e.fragmentShader !== void 0 && (r.fragmentShader = e.fragmentShader), e.glslVersion !== void 0 && (r.glslVersion = e.glslVersion), e.extensions !== void 0)
      for (const s in e.extensions)
        r.extensions[s] = e.extensions[s];
    if (e.lights !== void 0 && (r.lights = e.lights), e.clipping !== void 0 && (r.clipping = e.clipping), e.size !== void 0 && (r.size = e.size), e.sizeAttenuation !== void 0 && (r.sizeAttenuation = e.sizeAttenuation), e.map !== void 0 && (r.map = n(e.map)), e.matcap !== void 0 && (r.matcap = n(e.matcap)), e.alphaMap !== void 0 && (r.alphaMap = n(e.alphaMap)), e.bumpMap !== void 0 && (r.bumpMap = n(e.bumpMap)), e.bumpScale !== void 0 && (r.bumpScale = e.bumpScale), e.normalMap !== void 0 && (r.normalMap = n(e.normalMap)), e.normalMapType !== void 0 && (r.normalMapType = e.normalMapType), e.normalScale !== void 0) {
      let s = e.normalScale;
      Array.isArray(s) === !1 && (s = [s, s]), r.normalScale = new Le().fromArray(s);
    }
    return e.displacementMap !== void 0 && (r.displacementMap = n(e.displacementMap)), e.displacementScale !== void 0 && (r.displacementScale = e.displacementScale), e.displacementBias !== void 0 && (r.displacementBias = e.displacementBias), e.roughnessMap !== void 0 && (r.roughnessMap = n(e.roughnessMap)), e.metalnessMap !== void 0 && (r.metalnessMap = n(e.metalnessMap)), e.emissiveMap !== void 0 && (r.emissiveMap = n(e.emissiveMap)), e.emissiveIntensity !== void 0 && (r.emissiveIntensity = e.emissiveIntensity), e.specularMap !== void 0 && (r.specularMap = n(e.specularMap)), e.specularIntensityMap !== void 0 && (r.specularIntensityMap = n(e.specularIntensityMap)), e.specularColorMap !== void 0 && (r.specularColorMap = n(e.specularColorMap)), e.envMap !== void 0 && (r.envMap = n(e.envMap)), e.envMapRotation !== void 0 && r.envMapRotation.fromArray(e.envMapRotation), e.envMapIntensity !== void 0 && (r.envMapIntensity = e.envMapIntensity), e.reflectivity !== void 0 && (r.reflectivity = e.reflectivity), e.refractionRatio !== void 0 && (r.refractionRatio = e.refractionRatio), e.lightMap !== void 0 && (r.lightMap = n(e.lightMap)), e.lightMapIntensity !== void 0 && (r.lightMapIntensity = e.lightMapIntensity), e.aoMap !== void 0 && (r.aoMap = n(e.aoMap)), e.aoMapIntensity !== void 0 && (r.aoMapIntensity = e.aoMapIntensity), e.gradientMap !== void 0 && (r.gradientMap = n(e.gradientMap)), e.clearcoatMap !== void 0 && (r.clearcoatMap = n(e.clearcoatMap)), e.clearcoatRoughnessMap !== void 0 && (r.clearcoatRoughnessMap = n(e.clearcoatRoughnessMap)), e.clearcoatNormalMap !== void 0 && (r.clearcoatNormalMap = n(e.clearcoatNormalMap)), e.clearcoatNormalScale !== void 0 && (r.clearcoatNormalScale = new Le().fromArray(e.clearcoatNormalScale)), e.iridescenceMap !== void 0 && (r.iridescenceMap = n(e.iridescenceMap)), e.iridescenceThicknessMap !== void 0 && (r.iridescenceThicknessMap = n(e.iridescenceThicknessMap)), e.transmissionMap !== void 0 && (r.transmissionMap = n(e.transmissionMap)), e.thicknessMap !== void 0 && (r.thicknessMap = n(e.thicknessMap)), e.anisotropyMap !== void 0 && (r.anisotropyMap = n(e.anisotropyMap)), e.sheenColorMap !== void 0 && (r.sheenColorMap = n(e.sheenColorMap)), e.sheenRoughnessMap !== void 0 && (r.sheenRoughnessMap = n(e.sheenRoughnessMap)), r;
  }
  /**
   * Textures are not embedded in the material JSON so they have
   * to be injected before the loading process starts.
   *
   * @param {Object} value - A dictionary holding textures for material properties.
   * @return {MaterialLoader} A reference to this material loader.
   */
  setTextures(e) {
    return this.textures = e, this;
  }
  /**
   * Creates a material for the given type.
   *
   * @param {string} type - The material type.
   * @return {Material} The new material.
   */
  createMaterialFromType(e) {
    return g2.createMaterialFromType(e);
  }
  /**
   * Creates a material for the given type.
   *
   * @static
   * @param {string} type - The material type.
   * @return {Material} The new material.
   */
  static createMaterialFromType(e) {
    const t = {
      ShadowMaterial: W3,
      SpriteMaterial: J_,
      RawShaderMaterial: $3,
      ShaderMaterial: Fr,
      PointsMaterial: S0,
      MeshPhysicalMaterial: j3,
      MeshStandardMaterial: f2,
      MeshPhongMaterial: A2,
      MeshToonMaterial: X3,
      MeshNormalMaterial: Y3,
      MeshLambertMaterial: Ea,
      MeshDepthMaterial: Q3,
      MeshDistanceMaterial: K3,
      MeshBasicMaterial: Nr,
      MeshMatcapMaterial: Z3,
      LineDashedMaterial: J3,
      LineBasicMaterial: br,
      Material: Br
    };
    return new t[e]();
  }
}
class zv {
  /**
   * Extracts the base URL from the given URL.
   *
   * @param {string} url -The URL to extract the base URL from.
   * @return {string} The extracted base URL.
   */
  static extractUrlBase(e) {
    const t = e.lastIndexOf("/");
    return t === -1 ? "./" : e.slice(0, t + 1);
  }
  /**
   * Resolves relative URLs against the given path. Absolute paths, data urls,
   * and blob URLs will be returned as is. Invalid URLs will return an empty
   * string.
   *
   * @param {string} url -The URL to resolve.
   * @param {string} path - The base path for relative URLs to be resolved against.
   * @return {string} The resolved URL.
   */
  static resolveURL(e, t) {
    return typeof e != "string" || e === "" ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e);
  }
}
class cS extends Yt {
  /**
   * Constructs a new instanced buffer geometry.
   */
  constructor() {
    super(), this.isInstancedBufferGeometry = !0, this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0;
  }
  copy(e) {
    return super.copy(e), this.instanceCount = e.instanceCount, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.instanceCount = this.instanceCount, e.isInstancedBufferGeometry = !0, e;
  }
}
class p8 extends uo {
  /**
   * Constructs a new geometry loader.
   *
   * @param {LoadingManager} [manager] - The loading manager.
   */
  constructor(e) {
    super(e);
  }
  /**
   * Starts loading from the given URL and pass the loaded geometry to the `onLoad()` callback.
   *
   * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.
   * @param {function(BufferGeometry)} onLoad - Executed when the loading process has been finished.
   * @param {onProgressCallback} onProgress - Executed while the loading is in progress.
   * @param {onErrorCallback} onError - Executed when errors occur.
   */
  load(e, t, n, r) {
    const s = this, o = new Wl(s.manager);
    o.setPath(s.path), o.setRequestHeader(s.requestHeader), o.setWithCredentials(s.withCredentials), o.load(e, function(a) {
      try {
        t(s.parse(JSON.parse(a)));
      } catch (l) {
        r ? r(l) : Ie(l), s.manager.itemError(e);
      }
    }, n, r);
  }
  /**
   * Parses the given JSON object and returns a geometry.
   *
   * @param {Object} json - The serialized geometry.
   * @return {BufferGeometry} The parsed geometry.
   */
  parse(e) {
    const t = {}, n = {};
    function r(_, y) {
      if (t[y] !== void 0) return t[y];
      const b = _.interleavedBuffers[y], S = s(_, b.buffer), E = af(b.type, S), R = new aA(E, b.stride);
      return R.uuid = b.uuid, t[y] = R, R;
    }
    function s(_, y) {
      if (n[y] !== void 0) return n[y];
      const b = _.arrayBuffers[y], S = new Uint32Array(b).buffer;
      return n[y] = S, S;
    }
    const o = e.isInstancedBufferGeometry ? new cS() : new Yt(), a = e.data.index;
    if (a !== void 0) {
      const _ = af(a.type, a.array);
      o.setIndex(new Dn(_, 1));
    }
    const l = e.data.attributes;
    for (const _ in l) {
      const y = l[_];
      let T;
      if (y.isInterleavedBufferAttribute) {
        const b = r(e.data, y.data);
        T = new Bs(b, y.itemSize, y.offset, y.normalized);
      } else {
        const b = af(y.type, y.array), S = y.isInstancedBufferAttribute ? to : Dn;
        T = new S(b, y.itemSize, y.normalized);
      }
      y.name !== void 0 && (T.name = y.name), y.usage !== void 0 && T.setUsage(y.usage), o.setAttribute(_, T);
    }
    const u = e.data.morphAttributes;
    if (u)
      for (const _ in u) {
        const y = u[_], T = [];
        for (let b = 0, S = y.length; b < S; b++) {
          const E = y[b];
          let R;
          if (E.isInterleavedBufferAttribute) {
            const C = r(e.data, E.data);
            R = new Bs(C, E.itemSize, E.offset, E.normalized);
          } else {
            const C = af(E.type, E.array);
            R = new Dn(C, E.itemSize, E.normalized);
          }
          E.name !== void 0 && (R.name = E.name), T.push(R);
        }
        o.morphAttributes[_] = T;
      }
    e.data.morphTargetsRelative && (o.morphTargetsRelative = !0);
    const A = e.data.groups || e.data.drawcalls || e.data.offsets;
    if (A !== void 0)
      for (let _ = 0, y = A.length; _ !== y; ++_) {
        const T = A[_];
        o.addGroup(T.start, T.count, T.materialIndex);
      }
    const m = e.data.boundingSphere;
    return m !== void 0 && (o.boundingSphere = new fr().fromJSON(m)), e.name && (o.name = e.name), e.userData && (o.userData = e.userData), o;
  }
}
class FO extends uo {
  /**
   * Constructs a new object loader.
   *
   * @param {LoadingManager} [manager] - The loading manager.
   */
  constructor(e) {
    super(e);
  }
  /**
   * Starts loading from the given URL and pass the loaded 3D object to the `onLoad()` callback.
   *
   * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.
   * @param {function(Object3D)} onLoad - Executed when the loading process has been finished.
   * @param {onProgressCallback} onProgress - Executed while the loading is in progress.
   * @param {onErrorCallback} onError - Executed when errors occur.
   */
  load(e, t, n, r) {
    const s = this, o = this.path === "" ? zv.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || o;
    const a = new Wl(this.manager);
    a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(e, function(l) {
      let u = null;
      try {
        u = JSON.parse(l);
      } catch (A) {
        r !== void 0 && r(A), A("ObjectLoader: Can't parse " + e + ".", A.message);
        return;
      }
      const c = u.metadata;
      if (c === void 0 || c.type === void 0 || c.type.toLowerCase() === "geometry") {
        r !== void 0 && r(new Error("THREE.ObjectLoader: Can't load " + e)), Ie("ObjectLoader: Can't load " + e);
        return;
      }
      s.parse(u, t);
    }, n, r);
  }
  /**
   * Async version of {@link ObjectLoader#load}.
   *
   * @async
   * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.
   * @param {onProgressCallback} onProgress - Executed while the loading is in progress.
   * @return {Promise<Object3D>} A Promise that resolves with the loaded 3D object.
   */
  async loadAsync(e, t) {
    const n = this, r = this.path === "" ? zv.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || r;
    const s = new Wl(this.manager);
    s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials);
    const o = await s.loadAsync(e, t), a = JSON.parse(o), l = a.metadata;
    if (l === void 0 || l.type === void 0 || l.type.toLowerCase() === "geometry")
      throw new Error("THREE.ObjectLoader: Can't load " + e);
    return await n.parseAsync(a);
  }
  /**
   * Parses the given JSON. This is used internally by {@link ObjectLoader#load}
   * but can also be used directly to parse a previously loaded JSON structure.
   *
   * @param {Object} json - The serialized 3D object.
   * @param {onLoad} onLoad - Executed when all resources (e.g. textures) have been fully loaded.
   * @return {Object3D} The parsed 3D object.
   */
  parse(e, t) {
    const n = this.parseAnimations(e.animations), r = this.parseShapes(e.shapes), s = this.parseGeometries(e.geometries, r), o = this.parseImages(e.images, function() {
      t !== void 0 && t(u);
    }), a = this.parseTextures(e.textures, o), l = this.parseMaterials(e.materials, a), u = this.parseObject(e.object, s, l, a, n), c = this.parseSkeletons(e.skeletons, u);
    if (this.bindSkeletons(u, c), this.bindLightTargets(u), t !== void 0) {
      let A = !1;
      for (const m in o)
        if (o[m].data instanceof HTMLImageElement) {
          A = !0;
          break;
        }
      A === !1 && t(u);
    }
    return u;
  }
  /**
   * Async version of {@link ObjectLoader#parse}.
   *
   * @param {Object} json - The serialized 3D object.
   * @return {Promise<Object3D>} A Promise that resolves with the parsed 3D object.
   */
  async parseAsync(e) {
    const t = this.parseAnimations(e.animations), n = this.parseShapes(e.shapes), r = this.parseGeometries(e.geometries, n), s = await this.parseImagesAsync(e.images), o = this.parseTextures(e.textures, s), a = this.parseMaterials(e.materials, o), l = this.parseObject(e.object, r, a, o, t), u = this.parseSkeletons(e.skeletons, l);
    return this.bindSkeletons(l, u), this.bindLightTargets(l), l;
  }
  // internals
  parseShapes(e) {
    const t = {};
    if (e !== void 0)
      for (let n = 0, r = e.length; n < r; n++) {
        const s = new lh().fromJSON(e[n]);
        t[s.uuid] = s;
      }
    return t;
  }
  parseSkeletons(e, t) {
    const n = {}, r = {};
    if (t.traverse(function(s) {
      s.isBone && (r[s.uuid] = s);
    }), e !== void 0)
      for (let s = 0, o = e.length; s < o; s++) {
        const a = new e2().fromJSON(e[s], r);
        n[a.uuid] = a;
      }
    return n;
  }
  parseGeometries(e, t) {
    const n = {};
    if (e !== void 0) {
      const r = new p8();
      for (let s = 0, o = e.length; s < o; s++) {
        let a;
        const l = e[s];
        switch (l.type) {
          case "BufferGeometry":
          case "InstancedBufferGeometry":
            a = r.parse(l);
            break;
          default:
            l.type in JM ? a = JM[l.type].fromJSON(l, t) : Me(`ObjectLoader: Unsupported geometry type "${l.type}"`);
        }
        a.uuid = l.uuid, l.name !== void 0 && (a.name = l.name), l.userData !== void 0 && (a.userData = l.userData), n[l.uuid] = a;
      }
    }
    return n;
  }
  parseMaterials(e, t) {
    const n = {}, r = {};
    if (e !== void 0) {
      const s = new g2();
      s.setTextures(t);
      for (let o = 0, a = e.length; o < a; o++) {
        const l = e[o];
        n[l.uuid] === void 0 && (n[l.uuid] = s.parse(l)), r[l.uuid] = n[l.uuid];
      }
    }
    return r;
  }
  parseAnimations(e) {
    const t = {};
    if (e !== void 0)
      for (let n = 0; n < e.length; n++) {
        const r = e[n], s = Hp.parse(r);
        t[s.uuid] = s;
      }
    return t;
  }
  parseImages(e, t) {
    const n = this, r = {};
    let s;
    function o(l) {
      return n.manager.itemStart(l), s.load(l, function() {
        n.manager.itemEnd(l);
      }, void 0, function() {
        n.manager.itemError(l), n.manager.itemEnd(l);
      });
    }
    function a(l) {
      if (typeof l == "string") {
        const u = l, c = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(u) ? u : n.resourcePath + u;
        return o(c);
      } else
        return l.data ? {
          data: af(l.type, l.data),
          width: l.width,
          height: l.height
        } : null;
    }
    if (e !== void 0 && e.length > 0) {
      const l = new iS(t);
      s = new Wp(l), s.setCrossOrigin(this.crossOrigin);
      for (let u = 0, c = e.length; u < c; u++) {
        const A = e[u], m = A.url;
        if (Array.isArray(m)) {
          const _ = [];
          for (let y = 0, T = m.length; y < T; y++) {
            const b = m[y], S = a(b);
            S !== null && (S instanceof HTMLImageElement ? _.push(S) : _.push(new wo(S.data, S.width, S.height)));
          }
          r[A.uuid] = new Lu(_);
        } else {
          const _ = a(A.url);
          r[A.uuid] = new Lu(_);
        }
      }
    }
    return r;
  }
  async parseImagesAsync(e) {
    const t = this, n = {};
    let r;
    async function s(o) {
      if (typeof o == "string") {
        const a = o, l = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(a) ? a : t.resourcePath + a;
        return await r.loadAsync(l);
      } else
        return o.data ? {
          data: af(o.type, o.data),
          width: o.width,
          height: o.height
        } : null;
    }
    if (e !== void 0 && e.length > 0) {
      r = new Wp(this.manager), r.setCrossOrigin(this.crossOrigin);
      for (let o = 0, a = e.length; o < a; o++) {
        const l = e[o], u = l.url;
        if (Array.isArray(u)) {
          const c = [];
          for (let A = 0, m = u.length; A < m; A++) {
            const _ = u[A], y = await s(_);
            y !== null && (y instanceof HTMLImageElement ? c.push(y) : c.push(new wo(y.data, y.width, y.height)));
          }
          n[l.uuid] = new Lu(c);
        } else {
          const c = await s(l.url);
          n[l.uuid] = new Lu(c);
        }
      }
    }
    return n;
  }
  parseTextures(e, t) {
    function n(s, o) {
      return typeof s == "number" ? s : (Me("ObjectLoader.parseTexture: Constant should be in numeric form.", s), o[s]);
    }
    const r = {};
    if (e !== void 0)
      for (let s = 0, o = e.length; s < o; s++) {
        const a = e[s];
        a.image === void 0 && Me('ObjectLoader: No "image" specified for', a.uuid), t[a.image] === void 0 && Me("ObjectLoader: Undefined image", a.image);
        const l = t[a.image], u = l.data;
        let c;
        Array.isArray(u) ? (c = new Ju(), u.length === 6 && (c.needsUpdate = !0)) : (u && u.data ? c = new wo() : c = new Ii(), u && (c.needsUpdate = !0)), c.source = l, c.uuid = a.uuid, a.name !== void 0 && (c.name = a.name), a.mapping !== void 0 && (c.mapping = n(a.mapping, UO)), a.channel !== void 0 && (c.channel = a.channel), a.offset !== void 0 && c.offset.fromArray(a.offset), a.repeat !== void 0 && c.repeat.fromArray(a.repeat), a.center !== void 0 && c.center.fromArray(a.center), a.rotation !== void 0 && (c.rotation = a.rotation), a.wrap !== void 0 && (c.wrapS = n(a.wrap[0], nE), c.wrapT = n(a.wrap[1], nE)), a.format !== void 0 && (c.format = a.format), a.internalFormat !== void 0 && (c.internalFormat = a.internalFormat), a.type !== void 0 && (c.type = a.type), a.colorSpace !== void 0 && (c.colorSpace = a.colorSpace), a.minFilter !== void 0 && (c.minFilter = n(a.minFilter, iE)), a.magFilter !== void 0 && (c.magFilter = n(a.magFilter, iE)), a.anisotropy !== void 0 && (c.anisotropy = a.anisotropy), a.flipY !== void 0 && (c.flipY = a.flipY), a.generateMipmaps !== void 0 && (c.generateMipmaps = a.generateMipmaps), a.premultiplyAlpha !== void 0 && (c.premultiplyAlpha = a.premultiplyAlpha), a.unpackAlignment !== void 0 && (c.unpackAlignment = a.unpackAlignment), a.compareFunction !== void 0 && (c.compareFunction = a.compareFunction), a.userData !== void 0 && (c.userData = a.userData), r[a.uuid] = c;
      }
    return r;
  }
  parseObject(e, t, n, r, s) {
    let o;
    function a(m) {
      return t[m] === void 0 && Me("ObjectLoader: Undefined geometry", m), t[m];
    }
    function l(m) {
      if (m !== void 0) {
        if (Array.isArray(m)) {
          const _ = [];
          for (let y = 0, T = m.length; y < T; y++) {
            const b = m[y];
            n[b] === void 0 && Me("ObjectLoader: Undefined material", b), _.push(n[b]);
          }
          return _;
        }
        return n[m] === void 0 && Me("ObjectLoader: Undefined material", m), n[m];
      }
    }
    function u(m) {
      return r[m] === void 0 && Me("ObjectLoader: Undefined texture", m), r[m];
    }
    let c, A;
    switch (e.type) {
      case "Scene":
        o = new oA(), e.background !== void 0 && (Number.isInteger(e.background) ? o.background = new ct(e.background) : o.background = u(e.background)), e.environment !== void 0 && (o.environment = u(e.environment)), e.fog !== void 0 && (e.fog.type === "Fog" ? o.fog = new Z_(e.fog.color, e.fog.near, e.fog.far) : e.fog.type === "FogExp2" && (o.fog = new K_(e.fog.color, e.fog.density)), e.fog.name !== "" && (o.fog.name = e.fog.name)), e.backgroundBlurriness !== void 0 && (o.backgroundBlurriness = e.backgroundBlurriness), e.backgroundIntensity !== void 0 && (o.backgroundIntensity = e.backgroundIntensity), e.backgroundRotation !== void 0 && o.backgroundRotation.fromArray(e.backgroundRotation), e.environmentIntensity !== void 0 && (o.environmentIntensity = e.environmentIntensity), e.environmentRotation !== void 0 && o.environmentRotation.fromArray(e.environmentRotation);
        break;
      case "PerspectiveCamera":
        o = new Ji(e.fov, e.aspect, e.near, e.far), e.focus !== void 0 && (o.focus = e.focus), e.zoom !== void 0 && (o.zoom = e.zoom), e.filmGauge !== void 0 && (o.filmGauge = e.filmGauge), e.filmOffset !== void 0 && (o.filmOffset = e.filmOffset), e.view !== void 0 && (o.view = Object.assign({}, e.view));
        break;
      case "OrthographicCamera":
        o = new ic(e.left, e.right, e.top, e.bottom, e.near, e.far), e.zoom !== void 0 && (o.zoom = e.zoom), e.view !== void 0 && (o.view = Object.assign({}, e.view));
        break;
      case "AmbientLight":
        o = new m2(e.color, e.intensity);
        break;
      case "DirectionalLight":
        o = new p2(e.color, e.intensity), o.target = e.target || "";
        break;
      case "PointLight":
        o = new oS(e.color, e.intensity, e.distance, e.decay);
        break;
      case "RectAreaLight":
        o = new aS(e.color, e.intensity, e.width, e.height);
        break;
      case "SpotLight":
        o = new N0(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay), o.target = e.target || "";
        break;
      case "HemisphereLight":
        o = new rS(e.color, e.groundColor, e.intensity);
        break;
      case "LightProbe":
        const m = new lS().fromArray(e.sh);
        o = new uS(m, e.intensity);
        break;
      case "SkinnedMesh":
        c = a(e.geometry), A = l(e.material), o = new Q5(c, A), e.bindMode !== void 0 && (o.bindMode = e.bindMode), e.bindMatrix !== void 0 && o.bindMatrix.fromArray(e.bindMatrix), e.skeleton !== void 0 && (o.skeleton = e.skeleton);
        break;
      case "Mesh":
        c = a(e.geometry), A = l(e.material), o = new Tn(c, A);
        break;
      case "InstancedMesh":
        c = a(e.geometry), A = l(e.material);
        const _ = e.count, y = e.instanceMatrix, T = e.instanceColor;
        o = new K5(c, A, _), o.instanceMatrix = new to(new Float32Array(y.array), 16), T !== void 0 && (o.instanceColor = new to(new Float32Array(T.array), T.itemSize));
        break;
      case "BatchedMesh":
        c = a(e.geometry), A = l(e.material), o = new Z5(e.maxInstanceCount, e.maxVertexCount, e.maxIndexCount, A), o.geometry = c, o.perObjectFrustumCulled = e.perObjectFrustumCulled, o.sortObjects = e.sortObjects, o._drawRanges = e.drawRanges, o._reservedRanges = e.reservedRanges, o._geometryInfo = e.geometryInfo.map((b) => {
          let S = null, E = null;
          return b.boundingBox !== void 0 && (S = new dr().fromJSON(b.boundingBox)), b.boundingSphere !== void 0 && (E = new fr().fromJSON(b.boundingSphere)), {
            ...b,
            boundingBox: S,
            boundingSphere: E
          };
        }), o._instanceInfo = e.instanceInfo, o._availableInstanceIds = e._availableInstanceIds, o._availableGeometryIds = e._availableGeometryIds, o._nextIndexStart = e.nextIndexStart, o._nextVertexStart = e.nextVertexStart, o._geometryCount = e.geometryCount, o._maxInstanceCount = e.maxInstanceCount, o._maxVertexCount = e.maxVertexCount, o._maxIndexCount = e.maxIndexCount, o._geometryInitialized = e.geometryInitialized, o._matricesTexture = u(e.matricesTexture.uuid), o._indirectTexture = u(e.indirectTexture.uuid), e.colorsTexture !== void 0 && (o._colorsTexture = u(e.colorsTexture.uuid)), e.boundingSphere !== void 0 && (o.boundingSphere = new fr().fromJSON(e.boundingSphere)), e.boundingBox !== void 0 && (o.boundingBox = new dr().fromJSON(e.boundingBox));
        break;
      case "LOD":
        o = new Y5();
        break;
      case "Line":
        o = new va(a(e.geometry), l(e.material));
        break;
      case "LineLoop":
        o = new J5(a(e.geometry), l(e.material));
        break;
      case "LineSegments":
        o = new Qo(a(e.geometry), l(e.material));
        break;
      case "PointCloud":
      case "Points":
        o = new I3(a(e.geometry), l(e.material));
        break;
      case "Sprite":
        o = new X5(l(e.material));
        break;
      case "Group":
        o = new As();
        break;
      case "Bone":
        o = new L3();
        break;
      default:
        o = new Vn();
    }
    if (o.uuid = e.uuid, e.name !== void 0 && (o.name = e.name), e.matrix !== void 0 ? (o.matrix.fromArray(e.matrix), e.matrixAutoUpdate !== void 0 && (o.matrixAutoUpdate = e.matrixAutoUpdate), o.matrixAutoUpdate && o.matrix.decompose(o.position, o.quaternion, o.scale)) : (e.position !== void 0 && o.position.fromArray(e.position), e.rotation !== void 0 && o.rotation.fromArray(e.rotation), e.quaternion !== void 0 && o.quaternion.fromArray(e.quaternion), e.scale !== void 0 && o.scale.fromArray(e.scale)), e.up !== void 0 && o.up.fromArray(e.up), e.castShadow !== void 0 && (o.castShadow = e.castShadow), e.receiveShadow !== void 0 && (o.receiveShadow = e.receiveShadow), e.shadow && (e.shadow.intensity !== void 0 && (o.shadow.intensity = e.shadow.intensity), e.shadow.bias !== void 0 && (o.shadow.bias = e.shadow.bias), e.shadow.normalBias !== void 0 && (o.shadow.normalBias = e.shadow.normalBias), e.shadow.radius !== void 0 && (o.shadow.radius = e.shadow.radius), e.shadow.mapSize !== void 0 && o.shadow.mapSize.fromArray(e.shadow.mapSize), e.shadow.camera !== void 0 && (o.shadow.camera = this.parseObject(e.shadow.camera))), e.visible !== void 0 && (o.visible = e.visible), e.frustumCulled !== void 0 && (o.frustumCulled = e.frustumCulled), e.renderOrder !== void 0 && (o.renderOrder = e.renderOrder), e.userData !== void 0 && (o.userData = e.userData), e.layers !== void 0 && (o.layers.mask = e.layers), e.children !== void 0) {
      const m = e.children;
      for (let _ = 0; _ < m.length; _++)
        o.add(this.parseObject(m[_], t, n, r, s));
    }
    if (e.animations !== void 0) {
      const m = e.animations;
      for (let _ = 0; _ < m.length; _++) {
        const y = m[_];
        o.animations.push(s[y]);
      }
    }
    if (e.type === "LOD") {
      e.autoUpdate !== void 0 && (o.autoUpdate = e.autoUpdate);
      const m = e.levels;
      for (let _ = 0; _ < m.length; _++) {
        const y = m[_], T = o.getObjectByProperty("uuid", y.object);
        T !== void 0 && o.addLevel(T, y.distance, y.hysteresis);
      }
    }
    return o;
  }
  bindSkeletons(e, t) {
    Object.keys(t).length !== 0 && e.traverse(function(n) {
      if (n.isSkinnedMesh === !0 && n.skeleton !== void 0) {
        const r = t[n.skeleton];
        r === void 0 ? Me("ObjectLoader: No skeleton found with UUID:", n.skeleton) : n.bind(r, n.bindMatrix);
      }
    });
  }
  bindLightTargets(e) {
    e.traverse(function(t) {
      if (t.isDirectionalLight || t.isSpotLight) {
        const n = t.target, r = e.getObjectByProperty("uuid", n);
        r !== void 0 ? t.target = r : t.target = new Vn();
      }
    });
  }
}
const UO = {
  UVMapping: A0,
  CubeReflectionMapping: no,
  CubeRefractionMapping: qo,
  EquirectangularReflectionMapping: Gu,
  EquirectangularRefractionMapping: zu,
  CubeUVReflectionMapping: Gl
}, nE = {
  RepeatWrapping: zl,
  ClampToEdgeWrapping: xr,
  MirroredRepeatWrapping: ql
}, iE = {
  NearestFilter: ei,
  NearestMipmapNearestFilter: p0,
  NearestMipmapLinearFilter: Aa,
  LinearFilter: qn,
  LinearMipmapNearestFilter: Uu,
  LinearMipmapLinearFilter: $r
}, _y = /* @__PURE__ */ new WeakMap();
class OO extends uo {
  /**
   * Constructs a new image bitmap loader.
   *
   * @param {LoadingManager} [manager] - The loading manager.
   */
  constructor(e) {
    super(e), this.isImageBitmapLoader = !0, typeof createImageBitmap > "u" && Me("ImageBitmapLoader: createImageBitmap() not supported."), typeof fetch > "u" && Me("ImageBitmapLoader: fetch() not supported."), this.options = { premultiplyAlpha: "none" }, this._abortController = new AbortController();
  }
  /**
   * Sets the given loader options. The structure of the object must match the `options` parameter of
   * [createImageBitmap](https://developer.mozilla.org/en-US/docs/Web/API/Window/createImageBitmap).
   *
   * @param {Object} options - The loader options to set.
   * @return {ImageBitmapLoader} A reference to this image bitmap loader.
   */
  setOptions(e) {
    return this.options = e, this;
  }
  /**
   * Starts loading from the given URL and pass the loaded image bitmap to the `onLoad()` callback.
   *
   * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.
   * @param {function(ImageBitmap)} onLoad - Executed when the loading process has been finished.
   * @param {onProgressCallback} onProgress - Unsupported in this loader.
   * @param {onErrorCallback} onError - Executed when errors occur.
   * @return {ImageBitmap|undefined} The image bitmap.
   */
  load(e, t, n, r) {
    e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const s = this, o = ja.get(`image-bitmap:${e}`);
    if (o !== void 0) {
      if (s.manager.itemStart(e), o.then) {
        o.then((u) => {
          if (_y.has(o) === !0)
            r && r(_y.get(o)), s.manager.itemError(e), s.manager.itemEnd(e);
          else
            return t && t(u), s.manager.itemEnd(e), u;
        });
        return;
      }
      return setTimeout(function() {
        t && t(o), s.manager.itemEnd(e);
      }, 0), o;
    }
    const a = {};
    a.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include", a.headers = this.requestHeader, a.signal = typeof AbortSignal.any == "function" ? AbortSignal.any([this._abortController.signal, this.manager.abortController.signal]) : this._abortController.signal;
    const l = fetch(e, a).then(function(u) {
      return u.blob();
    }).then(function(u) {
      return createImageBitmap(u, Object.assign(s.options, { colorSpaceConversion: "none" }));
    }).then(function(u) {
      return ja.add(`image-bitmap:${e}`, u), t && t(u), s.manager.itemEnd(e), u;
    }).catch(function(u) {
      r && r(u), _y.set(l, u), ja.remove(`image-bitmap:${e}`), s.manager.itemError(e), s.manager.itemEnd(e);
    });
    ja.add(`image-bitmap:${e}`, l), s.manager.itemStart(e);
  }
  /**
   * Aborts ongoing fetch requests.
   *
   * @return {ImageBitmapLoader} A reference to this instance.
   */
  abort() {
    return this._abortController.abort(), this._abortController = new AbortController(), this;
  }
}
let km;
class hS {
  /**
   * Returns the global native audio context.
   *
   * @return {AudioContext} The native audio context.
   */
  static getContext() {
    return km === void 0 && (km = new (window.AudioContext || window.webkitAudioContext)()), km;
  }
  /**
   * Allows to set the global native audio context from outside.
   *
   * @param {AudioContext} value - The native context to set.
   */
  static setContext(e) {
    km = e;
  }
}
class kO extends uo {
  /**
   * Constructs a new audio loader.
   *
   * @param {LoadingManager} [manager] - The loading manager.
   */
  constructor(e) {
    super(e);
  }
  /**
   * Starts loading from the given URL and passes the loaded audio buffer
   * to the `onLoad()` callback.
   *
   * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.
   * @param {function(AudioBuffer)} onLoad - Executed when the loading process has been finished.
   * @param {onProgressCallback} onProgress - Executed while the loading is in progress.
   * @param {onErrorCallback} onError - Executed when errors occur.
   */
  load(e, t, n, r) {
    const s = this, o = new Wl(this.manager);
    o.setResponseType("arraybuffer"), o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(e, function(l) {
      try {
        const u = l.slice(0);
        hS.getContext().decodeAudioData(u, function(A) {
          t(A);
        }).catch(a);
      } catch (u) {
        a(u);
      }
    }, n, r);
    function a(l) {
      r ? r(l) : Ie(l), s.manager.itemError(e);
    }
  }
}
const rE = /* @__PURE__ */ new Mt(), sE = /* @__PURE__ */ new Mt(), Sc = /* @__PURE__ */ new Mt();
class VO {
  /**
   * Constructs a new stereo camera.
   */
  constructor() {
    this.type = "StereoCamera", this.aspect = 1, this.eyeSep = 0.064, this.cameraL = new Ji(), this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new Ji(), this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = {
      focus: null,
      fov: null,
      aspect: null,
      near: null,
      far: null,
      zoom: null,
      eyeSep: null
    };
  }
  /**
   * Updates the stereo camera based on the given perspective camera.
   *
   * @param {PerspectiveCamera} camera - The perspective camera.
   */
  update(e) {
    const t = this._cache;
    if (t.focus !== e.focus || t.fov !== e.fov || t.aspect !== e.aspect * this.aspect || t.near !== e.near || t.far !== e.far || t.zoom !== e.zoom || t.eyeSep !== this.eyeSep) {
      t.focus = e.focus, t.fov = e.fov, t.aspect = e.aspect * this.aspect, t.near = e.near, t.far = e.far, t.zoom = e.zoom, t.eyeSep = this.eyeSep, Sc.copy(e.projectionMatrix);
      const r = t.eyeSep / 2, s = r * t.near / t.focus, o = t.near * Math.tan(ah * t.fov * 0.5) / t.zoom;
      let a, l;
      sE.elements[12] = -r, rE.elements[12] = r, a = -o * t.aspect + s, l = o * t.aspect + s, Sc.elements[0] = 2 * t.near / (l - a), Sc.elements[8] = (l + a) / (l - a), this.cameraL.projectionMatrix.copy(Sc), a = -o * t.aspect - s, l = o * t.aspect - s, Sc.elements[0] = 2 * t.near / (l - a), Sc.elements[8] = (l + a) / (l - a), this.cameraR.projectionMatrix.copy(Sc);
    }
    this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(sE), this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(rE);
  }
}
class dS extends Ji {
  /**
   * Constructs a new array camera.
   *
   * @param {Array<PerspectiveCamera>} [array=[]] - An array of perspective sub cameras.
   */
  constructor(e = []) {
    super(), this.isArrayCamera = !0, this.isMultiViewCamera = !1, this.cameras = e;
  }
}
class _2 {
  /**
   * Constructs a new clock.
   *
   * @param {boolean} [autoStart=true] - Whether to automatically start the clock when
   * `getDelta()` is called for the first time.
   */
  constructor(e = !0) {
    this.autoStart = e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1;
  }
  /**
   * Starts the clock. When `autoStart` is set to `true`, the method is automatically
   * called by the class.
   */
  start() {
    this.startTime = performance.now(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0;
  }
  /**
   * Stops the clock.
   */
  stop() {
    this.getElapsedTime(), this.running = !1, this.autoStart = !1;
  }
  /**
   * Returns the elapsed time in seconds.
   *
   * @return {number} The elapsed time.
   */
  getElapsedTime() {
    return this.getDelta(), this.elapsedTime;
  }
  /**
   * Returns the delta time in seconds.
   *
   * @return {number} The delta time.
   */
  getDelta() {
    let e = 0;
    if (this.autoStart && !this.running)
      return this.start(), 0;
    if (this.running) {
      const t = performance.now();
      e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e;
    }
    return e;
  }
}
const Tc = /* @__PURE__ */ new j(), xy = /* @__PURE__ */ new hr(), GO = /* @__PURE__ */ new j(), wc = /* @__PURE__ */ new j(), Mc = /* @__PURE__ */ new j();
class zO extends Vn {
  /**
   * Constructs a new audio listener.
   */
  constructor() {
    super(), this.type = "AudioListener", this.context = hS.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new _2();
  }
  /**
   * Returns the listener's input node.
   *
   * This method is used by other audio nodes to connect to this listener.
   *
   * @return {GainNode} The input node.
   */
  getInput() {
    return this.gain;
  }
  /**
   * Removes the current filter from this listener.
   *
   * @return {AudioListener} A reference to this listener.
   */
  removeFilter() {
    return this.filter !== null && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this;
  }
  /**
   * Returns the current set filter.
   *
   * @return {?AudioNode} The filter.
   */
  getFilter() {
    return this.filter;
  }
  /**
   * Sets the given filter to this listener.
   *
   * @param {AudioNode} value - The filter to set.
   * @return {AudioListener} A reference to this listener.
   */
  setFilter(e) {
    return this.filter !== null ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this;
  }
  /**
   * Returns the applications master volume.
   *
   * @return {number} The master volume.
   */
  getMasterVolume() {
    return this.gain.gain.value;
  }
  /**
   * Sets the applications master volume. This volume setting affects
   * all audio nodes in the scene.
   *
   * @param {number} value - The master volume to set.
   * @return {AudioListener} A reference to this listener.
   */
  setMasterVolume(e) {
    return this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this;
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e);
    const t = this.context.listener;
    if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(Tc, xy, GO), wc.set(0, 0, -1).applyQuaternion(xy), Mc.set(0, 1, 0).applyQuaternion(xy), t.positionX) {
      const n = this.context.currentTime + this.timeDelta;
      t.positionX.linearRampToValueAtTime(Tc.x, n), t.positionY.linearRampToValueAtTime(Tc.y, n), t.positionZ.linearRampToValueAtTime(Tc.z, n), t.forwardX.linearRampToValueAtTime(wc.x, n), t.forwardY.linearRampToValueAtTime(wc.y, n), t.forwardZ.linearRampToValueAtTime(wc.z, n), t.upX.linearRampToValueAtTime(Mc.x, n), t.upY.linearRampToValueAtTime(Mc.y, n), t.upZ.linearRampToValueAtTime(Mc.z, n);
    } else
      t.setPosition(Tc.x, Tc.y, Tc.z), t.setOrientation(wc.x, wc.y, wc.z, Mc.x, Mc.y, Mc.z);
  }
}
class m8 extends Vn {
  /**
   * Constructs a new audio.
   *
   * @param {AudioListener} listener - The global audio listener.
   */
  constructor(e) {
    super(), this.type = "Audio", this.listener = e, this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = [];
  }
  /**
   * Returns the output audio node.
   *
   * @return {GainNode} The output node.
   */
  getOutput() {
    return this.gain;
  }
  /**
   * Sets the given audio node as the source of this instance.
   *
   * {@link Audio#sourceType} is set to `audioNode` and {@link Audio#hasPlaybackControl} to `false`.
   *
   * @param {AudioNode} audioNode - The audio node like an instance of `OscillatorNode`.
   * @return {Audio} A reference to this instance.
   */
  setNodeSource(e) {
    return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this;
  }
  /**
   * Sets the given media element as the source of this instance.
   *
   * {@link Audio#sourceType} is set to `mediaNode` and {@link Audio#hasPlaybackControl} to `false`.
   *
   * @param {HTMLMediaElement} mediaElement - The media element.
   * @return {Audio} A reference to this instance.
   */
  setMediaElementSource(e) {
    return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this;
  }
  /**
   * Sets the given media stream as the source of this instance.
   *
   * {@link Audio#sourceType} is set to `mediaStreamNode` and {@link Audio#hasPlaybackControl} to `false`.
   *
   * @param {MediaStream} mediaStream - The media stream.
   * @return {Audio} A reference to this instance.
   */
  setMediaStreamSource(e) {
    return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(e), this.connect(), this;
  }
  /**
   * Sets the given audio buffer as the source of this instance.
   *
   * {@link Audio#sourceType} is set to `buffer` and {@link Audio#hasPlaybackControl} to `true`.
   *
   * @param {AudioBuffer} audioBuffer - The audio buffer.
   * @return {Audio} A reference to this instance.
   */
  setBuffer(e) {
    return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this;
  }
  /**
   * Starts the playback of the audio.
   *
   * Can only be used with compatible audio sources that allow playback control.
   *
   * @param {number} [delay=0] - The delay, in seconds, at which the audio should start playing.
   * @return {Audio|undefined} A reference to this instance.
   */
  play(e = 0) {
    if (this.isPlaying === !0) {
      Me("Audio: Audio is already playing.");
      return;
    }
    if (this.hasPlaybackControl === !1) {
      Me("Audio: this Audio has no playback control.");
      return;
    }
    this._startedAt = this.context.currentTime + e;
    const t = this.context.createBufferSource();
    return t.buffer = this.buffer, t.loop = this.loop, t.loopStart = this.loopStart, t.loopEnd = this.loopEnd, t.onended = this.onEnded.bind(this), t.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = t, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect();
  }
  /**
   * Pauses the playback of the audio.
   *
   * Can only be used with compatible audio sources that allow playback control.
   *
   * @return {Audio|undefined} A reference to this instance.
   */
  pause() {
    if (this.hasPlaybackControl === !1) {
      Me("Audio: this Audio has no playback control.");
      return;
    }
    return this.isPlaying === !0 && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, this.loop === !0 && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this;
  }
  /**
   * Stops the playback of the audio.
   *
   * Can only be used with compatible audio sources that allow playback control.
   *
   * @param {number} [delay=0] - The delay, in seconds, at which the audio should stop playing.
   * @return {Audio|undefined} A reference to this instance.
   */
  stop(e = 0) {
    if (this.hasPlaybackControl === !1) {
      Me("Audio: this Audio has no playback control.");
      return;
    }
    return this._progress = 0, this.source !== null && (this.source.stop(this.context.currentTime + e), this.source.onended = null), this.isPlaying = !1, this;
  }
  /**
   * Connects to the audio source. This is used internally on
   * initialisation and when setting / removing filters.
   *
   * @return {Audio} A reference to this instance.
   */
  connect() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);
      for (let e = 1, t = this.filters.length; e < t; e++)
        this.filters[e - 1].connect(this.filters[e]);
      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else
      this.source.connect(this.getOutput());
    return this._connected = !0, this;
  }
  /**
   * Disconnects to the audio source. This is used internally on
   * initialisation and when setting / removing filters.
   *
   * @return {Audio|undefined} A reference to this instance.
   */
  disconnect() {
    if (this._connected !== !1) {
      if (this.filters.length > 0) {
        this.source.disconnect(this.filters[0]);
        for (let e = 1, t = this.filters.length; e < t; e++)
          this.filters[e - 1].disconnect(this.filters[e]);
        this.filters[this.filters.length - 1].disconnect(this.getOutput());
      } else
        this.source.disconnect(this.getOutput());
      return this._connected = !1, this;
    }
  }
  /**
   * Returns the current set filters.
   *
   * @return {Array<AudioNode>} The list of filters.
   */
  getFilters() {
    return this.filters;
  }
  /**
   * Sets an array of filters and connects them with the audio source.
   *
   * @param {Array<AudioNode>} [value] - A list of filters.
   * @return {Audio} A reference to this instance.
   */
  setFilters(e) {
    return e || (e = []), this._connected === !0 ? (this.disconnect(), this.filters = e.slice(), this.connect()) : this.filters = e.slice(), this;
  }
  /**
   * Defines the detuning of oscillation in cents.
   *
   * @param {number} value - The detuning of oscillation in cents.
   * @return {Audio} A reference to this instance.
   */
  setDetune(e) {
    return this.detune = e, this.isPlaying === !0 && this.source.detune !== void 0 && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01), this;
  }
  /**
   * Returns the detuning of oscillation in cents.
   *
   * @return {number} The detuning of oscillation in cents.
   */
  getDetune() {
    return this.detune;
  }
  /**
   * Returns the first filter in the list of filters.
   *
   * @return {AudioNode|undefined} The first filter in the list of filters.
   */
  getFilter() {
    return this.getFilters()[0];
  }
  /**
   * Applies a single filter node to the audio.
   *
   * @param {AudioNode} [filter] - The filter to set.
   * @return {Audio} A reference to this instance.
   */
  setFilter(e) {
    return this.setFilters(e ? [e] : []);
  }
  /**
   * Sets the playback rate.
   *
   * Can only be used with compatible audio sources that allow playback control.
   *
   * @param {number} [value] - The playback rate to set.
   * @return {Audio|undefined} A reference to this instance.
   */
  setPlaybackRate(e) {
    if (this.hasPlaybackControl === !1) {
      Me("Audio: this Audio has no playback control.");
      return;
    }
    return this.playbackRate = e, this.isPlaying === !0 && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01), this;
  }
  /**
  	 * Returns the current playback rate.

  	 * @return {number} The playback rate.
  	 */
  getPlaybackRate() {
    return this.playbackRate;
  }
  /**
   * Automatically called when playback finished.
   */
  onEnded() {
    this.isPlaying = !1, this._progress = 0;
  }
  /**
   * Returns the loop flag.
   *
   * Can only be used with compatible audio sources that allow playback control.
   *
   * @return {boolean} Whether the audio should loop or not.
   */
  getLoop() {
    return this.hasPlaybackControl === !1 ? (Me("Audio: this Audio has no playback control."), !1) : this.loop;
  }
  /**
   * Sets the loop flag.
   *
   * Can only be used with compatible audio sources that allow playback control.
   *
   * @param {boolean} value - Whether the audio should loop or not.
   * @return {Audio|undefined} A reference to this instance.
   */
  setLoop(e) {
    if (this.hasPlaybackControl === !1) {
      Me("Audio: this Audio has no playback control.");
      return;
    }
    return this.loop = e, this.isPlaying === !0 && (this.source.loop = this.loop), this;
  }
  /**
   * Sets the loop start value which defines where in the audio buffer the replay should
   * start, in seconds.
   *
   * @param {number} value - The loop start value.
   * @return {Audio} A reference to this instance.
   */
  setLoopStart(e) {
    return this.loopStart = e, this;
  }
  /**
   * Sets the loop end value which defines where in the audio buffer the replay should
   * stop, in seconds.
   *
   * @param {number} value - The loop end value.
   * @return {Audio} A reference to this instance.
   */
  setLoopEnd(e) {
    return this.loopEnd = e, this;
  }
  /**
   * Returns the volume.
   *
   * @return {number} The volume.
   */
  getVolume() {
    return this.gain.gain.value;
  }
  /**
   * Sets the volume.
   *
   * @param {number} value - The volume to set.
   * @return {Audio} A reference to this instance.
   */
  setVolume(e) {
    return this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this;
  }
  copy(e, t) {
    return super.copy(e, t), e.sourceType !== "buffer" ? (Me("Audio: Audio source type cannot be copied."), this) : (this.autoplay = e.autoplay, this.buffer = e.buffer, this.detune = e.detune, this.loop = e.loop, this.loopStart = e.loopStart, this.loopEnd = e.loopEnd, this.offset = e.offset, this.duration = e.duration, this.playbackRate = e.playbackRate, this.hasPlaybackControl = e.hasPlaybackControl, this.sourceType = e.sourceType, this.filters = e.filters.slice(), this);
  }
  clone(e) {
    return new this.constructor(this.listener).copy(this, e);
  }
}
const Ec = /* @__PURE__ */ new j(), oE = /* @__PURE__ */ new hr(), qO = /* @__PURE__ */ new j(), Rc = /* @__PURE__ */ new j();
class HO extends m8 {
  /**
   * Constructs a positional audio.
   *
   * @param {AudioListener} listener - The global audio listener.
   */
  constructor(e) {
    super(e), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain);
  }
  connect() {
    return super.connect(), this.panner.connect(this.gain), this;
  }
  disconnect() {
    return super.disconnect(), this.panner.disconnect(this.gain), this;
  }
  getOutput() {
    return this.panner;
  }
  /**
   * Returns the current reference distance.
   *
   * @return {number} The reference distance.
   */
  getRefDistance() {
    return this.panner.refDistance;
  }
  /**
   * Defines the reference distance for reducing volume as the audio source moves
   * further from the listener  i.e. the distance at which the volume reduction
   * starts taking effect.
   *
   * @param {number} value - The reference distance to set.
   * @return {PositionalAudio} A reference to this instance.
   */
  setRefDistance(e) {
    return this.panner.refDistance = e, this;
  }
  /**
   * Returns the current rolloff factor.
   *
   * @return {number} The rolloff factor.
   */
  getRolloffFactor() {
    return this.panner.rolloffFactor;
  }
  /**
   * Defines how quickly the volume is reduced as the source moves away from the listener.
   *
   * @param {number} value - The rolloff factor.
   * @return {PositionalAudio} A reference to this instance.
   */
  setRolloffFactor(e) {
    return this.panner.rolloffFactor = e, this;
  }
  /**
   * Returns the current distance model.
   *
   * @return {('linear'|'inverse'|'exponential')} The distance model.
   */
  getDistanceModel() {
    return this.panner.distanceModel;
  }
  /**
   * Defines which algorithm to use to reduce the volume of the audio source
   * as it moves away from the listener.
   *
   * Read [the spec](https://www.w3.org/TR/webaudio-1.1/#enumdef-distancemodeltype)
   * for more details.
   *
   * @param {('linear'|'inverse'|'exponential')} value - The distance model to set.
   * @return {PositionalAudio} A reference to this instance.
   */
  setDistanceModel(e) {
    return this.panner.distanceModel = e, this;
  }
  /**
   * Returns the current max distance.
   *
   * @return {number} The max distance.
   */
  getMaxDistance() {
    return this.panner.maxDistance;
  }
  /**
   * Defines the maximum distance between the audio source and the listener,
   * after which the volume is not reduced any further.
   *
   * This value is used only by the `linear` distance model.
   *
   * @param {number} value - The max distance.
   * @return {PositionalAudio} A reference to this instance.
   */
  setMaxDistance(e) {
    return this.panner.maxDistance = e, this;
  }
  /**
   * Sets the directional cone in which the audio can be listened.
   *
   * @param {number} coneInnerAngle - An angle, in degrees, of a cone inside of which there will be no volume reduction.
   * @param {number} coneOuterAngle - An angle, in degrees, of a cone outside of which the volume will be reduced by a constant value, defined by the `coneOuterGain` parameter.
   * @param {number} coneOuterGain - The amount of volume reduction outside the cone defined by the `coneOuterAngle`. When set to `0`, no sound can be heard.
   * @return {PositionalAudio} A reference to this instance.
   */
  setDirectionalCone(e, t, n) {
    return this.panner.coneInnerAngle = e, this.panner.coneOuterAngle = t, this.panner.coneOuterGain = n, this;
  }
  updateMatrixWorld(e) {
    if (super.updateMatrixWorld(e), this.hasPlaybackControl === !0 && this.isPlaying === !1) return;
    this.matrixWorld.decompose(Ec, oE, qO), Rc.set(0, 0, 1).applyQuaternion(oE);
    const t = this.panner;
    if (t.positionX) {
      const n = this.context.currentTime + this.listener.timeDelta;
      t.positionX.linearRampToValueAtTime(Ec.x, n), t.positionY.linearRampToValueAtTime(Ec.y, n), t.positionZ.linearRampToValueAtTime(Ec.z, n), t.orientationX.linearRampToValueAtTime(Rc.x, n), t.orientationY.linearRampToValueAtTime(Rc.y, n), t.orientationZ.linearRampToValueAtTime(Rc.z, n);
    } else
      t.setPosition(Ec.x, Ec.y, Ec.z), t.setOrientation(Rc.x, Rc.y, Rc.z);
  }
}
class WO {
  /**
   * Constructs a new audio analyzer.
   *
   * @param {Audio} audio - The audio to analyze.
   * @param {number} [fftSize=2048] - The window size in samples that is used when performing a Fast Fourier Transform (FFT) to get frequency domain data.
   */
  constructor(e, t = 2048) {
    this.analyser = e.context.createAnalyser(), this.analyser.fftSize = t, this.data = new Uint8Array(this.analyser.frequencyBinCount), e.getOutput().connect(this.analyser);
  }
  /**
   * Returns an array with frequency data of the audio.
   *
   * Each item in the array represents the decibel value for a specific frequency.
   * The frequencies are spread linearly from 0 to 1/2 of the sample rate.
   * For example, for 48000 sample rate, the last item of the array will represent
   * the decibel value for 24000 Hz.
   *
   * @return {Uint8Array} The frequency data.
   */
  getFrequencyData() {
    return this.analyser.getByteFrequencyData(this.data), this.data;
  }
  /**
   * Returns the average of the frequencies returned by {@link AudioAnalyser#getFrequencyData}.
   *
   * @return {number} The average frequency.
   */
  getAverageFrequency() {
    let e = 0;
    const t = this.getFrequencyData();
    for (let n = 0; n < t.length; n++)
      e += t[n];
    return e / t.length;
  }
}
class g8 {
  /**
   * Constructs a new property mixer.
   *
   * @param {PropertyBinding} binding - The property binding.
   * @param {string} typeName - The keyframe track type name.
   * @param {number} valueSize - The keyframe track value size.
   */
  constructor(e, t, n) {
    this.binding = e, this.valueSize = n;
    let r, s, o;
    switch (t) {
      case "quaternion":
        r = this._slerp, s = this._slerpAdditive, o = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(n * 6), this._workIndex = 5;
        break;
      case "string":
      case "bool":
        r = this._select, s = this._select, o = this._setAdditiveIdentityOther, this.buffer = new Array(n * 5);
        break;
      default:
        r = this._lerp, s = this._lerpAdditive, o = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(n * 5);
    }
    this._mixBufferRegion = r, this._mixBufferRegionAdditive = s, this._setIdentity = o, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0;
  }
  /**
   * Accumulates data in the `incoming` region into `accu<i>`.
   *
   * @param {number} accuIndex - The accumulation index.
   * @param {number} weight - The weight.
   */
  accumulate(e, t) {
    const n = this.buffer, r = this.valueSize, s = e * r + r;
    let o = this.cumulativeWeight;
    if (o === 0) {
      for (let a = 0; a !== r; ++a)
        n[s + a] = n[a];
      o = t;
    } else {
      o += t;
      const a = t / o;
      this._mixBufferRegion(n, s, 0, a, r);
    }
    this.cumulativeWeight = o;
  }
  /**
   * Accumulates data in the `incoming` region into `add`.
   *
   * @param {number} weight - The weight.
   */
  accumulateAdditive(e) {
    const t = this.buffer, n = this.valueSize, r = n * this._addIndex;
    this.cumulativeWeightAdditive === 0 && this._setIdentity(), this._mixBufferRegionAdditive(t, r, 0, e, n), this.cumulativeWeightAdditive += e;
  }
  /**
   * Applies the state of `accu<i>` to the binding when accus differ.
   *
   * @param {number} accuIndex - The accumulation index.
   */
  apply(e) {
    const t = this.valueSize, n = this.buffer, r = e * t + t, s = this.cumulativeWeight, o = this.cumulativeWeightAdditive, a = this.binding;
    if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, s < 1) {
      const l = t * this._origIndex;
      this._mixBufferRegion(
        n,
        r,
        l,
        1 - s,
        t
      );
    }
    o > 0 && this._mixBufferRegionAdditive(n, r, this._addIndex * t, 1, t);
    for (let l = t, u = t + t; l !== u; ++l)
      if (n[l] !== n[l + t]) {
        a.setValue(n, r);
        break;
      }
  }
  /**
   * Remembers the state of the bound property and copy it to both accus.
   */
  saveOriginalState() {
    const e = this.binding, t = this.buffer, n = this.valueSize, r = n * this._origIndex;
    e.getValue(t, r);
    for (let s = n, o = r; s !== o; ++s)
      t[s] = t[r + s % n];
    this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0;
  }
  /**
   * Applies the state previously taken via {@link PropertyMixer#saveOriginalState} to the binding.
   */
  restoreOriginalState() {
    const e = this.valueSize * 3;
    this.binding.setValue(this.buffer, e);
  }
  // internals
  _setAdditiveIdentityNumeric() {
    const e = this._addIndex * this.valueSize, t = e + this.valueSize;
    for (let n = e; n < t; n++)
      this.buffer[n] = 0;
  }
  _setAdditiveIdentityQuaternion() {
    this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1;
  }
  _setAdditiveIdentityOther() {
    const e = this._origIndex * this.valueSize, t = this._addIndex * this.valueSize;
    for (let n = 0; n < this.valueSize; n++)
      this.buffer[t + n] = this.buffer[e + n];
  }
  // mix functions
  _select(e, t, n, r, s) {
    if (r >= 0.5)
      for (let o = 0; o !== s; ++o)
        e[t + o] = e[n + o];
  }
  _slerp(e, t, n, r) {
    hr.slerpFlat(e, t, e, t, e, n, r);
  }
  _slerpAdditive(e, t, n, r, s) {
    const o = this._workIndex * s;
    hr.multiplyQuaternionsFlat(e, o, e, t, e, n), hr.slerpFlat(e, t, e, t, e, o, r);
  }
  _lerp(e, t, n, r, s) {
    const o = 1 - r;
    for (let a = 0; a !== s; ++a) {
      const l = t + a;
      e[l] = e[l] * o + e[n + a] * r;
    }
  }
  _lerpAdditive(e, t, n, r, s) {
    for (let o = 0; o !== s; ++o) {
      const a = t + o;
      e[a] = e[a] + e[n + o] * r;
    }
  }
}
const fS = "\\[\\]\\.:\\/", $O = new RegExp("[" + fS + "]", "g"), AS = "[^" + fS + "]", jO = "[^" + fS.replace("\\.", "") + "]", XO = /* @__PURE__ */ /((?:WC+[\/:])*)/.source.replace("WC", AS), YO = /* @__PURE__ */ /(WCOD+)?/.source.replace("WCOD", jO), QO = /* @__PURE__ */ /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", AS), KO = /* @__PURE__ */ /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", AS), ZO = new RegExp(
  "^" + XO + YO + QO + KO + "$"
), JO = ["material", "materials", "bones", "map"];
class e9 {
  constructor(e, t, n) {
    const r = n || Xn.parseTrackName(t);
    this._targetGroup = e, this._bindings = e.subscribe_(t, r);
  }
  getValue(e, t) {
    this.bind();
    const n = this._targetGroup.nCachedObjects_, r = this._bindings[n];
    r !== void 0 && r.getValue(e, t);
  }
  setValue(e, t) {
    const n = this._bindings;
    for (let r = this._targetGroup.nCachedObjects_, s = n.length; r !== s; ++r)
      n[r].setValue(e, t);
  }
  bind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)
      e[t].bind();
  }
  unbind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)
      e[t].unbind();
  }
}
class Xn {
  /**
   * Constructs a new property binding.
   *
   * @param {Object} rootNode - The root node.
   * @param {string} path - The path.
   * @param {?Object} [parsedPath] - The parsed path.
   */
  constructor(e, t, n) {
    this.path = t, this.parsedPath = n || Xn.parseTrackName(t), this.node = Xn.findNode(e, this.parsedPath.nodeName), this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
  }
  /**
   * Factory method for creating a property binding from the given parameters.
   *
   * @static
   * @param {Object} root - The root node.
   * @param {string} path - The path.
   * @param {?Object} [parsedPath] - The parsed path.
   * @return {PropertyBinding|Composite} The created property binding or composite.
   */
  static create(e, t, n) {
    return e && e.isAnimationObjectGroup ? new Xn.Composite(e, t, n) : new Xn(e, t, n);
  }
  /**
   * Replaces spaces with underscores and removes unsupported characters from
   * node names, to ensure compatibility with parseTrackName().
   *
   * @param {string} name - Node name to be sanitized.
   * @return {string} The sanitized node name.
   */
  static sanitizeNodeName(e) {
    return e.replace(/\s/g, "_").replace($O, "");
  }
  /**
   * Parses the given track name (an object path to an animated property) and
   * returns an object with information about the path. Matches strings in the following forms:
   *
   * - nodeName.property
   * - nodeName.property[accessor]
   * - nodeName.material.property[accessor]
   * - uuid.property[accessor]
   * - uuid.objectName[objectIndex].propertyName[propertyIndex]
   * - parentName/nodeName.property
   * - parentName/parentName/nodeName.property[index]
   * - .bone[Armature.DEF_cog].position
   * - scene:helium_balloon_model:helium_balloon_model.position
   *
   * @static
   * @param {string} trackName - The track name to parse.
   * @return {Object} The parsed track name as an object.
   */
  static parseTrackName(e) {
    const t = ZO.exec(e);
    if (t === null)
      throw new Error("PropertyBinding: Cannot parse trackName: " + e);
    const n = {
      // directoryName: matches[ 1 ], // (tschw) currently unused
      nodeName: t[2],
      objectName: t[3],
      objectIndex: t[4],
      propertyName: t[5],
      // required
      propertyIndex: t[6]
    }, r = n.nodeName && n.nodeName.lastIndexOf(".");
    if (r !== void 0 && r !== -1) {
      const s = n.nodeName.substring(r + 1);
      JO.indexOf(s) !== -1 && (n.nodeName = n.nodeName.substring(0, r), n.objectName = s);
    }
    if (n.propertyName === null || n.propertyName.length === 0)
      throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
    return n;
  }
  /**
   * Searches for a node in the hierarchy of the given root object by the given
   * node name.
   *
   * @static
   * @param {Object} root - The root object.
   * @param {string|number} nodeName - The name of the node.
   * @return {?Object} The found node. Returns `null` if no object was found.
   */
  static findNode(e, t) {
    if (t === void 0 || t === "" || t === "." || t === -1 || t === e.name || t === e.uuid)
      return e;
    if (e.skeleton) {
      const n = e.skeleton.getBoneByName(t);
      if (n !== void 0)
        return n;
    }
    if (e.children) {
      const n = function(s) {
        for (let o = 0; o < s.length; o++) {
          const a = s[o];
          if (a.name === t || a.uuid === t)
            return a;
          const l = n(a.children);
          if (l) return l;
        }
        return null;
      }, r = n(e.children);
      if (r)
        return r;
    }
    return null;
  }
  // these are used to "bind" a nonexistent property
  _getValue_unavailable() {
  }
  _setValue_unavailable() {
  }
  // Getters
  _getValue_direct(e, t) {
    e[t] = this.targetObject[this.propertyName];
  }
  _getValue_array(e, t) {
    const n = this.resolvedProperty;
    for (let r = 0, s = n.length; r !== s; ++r)
      e[t++] = n[r];
  }
  _getValue_arrayElement(e, t) {
    e[t] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(e, t) {
    this.resolvedProperty.toArray(e, t);
  }
  // Direct
  _setValue_direct(e, t) {
    this.targetObject[this.propertyName] = e[t];
  }
  _setValue_direct_setNeedsUpdate(e, t) {
    this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0;
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
    this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  // EntireArray
  _setValue_array(e, t) {
    const n = this.resolvedProperty;
    for (let r = 0, s = n.length; r !== s; ++r)
      n[r] = e[t++];
  }
  _setValue_array_setNeedsUpdate(e, t) {
    const n = this.resolvedProperty;
    for (let r = 0, s = n.length; r !== s; ++r)
      n[r] = e[t++];
    this.targetObject.needsUpdate = !0;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
    const n = this.resolvedProperty;
    for (let r = 0, s = n.length; r !== s; ++r)
      n[r] = e[t++];
    this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  // ArrayElement
  _setValue_arrayElement(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t];
  }
  _setValue_arrayElement_setNeedsUpdate(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0;
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  // HasToFromArray
  _setValue_fromArray(e, t) {
    this.resolvedProperty.fromArray(e, t);
  }
  _setValue_fromArray_setNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0;
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  _getValue_unbound(e, t) {
    this.bind(), this.getValue(e, t);
  }
  _setValue_unbound(e, t) {
    this.bind(), this.setValue(e, t);
  }
  /**
   * Creates a getter / setter pair for the property tracked by this binding.
   */
  bind() {
    let e = this.node;
    const t = this.parsedPath, n = t.objectName, r = t.propertyName;
    let s = t.propertyIndex;
    if (e || (e = Xn.findNode(this.rootNode, t.nodeName), this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) {
      Me("PropertyBinding: No target node found for track: " + this.path + ".");
      return;
    }
    if (n) {
      let u = t.objectIndex;
      switch (n) {
        case "materials":
          if (!e.material) {
            Ie("PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!e.material.materials) {
            Ie("PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
            return;
          }
          e = e.material.materials;
          break;
        case "bones":
          if (!e.skeleton) {
            Ie("PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
            return;
          }
          e = e.skeleton.bones;
          for (let c = 0; c < e.length; c++)
            if (e[c].name === u) {
              u = c;
              break;
            }
          break;
        case "map":
          if ("map" in e) {
            e = e.map;
            break;
          }
          if (!e.material) {
            Ie("PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!e.material.map) {
            Ie("PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
            return;
          }
          e = e.material.map;
          break;
        default:
          if (e[n] === void 0) {
            Ie("PropertyBinding: Can not bind to objectName of node undefined.", this);
            return;
          }
          e = e[n];
      }
      if (u !== void 0) {
        if (e[u] === void 0) {
          Ie("PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
          return;
        }
        e = e[u];
      }
    }
    const o = e[r];
    if (o === void 0) {
      const u = t.nodeName;
      Ie("PropertyBinding: Trying to update property for track: " + u + "." + r + " but it wasn't found.", e);
      return;
    }
    let a = this.Versioning.None;
    this.targetObject = e, e.isMaterial === !0 ? a = this.Versioning.NeedsUpdate : e.isObject3D === !0 && (a = this.Versioning.MatrixWorldNeedsUpdate);
    let l = this.BindingType.Direct;
    if (s !== void 0) {
      if (r === "morphTargetInfluences") {
        if (!e.geometry) {
          Ie("PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
          return;
        }
        if (!e.geometry.morphAttributes) {
          Ie("PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
          return;
        }
        e.morphTargetDictionary[s] !== void 0 && (s = e.morphTargetDictionary[s]);
      }
      l = this.BindingType.ArrayElement, this.resolvedProperty = o, this.propertyIndex = s;
    } else o.fromArray !== void 0 && o.toArray !== void 0 ? (l = this.BindingType.HasFromToArray, this.resolvedProperty = o) : Array.isArray(o) ? (l = this.BindingType.EntireArray, this.resolvedProperty = o) : this.propertyName = r;
    this.getValue = this.GetterByBindingType[l], this.setValue = this.SetterByBindingTypeAndVersioning[l][a];
  }
  /**
   * Unbinds the property.
   */
  unbind() {
    this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
  }
}
Xn.Composite = e9;
Xn.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3
};
Xn.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2
};
Xn.prototype.GetterByBindingType = [
  Xn.prototype._getValue_direct,
  Xn.prototype._getValue_array,
  Xn.prototype._getValue_arrayElement,
  Xn.prototype._getValue_toArray
];
Xn.prototype.SetterByBindingTypeAndVersioning = [
  [
    // Direct
    Xn.prototype._setValue_direct,
    Xn.prototype._setValue_direct_setNeedsUpdate,
    Xn.prototype._setValue_direct_setMatrixWorldNeedsUpdate
  ],
  [
    // EntireArray
    Xn.prototype._setValue_array,
    Xn.prototype._setValue_array_setNeedsUpdate,
    Xn.prototype._setValue_array_setMatrixWorldNeedsUpdate
  ],
  [
    // ArrayElement
    Xn.prototype._setValue_arrayElement,
    Xn.prototype._setValue_arrayElement_setNeedsUpdate,
    Xn.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate
  ],
  [
    // HasToFromArray
    Xn.prototype._setValue_fromArray,
    Xn.prototype._setValue_fromArray_setNeedsUpdate,
    Xn.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate
  ]
];
class t9 {
  /**
   * Constructs a new animation group.
   *
   * @param {...Object3D} arguments - An arbitrary number of 3D objects that share the same animation state.
   */
  constructor() {
    this.isAnimationObjectGroup = !0, this.uuid = To(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
    const e = {};
    this._indicesByUUID = e;
    for (let n = 0, r = arguments.length; n !== r; ++n)
      e[arguments[n].uuid] = n;
    this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
    const t = this;
    this.stats = {
      objects: {
        get total() {
          return t._objects.length;
        },
        get inUse() {
          return this.total - t.nCachedObjects_;
        }
      },
      get bindingsPerObject() {
        return t._bindings.length;
      }
    };
  }
  /**
   * Adds an arbitrary number of objects to this animation group.
   *
   * @param {...Object3D} arguments - The 3D objects to add.
   */
  add() {
    const e = this._objects, t = this._indicesByUUID, n = this._paths, r = this._parsedPaths, s = this._bindings, o = s.length;
    let a, l = e.length, u = this.nCachedObjects_;
    for (let c = 0, A = arguments.length; c !== A; ++c) {
      const m = arguments[c], _ = m.uuid;
      let y = t[_];
      if (y === void 0) {
        y = l++, t[_] = y, e.push(m);
        for (let T = 0, b = o; T !== b; ++T)
          s[T].push(new Xn(m, n[T], r[T]));
      } else if (y < u) {
        a = e[y];
        const T = --u, b = e[T];
        t[b.uuid] = y, e[y] = b, t[_] = T, e[T] = m;
        for (let S = 0, E = o; S !== E; ++S) {
          const R = s[S], C = R[T];
          let L = R[y];
          R[y] = C, L === void 0 && (L = new Xn(m, n[S], r[S])), R[T] = L;
        }
      } else e[y] !== a && Ie("AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
    }
    this.nCachedObjects_ = u;
  }
  /**
   * Removes an arbitrary number of objects to this animation group
   *
   * @param {...Object3D} arguments - The 3D objects to remove.
   */
  remove() {
    const e = this._objects, t = this._indicesByUUID, n = this._bindings, r = n.length;
    let s = this.nCachedObjects_;
    for (let o = 0, a = arguments.length; o !== a; ++o) {
      const l = arguments[o], u = l.uuid, c = t[u];
      if (c !== void 0 && c >= s) {
        const A = s++, m = e[A];
        t[m.uuid] = c, e[c] = m, t[u] = A, e[A] = l;
        for (let _ = 0, y = r; _ !== y; ++_) {
          const T = n[_], b = T[A], S = T[c];
          T[c] = b, T[A] = S;
        }
      }
    }
    this.nCachedObjects_ = s;
  }
  /**
   * Deallocates all memory resources for the passed 3D objects of this animation group.
   *
   * @param {...Object3D} arguments - The 3D objects to uncache.
   */
  uncache() {
    const e = this._objects, t = this._indicesByUUID, n = this._bindings, r = n.length;
    let s = this.nCachedObjects_, o = e.length;
    for (let a = 0, l = arguments.length; a !== l; ++a) {
      const u = arguments[a], c = u.uuid, A = t[c];
      if (A !== void 0)
        if (delete t[c], A < s) {
          const m = --s, _ = e[m], y = --o, T = e[y];
          t[_.uuid] = A, e[A] = _, t[T.uuid] = m, e[m] = T, e.pop();
          for (let b = 0, S = r; b !== S; ++b) {
            const E = n[b], R = E[m], C = E[y];
            E[A] = R, E[m] = C, E.pop();
          }
        } else {
          const m = --o, _ = e[m];
          m > 0 && (t[_.uuid] = A), e[A] = _, e.pop();
          for (let y = 0, T = r; y !== T; ++y) {
            const b = n[y];
            b[A] = b[m], b.pop();
          }
        }
    }
    this.nCachedObjects_ = s;
  }
  // Internal interface used by befriended PropertyBinding.Composite:
  subscribe_(e, t) {
    const n = this._bindingsIndicesByPath;
    let r = n[e];
    const s = this._bindings;
    if (r !== void 0) return s[r];
    const o = this._paths, a = this._parsedPaths, l = this._objects, u = l.length, c = this.nCachedObjects_, A = new Array(u);
    r = s.length, n[e] = r, o.push(e), a.push(t), s.push(A);
    for (let m = c, _ = l.length; m !== _; ++m) {
      const y = l[m];
      A[m] = new Xn(y, e, t);
    }
    return A;
  }
  unsubscribe_(e) {
    const t = this._bindingsIndicesByPath, n = t[e];
    if (n !== void 0) {
      const r = this._paths, s = this._parsedPaths, o = this._bindings, a = o.length - 1, l = o[a], u = e[a];
      t[u] = n, o[n] = l, o.pop(), s[n] = s[a], s.pop(), r[n] = r[a], r.pop();
    }
  }
}
class _8 {
  /**
   * Constructs a new animation action.
   *
   * @param {AnimationMixer} mixer - The mixer that is controlled by this action.
   * @param {AnimationClip} clip - The animation clip that holds the actual keyframes.
   * @param {?Object3D} [localRoot=null] - The root object on which this action is performed.
   * @param {(NormalAnimationBlendMode|AdditiveAnimationBlendMode)} [blendMode] - The blend mode.
   */
  constructor(e, t, n = null, r = t.blendMode) {
    this._mixer = e, this._clip = t, this._localRoot = n, this.blendMode = r;
    const s = t.tracks, o = s.length, a = new Array(o), l = {
      endingStart: Kc,
      endingEnd: Kc
    };
    for (let u = 0; u !== o; ++u) {
      const c = s[u].createInterpolant(null);
      a[u] = c, c.settings = l;
    }
    this._interpolantSettings = l, this._interpolants = a, this._propertyBindings = new Array(o), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = T5, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0;
  }
  /**
   * Starts the playback of the animation.
   *
   * @return {AnimationAction} A reference to this animation action.
   */
  play() {
    return this._mixer._activateAction(this), this;
  }
  /**
   * Stops the playback of the animation.
   *
   * @return {AnimationAction} A reference to this animation action.
   */
  stop() {
    return this._mixer._deactivateAction(this), this.reset();
  }
  /**
   * Resets the playback of the animation.
   *
   * @return {AnimationAction} A reference to this animation action.
   */
  reset() {
    return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping();
  }
  /**
   * Returns `true` if the animation is running.
   *
   * @return {boolean} Whether the animation is running or not.
   */
  isRunning() {
    return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
  }
  /**
   * Returns `true` when {@link AnimationAction#play} has been called.
   *
   * @return {boolean} Whether the animation is scheduled or not.
   */
  isScheduled() {
    return this._mixer._isActiveAction(this);
  }
  /**
   * Defines the time when the animation should start.
   *
   * @param {number} time - The start time in seconds.
   * @return {AnimationAction} A reference to this animation action.
   */
  startAt(e) {
    return this._startTime = e, this;
  }
  /**
   * Configures the loop settings for this action.
   *
   * @param {(LoopRepeat|LoopOnce|LoopPingPong)} mode - The loop mode.
   * @param {number} repetitions - The number of repetitions.
   * @return {AnimationAction} A reference to this animation action.
   */
  setLoop(e, t) {
    return this.loop = e, this.repetitions = t, this;
  }
  /**
   * Sets the effective weight of this action.
   *
   * An action has no effect and thus an effective weight of zero when the
   * action is disabled.
   *
   * @param {number} weight - The weight to set.
   * @return {AnimationAction} A reference to this animation action.
   */
  setEffectiveWeight(e) {
    return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading();
  }
  /**
   * Returns the effective weight of this action.
   *
   * @return {number} The effective weight.
   */
  getEffectiveWeight() {
    return this._effectiveWeight;
  }
  /**
   * Fades the animation in by increasing its weight gradually from `0` to `1`,
   * within the passed time interval.
   *
   * @param {number} duration - The duration of the fade.
   * @return {AnimationAction} A reference to this animation action.
   */
  fadeIn(e) {
    return this._scheduleFading(e, 0, 1);
  }
  /**
   * Fades the animation out by decreasing its weight gradually from `1` to `0`,
   * within the passed time interval.
   *
   * @param {number} duration - The duration of the fade.
   * @return {AnimationAction} A reference to this animation action.
   */
  fadeOut(e) {
    return this._scheduleFading(e, 1, 0);
  }
  /**
   * Causes this action to fade in and the given action to fade out,
   * within the passed time interval.
   *
   * @param {AnimationAction} fadeOutAction - The animation action to fade out.
   * @param {number} duration - The duration of the fade.
   * @param {boolean} [warp=false] - Whether warping should be used or not.
   * @return {AnimationAction} A reference to this animation action.
   */
  crossFadeFrom(e, t, n = !1) {
    if (e.fadeOut(t), this.fadeIn(t), n === !0) {
      const r = this._clip.duration, s = e._clip.duration, o = s / r, a = r / s;
      e.warp(1, o, t), this.warp(a, 1, t);
    }
    return this;
  }
  /**
   * Causes this action to fade out and the given action to fade in,
   * within the passed time interval.
   *
   * @param {AnimationAction} fadeInAction - The animation action to fade in.
   * @param {number} duration - The duration of the fade.
   * @param {boolean} [warp=false] - Whether warping should be used or not.
   * @return {AnimationAction} A reference to this animation action.
   */
  crossFadeTo(e, t, n = !1) {
    return e.crossFadeFrom(this, t, n);
  }
  /**
   * Stops any fading which is applied to this action.
   *
   * @return {AnimationAction} A reference to this animation action.
   */
  stopFading() {
    const e = this._weightInterpolant;
    return e !== null && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this;
  }
  /**
   * Sets the effective time scale of this action.
   *
   * An action has no effect and thus an effective time scale of zero when the
   * action is paused.
   *
   * @param {number} timeScale - The time scale to set.
   * @return {AnimationAction} A reference to this animation action.
   */
  setEffectiveTimeScale(e) {
    return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping();
  }
  /**
   * Returns the effective time scale of this action.
   *
   * @return {number} The effective time scale.
   */
  getEffectiveTimeScale() {
    return this._effectiveTimeScale;
  }
  /**
   * Sets the duration for a single loop of this action.
   *
   * @param {number} duration - The duration to set.
   * @return {AnimationAction} A reference to this animation action.
   */
  setDuration(e) {
    return this.timeScale = this._clip.duration / e, this.stopWarping();
  }
  /**
   * Synchronizes this action with the passed other action.
   *
   * @param {AnimationAction} action - The action to sync with.
   * @return {AnimationAction} A reference to this animation action.
   */
  syncWith(e) {
    return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping();
  }
  /**
   * Decelerates this animation's speed to `0` within the passed time interval.
   *
   * @param {number} duration - The duration.
   * @return {AnimationAction} A reference to this animation action.
   */
  halt(e) {
    return this.warp(this._effectiveTimeScale, 0, e);
  }
  /**
   * Changes the playback speed, within the passed time interval, by modifying
   * {@link AnimationAction#timeScale} gradually from `startTimeScale` to
   * `endTimeScale`.
   *
   * @param {number} startTimeScale - The start time scale.
   * @param {number} endTimeScale - The end time scale.
   * @param {number} duration - The duration.
   * @return {AnimationAction} A reference to this animation action.
   */
  warp(e, t, n) {
    const r = this._mixer, s = r.time, o = this.timeScale;
    let a = this._timeScaleInterpolant;
    a === null && (a = r._lendControlInterpolant(), this._timeScaleInterpolant = a);
    const l = a.parameterPositions, u = a.sampleValues;
    return l[0] = s, l[1] = s + n, u[0] = e / o, u[1] = t / o, this;
  }
  /**
   * Stops any scheduled warping which is applied to this action.
   *
   * @return {AnimationAction} A reference to this animation action.
   */
  stopWarping() {
    const e = this._timeScaleInterpolant;
    return e !== null && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this;
  }
  /**
   * Returns the animation mixer of this animation action.
   *
   * @return {AnimationMixer} The animation mixer.
   */
  getMixer() {
    return this._mixer;
  }
  /**
   * Returns the animation clip of this animation action.
   *
   * @return {AnimationClip} The animation clip.
   */
  getClip() {
    return this._clip;
  }
  /**
   * Returns the root object of this animation action.
   *
   * @return {Object3D} The root object.
   */
  getRoot() {
    return this._localRoot || this._mixer._root;
  }
  // Interna
  _update(e, t, n, r) {
    if (!this.enabled) {
      this._updateWeight(e);
      return;
    }
    const s = this._startTime;
    if (s !== null) {
      const l = (e - s) * n;
      l < 0 || n === 0 ? t = 0 : (this._startTime = null, t = n * l);
    }
    t *= this._updateTimeScale(e);
    const o = this._updateTime(t), a = this._updateWeight(e);
    if (a > 0) {
      const l = this._interpolants, u = this._propertyBindings;
      switch (this.blendMode) {
        case w3:
          for (let c = 0, A = l.length; c !== A; ++c)
            l[c].evaluate(o), u[c].accumulateAdditive(a);
          break;
        case V_:
        default:
          for (let c = 0, A = l.length; c !== A; ++c)
            l[c].evaluate(o), u[c].accumulate(r, a);
      }
    }
  }
  _updateWeight(e) {
    let t = 0;
    if (this.enabled) {
      t = this.weight;
      const n = this._weightInterpolant;
      if (n !== null) {
        const r = n.evaluate(e)[0];
        t *= r, e > n.parameterPositions[1] && (this.stopFading(), r === 0 && (this.enabled = !1));
      }
    }
    return this._effectiveWeight = t, t;
  }
  _updateTimeScale(e) {
    let t = 0;
    if (!this.paused) {
      t = this.timeScale;
      const n = this._timeScaleInterpolant;
      if (n !== null) {
        const r = n.evaluate(e)[0];
        t *= r, e > n.parameterPositions[1] && (this.stopWarping(), t === 0 ? this.paused = !0 : this.timeScale = t);
      }
    }
    return this._effectiveTimeScale = t, t;
  }
  _updateTime(e) {
    const t = this._clip.duration, n = this.loop;
    let r = this.time + e, s = this._loopCount;
    const o = n === w5;
    if (e === 0)
      return s === -1 ? r : o && (s & 1) === 1 ? t - r : r;
    if (n === S5) {
      s === -1 && (this._loopCount = 0, this._setEndings(!0, !0, !1));
      e: {
        if (r >= t)
          r = t;
        else if (r < 0)
          r = 0;
        else {
          this.time = r;
          break e;
        }
        this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = r, this._mixer.dispatchEvent({
          type: "finished",
          action: this,
          direction: e < 0 ? -1 : 1
        });
      }
    } else {
      if (s === -1 && (e >= 0 ? (s = 0, this._setEndings(!0, this.repetitions === 0, o)) : this._setEndings(this.repetitions === 0, !0, o)), r >= t || r < 0) {
        const a = Math.floor(r / t);
        r -= t * a, s += Math.abs(a);
        const l = this.repetitions - s;
        if (l <= 0)
          this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, r = e > 0 ? t : 0, this.time = r, this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: e > 0 ? 1 : -1
          });
        else {
          if (l === 1) {
            const u = e < 0;
            this._setEndings(u, !u, o);
          } else
            this._setEndings(!1, !1, o);
          this._loopCount = s, this.time = r, this._mixer.dispatchEvent({
            type: "loop",
            action: this,
            loopDelta: a
          });
        }
      } else
        this.time = r;
      if (o && (s & 1) === 1)
        return t - r;
    }
    return r;
  }
  _setEndings(e, t, n) {
    const r = this._interpolantSettings;
    n ? (r.endingStart = Zc, r.endingEnd = Zc) : (e ? r.endingStart = this.zeroSlopeAtStart ? Zc : Kc : r.endingStart = Up, t ? r.endingEnd = this.zeroSlopeAtEnd ? Zc : Kc : r.endingEnd = Up);
  }
  _scheduleFading(e, t, n) {
    const r = this._mixer, s = r.time;
    let o = this._weightInterpolant;
    o === null && (o = r._lendControlInterpolant(), this._weightInterpolant = o);
    const a = o.parameterPositions, l = o.sampleValues;
    return a[0] = s, l[0] = t, a[1] = s + e, l[1] = n, this;
  }
}
const n9 = new Float32Array(1);
class i9 extends lo {
  /**
   * Constructs a new animation mixer.
   *
   * @param {Object3D} root - The object whose animations shall be played by this mixer.
   */
  constructor(e) {
    super(), this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1;
  }
  _bindAction(e, t) {
    const n = e._localRoot || this._root, r = e._clip.tracks, s = r.length, o = e._propertyBindings, a = e._interpolants, l = n.uuid, u = this._bindingsByRootAndName;
    let c = u[l];
    c === void 0 && (c = {}, u[l] = c);
    for (let A = 0; A !== s; ++A) {
      const m = r[A], _ = m.name;
      let y = c[_];
      if (y !== void 0)
        ++y.referenceCount, o[A] = y;
      else {
        if (y = o[A], y !== void 0) {
          y._cacheIndex === null && (++y.referenceCount, this._addInactiveBinding(y, l, _));
          continue;
        }
        const T = t && t._propertyBindings[A].binding.parsedPath;
        y = new g8(
          Xn.create(n, _, T),
          m.ValueTypeName,
          m.getValueSize()
        ), ++y.referenceCount, this._addInactiveBinding(y, l, _), o[A] = y;
      }
      a[A].resultBuffer = y.buffer;
    }
  }
  _activateAction(e) {
    if (!this._isActiveAction(e)) {
      if (e._cacheIndex === null) {
        const n = (e._localRoot || this._root).uuid, r = e._clip.uuid, s = this._actionsByClip[r];
        this._bindAction(
          e,
          s && s.knownActions[0]
        ), this._addInactiveAction(e, r, n);
      }
      const t = e._propertyBindings;
      for (let n = 0, r = t.length; n !== r; ++n) {
        const s = t[n];
        s.useCount++ === 0 && (this._lendBinding(s), s.saveOriginalState());
      }
      this._lendAction(e);
    }
  }
  _deactivateAction(e) {
    if (this._isActiveAction(e)) {
      const t = e._propertyBindings;
      for (let n = 0, r = t.length; n !== r; ++n) {
        const s = t[n];
        --s.useCount === 0 && (s.restoreOriginalState(), this._takeBackBinding(s));
      }
      this._takeBackAction(e);
    }
  }
  // Memory manager
  _initMemoryManager() {
    this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
    const e = this;
    this.stats = {
      actions: {
        get total() {
          return e._actions.length;
        },
        get inUse() {
          return e._nActiveActions;
        }
      },
      bindings: {
        get total() {
          return e._bindings.length;
        },
        get inUse() {
          return e._nActiveBindings;
        }
      },
      controlInterpolants: {
        get total() {
          return e._controlInterpolants.length;
        },
        get inUse() {
          return e._nActiveControlInterpolants;
        }
      }
    };
  }
  // Memory management for AnimationAction objects
  _isActiveAction(e) {
    const t = e._cacheIndex;
    return t !== null && t < this._nActiveActions;
  }
  _addInactiveAction(e, t, n) {
    const r = this._actions, s = this._actionsByClip;
    let o = s[t];
    if (o === void 0)
      o = {
        knownActions: [e],
        actionByRoot: {}
      }, e._byClipCacheIndex = 0, s[t] = o;
    else {
      const a = o.knownActions;
      e._byClipCacheIndex = a.length, a.push(e);
    }
    e._cacheIndex = r.length, r.push(e), o.actionByRoot[n] = e;
  }
  _removeInactiveAction(e) {
    const t = this._actions, n = t[t.length - 1], r = e._cacheIndex;
    n._cacheIndex = r, t[r] = n, t.pop(), e._cacheIndex = null;
    const s = e._clip.uuid, o = this._actionsByClip, a = o[s], l = a.knownActions, u = l[l.length - 1], c = e._byClipCacheIndex;
    u._byClipCacheIndex = c, l[c] = u, l.pop(), e._byClipCacheIndex = null;
    const A = a.actionByRoot, m = (e._localRoot || this._root).uuid;
    delete A[m], l.length === 0 && delete o[s], this._removeInactiveBindingsForAction(e);
  }
  _removeInactiveBindingsForAction(e) {
    const t = e._propertyBindings;
    for (let n = 0, r = t.length; n !== r; ++n) {
      const s = t[n];
      --s.referenceCount === 0 && this._removeInactiveBinding(s);
    }
  }
  _lendAction(e) {
    const t = this._actions, n = e._cacheIndex, r = this._nActiveActions++, s = t[r];
    e._cacheIndex = r, t[r] = e, s._cacheIndex = n, t[n] = s;
  }
  _takeBackAction(e) {
    const t = this._actions, n = e._cacheIndex, r = --this._nActiveActions, s = t[r];
    e._cacheIndex = r, t[r] = e, s._cacheIndex = n, t[n] = s;
  }
  // Memory management for PropertyMixer objects
  _addInactiveBinding(e, t, n) {
    const r = this._bindingsByRootAndName, s = this._bindings;
    let o = r[t];
    o === void 0 && (o = {}, r[t] = o), o[n] = e, e._cacheIndex = s.length, s.push(e);
  }
  _removeInactiveBinding(e) {
    const t = this._bindings, n = e.binding, r = n.rootNode.uuid, s = n.path, o = this._bindingsByRootAndName, a = o[r], l = t[t.length - 1], u = e._cacheIndex;
    l._cacheIndex = u, t[u] = l, t.pop(), delete a[s], Object.keys(a).length === 0 && delete o[r];
  }
  _lendBinding(e) {
    const t = this._bindings, n = e._cacheIndex, r = this._nActiveBindings++, s = t[r];
    e._cacheIndex = r, t[r] = e, s._cacheIndex = n, t[n] = s;
  }
  _takeBackBinding(e) {
    const t = this._bindings, n = e._cacheIndex, r = --this._nActiveBindings, s = t[r];
    e._cacheIndex = r, t[r] = e, s._cacheIndex = n, t[n] = s;
  }
  // Memory management of Interpolants for weight and time scale
  _lendControlInterpolant() {
    const e = this._controlInterpolants, t = this._nActiveControlInterpolants++;
    let n = e[t];
    return n === void 0 && (n = new tS(
      new Float32Array(2),
      new Float32Array(2),
      1,
      n9
    ), n.__cacheIndex = t, e[t] = n), n;
  }
  _takeBackControlInterpolant(e) {
    const t = this._controlInterpolants, n = e.__cacheIndex, r = --this._nActiveControlInterpolants, s = t[r];
    e.__cacheIndex = r, t[r] = e, s.__cacheIndex = n, t[n] = s;
  }
  /**
   * Returns an instance of {@link AnimationAction} for the passed clip.
   *
   * If an action fitting the clip and root parameters doesn't yet exist, it
   * will be created by this method. Calling this method several times with the
   * same clip and root parameters always returns the same action.
   *
   * @param {AnimationClip|string} clip - An animation clip or alternatively the name of the animation clip.
   * @param {Object3D} [optionalRoot] - An alternative root object.
   * @param {(NormalAnimationBlendMode|AdditiveAnimationBlendMode)} [blendMode] - The blend mode.
   * @return {?AnimationAction} The animation action.
   */
  clipAction(e, t, n) {
    const r = t || this._root, s = r.uuid;
    let o = typeof e == "string" ? Hp.findByName(r, e) : e;
    const a = o !== null ? o.uuid : e, l = this._actionsByClip[a];
    let u = null;
    if (n === void 0 && (o !== null ? n = o.blendMode : n = V_), l !== void 0) {
      const A = l.actionByRoot[s];
      if (A !== void 0 && A.blendMode === n)
        return A;
      u = l.knownActions[0], o === null && (o = u._clip);
    }
    if (o === null) return null;
    const c = new _8(this, o, t, n);
    return this._bindAction(c, u), this._addInactiveAction(c, a, s), c;
  }
  /**
   * Returns an existing animation action for the passed clip.
   *
   * @param {AnimationClip|string} clip - An animation clip or alternatively the name of the animation clip.
   * @param {Object3D} [optionalRoot] - An alternative root object.
   * @return {?AnimationAction} The animation action. Returns `null` if no action was found.
   */
  existingAction(e, t) {
    const n = t || this._root, r = n.uuid, s = typeof e == "string" ? Hp.findByName(n, e) : e, o = s ? s.uuid : e, a = this._actionsByClip[o];
    return a !== void 0 && a.actionByRoot[r] || null;
  }
  /**
   * Deactivates all previously scheduled actions on this mixer.
   *
   * @return {AnimationMixer} A reference to this animation mixer.
   */
  stopAllAction() {
    const e = this._actions, t = this._nActiveActions;
    for (let n = t - 1; n >= 0; --n)
      e[n].stop();
    return this;
  }
  /**
   * Advances the global mixer time and updates the animation.
   *
   * This is usually done in the render loop by passing the delta
   * time from {@link Clock} or {@link Timer}.
   *
   * @param {number} deltaTime - The delta time in seconds.
   * @return {AnimationMixer} A reference to this animation mixer.
   */
  update(e) {
    e *= this.timeScale;
    const t = this._actions, n = this._nActiveActions, r = this.time += e, s = Math.sign(e), o = this._accuIndex ^= 1;
    for (let u = 0; u !== n; ++u)
      t[u]._update(r, e, s, o);
    const a = this._bindings, l = this._nActiveBindings;
    for (let u = 0; u !== l; ++u)
      a[u].apply(o);
    return this;
  }
  /**
   * Sets the global mixer to a specific time and updates the animation accordingly.
   *
   * This is useful when you need to jump to an exact time in an animation. The
   * input parameter will be scaled by {@link AnimationMixer#timeScale}
   *
   * @param {number} time - The time to set in seconds.
   * @return {AnimationMixer} A reference to this animation mixer.
   */
  setTime(e) {
    this.time = 0;
    for (let t = 0; t < this._actions.length; t++)
      this._actions[t].time = 0;
    return this.update(e);
  }
  /**
   * Returns this mixer's root object.
   *
   * @return {Object3D} The mixer's root object.
   */
  getRoot() {
    return this._root;
  }
  /**
   * Deallocates all memory resources for a clip. Before using this method make
   * sure to call {@link AnimationAction#stop} for all related actions.
   *
   * @param {AnimationClip} clip - The clip to uncache.
   */
  uncacheClip(e) {
    const t = this._actions, n = e.uuid, r = this._actionsByClip, s = r[n];
    if (s !== void 0) {
      const o = s.knownActions;
      for (let a = 0, l = o.length; a !== l; ++a) {
        const u = o[a];
        this._deactivateAction(u);
        const c = u._cacheIndex, A = t[t.length - 1];
        u._cacheIndex = null, u._byClipCacheIndex = null, A._cacheIndex = c, t[c] = A, t.pop(), this._removeInactiveBindingsForAction(u);
      }
      delete r[n];
    }
  }
  /**
   * Deallocates all memory resources for a root object. Before using this
   * method make sure to call {@link AnimationAction#stop} for all related
   * actions or alternatively {@link AnimationMixer#stopAllAction} when the
   * mixer operates on a single root.
   *
   * @param {Object3D} root - The root object to uncache.
   */
  uncacheRoot(e) {
    const t = e.uuid, n = this._actionsByClip;
    for (const o in n) {
      const a = n[o].actionByRoot, l = a[t];
      l !== void 0 && (this._deactivateAction(l), this._removeInactiveAction(l));
    }
    const r = this._bindingsByRootAndName, s = r[t];
    if (s !== void 0)
      for (const o in s) {
        const a = s[o];
        a.restoreOriginalState(), this._removeInactiveBinding(a);
      }
  }
  /**
   * Deallocates all memory resources for an action. The action is identified by the
   * given clip and an optional root object. Before using this method make
   * sure to call {@link AnimationAction#stop} to deactivate the action.
   *
   * @param {AnimationClip|string} clip - An animation clip or alternatively the name of the animation clip.
   * @param {Object3D} [optionalRoot] - An alternative root object.
   */
  uncacheAction(e, t) {
    const n = this.existingAction(e, t);
    n !== null && (this._deactivateAction(n), this._removeInactiveAction(n));
  }
}
class r9 extends Ma {
  /**
   * Constructs a new 3D render target.
   *
   * @param {number} [width=1] - The width of the render target.
   * @param {number} [height=1] - The height of the render target.
   * @param {number} [depth=1] - The height of the render target.
   * @param {RenderTarget~Options} [options] - The configuration object.
   */
  constructor(e = 1, t = 1, n = 1, r = {}) {
    super(e, t, r), this.isRenderTarget3D = !0, this.depth = n, this.texture = new $_(null, e, t, n), this._setTextureOptions(r), this.texture.isRenderTargetTexture = !0;
  }
}
let s9 = class x8 {
  /**
   * Constructs a new uniform.
   *
   * @param {any} value - The uniform value.
   */
  constructor(e) {
    this.value = e;
  }
  /**
   * Returns a new uniform with copied values from this instance.
   * If the value has a `clone()` method, the value is cloned as well.
   *
   * @return {Uniform} A clone of this instance.
   */
  clone() {
    return new x8(this.value.clone === void 0 ? this.value : this.value.clone());
  }
}, o9 = 0, a9 = class extends lo {
  /**
   * Constructs a new uniforms group.
   */
  constructor() {
    super(), this.isUniformsGroup = !0, Object.defineProperty(this, "id", { value: o9++ }), this.name = "", this.usage = Wu, this.uniforms = [];
  }
  /**
   * Adds the given uniform to this uniforms group.
   *
   * @param {Uniform} uniform - The uniform to add.
   * @return {UniformsGroup} A reference to this uniforms group.
   */
  add(e) {
    return this.uniforms.push(e), this;
  }
  /**
   * Removes the given uniform from this uniforms group.
   *
   * @param {Uniform} uniform - The uniform to remove.
   * @return {UniformsGroup} A reference to this uniforms group.
   */
  remove(e) {
    const t = this.uniforms.indexOf(e);
    return t !== -1 && this.uniforms.splice(t, 1), this;
  }
  /**
   * Sets the name of this uniforms group.
   *
   * @param {string} name - The name to set.
   * @return {UniformsGroup} A reference to this uniforms group.
   */
  setName(e) {
    return this.name = e, this;
  }
  /**
   * Sets the usage of this uniforms group.
   *
   * @param {(StaticDrawUsage|DynamicDrawUsage|StreamDrawUsage|StaticReadUsage|DynamicReadUsage|StreamReadUsage|StaticCopyUsage|DynamicCopyUsage|StreamCopyUsage)} value - The usage to set.
   * @return {UniformsGroup} A reference to this uniforms group.
   */
  setUsage(e) {
    return this.usage = e, this;
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   *
   * @fires Texture#dispose
   */
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  /**
   * Copies the values of the given uniforms group to this instance.
   *
   * @param {UniformsGroup} source - The uniforms group to copy.
   * @return {UniformsGroup} A reference to this uniforms group.
   */
  copy(e) {
    this.name = e.name, this.usage = e.usage;
    const t = e.uniforms;
    this.uniforms.length = 0;
    for (let n = 0, r = t.length; n < r; n++) {
      const s = Array.isArray(t[n]) ? t[n] : [t[n]];
      for (let o = 0; o < s.length; o++)
        this.uniforms.push(s[o].clone());
    }
    return this;
  }
  /**
   * Returns a new uniforms group with copied values from this instance.
   *
   * @return {UniformsGroup} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
};
class $p extends aA {
  /**
   * Constructs a new instanced interleaved buffer.
   *
   * @param {TypedArray} array - A typed array with a shared buffer storing attribute data.
   * @param {number} stride - The number of typed-array elements per vertex.
   * @param {number} [meshPerAttribute=1] - Defines how often a value of this interleaved buffer should be repeated.
   */
  constructor(e, t, n = 1) {
    super(e, t), this.isInstancedInterleavedBuffer = !0, this.meshPerAttribute = n;
  }
  copy(e) {
    return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
  }
  clone(e) {
    const t = super.clone(e);
    return t.meshPerAttribute = this.meshPerAttribute, t;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.isInstancedInterleavedBuffer = !0, t.meshPerAttribute = this.meshPerAttribute, t;
  }
}
class l9 {
  /**
   * Constructs a new GL buffer attribute.
   *
   * @param {WebGLBuffer} buffer - The native WebGL buffer.
   * @param {number} type - The native data type (e.g. `gl.FLOAT`).
   * @param {number} itemSize - The item size.
   * @param {number} elementSize - The corresponding size (in bytes) for the given `type` parameter.
   * @param {number} count - The expected number of vertices in VBO.
   * @param {boolean} [normalized=false] - Whether the data are normalized or not.
   */
  constructor(e, t, n, r, s, o = !1) {
    this.isGLBufferAttribute = !0, this.name = "", this.buffer = e, this.type = t, this.itemSize = n, this.elementSize = r, this.count = s, this.normalized = o, this.version = 0;
  }
  /**
   * Flag to indicate that this attribute has changed and should be re-sent to
   * the GPU. Set this to `true` when you modify the value of the array.
   *
   * @type {number}
   * @default false
   * @param {boolean} value
   */
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  /**
   * Sets the given native WebGL buffer.
   *
   * @param {WebGLBuffer} buffer - The buffer to set.
   * @return {BufferAttribute} A reference to this instance.
   */
  setBuffer(e) {
    return this.buffer = e, this;
  }
  /**
   * Sets the given native data type and element size.
   *
   * @param {number} type - The native data type (e.g. `gl.FLOAT`).
   * @param {number} elementSize - The corresponding size (in bytes) for the given `type` parameter.
   * @return {BufferAttribute} A reference to this instance.
   */
  setType(e, t) {
    return this.type = e, this.elementSize = t, this;
  }
  /**
   * Sets the item size.
   *
   * @param {number} itemSize - The item size.
   * @return {BufferAttribute} A reference to this instance.
   */
  setItemSize(e) {
    return this.itemSize = e, this;
  }
  /**
   * Sets the count (the expected number of vertices in VBO).
   *
   * @param {number} count - The count.
   * @return {BufferAttribute} A reference to this instance.
   */
  setCount(e) {
    return this.count = e, this;
  }
}
const aE = /* @__PURE__ */ new Mt();
class y8 {
  /**
   * Constructs a new raycaster.
   *
   * @param {Vector3} origin - The origin vector where the ray casts from.
   * @param {Vector3} direction - The (normalized) direction vector that gives direction to the ray.
   * @param {number} [near=0] - All results returned are further away than near. Near can't be negative.
   * @param {number} [far=Infinity] - All results returned are closer than far. Far can't be lower than near.
   */
  constructor(e, t, n = 0, r = 1 / 0) {
    this.ray = new Zh(e, t), this.near = n, this.far = r, this.camera = null, this.layers = new j_(), this.params = {
      Mesh: {},
      Line: { threshold: 1 },
      LOD: {},
      Points: { threshold: 1 },
      Sprite: {}
    };
  }
  /**
   * Updates the ray with a new origin and direction by copying the values from the arguments.
   *
   * @param {Vector3} origin - The origin vector where the ray casts from.
   * @param {Vector3} direction - The (normalized) direction vector that gives direction to the ray.
   */
  set(e, t) {
    this.ray.set(e, t);
  }
  /**
   * Uses the given coordinates and camera to compute a new origin and direction for the internal ray.
   *
   * @param {Vector2} coords - 2D coordinates of the mouse, in normalized device coordinates (NDC).
   * X and Y components should be between `-1` and `1`.
   * @param {Camera} camera - The camera from which the ray should originate.
   */
  setFromCamera(e, t) {
    t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, 0.5).unproject(t).sub(this.ray.origin).normalize(), this.camera = t) : t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t) : Ie("Raycaster: Unsupported camera type: " + t.type);
  }
  /**
   * Uses the given WebXR controller to compute a new origin and direction for the internal ray.
   *
   * @param {WebXRController} controller - The controller to copy the position and direction from.
   * @return {Raycaster} A reference to this raycaster.
   */
  setFromXRController(e) {
    return aE.identity().extractRotation(e.matrixWorld), this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(0, 0, -1).applyMatrix4(aE), this;
  }
  /**
   * The intersection point of a raycaster intersection test.
   * @typedef {Object} Raycaster~Intersection
   * @property {number} distance - The distance from the ray's origin to the intersection point.
   * @property {number} distanceToRay -  Some 3D objects e.g. {@link Points} provide the distance of the
   * intersection to the nearest point on the ray. For other objects it will be `undefined`.
   * @property {Vector3} point - The intersection point, in world coordinates.
   * @property {Object} face - The face that has been intersected.
   * @property {number} faceIndex - The face index.
   * @property {Object3D} object - The 3D object that has been intersected.
   * @property {Vector2} uv - U,V coordinates at point of intersection.
   * @property {Vector2} uv1 - Second set of U,V coordinates at point of intersection.
   * @property {Vector3} normal - Interpolated normal vector at point of intersection.
   * @property {number} instanceId - The index number of the instance where the ray
   * intersects the {@link InstancedMesh}.
   */
  /**
   * Checks all intersection between the ray and the object with or without the
   * descendants. Intersections are returned sorted by distance, closest first.
   *
   * `Raycaster` delegates to the `raycast()` method of the passed 3D object, when
   * evaluating whether the ray intersects the object or not. This allows meshes to respond
   * differently to ray casting than lines or points.
   *
   * Note that for meshes, faces must be pointed towards the origin of the ray in order
   * to be detected; intersections of the ray passing through the back of a face will not
   * be detected. To raycast against both faces of an object, you'll want to set  {@link Material#side}
   * to `THREE.DoubleSide`.
   *
   * @param {Object3D} object - The 3D object to check for intersection with the ray.
   * @param {boolean} [recursive=true] - If set to `true`, it also checks all descendants.
   * Otherwise it only checks intersection with the object.
   * @param {Array<Raycaster~Intersection>} [intersects=[]] The target array that holds the result of the method.
   * @return {Array<Raycaster~Intersection>} An array holding the intersection points.
   */
  intersectObject(e, t = !0, n = []) {
    return qv(e, this, n, t), n.sort(lE), n;
  }
  /**
   * Checks all intersection between the ray and the objects with or without
   * the descendants. Intersections are returned sorted by distance, closest first.
   *
   * @param {Array<Object3D>} objects - The 3D objects to check for intersection with the ray.
   * @param {boolean} [recursive=true] - If set to `true`, it also checks all descendants.
   * Otherwise it only checks intersection with the object.
   * @param {Array<Raycaster~Intersection>} [intersects=[]] The target array that holds the result of the method.
   * @return {Array<Raycaster~Intersection>} An array holding the intersection points.
   */
  intersectObjects(e, t = !0, n = []) {
    for (let r = 0, s = e.length; r < s; r++)
      qv(e[r], this, n, t);
    return n.sort(lE), n;
  }
}
function lE(i, e) {
  return i.distance - e.distance;
}
function qv(i, e, t, n) {
  let r = !0;
  if (i.layers.test(e.layers) && i.raycast(e, t) === !1 && (r = !1), r === !0 && n === !0) {
    const s = i.children;
    for (let o = 0, a = s.length; o < a; o++)
      qv(s[o], e, t, !0);
  }
}
class u9 {
  /**
   * Constructs a new timer.
   */
  constructor() {
    this._previousTime = 0, this._currentTime = 0, this._startTime = performance.now(), this._delta = 0, this._elapsed = 0, this._timescale = 1, this._document = null, this._pageVisibilityHandler = null;
  }
  /**
   * Connect the timer to the given document.Calling this method is not mandatory to
   * use the timer but enables the usage of the Page Visibility API to avoid large time
   * delta values.
   *
   * @param {Document} document - The document.
   */
  connect(e) {
    this._document = e, e.hidden !== void 0 && (this._pageVisibilityHandler = c9.bind(this), e.addEventListener("visibilitychange", this._pageVisibilityHandler, !1));
  }
  /**
   * Disconnects the timer from the DOM and also disables the usage of the Page Visibility API.
   */
  disconnect() {
    this._pageVisibilityHandler !== null && (this._document.removeEventListener("visibilitychange", this._pageVisibilityHandler), this._pageVisibilityHandler = null), this._document = null;
  }
  /**
   * Returns the time delta in seconds.
   *
   * @return {number} The time delta in second.
   */
  getDelta() {
    return this._delta / 1e3;
  }
  /**
   * Returns the elapsed time in seconds.
   *
   * @return {number} The elapsed time in second.
   */
  getElapsed() {
    return this._elapsed / 1e3;
  }
  /**
   * Returns the timescale.
   *
   * @return {number} The timescale.
   */
  getTimescale() {
    return this._timescale;
  }
  /**
   * Sets the given timescale which scale the time delta computation
   * in `update()`.
   *
   * @param {number} timescale - The timescale to set.
   * @return {Timer} A reference to this timer.
   */
  setTimescale(e) {
    return this._timescale = e, this;
  }
  /**
   * Resets the time computation for the current simulation step.
   *
   * @return {Timer} A reference to this timer.
   */
  reset() {
    return this._currentTime = performance.now() - this._startTime, this;
  }
  /**
   * Can be used to free all internal resources. Usually called when
   * the timer instance isn't required anymore.
   */
  dispose() {
    this.disconnect();
  }
  /**
   * Updates the internal state of the timer. This method should be called
   * once per simulation step and before you perform queries against the timer
   * (e.g. via `getDelta()`).
   *
   * @param {number} timestamp - The current time in milliseconds. Can be obtained
   * from the `requestAnimationFrame` callback argument. If not provided, the current
   * time will be determined with `performance.now`.
   * @return {Timer} A reference to this timer.
   */
  update(e) {
    return this._pageVisibilityHandler !== null && this._document.hidden === !0 ? this._delta = 0 : (this._previousTime = this._currentTime, this._currentTime = (e !== void 0 ? e : performance.now()) - this._startTime, this._delta = (this._currentTime - this._previousTime) * this._timescale, this._elapsed += this._delta), this;
  }
}
function c9() {
  this._document.hidden === !1 && this.reset();
}
class Hv {
  /**
   * Constructs a new spherical.
   *
   * @param {number} [radius=1] - The radius, or the Euclidean distance (straight-line distance) from the point to the origin.
   * @param {number} [phi=0] - The polar angle in radians from the y (up) axis.
   * @param {number} [theta=0] - The equator/azimuthal angle in radians around the y (up) axis.
   */
  constructor(e = 1, t = 0, n = 0) {
    this.radius = e, this.phi = t, this.theta = n;
  }
  /**
   * Sets the spherical components by copying the given values.
   *
   * @param {number} radius - The radius.
   * @param {number} phi - The polar angle.
   * @param {number} theta - The azimuthal angle.
   * @return {Spherical} A reference to this spherical.
   */
  set(e, t, n) {
    return this.radius = e, this.phi = t, this.theta = n, this;
  }
  /**
   * Copies the values of the given spherical to this instance.
   *
   * @param {Spherical} other - The spherical to copy.
   * @return {Spherical} A reference to this spherical.
   */
  copy(e) {
    return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this;
  }
  /**
   * Restricts the polar angle [page:.phi phi] to be between `0.000001` and pi -
   * `0.000001`.
   *
   * @return {Spherical} A reference to this spherical.
   */
  makeSafe() {
    return this.phi = dn(this.phi, 1e-6, Math.PI - 1e-6), this;
  }
  /**
   * Sets the spherical components from the given vector which is assumed to hold
   * Cartesian coordinates.
   *
   * @param {Vector3} v - The vector to set.
   * @return {Spherical} A reference to this spherical.
   */
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  /**
   * Sets the spherical components from the given Cartesian coordinates.
   *
   * @param {number} x - The x value.
   * @param {number} y - The y value.
   * @param {number} z - The z value.
   * @return {Spherical} A reference to this spherical.
   */
  setFromCartesianCoords(e, t, n) {
    return this.radius = Math.sqrt(e * e + t * t + n * n), this.radius === 0 ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, n), this.phi = Math.acos(dn(t / this.radius, -1, 1))), this;
  }
  /**
   * Returns a new spherical with copied values from this instance.
   *
   * @return {Spherical} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
}
class h9 {
  /**
   * Constructs a new cylindrical.
   *
   * @param {number} [radius=1] - The distance from the origin to a point in the x-z plane.
   * @param {number} [theta=0] - A counterclockwise angle in the x-z plane measured in radians from the positive z-axis.
   * @param {number} [y=0] - The height above the x-z plane.
   */
  constructor(e = 1, t = 0, n = 0) {
    this.radius = e, this.theta = t, this.y = n;
  }
  /**
   * Sets the cylindrical components by copying the given values.
   *
   * @param {number} radius - The radius.
   * @param {number} theta - The theta angle.
   * @param {number} y - The height value.
   * @return {Cylindrical} A reference to this cylindrical.
   */
  set(e, t, n) {
    return this.radius = e, this.theta = t, this.y = n, this;
  }
  /**
   * Copies the values of the given cylindrical to this instance.
   *
   * @param {Cylindrical} other - The cylindrical to copy.
   * @return {Cylindrical} A reference to this cylindrical.
   */
  copy(e) {
    return this.radius = e.radius, this.theta = e.theta, this.y = e.y, this;
  }
  /**
   * Sets the cylindrical components from the given vector which is assumed to hold
   * Cartesian coordinates.
   *
   * @param {Vector3} v - The vector to set.
   * @return {Cylindrical} A reference to this cylindrical.
   */
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  /**
   * Sets the cylindrical components from the given Cartesian coordinates.
   *
   * @param {number} x - The x value.
   * @param {number} y - The x value.
   * @param {number} z - The x value.
   * @return {Cylindrical} A reference to this cylindrical.
   */
  setFromCartesianCoords(e, t, n) {
    return this.radius = Math.sqrt(e * e + n * n), this.theta = Math.atan2(e, n), this.y = t, this;
  }
  /**
   * Returns a new cylindrical with copied values from this instance.
   *
   * @return {Cylindrical} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
}
class D0 {
  /**
   * Constructs a new 2x2 matrix. The arguments are supposed to be
   * in row-major order. If no arguments are provided, the constructor
   * initializes the matrix as an identity matrix.
   *
   * @param {number} [n11] - 1-1 matrix element.
   * @param {number} [n12] - 1-2 matrix element.
   * @param {number} [n21] - 2-1 matrix element.
   * @param {number} [n22] - 2-2 matrix element.
   */
  constructor(e, t, n, r) {
    D0.prototype.isMatrix2 = !0, this.elements = [
      1,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, t, n, r);
  }
  /**
   * Sets this matrix to the 2x2 identity matrix.
   *
   * @return {Matrix2} A reference to this matrix.
   */
  identity() {
    return this.set(
      1,
      0,
      0,
      1
    ), this;
  }
  /**
   * Sets the elements of the matrix from the given array.
   *
   * @param {Array<number>} array - The matrix elements in column-major order.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Matrix2} A reference to this matrix.
   */
  fromArray(e, t = 0) {
    for (let n = 0; n < 4; n++)
      this.elements[n] = e[n + t];
    return this;
  }
  /**
   * Sets the elements of the matrix.The arguments are supposed to be
   * in row-major order.
   *
   * @param {number} n11 - 1-1 matrix element.
   * @param {number} n12 - 1-2 matrix element.
   * @param {number} n21 - 2-1 matrix element.
   * @param {number} n22 - 2-2 matrix element.
   * @return {Matrix2} A reference to this matrix.
   */
  set(e, t, n, r) {
    const s = this.elements;
    return s[0] = e, s[2] = t, s[1] = n, s[3] = r, this;
  }
}
const uE = /* @__PURE__ */ new Le();
class d9 {
  /**
   * Constructs a new bounding box.
   *
   * @param {Vector2} [min=(Infinity,Infinity)] - A vector representing the lower boundary of the box.
   * @param {Vector2} [max=(-Infinity,-Infinity)] - A vector representing the upper boundary of the box.
   */
  constructor(e = new Le(1 / 0, 1 / 0), t = new Le(-1 / 0, -1 / 0)) {
    this.isBox2 = !0, this.min = e, this.max = t;
  }
  /**
   * Sets the lower and upper boundaries of this box.
   * Please note that this method only copies the values from the given objects.
   *
   * @param {Vector2} min - The lower boundary of the box.
   * @param {Vector2} max - The upper boundary of the box.
   * @return {Box2} A reference to this bounding box.
   */
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  /**
   * Sets the upper and lower bounds of this box so it encloses the position data
   * in the given array.
   *
   * @param {Array<Vector2>} points - An array holding 2D position data as instances of {@link Vector2}.
   * @return {Box2} A reference to this bounding box.
   */
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, n = e.length; t < n; t++)
      this.expandByPoint(e[t]);
    return this;
  }
  /**
   * Centers this box on the given center vector and sets this box's width, height and
   * depth to the given size values.
   *
   * @param {Vector2} center - The center of the box.
   * @param {Vector2} size - The x and y dimensions of the box.
   * @return {Box2} A reference to this bounding box.
   */
  setFromCenterAndSize(e, t) {
    const n = uE.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
  }
  /**
   * Returns a new box with copied values from this instance.
   *
   * @return {Box2} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
  /**
   * Copies the values of the given box to this instance.
   *
   * @param {Box2} box - The box to copy.
   * @return {Box2} A reference to this bounding box.
   */
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  /**
   * Makes this box empty which means in encloses a zero space in 2D.
   *
   * @return {Box2} A reference to this bounding box.
   */
  makeEmpty() {
    return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this;
  }
  /**
   * Returns true if this box includes zero points within its bounds.
   * Note that a box with equal lower and upper bounds still includes one
   * point, the one both bounds share.
   *
   * @return {boolean} Whether this box is empty or not.
   */
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  }
  /**
   * Returns the center point of this box.
   *
   * @param {Vector2} target - The target vector that is used to store the method's result.
   * @return {Vector2} The center point.
   */
  getCenter(e) {
    return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  /**
   * Returns the dimensions of this box.
   *
   * @param {Vector2} target - The target vector that is used to store the method's result.
   * @return {Vector2} The size.
   */
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min);
  }
  /**
   * Expands the boundaries of this box to include the given point.
   *
   * @param {Vector2} point - The point that should be included by the bounding box.
   * @return {Box2} A reference to this bounding box.
   */
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  /**
   * Expands this box equilaterally by the given vector. The width of this
   * box will be expanded by the x component of the vector in both
   * directions. The height of this box will be expanded by the y component of
   * the vector in both directions.
   *
   * @param {Vector2} vector - The vector that should expand the bounding box.
   * @return {Box2} A reference to this bounding box.
   */
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  /**
   * Expands each dimension of the box by the given scalar. If negative, the
   * dimensions of the box will be contracted.
   *
   * @param {number} scalar - The scalar value that should expand the bounding box.
   * @return {Box2} A reference to this bounding box.
   */
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  /**
   * Returns `true` if the given point lies within or on the boundaries of this box.
   *
   * @param {Vector2} point - The point to test.
   * @return {boolean} Whether the bounding box contains the given point or not.
   */
  containsPoint(e) {
    return e.x >= this.min.x && e.x <= this.max.x && e.y >= this.min.y && e.y <= this.max.y;
  }
  /**
   * Returns `true` if this bounding box includes the entirety of the given bounding box.
   * If this box and the given one are identical, this function also returns `true`.
   *
   * @param {Box2} box - The bounding box to test.
   * @return {boolean} Whether the bounding box contains the given bounding box or not.
   */
  containsBox(e) {
    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y;
  }
  /**
   * Returns a point as a proportion of this box's width and height.
   *
   * @param {Vector2} point - A point in 2D space.
   * @param {Vector2} target - The target vector that is used to store the method's result.
   * @return {Vector2} A point as a proportion of this box's width and height.
   */
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y)
    );
  }
  /**
   * Returns `true` if the given bounding box intersects with this bounding box.
   *
   * @param {Box2} box - The bounding box to test.
   * @return {boolean} Whether the given bounding box intersects with this bounding box.
   */
  intersectsBox(e) {
    return e.max.x >= this.min.x && e.min.x <= this.max.x && e.max.y >= this.min.y && e.min.y <= this.max.y;
  }
  /**
   * Clamps the given point within the bounds of this box.
   *
   * @param {Vector2} point - The point to clamp.
   * @param {Vector2} target - The target vector that is used to store the method's result.
   * @return {Vector2} The clamped point.
   */
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  /**
   * Returns the euclidean distance from any edge of this box to the specified point. If
   * the given point lies inside of this box, the distance will be `0`.
   *
   * @param {Vector2} point - The point to compute the distance to.
   * @return {number} The euclidean distance.
   */
  distanceToPoint(e) {
    return this.clampPoint(e, uE).distanceTo(e);
  }
  /**
   * Computes the intersection of this bounding box and the given one, setting the upper
   * bound of this box to the lesser of the two boxes' upper bounds and the
   * lower bound of this box to the greater of the two boxes' lower bounds. If
   * there's no overlap, makes this box empty.
   *
   * @param {Box2} box - The bounding box to intersect with.
   * @return {Box2} A reference to this bounding box.
   */
  intersect(e) {
    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
  }
  /**
   * Computes the union of this box and another and the given one, setting the upper
   * bound of this box to the greater of the two boxes' upper bounds and the
   * lower bound of this box to the lesser of the two boxes' lower bounds.
   *
   * @param {Box2} box - The bounding box that will be unioned with this instance.
   * @return {Box2} A reference to this bounding box.
   */
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  /**
   * Adds the given offset to both the upper and lower bounds of this bounding box,
   * effectively moving it in 2D space.
   *
   * @param {Vector2} offset - The offset that should be used to translate the bounding box.
   * @return {Box2} A reference to this bounding box.
   */
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  /**
   * Returns `true` if this bounding box is equal with the given one.
   *
   * @param {Box2} box - The box to test for equality.
   * @return {boolean} Whether this bounding box is equal with the given one.
   */
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const cE = /* @__PURE__ */ new j(), Vm = /* @__PURE__ */ new j(), Bd = /* @__PURE__ */ new j(), Fd = /* @__PURE__ */ new j(), yy = /* @__PURE__ */ new j(), f9 = /* @__PURE__ */ new j(), A9 = /* @__PURE__ */ new j();
class v8 {
  /**
   * Constructs a new line segment.
   *
   * @param {Vector3} [start=(0,0,0)] - Start of the line segment.
   * @param {Vector3} [end=(0,0,0)] - End of the line segment.
   */
  constructor(e = new j(), t = new j()) {
    this.start = e, this.end = t;
  }
  /**
   * Sets the start and end values by copying the given vectors.
   *
   * @param {Vector3} start - The start point.
   * @param {Vector3} end - The end point.
   * @return {Line3} A reference to this line segment.
   */
  set(e, t) {
    return this.start.copy(e), this.end.copy(t), this;
  }
  /**
   * Copies the values of the given line segment to this instance.
   *
   * @param {Line3} line - The line segment to copy.
   * @return {Line3} A reference to this line segment.
   */
  copy(e) {
    return this.start.copy(e.start), this.end.copy(e.end), this;
  }
  /**
   * Returns the center of the line segment.
   *
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The center point.
   */
  getCenter(e) {
    return e.addVectors(this.start, this.end).multiplyScalar(0.5);
  }
  /**
   * Returns the delta vector of the line segment's start and end point.
   *
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The delta vector.
   */
  delta(e) {
    return e.subVectors(this.end, this.start);
  }
  /**
   * Returns the squared Euclidean distance between the line' start and end point.
   *
   * @return {number} The squared Euclidean distance.
   */
  distanceSq() {
    return this.start.distanceToSquared(this.end);
  }
  /**
   * Returns the Euclidean distance between the line' start and end point.
   *
   * @return {number} The Euclidean distance.
   */
  distance() {
    return this.start.distanceTo(this.end);
  }
  /**
   * Returns a vector at a certain position along the line segment.
   *
   * @param {number} t - A value between `[0,1]` to represent a position along the line segment.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The delta vector.
   */
  at(e, t) {
    return this.delta(t).multiplyScalar(e).add(this.start);
  }
  /**
   * Returns a point parameter based on the closest point as projected on the line segment.
   *
   * @param {Vector3} point - The point for which to return a point parameter.
   * @param {boolean} clampToLine - Whether to clamp the result to the range `[0,1]` or not.
   * @return {number} The point parameter.
   */
  closestPointToPointParameter(e, t) {
    cE.subVectors(e, this.start), Vm.subVectors(this.end, this.start);
    const n = Vm.dot(Vm);
    let s = Vm.dot(cE) / n;
    return t && (s = dn(s, 0, 1)), s;
  }
  /**
   * Returns the closest point on the line for a given point.
   *
   * @param {Vector3} point - The point to compute the closest point on the line for.
   * @param {boolean} clampToLine - Whether to clamp the result to the range `[0,1]` or not.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The closest point on the line.
   */
  closestPointToPoint(e, t, n) {
    const r = this.closestPointToPointParameter(e, t);
    return this.delta(n).multiplyScalar(r).add(this.start);
  }
  /**
   * Returns the closest squared distance between this line segment and the given one.
   *
   * @param {Line3} line - The line segment to compute the closest squared distance to.
   * @param {Vector3} [c1] - The closest point on this line segment.
   * @param {Vector3} [c2] - The closest point on the given line segment.
   * @return {number} The squared distance between this line segment and the given one.
   */
  distanceSqToLine3(e, t = f9, n = A9) {
    const r = 10000000000000001e-32;
    let s, o;
    const a = this.start, l = e.start, u = this.end, c = e.end;
    Bd.subVectors(u, a), Fd.subVectors(c, l), yy.subVectors(a, l);
    const A = Bd.dot(Bd), m = Fd.dot(Fd), _ = Fd.dot(yy);
    if (A <= r && m <= r)
      return t.copy(a), n.copy(l), t.sub(n), t.dot(t);
    if (A <= r)
      s = 0, o = _ / m, o = dn(o, 0, 1);
    else {
      const y = Bd.dot(yy);
      if (m <= r)
        o = 0, s = dn(-y / A, 0, 1);
      else {
        const T = Bd.dot(Fd), b = A * m - T * T;
        b !== 0 ? s = dn((T * _ - y * m) / b, 0, 1) : s = 0, o = (T * s + _) / m, o < 0 ? (o = 0, s = dn(-y / A, 0, 1)) : o > 1 && (o = 1, s = dn((T - y) / A, 0, 1));
      }
    }
    return t.copy(a).add(Bd.multiplyScalar(s)), n.copy(l).add(Fd.multiplyScalar(o)), t.sub(n), t.dot(t);
  }
  /**
   * Applies a 4x4 transformation matrix to this line segment.
   *
   * @param {Matrix4} matrix - The transformation matrix.
   * @return {Line3} A reference to this line segment.
   */
  applyMatrix4(e) {
    return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this;
  }
  /**
   * Returns `true` if this line segment is equal with the given one.
   *
   * @param {Line3} line - The line segment to test for equality.
   * @return {boolean} Whether this line segment is equal with the given one.
   */
  equals(e) {
    return e.start.equals(this.start) && e.end.equals(this.end);
  }
  /**
   * Returns a new line segment with copied values from this instance.
   *
   * @return {Line3} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
}
const hE = /* @__PURE__ */ new j();
class p9 extends Vn {
  /**
   * Constructs a new spot light helper.
   *
   * @param {HemisphereLight} light - The light to be visualized.
   * @param {number|Color|string} [color] - The helper's color. If not set, the helper will take
   * the color of the light.
   */
  constructor(e, t) {
    super(), this.light = e, this.matrixAutoUpdate = !1, this.color = t, this.type = "SpotLightHelper";
    const n = new Yt(), r = [
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      1,
      0,
      0,
      0,
      -1,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      1,
      0,
      0,
      0,
      0,
      -1,
      1
    ];
    for (let o = 0, a = 1, l = 32; o < l; o++, a++) {
      const u = o / l * Math.PI * 2, c = a / l * Math.PI * 2;
      r.push(
        Math.cos(u),
        Math.sin(u),
        1,
        Math.cos(c),
        Math.sin(c),
        1
      );
    }
    n.setAttribute("position", new xt(r, 3));
    const s = new br({ fog: !1, toneMapped: !1 });
    this.cone = new Qo(n, s), this.add(this.cone), this.update();
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   */
  dispose() {
    this.cone.geometry.dispose(), this.cone.material.dispose();
  }
  /**
   * Updates the helper to match the position and direction of the
   * light being visualized.
   */
  update() {
    this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1), this.parent ? (this.parent.updateWorldMatrix(!0), this.matrix.copy(this.parent.matrixWorld).invert().multiply(this.light.matrixWorld)) : this.matrix.copy(this.light.matrixWorld), this.matrixWorld.copy(this.light.matrixWorld);
    const e = this.light.distance ? this.light.distance : 1e3, t = e * Math.tan(this.light.angle);
    this.cone.scale.set(t, t, e), hE.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(hE), this.color !== void 0 ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color);
  }
}
const pu = /* @__PURE__ */ new j(), Gm = /* @__PURE__ */ new Mt(), vy = /* @__PURE__ */ new Mt();
class m9 extends Qo {
  /**
   * Constructs a new skeleton helper.
   *
   * @param {Object3D} object -  Usually an instance of {@link SkinnedMesh}. However, any 3D object
   * can be used if it represents a hierarchy of bones (see {@link Bone}).
   */
  constructor(e) {
    const t = b8(e), n = new Yt(), r = [], s = [];
    for (let u = 0; u < t.length; u++) {
      const c = t[u];
      c.parent && c.parent.isBone && (r.push(0, 0, 0), r.push(0, 0, 0), s.push(0, 0, 0), s.push(0, 0, 0));
    }
    n.setAttribute("position", new xt(r, 3)), n.setAttribute("color", new xt(s, 3));
    const o = new br({ vertexColors: !0, depthTest: !1, depthWrite: !1, toneMapped: !1, transparent: !0 });
    super(n, o), this.isSkeletonHelper = !0, this.type = "SkeletonHelper", this.root = e, this.bones = t, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1;
    const a = new ct(255), l = new ct(65280);
    this.setColors(a, l);
  }
  updateMatrixWorld(e) {
    const t = this.bones, n = this.geometry, r = n.getAttribute("position");
    vy.copy(this.root.matrixWorld).invert();
    for (let s = 0, o = 0; s < t.length; s++) {
      const a = t[s];
      a.parent && a.parent.isBone && (Gm.multiplyMatrices(vy, a.matrixWorld), pu.setFromMatrixPosition(Gm), r.setXYZ(o, pu.x, pu.y, pu.z), Gm.multiplyMatrices(vy, a.parent.matrixWorld), pu.setFromMatrixPosition(Gm), r.setXYZ(o + 1, pu.x, pu.y, pu.z), o += 2);
    }
    n.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(e);
  }
  /**
   * Defines the colors of the helper.
   *
   * @param {Color} color1 - The first line color for each bone.
   * @param {Color} color2 - The second line color for each bone.
   * @return {SkeletonHelper} A reference to this helper.
   */
  setColors(e, t) {
    const r = this.geometry.getAttribute("color");
    for (let s = 0; s < r.count; s += 2)
      r.setXYZ(s, e.r, e.g, e.b), r.setXYZ(s + 1, t.r, t.g, t.b);
    return r.needsUpdate = !0, this;
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   */
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function b8(i) {
  const e = [];
  i.isBone === !0 && e.push(i);
  for (let t = 0; t < i.children.length; t++)
    e.push(...b8(i.children[t]));
  return e;
}
class g9 extends Tn {
  /**
   * Constructs a new point light helper.
   *
   * @param {PointLight} light - The light to be visualized.
   * @param {number} [sphereSize=1] - The size of the sphere helper.
   * @param {number|Color|string} [color] - The helper's color. If not set, the helper will take
   * the color of the light.
   */
  constructor(e, t, n) {
    const r = new Co(t, 4, 2), s = new Nr({ wireframe: !0, fog: !1, toneMapped: !1 });
    super(r, s), this.light = e, this.color = n, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update();
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   */
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
  /**
   * Updates the helper to match the position of the
   * light being visualized.
   */
  update() {
    this.light.updateWorldMatrix(!0, !1), this.color !== void 0 ? this.material.color.set(this.color) : this.material.color.copy(this.light.color);
  }
}
const _9 = /* @__PURE__ */ new j(), dE = /* @__PURE__ */ new ct(), fE = /* @__PURE__ */ new ct();
class x9 extends Vn {
  /**
   * Constructs a new hemisphere light helper.
   *
   * @param {HemisphereLight} light - The light to be visualized.
   * @param {number} [size=1] - The size of the mesh used to visualize the light.
   * @param {number|Color|string} [color] - The helper's color. If not set, the helper will take
   * the color of the light.
   */
  constructor(e, t, n) {
    super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = n, this.type = "HemisphereLightHelper";
    const r = new M0(t);
    r.rotateY(Math.PI * 0.5), this.material = new Nr({ wireframe: !0, fog: !1, toneMapped: !1 }), this.color === void 0 && (this.material.vertexColors = !0);
    const s = r.getAttribute("position"), o = new Float32Array(s.count * 3);
    r.setAttribute("color", new Dn(o, 3)), this.add(new Tn(r, this.material)), this.update();
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   */
  dispose() {
    this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
  /**
   * Updates the helper to match the position and direction of the
   * light being visualized.
   */
  update() {
    const e = this.children[0];
    if (this.color !== void 0)
      this.material.color.set(this.color);
    else {
      const t = e.geometry.getAttribute("color");
      dE.copy(this.light.color), fE.copy(this.light.groundColor);
      for (let n = 0, r = t.count; n < r; n++) {
        const s = n < r / 2 ? dE : fE;
        t.setXYZ(n, s.r, s.g, s.b);
      }
      t.needsUpdate = !0;
    }
    this.light.updateWorldMatrix(!0, !1), e.lookAt(_9.setFromMatrixPosition(this.light.matrixWorld).negate());
  }
}
class y9 extends Qo {
  /**
   * Constructs a new grid helper.
   *
   * @param {number} [size=10] - The size of the grid.
   * @param {number} [divisions=10] - The number of divisions across the grid.
   * @param {number|Color|string} [color1=0x444444] - The color of the center line.
   * @param {number|Color|string} [color2=0x888888] - The color of the lines of the grid.
   */
  constructor(e = 10, t = 10, n = 4473924, r = 8947848) {
    n = new ct(n), r = new ct(r);
    const s = t / 2, o = e / t, a = e / 2, l = [], u = [];
    for (let m = 0, _ = 0, y = -a; m <= t; m++, y += o) {
      l.push(-a, 0, y, a, 0, y), l.push(y, 0, -a, y, 0, a);
      const T = m === s ? n : r;
      T.toArray(u, _), _ += 3, T.toArray(u, _), _ += 3, T.toArray(u, _), _ += 3, T.toArray(u, _), _ += 3;
    }
    const c = new Yt();
    c.setAttribute("position", new xt(l, 3)), c.setAttribute("color", new xt(u, 3));
    const A = new br({ vertexColors: !0, toneMapped: !1 });
    super(c, A), this.type = "GridHelper";
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   */
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class v9 extends Qo {
  /**
   * Constructs a new polar grid helper.
   *
   * @param {number} [radius=10] - The radius of the polar grid. This can be any positive number.
   * @param {number} [sectors=16] - The number of sectors the grid will be divided into. This can be any positive integer.
   * @param {number} [rings=16] - The number of rings. This can be any positive integer.
   * @param {number} [divisions=64] - The number of line segments used for each circle. This can be any positive integer.
   * @param {number|Color|string} [color1=0x444444] - The first color used for grid elements.
   * @param {number|Color|string} [color2=0x888888] -  The second color used for grid elements.
   */
  constructor(e = 10, t = 16, n = 8, r = 64, s = 4473924, o = 8947848) {
    s = new ct(s), o = new ct(o);
    const a = [], l = [];
    if (t > 1)
      for (let A = 0; A < t; A++) {
        const m = A / t * (Math.PI * 2), _ = Math.sin(m) * e, y = Math.cos(m) * e;
        a.push(0, 0, 0), a.push(_, 0, y);
        const T = A & 1 ? s : o;
        l.push(T.r, T.g, T.b), l.push(T.r, T.g, T.b);
      }
    for (let A = 0; A < n; A++) {
      const m = A & 1 ? s : o, _ = e - e / n * A;
      for (let y = 0; y < r; y++) {
        let T = y / r * (Math.PI * 2), b = Math.sin(T) * _, S = Math.cos(T) * _;
        a.push(b, 0, S), l.push(m.r, m.g, m.b), T = (y + 1) / r * (Math.PI * 2), b = Math.sin(T) * _, S = Math.cos(T) * _, a.push(b, 0, S), l.push(m.r, m.g, m.b);
      }
    }
    const u = new Yt();
    u.setAttribute("position", new xt(a, 3)), u.setAttribute("color", new xt(l, 3));
    const c = new br({ vertexColors: !0, toneMapped: !1 });
    super(u, c), this.type = "PolarGridHelper";
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   */
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
const AE = /* @__PURE__ */ new j(), zm = /* @__PURE__ */ new j(), pE = /* @__PURE__ */ new j();
class b9 extends Vn {
  /**
   * Constructs a new directional light helper.
   *
   * @param {DirectionalLight} light - The light to be visualized.
   * @param {number} [size=1] - The dimensions of the plane.
   * @param {number|Color|string} [color] - The helper's color. If not set, the helper will take
   * the color of the light.
   */
  constructor(e, t, n) {
    super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = n, this.type = "DirectionalLightHelper", t === void 0 && (t = 1);
    let r = new Yt();
    r.setAttribute("position", new xt([
      -t,
      t,
      0,
      t,
      t,
      0,
      t,
      -t,
      0,
      -t,
      -t,
      0,
      -t,
      t,
      0
    ], 3));
    const s = new br({ fog: !1, toneMapped: !1 });
    this.lightPlane = new va(r, s), this.add(this.lightPlane), r = new Yt(), r.setAttribute("position", new xt([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new va(r, s), this.add(this.targetLine), this.update();
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   */
  dispose() {
    this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose();
  }
  /**
   * Updates the helper to match the position and direction of the
   * light being visualized.
   */
  update() {
    this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1), AE.setFromMatrixPosition(this.light.matrixWorld), zm.setFromMatrixPosition(this.light.target.matrixWorld), pE.subVectors(zm, AE), this.lightPlane.lookAt(zm), this.color !== void 0 ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(zm), this.targetLine.scale.z = pE.length();
  }
}
const qm = /* @__PURE__ */ new j(), Qi = /* @__PURE__ */ new Jh();
class S9 extends Qo {
  /**
   * Constructs a new arrow helper.
   *
   * @param {Camera} camera - The camera to visualize.
   */
  constructor(e) {
    const t = new Yt(), n = new br({ color: 16777215, vertexColors: !0, toneMapped: !1 }), r = [], s = [], o = {};
    a("n1", "n2"), a("n2", "n4"), a("n4", "n3"), a("n3", "n1"), a("f1", "f2"), a("f2", "f4"), a("f4", "f3"), a("f3", "f1"), a("n1", "f1"), a("n2", "f2"), a("n3", "f3"), a("n4", "f4"), a("p", "n1"), a("p", "n2"), a("p", "n3"), a("p", "n4"), a("u1", "u2"), a("u2", "u3"), a("u3", "u1"), a("c", "t"), a("p", "c"), a("cn1", "cn2"), a("cn3", "cn4"), a("cf1", "cf2"), a("cf3", "cf4");
    function a(y, T) {
      l(y), l(T);
    }
    function l(y) {
      r.push(0, 0, 0), s.push(0, 0, 0), o[y] === void 0 && (o[y] = []), o[y].push(r.length / 3 - 1);
    }
    t.setAttribute("position", new xt(r, 3)), t.setAttribute("color", new xt(s, 3)), super(t, n), this.type = "CameraHelper", this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = o, this.update();
    const u = new ct(16755200), c = new ct(16711680), A = new ct(43775), m = new ct(16777215), _ = new ct(3355443);
    this.setColors(u, c, A, m, _);
  }
  /**
   * Defines the colors of the helper.
   *
   * @param {Color} frustum - The frustum line color.
   * @param {Color} cone - The cone line color.
   * @param {Color} up - The up line color.
   * @param {Color} target - The target line color.
   * @param {Color} cross - The cross line color.
   * @return {CameraHelper} A reference to this helper.
   */
  setColors(e, t, n, r, s) {
    const a = this.geometry.getAttribute("color");
    return a.setXYZ(0, e.r, e.g, e.b), a.setXYZ(1, e.r, e.g, e.b), a.setXYZ(2, e.r, e.g, e.b), a.setXYZ(3, e.r, e.g, e.b), a.setXYZ(4, e.r, e.g, e.b), a.setXYZ(5, e.r, e.g, e.b), a.setXYZ(6, e.r, e.g, e.b), a.setXYZ(7, e.r, e.g, e.b), a.setXYZ(8, e.r, e.g, e.b), a.setXYZ(9, e.r, e.g, e.b), a.setXYZ(10, e.r, e.g, e.b), a.setXYZ(11, e.r, e.g, e.b), a.setXYZ(12, e.r, e.g, e.b), a.setXYZ(13, e.r, e.g, e.b), a.setXYZ(14, e.r, e.g, e.b), a.setXYZ(15, e.r, e.g, e.b), a.setXYZ(16, e.r, e.g, e.b), a.setXYZ(17, e.r, e.g, e.b), a.setXYZ(18, e.r, e.g, e.b), a.setXYZ(19, e.r, e.g, e.b), a.setXYZ(20, e.r, e.g, e.b), a.setXYZ(21, e.r, e.g, e.b), a.setXYZ(22, e.r, e.g, e.b), a.setXYZ(23, e.r, e.g, e.b), a.setXYZ(24, t.r, t.g, t.b), a.setXYZ(25, t.r, t.g, t.b), a.setXYZ(26, t.r, t.g, t.b), a.setXYZ(27, t.r, t.g, t.b), a.setXYZ(28, t.r, t.g, t.b), a.setXYZ(29, t.r, t.g, t.b), a.setXYZ(30, t.r, t.g, t.b), a.setXYZ(31, t.r, t.g, t.b), a.setXYZ(32, n.r, n.g, n.b), a.setXYZ(33, n.r, n.g, n.b), a.setXYZ(34, n.r, n.g, n.b), a.setXYZ(35, n.r, n.g, n.b), a.setXYZ(36, n.r, n.g, n.b), a.setXYZ(37, n.r, n.g, n.b), a.setXYZ(38, r.r, r.g, r.b), a.setXYZ(39, r.r, r.g, r.b), a.setXYZ(40, s.r, s.g, s.b), a.setXYZ(41, s.r, s.g, s.b), a.setXYZ(42, s.r, s.g, s.b), a.setXYZ(43, s.r, s.g, s.b), a.setXYZ(44, s.r, s.g, s.b), a.setXYZ(45, s.r, s.g, s.b), a.setXYZ(46, s.r, s.g, s.b), a.setXYZ(47, s.r, s.g, s.b), a.setXYZ(48, s.r, s.g, s.b), a.setXYZ(49, s.r, s.g, s.b), a.needsUpdate = !0, this;
  }
  /**
   * Updates the helper based on the projection matrix of the camera.
   */
  update() {
    const e = this.geometry, t = this.pointMap, n = 1, r = 1;
    let s, o;
    if (Qi.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), this.camera.reversedDepth === !0)
      s = 1, o = 0;
    else if (this.camera.coordinateSystem === jr)
      s = -1, o = 1;
    else if (this.camera.coordinateSystem === io)
      s = 0, o = 1;
    else
      throw new Error("THREE.CameraHelper.update(): Invalid coordinate system: " + this.camera.coordinateSystem);
    ir("c", t, e, Qi, 0, 0, s), ir("t", t, e, Qi, 0, 0, o), ir("n1", t, e, Qi, -n, -r, s), ir("n2", t, e, Qi, n, -r, s), ir("n3", t, e, Qi, -n, r, s), ir("n4", t, e, Qi, n, r, s), ir("f1", t, e, Qi, -n, -r, o), ir("f2", t, e, Qi, n, -r, o), ir("f3", t, e, Qi, -n, r, o), ir("f4", t, e, Qi, n, r, o), ir("u1", t, e, Qi, n * 0.7, r * 1.1, s), ir("u2", t, e, Qi, -n * 0.7, r * 1.1, s), ir("u3", t, e, Qi, 0, r * 2, s), ir("cf1", t, e, Qi, -n, 0, o), ir("cf2", t, e, Qi, n, 0, o), ir("cf3", t, e, Qi, 0, -r, o), ir("cf4", t, e, Qi, 0, r, o), ir("cn1", t, e, Qi, -n, 0, s), ir("cn2", t, e, Qi, n, 0, s), ir("cn3", t, e, Qi, 0, -r, s), ir("cn4", t, e, Qi, 0, r, s), e.getAttribute("position").needsUpdate = !0;
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   */
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function ir(i, e, t, n, r, s, o) {
  qm.set(r, s, o).unproject(n);
  const a = e[i];
  if (a !== void 0) {
    const l = t.getAttribute("position");
    for (let u = 0, c = a.length; u < c; u++)
      l.setXYZ(a[u], qm.x, qm.y, qm.z);
  }
}
const Hm = /* @__PURE__ */ new dr();
class T9 extends Qo {
  /**
   * Constructs a new box helper.
   *
   * @param {Object3D} [object] - The 3D object to show the world-axis-aligned bounding box.
   * @param {number|Color|string} [color=0xffff00] - The box's color.
   */
  constructor(e, t = 16776960) {
    const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), r = new Float32Array(24), s = new Yt();
    s.setIndex(new Dn(n, 1)), s.setAttribute("position", new Dn(r, 3)), super(s, new br({ color: t, toneMapped: !1 })), this.object = e, this.type = "BoxHelper", this.matrixAutoUpdate = !1, this.update();
  }
  /**
   * Updates the helper's geometry to match the dimensions of the object,
   * including any children.
   */
  update() {
    if (this.object !== void 0 && Hm.setFromObject(this.object), Hm.isEmpty()) return;
    const e = Hm.min, t = Hm.max, n = this.geometry.attributes.position, r = n.array;
    r[0] = t.x, r[1] = t.y, r[2] = t.z, r[3] = e.x, r[4] = t.y, r[5] = t.z, r[6] = e.x, r[7] = e.y, r[8] = t.z, r[9] = t.x, r[10] = e.y, r[11] = t.z, r[12] = t.x, r[13] = t.y, r[14] = e.z, r[15] = e.x, r[16] = t.y, r[17] = e.z, r[18] = e.x, r[19] = e.y, r[20] = e.z, r[21] = t.x, r[22] = e.y, r[23] = e.z, n.needsUpdate = !0, this.geometry.computeBoundingSphere();
  }
  /**
   * Updates the wireframe box for the passed object.
   *
   * @param {Object3D} object - The 3D object to create the helper for.
   * @return {BoxHelper} A reference to this instance.
   */
  setFromObject(e) {
    return this.object = e, this.update(), this;
  }
  copy(e, t) {
    return super.copy(e, t), this.object = e.object, this;
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   */
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class w9 extends Qo {
  /**
   * Constructs a new box3 helper.
   *
   * @param {Box3} box - The box to visualize.
   * @param {number|Color|string} [color=0xffff00] - The box's color.
   */
  constructor(e, t = 16776960) {
    const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), r = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], s = new Yt();
    s.setIndex(new Dn(n, 1)), s.setAttribute("position", new xt(r, 3)), super(s, new br({ color: t, toneMapped: !1 })), this.box = e, this.type = "Box3Helper", this.geometry.computeBoundingSphere();
  }
  updateMatrixWorld(e) {
    const t = this.box;
    t.isEmpty() || (t.getCenter(this.position), t.getSize(this.scale), this.scale.multiplyScalar(0.5), super.updateMatrixWorld(e));
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   */
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class M9 extends va {
  /**
   * Constructs a new plane helper.
   *
   * @param {Plane} plane - The plane to be visualized.
   * @param {number} [size=1] - The side length of plane helper.
   * @param {number|Color|string} [hex=0xffff00] - The helper's color.
   */
  constructor(e, t = 1, n = 16776960) {
    const r = n, s = [1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], o = new Yt();
    o.setAttribute("position", new xt(s, 3)), o.computeBoundingSphere(), super(o, new br({ color: r, toneMapped: !1 })), this.type = "PlaneHelper", this.plane = e, this.size = t;
    const a = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], l = new Yt();
    l.setAttribute("position", new xt(a, 3)), l.computeBoundingSphere(), this.add(new Tn(l, new Nr({ color: r, opacity: 0.2, transparent: !0, depthWrite: !1, toneMapped: !1 })));
  }
  updateMatrixWorld(e) {
    this.position.set(0, 0, 0), this.scale.set(0.5 * this.size, 0.5 * this.size, 1), this.lookAt(this.plane.normal), this.translateZ(-this.plane.constant), super.updateMatrixWorld(e);
  }
  /**
   * Updates the helper to match the position and direction of the
   * light being visualized.
   */
  dispose() {
    this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
}
const mE = /* @__PURE__ */ new j();
let Wm, by;
class E9 extends Vn {
  /**
   * Constructs a new arrow helper.
   *
   * @param {Vector3} [dir=(0, 0, 1)] - The (normalized) direction vector.
   * @param {Vector3} [origin=(0, 0, 0)] - Point at which the arrow starts.
   * @param {number} [length=1] - Length of the arrow in world units.
   * @param {(number|Color|string)} [color=0xffff00] - Color of the arrow.
   * @param {number} [headLength=length*0.2] - The length of the head of the arrow.
   * @param {number} [headWidth=headLength*0.2] - The width of the head of the arrow.
   */
  constructor(e = new j(0, 0, 1), t = new j(0, 0, 0), n = 1, r = 16776960, s = n * 0.2, o = s * 0.2) {
    super(), this.type = "ArrowHelper", Wm === void 0 && (Wm = new Yt(), Wm.setAttribute("position", new xt([0, 0, 0, 0, 1, 0], 3)), by = new T0(0.5, 1, 5, 1), by.translate(0, -0.5, 0)), this.position.copy(t), this.line = new va(Wm, new br({ color: r, toneMapped: !1 })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new Tn(by, new Nr({ color: r, toneMapped: !1 })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(e), this.setLength(n, s, o);
  }
  /**
   * Sets the direction of the helper.
   *
   * @param {Vector3} dir - The normalized direction vector.
   */
  setDirection(e) {
    if (e.y > 0.99999)
      this.quaternion.set(0, 0, 0, 1);
    else if (e.y < -0.99999)
      this.quaternion.set(1, 0, 0, 0);
    else {
      mE.set(e.z, 0, -e.x).normalize();
      const t = Math.acos(e.y);
      this.quaternion.setFromAxisAngle(mE, t);
    }
  }
  /**
   * Sets the length of the helper.
   *
   * @param {number} length - Length of the arrow in world units.
   * @param {number} [headLength=length*0.2] - The length of the head of the arrow.
   * @param {number} [headWidth=headLength*0.2] - The width of the head of the arrow.
   */
  setLength(e, t = e * 0.2, n = t * 0.2) {
    this.line.scale.set(1, Math.max(1e-4, e - t), 1), this.line.updateMatrix(), this.cone.scale.set(n, t, n), this.cone.position.y = e, this.cone.updateMatrix();
  }
  /**
   * Sets the color of the helper.
   *
   * @param {number|Color|string} color - The color to set.
   */
  setColor(e) {
    this.line.material.color.set(e), this.cone.material.color.set(e);
  }
  copy(e) {
    return super.copy(e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this;
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   */
  dispose() {
    this.line.geometry.dispose(), this.line.material.dispose(), this.cone.geometry.dispose(), this.cone.material.dispose();
  }
}
class R9 extends Qo {
  /**
   * Constructs a new axes helper.
   *
   * @param {number} [size=1] - Size of the lines representing the axes.
   */
  constructor(e = 1) {
    const t = [
      0,
      0,
      0,
      e,
      0,
      0,
      0,
      0,
      0,
      0,
      e,
      0,
      0,
      0,
      0,
      0,
      0,
      e
    ], n = [
      1,
      0,
      0,
      1,
      0.6,
      0,
      0,
      1,
      0,
      0.6,
      1,
      0,
      0,
      0,
      1,
      0,
      0.6,
      1
    ], r = new Yt();
    r.setAttribute("position", new xt(t, 3)), r.setAttribute("color", new xt(n, 3));
    const s = new br({ vertexColors: !0, toneMapped: !1 });
    super(r, s), this.type = "AxesHelper";
  }
  /**
   * Defines the colors of the axes helper.
   *
   * @param {number|Color|string} xAxisColor - The color for the x axis.
   * @param {number|Color|string} yAxisColor - The color for the y axis.
   * @param {number|Color|string} zAxisColor - The color for the z axis.
   * @return {AxesHelper} A reference to this axes helper.
   */
  setColors(e, t, n) {
    const r = new ct(), s = this.geometry.attributes.color.array;
    return r.set(e), r.toArray(s, 0), r.toArray(s, 3), r.set(t), r.toArray(s, 6), r.toArray(s, 9), r.set(n), r.toArray(s, 12), r.toArray(s, 15), this.geometry.attributes.color.needsUpdate = !0, this;
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   */
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class S8 {
  /**
   * Constructs a new shape path.
   */
  constructor() {
    this.type = "ShapePath", this.color = new ct(), this.subPaths = [], this.currentPath = null;
  }
  /**
   * Creates a new path and moves it current point to the given one.
   *
   * @param {number} x - The x coordinate.
   * @param {number} y - The y coordinate.
   * @return {ShapePath} A reference to this shape path.
   */
  moveTo(e, t) {
    return this.currentPath = new x1(), this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t), this;
  }
  /**
   * Adds an instance of {@link LineCurve} to the path by connecting
   * the current point with the given one.
   *
   * @param {number} x - The x coordinate of the end point.
   * @param {number} y - The y coordinate of the end point.
   * @return {ShapePath} A reference to this shape path.
   */
  lineTo(e, t) {
    return this.currentPath.lineTo(e, t), this;
  }
  /**
   * Adds an instance of {@link QuadraticBezierCurve} to the path by connecting
   * the current point with the given one.
   *
   * @param {number} aCPx - The x coordinate of the control point.
   * @param {number} aCPy - The y coordinate of the control point.
   * @param {number} aX - The x coordinate of the end point.
   * @param {number} aY - The y coordinate of the end point.
   * @return {ShapePath} A reference to this shape path.
   */
  quadraticCurveTo(e, t, n, r) {
    return this.currentPath.quadraticCurveTo(e, t, n, r), this;
  }
  /**
   * Adds an instance of {@link CubicBezierCurve} to the path by connecting
   * the current point with the given one.
   *
   * @param {number} aCP1x - The x coordinate of the first control point.
   * @param {number} aCP1y - The y coordinate of the first control point.
   * @param {number} aCP2x - The x coordinate of the second control point.
   * @param {number} aCP2y - The y coordinate of the second control point.
   * @param {number} aX - The x coordinate of the end point.
   * @param {number} aY - The y coordinate of the end point.
   * @return {ShapePath} A reference to this shape path.
   */
  bezierCurveTo(e, t, n, r, s, o) {
    return this.currentPath.bezierCurveTo(e, t, n, r, s, o), this;
  }
  /**
   * Adds an instance of {@link SplineCurve} to the path by connecting
   * the current point with the given list of points.
   *
   * @param {Array<Vector2>} pts - An array of points in 2D space.
   * @return {ShapePath} A reference to this shape path.
   */
  splineThru(e) {
    return this.currentPath.splineThru(e), this;
  }
  /**
   * Converts the paths into an array of shapes.
   *
   * @param {boolean} isCCW - By default solid shapes are  defined clockwise (CW) and holes are defined counterclockwise (CCW).
   * If this flag is set to `true`, then those are flipped.
   * @return {Array<Shape>} An array of shapes.
   */
  toShapes(e) {
    function t(S) {
      const E = [];
      for (let R = 0, C = S.length; R < C; R++) {
        const L = S[R], D = new lh();
        D.curves = L.curves, E.push(D);
      }
      return E;
    }
    function n(S, E) {
      const R = E.length;
      let C = !1;
      for (let L = R - 1, D = 0; D < R; L = D++) {
        let B = E[L], U = E[D], N = U.x - B.x, O = U.y - B.y;
        if (Math.abs(O) > Number.EPSILON) {
          if (O < 0 && (B = E[D], N = -N, U = E[L], O = -O), S.y < B.y || S.y > U.y) continue;
          if (S.y === B.y) {
            if (S.x === B.x) return !0;
          } else {
            const G = O * (S.x - B.x) - N * (S.y - B.y);
            if (G === 0) return !0;
            if (G < 0) continue;
            C = !C;
          }
        } else {
          if (S.y !== B.y) continue;
          if (U.x <= S.x && S.x <= B.x || B.x <= S.x && S.x <= U.x) return !0;
        }
      }
      return C;
    }
    const r = ma.isClockWise, s = this.subPaths;
    if (s.length === 0) return [];
    let o, a, l;
    const u = [];
    if (s.length === 1)
      return a = s[0], l = new lh(), l.curves = a.curves, u.push(l), u;
    let c = !r(s[0].getPoints());
    c = e ? !c : c;
    const A = [], m = [];
    let _ = [], y = 0, T;
    m[y] = void 0, _[y] = [];
    for (let S = 0, E = s.length; S < E; S++)
      a = s[S], T = a.getPoints(), o = r(T), o = e ? !o : o, o ? (!c && m[y] && y++, m[y] = { s: new lh(), p: T }, m[y].s.curves = a.curves, c && y++, _[y] = []) : _[y].push({ h: a, p: T[0] });
    if (!m[0]) return t(s);
    if (m.length > 1) {
      let S = !1, E = 0;
      for (let R = 0, C = m.length; R < C; R++)
        A[R] = [];
      for (let R = 0, C = m.length; R < C; R++) {
        const L = _[R];
        for (let D = 0; D < L.length; D++) {
          const B = L[D];
          let U = !0;
          for (let N = 0; N < m.length; N++)
            n(B.p, m[N].p) && (R !== N && E++, U ? (U = !1, A[N].push(B)) : S = !0);
          U && A[R].push(B);
        }
      }
      E > 0 && S === !1 && (_ = A);
    }
    let b;
    for (let S = 0, E = m.length; S < E; S++) {
      l = m[S].s, u.push(l), b = _[S];
      for (let R = 0, C = b.length; R < C; R++)
        l.holes.push(b[R].h);
    }
    return u;
  }
}
class x2 extends lo {
  /**
   * Constructs a new controls instance.
   *
   * @param {Object3D} object - The object that is managed by the controls.
   * @param {?HTMLElement} domElement - The HTML element used for event listeners.
   */
  constructor(e, t = null) {
    super(), this.object = e, this.domElement = t, this.enabled = !0, this.state = -1, this.keys = {}, this.mouseButtons = { LEFT: null, MIDDLE: null, RIGHT: null }, this.touches = { ONE: null, TWO: null };
  }
  /**
   * Connects the controls to the DOM. This method has so called "side effects" since
   * it adds the module's event listeners to the DOM.
   *
   * @param {HTMLElement} element - The DOM element to connect to.
   */
  connect(e) {
    if (e === void 0) {
      Me("Controls: connect() now requires an element.");
      return;
    }
    this.domElement !== null && this.disconnect(), this.domElement = e;
  }
  /**
   * Disconnects the controls from the DOM.
   */
  disconnect() {
  }
  /**
   * Call this method if you no longer want use to the controls. It frees all internal
   * resources and removes all event listeners.
   */
  dispose() {
  }
  /**
   * Controls should implement this method if they have to update their internal state
   * per simulation step.
   *
   * @param {number} [delta] - The time delta in seconds.
   */
  update() {
  }
}
function C9(i, e) {
  const t = i.image && i.image.width ? i.image.width / i.image.height : 1;
  return t > e ? (i.repeat.x = 1, i.repeat.y = t / e, i.offset.x = 0, i.offset.y = (1 - i.repeat.y) / 2) : (i.repeat.x = e / t, i.repeat.y = 1, i.offset.x = (1 - i.repeat.x) / 2, i.offset.y = 0), i;
}
function P9(i, e) {
  const t = i.image && i.image.width ? i.image.width / i.image.height : 1;
  return t > e ? (i.repeat.x = e / t, i.repeat.y = 1, i.offset.x = (1 - i.repeat.x) / 2, i.offset.y = 0) : (i.repeat.x = 1, i.repeat.y = t / e, i.offset.x = 0, i.offset.y = (1 - i.repeat.y) / 2), i;
}
function N9(i) {
  return i.repeat.x = 1, i.repeat.y = 1, i.offset.x = 0, i.offset.y = 0, i;
}
function y1(i, e, t, n) {
  const r = D9(n);
  switch (t) {
    // https://registry.khronos.org/OpenGL-Refpages/es3.0/html/glTexImage2D.xhtml
    case k_:
      return i * e;
    case Yh:
      return i * e / r.components * r.byteLength;
    case Zu:
      return i * e / r.components * r.byteLength;
    case fs:
      return i * e * 2 / r.components * r.byteLength;
    case Qh:
      return i * e * 2 / r.components * r.byteLength;
    case nA:
      return i * e * 3 / r.components * r.byteLength;
    case Pi:
      return i * e * 4 / r.components * r.byteLength;
    case Kh:
      return i * e * 4 / r.components * r.byteLength;
    // https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_s3tc_srgb/
    case Rl:
    case Cl:
      return Math.floor((i + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case Pl:
    case Nl:
      return Math.floor((i + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    // https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_pvrtc/
    case If:
    case Ff:
      return Math.max(i, 16) * Math.max(e, 8) / 4;
    case Lf:
    case Bf:
      return Math.max(i, 8) * Math.max(e, 8) / 2;
    // https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_etc/
    case mh:
    case gh:
    case xh:
    case yh:
      return Math.floor((i + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case _h:
    case qu:
    case vh:
      return Math.floor((i + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    // https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_astc/
    case bh:
      return Math.floor((i + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case Sh:
      return Math.floor((i + 4) / 5) * Math.floor((e + 3) / 4) * 16;
    case Th:
      return Math.floor((i + 4) / 5) * Math.floor((e + 4) / 5) * 16;
    case wh:
      return Math.floor((i + 5) / 6) * Math.floor((e + 4) / 5) * 16;
    case Mh:
      return Math.floor((i + 5) / 6) * Math.floor((e + 5) / 6) * 16;
    case Eh:
      return Math.floor((i + 7) / 8) * Math.floor((e + 4) / 5) * 16;
    case Rh:
      return Math.floor((i + 7) / 8) * Math.floor((e + 5) / 6) * 16;
    case Ch:
      return Math.floor((i + 7) / 8) * Math.floor((e + 7) / 8) * 16;
    case Ph:
      return Math.floor((i + 9) / 10) * Math.floor((e + 4) / 5) * 16;
    case Nh:
      return Math.floor((i + 9) / 10) * Math.floor((e + 5) / 6) * 16;
    case Dh:
      return Math.floor((i + 9) / 10) * Math.floor((e + 7) / 8) * 16;
    case Lh:
      return Math.floor((i + 9) / 10) * Math.floor((e + 9) / 10) * 16;
    case Ih:
      return Math.floor((i + 11) / 12) * Math.floor((e + 9) / 10) * 16;
    case Bh:
      return Math.floor((i + 11) / 12) * Math.floor((e + 11) / 12) * 16;
    // https://registry.khronos.org/webgl/extensions/EXT_texture_compression_bptc/
    case Fh:
    case d1:
    case f1:
      return Math.ceil(i / 4) * Math.ceil(e / 4) * 16;
    // https://registry.khronos.org/webgl/extensions/EXT_texture_compression_rgtc/
    case Uh:
    case Oh:
      return Math.ceil(i / 4) * Math.ceil(e / 4) * 8;
    case Hu:
    case kh:
      return Math.ceil(i / 4) * Math.ceil(e / 4) * 16;
  }
  throw new Error(
    `Unable to determine texture byte length for ${t} format.`
  );
}
function D9(i) {
  switch (i) {
    case Mi:
    case Ou:
      return { byteLength: 1, components: 1 };
    case Oo:
    case ku:
    case Ri:
      return { byteLength: 2, components: 1 };
    case m0:
    case g0:
      return { byteLength: 2, components: 4 };
    case Jn:
    case _r:
    case Ei:
      return { byteLength: 4, components: 1 };
    case _0:
    case x0:
      return { byteLength: 4, components: 3 };
  }
  throw new Error(`Unknown texture type ${i}.`);
}
class L9 {
  /**
   * Scales the texture as large as possible within its surface without cropping
   * or stretching the texture. The method preserves the original aspect ratio of
   * the texture. Akin to CSS `object-fit: contain`
   *
   * @param {Texture} texture - The texture.
   * @param {number} aspect - The texture's aspect ratio.
   * @return {Texture} The updated texture.
   */
  static contain(e, t) {
    return C9(e, t);
  }
  /**
   * Scales the texture to the smallest possible size to fill the surface, leaving
   * no empty space. The method preserves the original aspect ratio of the texture.
   * Akin to CSS `object-fit: cover`.
   *
   * @param {Texture} texture - The texture.
   * @param {number} aspect - The texture's aspect ratio.
   * @return {Texture} The updated texture.
   */
  static cover(e, t) {
    return P9(e, t);
  }
  /**
   * Configures the texture to the default transformation. Akin to CSS `object-fit: fill`.
   *
   * @param {Texture} texture - The texture.
   * @return {Texture} The updated texture.
   */
  static fill(e) {
    return N9(e);
  }
  /**
   * Determines how many bytes must be used to represent the texture.
   *
   * @param {number} width - The width of the texture.
   * @param {number} height - The height of the texture.
   * @param {number} format - The texture's format.
   * @param {number} type - The texture's type.
   * @return {number} The byte length.
   */
  static getByteLength(e, t, n, r) {
    return y1(e, t, n, r);
  }
}
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {
  revision: Ku
} }));
typeof window < "u" && (window.__THREE__ ? Me("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = Ku);
function T8() {
  let i = null, e = !1, t = null, n = null;
  function r(s, o) {
    t(s, o), n = i.requestAnimationFrame(r);
  }
  return {
    start: function() {
      e !== !0 && t !== null && (n = i.requestAnimationFrame(r), e = !0);
    },
    stop: function() {
      i.cancelAnimationFrame(n), e = !1;
    },
    setAnimationLoop: function(s) {
      t = s;
    },
    setContext: function(s) {
      i = s;
    }
  };
}
function I9(i) {
  const e = /* @__PURE__ */ new WeakMap();
  function t(a, l) {
    const u = a.array, c = a.usage, A = u.byteLength, m = i.createBuffer();
    i.bindBuffer(l, m), i.bufferData(l, u, c), a.onUploadCallback();
    let _;
    if (u instanceof Float32Array)
      _ = i.FLOAT;
    else if (typeof Float16Array < "u" && u instanceof Float16Array)
      _ = i.HALF_FLOAT;
    else if (u instanceof Uint16Array)
      a.isFloat16BufferAttribute ? _ = i.HALF_FLOAT : _ = i.UNSIGNED_SHORT;
    else if (u instanceof Int16Array)
      _ = i.SHORT;
    else if (u instanceof Uint32Array)
      _ = i.UNSIGNED_INT;
    else if (u instanceof Int32Array)
      _ = i.INT;
    else if (u instanceof Int8Array)
      _ = i.BYTE;
    else if (u instanceof Uint8Array)
      _ = i.UNSIGNED_BYTE;
    else if (u instanceof Uint8ClampedArray)
      _ = i.UNSIGNED_BYTE;
    else
      throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + u);
    return {
      buffer: m,
      type: _,
      bytesPerElement: u.BYTES_PER_ELEMENT,
      version: a.version,
      size: A
    };
  }
  function n(a, l, u) {
    const c = l.array, A = l.updateRanges;
    if (i.bindBuffer(u, a), A.length === 0)
      i.bufferSubData(u, 0, c);
    else {
      A.sort((_, y) => _.start - y.start);
      let m = 0;
      for (let _ = 1; _ < A.length; _++) {
        const y = A[m], T = A[_];
        T.start <= y.start + y.count + 1 ? y.count = Math.max(
          y.count,
          T.start + T.count - y.start
        ) : (++m, A[m] = T);
      }
      A.length = m + 1;
      for (let _ = 0, y = A.length; _ < y; _++) {
        const T = A[_];
        i.bufferSubData(
          u,
          T.start * c.BYTES_PER_ELEMENT,
          c,
          T.start,
          T.count
        );
      }
      l.clearUpdateRanges();
    }
    l.onUploadCallback();
  }
  function r(a) {
    return a.isInterleavedBufferAttribute && (a = a.data), e.get(a);
  }
  function s(a) {
    a.isInterleavedBufferAttribute && (a = a.data);
    const l = e.get(a);
    l && (i.deleteBuffer(l.buffer), e.delete(a));
  }
  function o(a, l) {
    if (a.isInterleavedBufferAttribute && (a = a.data), a.isGLBufferAttribute) {
      const c = e.get(a);
      (!c || c.version < a.version) && e.set(a, {
        buffer: a.buffer,
        type: a.type,
        bytesPerElement: a.elementSize,
        version: a.version
      });
      return;
    }
    const u = e.get(a);
    if (u === void 0)
      e.set(a, t(a, l));
    else if (u.version < a.version) {
      if (u.size !== a.array.byteLength)
        throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
      n(u.buffer, a, l), u.version = a.version;
    }
  }
  return {
    get: r,
    remove: s,
    update: o
  };
}
var B9 = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`, F9 = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`, U9 = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`, O9 = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, k9 = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`, V9 = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`, G9 = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT )
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN )
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`, z9 = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`, q9 = `#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`, H9 = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`, W9 = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`, $9 = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`, j9 = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`, X9 = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`, Y9 = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`, Q9 = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`, K9 = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`, Z9 = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`, J9 = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`, ek = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`, tk = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`, nk = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`, ik = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`, rk = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`, sk = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`, ok = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`, ak = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`, lk = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`, uk = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE
		emissiveColor = sRGBTransferEOTF( emissiveColor );
	#endif
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`, ck = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`, hk = "gl_FragColor = linearToOutputTexel( gl_FragColor );", dk = `vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferEOTF( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`, fk = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`, Ak = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
#endif`, pk = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`, mk = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS

		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`, gk = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`, _k = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`, xk = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`, yk = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`, vk = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`, bk = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`, Sk = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`, Tk = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`, wk = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`, Mk = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`, Ek = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, pow4( roughness ) ) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`, Rk = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`, Ck = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`, Pk = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`, Nk = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`, Dk = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.diffuseContribution = diffuseColor.rgb * ( 1.0 - metalnessFactor );
material.metalness = metalnessFactor;
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor;
	material.specularColorBlended = mix( material.specularColor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = vec3( 0.04 );
	material.specularColorBlended = mix( material.specularColor, diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.0001, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`, Lk = `uniform sampler2D dfgLUT;
struct PhysicalMaterial {
	vec3 diffuseColor;
	vec3 diffuseContribution;
	vec3 specularColor;
	vec3 specularColorBlended;
	float roughness;
	float metalness;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
		vec3 iridescenceFresnelDielectric;
		vec3 iridescenceFresnelMetallic;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return v;
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColorBlended;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transpose( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float rInv = 1.0 / ( roughness + 0.1 );
	float a = -1.9362 + 1.0678 * roughness + 0.4573 * r2 - 0.8469 * rInv;
	float b = -0.6014 + 0.5538 * roughness - 0.4670 * r2 - 0.1255 * rInv;
	float DG = exp( a * dotNV + b );
	return saturate( DG );
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	vec2 fab = texture2D( dfgLUT, vec2( roughness, dotNV ) ).rg;
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	float dotNV = saturate( dot( normal, viewDir ) );
	vec2 fab = texture2D( dfgLUT, vec2( roughness, dotNV ) ).rg;
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
vec3 BRDF_GGX_Multiscatter( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 singleScatter = BRDF_GGX( lightDir, viewDir, normal, material );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	vec2 dfgV = texture2D( dfgLUT, vec2( material.roughness, dotNV ) ).rg;
	vec2 dfgL = texture2D( dfgLUT, vec2( material.roughness, dotNL ) ).rg;
	vec3 FssEss_V = material.specularColorBlended * dfgV.x + material.specularF90 * dfgV.y;
	vec3 FssEss_L = material.specularColorBlended * dfgL.x + material.specularF90 * dfgL.y;
	float Ess_V = dfgV.x + dfgV.y;
	float Ess_L = dfgL.x + dfgL.y;
	float Ems_V = 1.0 - Ess_V;
	float Ems_L = 1.0 - Ess_L;
	vec3 Favg = material.specularColorBlended + ( 1.0 - material.specularColorBlended ) * 0.047619;
	vec3 Fms = FssEss_V * FssEss_L * Favg / ( 1.0 - Ems_V * Ems_L * Favg + EPSILON );
	float compensationFactor = Ems_V * Ems_L;
	vec3 multiScatter = Fms * compensationFactor;
	return singleScatter + multiScatter;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColorBlended * t2.x + ( vec3( 1.0 ) - material.specularColorBlended ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseContribution * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN

 		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );

 		float sheenAlbedoV = IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
 		float sheenAlbedoL = IBLSheenBRDF( geometryNormal, directLight.direction, material.sheenRoughness );

 		float sheenEnergyComp = 1.0 - max3( material.sheenColor ) * max( sheenAlbedoV, sheenAlbedoL );

 		irradiance *= sheenEnergyComp;

 	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX_Multiscatter( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseContribution );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 diffuse = irradiance * BRDF_Lambert( material.diffuseContribution );
	#ifdef USE_SHEEN
		float sheenAlbedo = IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
		float sheenEnergyComp = 1.0 - max3( material.sheenColor ) * sheenAlbedo;
		diffuse *= sheenEnergyComp;
	#endif
	reflectedLight.indirectDiffuse += diffuse;
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness ) * RECIPROCAL_PI;
 	#endif
	vec3 singleScatteringDielectric = vec3( 0.0 );
	vec3 multiScatteringDielectric = vec3( 0.0 );
	vec3 singleScatteringMetallic = vec3( 0.0 );
	vec3 multiScatteringMetallic = vec3( 0.0 );
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnelDielectric, material.roughness, singleScatteringDielectric, multiScatteringDielectric );
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.diffuseColor, material.specularF90, material.iridescence, material.iridescenceFresnelMetallic, material.roughness, singleScatteringMetallic, multiScatteringMetallic );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScatteringDielectric, multiScatteringDielectric );
		computeMultiscattering( geometryNormal, geometryViewDir, material.diffuseColor, material.specularF90, material.roughness, singleScatteringMetallic, multiScatteringMetallic );
	#endif
	vec3 singleScattering = mix( singleScatteringDielectric, singleScatteringMetallic, material.metalness );
	vec3 multiScattering = mix( multiScatteringDielectric, multiScatteringMetallic, material.metalness );
	vec3 totalScatteringDielectric = singleScatteringDielectric + multiScatteringDielectric;
	vec3 diffuse = material.diffuseContribution * ( 1.0 - totalScatteringDielectric );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	vec3 indirectSpecular = radiance * singleScattering;
	indirectSpecular += multiScattering * cosineWeightedIrradiance;
	vec3 indirectDiffuse = diffuse * cosineWeightedIrradiance;
	#ifdef USE_SHEEN
		float sheenAlbedo = IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
		float sheenEnergyComp = 1.0 - max3( material.sheenColor ) * sheenAlbedo;
		indirectSpecular *= sheenEnergyComp;
		indirectDiffuse *= sheenEnergyComp;
	#endif
	reflectedLight.indirectSpecular += indirectSpecular;
	reflectedLight.indirectDiffuse += indirectDiffuse;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`, Ik = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnelDielectric = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceFresnelMetallic = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.diffuseColor );
		material.iridescenceFresnel = mix( material.iridescenceFresnelDielectric, material.iridescenceFresnelMetallic, material.metalness );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS ) && ( defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_BASIC ) )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`, Bk = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`, Fk = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`, Uk = `#if defined( USE_LOGARITHMIC_DEPTH_BUFFER )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`, Ok = `#if defined( USE_LOGARITHMIC_DEPTH_BUFFER )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, kk = `#ifdef USE_LOGARITHMIC_DEPTH_BUFFER
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, Vk = `#ifdef USE_LOGARITHMIC_DEPTH_BUFFER
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`, Gk = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`, zk = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`, qk = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`, Hk = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, Wk = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`, $k = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`, jk = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`, Xk = `#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`, Yk = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`, Qk = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`, Kk = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`, Zk = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`, Jk = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`, eV = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, tV = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, nV = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`, iV = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`, rV = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`, sV = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`, oV = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`, aV = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`, lV = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`, uV = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`, cV = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`, hV = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`, dV = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`, fV = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`, AV = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`, pV = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`, mV = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#if defined( SHADOWMAP_TYPE_PCF )
			uniform sampler2DShadow directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		#else
			uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		#endif
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		#if defined( SHADOWMAP_TYPE_PCF )
			uniform sampler2DShadow spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		#else
			uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		#endif
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#if defined( SHADOWMAP_TYPE_PCF )
			uniform samplerCubeShadow pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		#elif defined( SHADOWMAP_TYPE_BASIC )
			uniform samplerCube pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		#endif
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	#if defined( SHADOWMAP_TYPE_PCF )
		float interleavedGradientNoise( vec2 position ) {
			return fract( 52.9829189 * fract( dot( position, vec2( 0.06711056, 0.00583715 ) ) ) );
		}
		vec2 vogelDiskSample( int sampleIndex, int samplesCount, float phi ) {
			const float goldenAngle = 2.399963229728653;
			float r = sqrt( ( float( sampleIndex ) + 0.5 ) / float( samplesCount ) );
			float theta = float( sampleIndex ) * goldenAngle + phi;
			return vec2( cos( theta ), sin( theta ) ) * r;
		}
	#endif
	#if defined( SHADOWMAP_TYPE_PCF )
		float getShadow( sampler2DShadow shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
			float shadow = 1.0;
			shadowCoord.xyz /= shadowCoord.w;
			shadowCoord.z += shadowBias;
			bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
			bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
			if ( frustumTest ) {
				vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
				float radius = shadowRadius * texelSize.x;
				float phi = interleavedGradientNoise( gl_FragCoord.xy ) * 6.28318530718;
				shadow = (
					texture( shadowMap, vec3( shadowCoord.xy + vogelDiskSample( 0, 5, phi ) * radius, shadowCoord.z ) ) +
					texture( shadowMap, vec3( shadowCoord.xy + vogelDiskSample( 1, 5, phi ) * radius, shadowCoord.z ) ) +
					texture( shadowMap, vec3( shadowCoord.xy + vogelDiskSample( 2, 5, phi ) * radius, shadowCoord.z ) ) +
					texture( shadowMap, vec3( shadowCoord.xy + vogelDiskSample( 3, 5, phi ) * radius, shadowCoord.z ) ) +
					texture( shadowMap, vec3( shadowCoord.xy + vogelDiskSample( 4, 5, phi ) * radius, shadowCoord.z ) )
				) * 0.2;
			}
			return mix( 1.0, shadow, shadowIntensity );
		}
	#elif defined( SHADOWMAP_TYPE_VSM )
		float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
			float shadow = 1.0;
			shadowCoord.xyz /= shadowCoord.w;
			shadowCoord.z += shadowBias;
			bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
			bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
			if ( frustumTest ) {
				vec2 distribution = texture2D( shadowMap, shadowCoord.xy ).rg;
				float mean = distribution.x;
				float variance = distribution.y * distribution.y;
				#ifdef USE_REVERSED_DEPTH_BUFFER
					float hard_shadow = step( mean, shadowCoord.z );
				#else
					float hard_shadow = step( shadowCoord.z, mean );
				#endif
				if ( hard_shadow == 1.0 ) {
					shadow = 1.0;
				} else {
					variance = max( variance, 0.0000001 );
					float d = shadowCoord.z - mean;
					float p_max = variance / ( variance + d * d );
					p_max = clamp( ( p_max - 0.3 ) / 0.65, 0.0, 1.0 );
					shadow = max( hard_shadow, p_max );
				}
			}
			return mix( 1.0, shadow, shadowIntensity );
		}
	#else
		float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
			float shadow = 1.0;
			shadowCoord.xyz /= shadowCoord.w;
			shadowCoord.z += shadowBias;
			bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
			bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
			if ( frustumTest ) {
				float depth = texture2D( shadowMap, shadowCoord.xy ).r;
				#ifdef USE_REVERSED_DEPTH_BUFFER
					shadow = step( depth, shadowCoord.z );
				#else
					shadow = step( shadowCoord.z, depth );
				#endif
			}
			return mix( 1.0, shadow, shadowIntensity );
		}
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#if defined( SHADOWMAP_TYPE_PCF )
	float getPointShadow( samplerCubeShadow shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		vec3 bd3D = normalize( lightToPosition );
		vec3 absVec = abs( lightToPosition );
		float viewSpaceZ = max( max( absVec.x, absVec.y ), absVec.z );
		if ( viewSpaceZ - shadowCameraFar <= 0.0 && viewSpaceZ - shadowCameraNear >= 0.0 ) {
			float dp = ( shadowCameraFar * ( viewSpaceZ - shadowCameraNear ) ) / ( viewSpaceZ * ( shadowCameraFar - shadowCameraNear ) );
			dp += shadowBias;
			float texelSize = shadowRadius / shadowMapSize.x;
			vec3 absDir = abs( bd3D );
			vec3 tangent = absDir.x > absDir.z ? vec3( 0.0, 1.0, 0.0 ) : vec3( 1.0, 0.0, 0.0 );
			tangent = normalize( cross( bd3D, tangent ) );
			vec3 bitangent = cross( bd3D, tangent );
			float phi = interleavedGradientNoise( gl_FragCoord.xy ) * 6.28318530718;
			shadow = (
				texture( shadowMap, vec4( bd3D + ( tangent * vogelDiskSample( 0, 5, phi ).x + bitangent * vogelDiskSample( 0, 5, phi ).y ) * texelSize, dp ) ) +
				texture( shadowMap, vec4( bd3D + ( tangent * vogelDiskSample( 1, 5, phi ).x + bitangent * vogelDiskSample( 1, 5, phi ).y ) * texelSize, dp ) ) +
				texture( shadowMap, vec4( bd3D + ( tangent * vogelDiskSample( 2, 5, phi ).x + bitangent * vogelDiskSample( 2, 5, phi ).y ) * texelSize, dp ) ) +
				texture( shadowMap, vec4( bd3D + ( tangent * vogelDiskSample( 3, 5, phi ).x + bitangent * vogelDiskSample( 3, 5, phi ).y ) * texelSize, dp ) ) +
				texture( shadowMap, vec4( bd3D + ( tangent * vogelDiskSample( 4, 5, phi ).x + bitangent * vogelDiskSample( 4, 5, phi ).y ) * texelSize, dp ) )
			) * 0.2;
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	#elif defined( SHADOWMAP_TYPE_BASIC )
	float getPointShadow( samplerCube shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		vec3 bd3D = normalize( lightToPosition );
		vec3 absVec = abs( lightToPosition );
		float viewSpaceZ = max( max( absVec.x, absVec.y ), absVec.z );
		if ( viewSpaceZ - shadowCameraFar <= 0.0 && viewSpaceZ - shadowCameraNear >= 0.0 ) {
			float dp = ( shadowCameraFar * ( viewSpaceZ - shadowCameraNear ) ) / ( viewSpaceZ * ( shadowCameraFar - shadowCameraNear ) );
			dp += shadowBias;
			float depth = textureCube( shadowMap, bd3D ).r;
			#ifdef USE_REVERSED_DEPTH_BUFFER
				shadow = step( depth, dp );
			#else
				shadow = step( dp, depth );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	#endif
	#endif
#endif`, gV = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`, _V = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`, xV = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0 && ( defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_BASIC ) )
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`, yV = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`, vV = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`, bV = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`, SV = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`, TV = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`, wV = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`, MV = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`, EV = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 CineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`, RV = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseContribution, material.specularColorBlended, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`, CV = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		#else
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`, PV = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, NV = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, DV = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`, LV = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const IV = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`, BV = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, FV = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, UV = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, OV = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, kV = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, VV = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`, GV = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	#ifdef USE_REVERSED_DEPTH_BUFFER
		float fragCoordZ = vHighPrecisionZW[ 0 ] / vHighPrecisionZW[ 1 ];
	#else
		float fragCoordZ = 0.5 * vHighPrecisionZW[ 0 ] / vHighPrecisionZW[ 1 ] + 0.5;
	#endif
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`, zV = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`, qV = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = vec4( dist, 0.0, 0.0, 1.0 );
}`, HV = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`, WV = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, $V = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, jV = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, XV = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`, YV = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, QV = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, KV = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, ZV = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`, JV = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, eG = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`, tG = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( normalize( normal ) * 0.5 + 0.5, diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`, nG = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, iG = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, rG = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`, sG = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN

		outgoingLight = outgoingLight + sheenSpecularDirect + sheenSpecularIndirect;

 	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, oG = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, aG = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, lG = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`, uG = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, cG = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, hG = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, dG = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix[ 3 ];
	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, fG = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, _n = {
  alphahash_fragment: B9,
  alphahash_pars_fragment: F9,
  alphamap_fragment: U9,
  alphamap_pars_fragment: O9,
  alphatest_fragment: k9,
  alphatest_pars_fragment: V9,
  aomap_fragment: G9,
  aomap_pars_fragment: z9,
  batching_pars_vertex: q9,
  batching_vertex: H9,
  begin_vertex: W9,
  beginnormal_vertex: $9,
  bsdfs: j9,
  iridescence_fragment: X9,
  bumpmap_pars_fragment: Y9,
  clipping_planes_fragment: Q9,
  clipping_planes_pars_fragment: K9,
  clipping_planes_pars_vertex: Z9,
  clipping_planes_vertex: J9,
  color_fragment: ek,
  color_pars_fragment: tk,
  color_pars_vertex: nk,
  color_vertex: ik,
  common: rk,
  cube_uv_reflection_fragment: sk,
  defaultnormal_vertex: ok,
  displacementmap_pars_vertex: ak,
  displacementmap_vertex: lk,
  emissivemap_fragment: uk,
  emissivemap_pars_fragment: ck,
  colorspace_fragment: hk,
  colorspace_pars_fragment: dk,
  envmap_fragment: fk,
  envmap_common_pars_fragment: Ak,
  envmap_pars_fragment: pk,
  envmap_pars_vertex: mk,
  envmap_physical_pars_fragment: Ek,
  envmap_vertex: gk,
  fog_vertex: _k,
  fog_pars_vertex: xk,
  fog_fragment: yk,
  fog_pars_fragment: vk,
  gradientmap_pars_fragment: bk,
  lightmap_pars_fragment: Sk,
  lights_lambert_fragment: Tk,
  lights_lambert_pars_fragment: wk,
  lights_pars_begin: Mk,
  lights_toon_fragment: Rk,
  lights_toon_pars_fragment: Ck,
  lights_phong_fragment: Pk,
  lights_phong_pars_fragment: Nk,
  lights_physical_fragment: Dk,
  lights_physical_pars_fragment: Lk,
  lights_fragment_begin: Ik,
  lights_fragment_maps: Bk,
  lights_fragment_end: Fk,
  logdepthbuf_fragment: Uk,
  logdepthbuf_pars_fragment: Ok,
  logdepthbuf_pars_vertex: kk,
  logdepthbuf_vertex: Vk,
  map_fragment: Gk,
  map_pars_fragment: zk,
  map_particle_fragment: qk,
  map_particle_pars_fragment: Hk,
  metalnessmap_fragment: Wk,
  metalnessmap_pars_fragment: $k,
  morphinstance_vertex: jk,
  morphcolor_vertex: Xk,
  morphnormal_vertex: Yk,
  morphtarget_pars_vertex: Qk,
  morphtarget_vertex: Kk,
  normal_fragment_begin: Zk,
  normal_fragment_maps: Jk,
  normal_pars_fragment: eV,
  normal_pars_vertex: tV,
  normal_vertex: nV,
  normalmap_pars_fragment: iV,
  clearcoat_normal_fragment_begin: rV,
  clearcoat_normal_fragment_maps: sV,
  clearcoat_pars_fragment: oV,
  iridescence_pars_fragment: aV,
  opaque_fragment: lV,
  packing: uV,
  premultiplied_alpha_fragment: cV,
  project_vertex: hV,
  dithering_fragment: dV,
  dithering_pars_fragment: fV,
  roughnessmap_fragment: AV,
  roughnessmap_pars_fragment: pV,
  shadowmap_pars_fragment: mV,
  shadowmap_pars_vertex: gV,
  shadowmap_vertex: _V,
  shadowmask_pars_fragment: xV,
  skinbase_vertex: yV,
  skinning_pars_vertex: vV,
  skinning_vertex: bV,
  skinnormal_vertex: SV,
  specularmap_fragment: TV,
  specularmap_pars_fragment: wV,
  tonemapping_fragment: MV,
  tonemapping_pars_fragment: EV,
  transmission_fragment: RV,
  transmission_pars_fragment: CV,
  uv_pars_fragment: PV,
  uv_pars_vertex: NV,
  uv_vertex: DV,
  worldpos_vertex: LV,
  background_vert: IV,
  background_frag: BV,
  backgroundCube_vert: FV,
  backgroundCube_frag: UV,
  cube_vert: OV,
  cube_frag: kV,
  depth_vert: VV,
  depth_frag: GV,
  distance_vert: zV,
  distance_frag: qV,
  equirect_vert: HV,
  equirect_frag: WV,
  linedashed_vert: $V,
  linedashed_frag: jV,
  meshbasic_vert: XV,
  meshbasic_frag: YV,
  meshlambert_vert: QV,
  meshlambert_frag: KV,
  meshmatcap_vert: ZV,
  meshmatcap_frag: JV,
  meshnormal_vert: eG,
  meshnormal_frag: tG,
  meshphong_vert: nG,
  meshphong_frag: iG,
  meshphysical_vert: rG,
  meshphysical_frag: sG,
  meshtoon_vert: oG,
  meshtoon_frag: aG,
  points_vert: lG,
  points_frag: uG,
  shadow_vert: cG,
  shadow_frag: hG,
  sprite_vert: dG,
  sprite_frag: fG
}, gt = {
  common: {
    diffuse: { value: /* @__PURE__ */ new ct(16777215) },
    opacity: { value: 1 },
    map: { value: null },
    mapTransform: { value: /* @__PURE__ */ new fn() },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new fn() },
    alphaTest: { value: 0 }
  },
  specularmap: {
    specularMap: { value: null },
    specularMapTransform: { value: /* @__PURE__ */ new fn() }
  },
  envmap: {
    envMap: { value: null },
    envMapRotation: { value: /* @__PURE__ */ new fn() },
    flipEnvMap: { value: -1 },
    reflectivity: { value: 1 },
    // basic, lambert, phong
    ior: { value: 1.5 },
    // physical
    refractionRatio: { value: 0.98 },
    // basic, lambert, phong
    dfgLUT: { value: null }
    // DFG LUT for physically-based rendering
  },
  aomap: {
    aoMap: { value: null },
    aoMapIntensity: { value: 1 },
    aoMapTransform: { value: /* @__PURE__ */ new fn() }
  },
  lightmap: {
    lightMap: { value: null },
    lightMapIntensity: { value: 1 },
    lightMapTransform: { value: /* @__PURE__ */ new fn() }
  },
  bumpmap: {
    bumpMap: { value: null },
    bumpMapTransform: { value: /* @__PURE__ */ new fn() },
    bumpScale: { value: 1 }
  },
  normalmap: {
    normalMap: { value: null },
    normalMapTransform: { value: /* @__PURE__ */ new fn() },
    normalScale: { value: /* @__PURE__ */ new Le(1, 1) }
  },
  displacementmap: {
    displacementMap: { value: null },
    displacementMapTransform: { value: /* @__PURE__ */ new fn() },
    displacementScale: { value: 1 },
    displacementBias: { value: 0 }
  },
  emissivemap: {
    emissiveMap: { value: null },
    emissiveMapTransform: { value: /* @__PURE__ */ new fn() }
  },
  metalnessmap: {
    metalnessMap: { value: null },
    metalnessMapTransform: { value: /* @__PURE__ */ new fn() }
  },
  roughnessmap: {
    roughnessMap: { value: null },
    roughnessMapTransform: { value: /* @__PURE__ */ new fn() }
  },
  gradientmap: {
    gradientMap: { value: null }
  },
  fog: {
    fogDensity: { value: 25e-5 },
    fogNear: { value: 1 },
    fogFar: { value: 2e3 },
    fogColor: { value: /* @__PURE__ */ new ct(16777215) }
  },
  lights: {
    ambientLightColor: { value: [] },
    lightProbe: { value: [] },
    directionalLights: { value: [], properties: {
      direction: {},
      color: {}
    } },
    directionalLightShadows: { value: [], properties: {
      shadowIntensity: 1,
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    directionalShadowMap: { value: [] },
    directionalShadowMatrix: { value: [] },
    spotLights: { value: [], properties: {
      color: {},
      position: {},
      direction: {},
      distance: {},
      coneCos: {},
      penumbraCos: {},
      decay: {}
    } },
    spotLightShadows: { value: [], properties: {
      shadowIntensity: 1,
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    spotLightMap: { value: [] },
    spotShadowMap: { value: [] },
    spotLightMatrix: { value: [] },
    pointLights: { value: [], properties: {
      color: {},
      position: {},
      decay: {},
      distance: {}
    } },
    pointLightShadows: { value: [], properties: {
      shadowIntensity: 1,
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {},
      shadowCameraNear: {},
      shadowCameraFar: {}
    } },
    pointShadowMap: { value: [] },
    pointShadowMatrix: { value: [] },
    hemisphereLights: { value: [], properties: {
      direction: {},
      skyColor: {},
      groundColor: {}
    } },
    // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
    rectAreaLights: { value: [], properties: {
      color: {},
      position: {},
      width: {},
      height: {}
    } },
    ltc_1: { value: null },
    ltc_2: { value: null }
  },
  points: {
    diffuse: { value: /* @__PURE__ */ new ct(16777215) },
    opacity: { value: 1 },
    size: { value: 1 },
    scale: { value: 1 },
    map: { value: null },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new fn() },
    alphaTest: { value: 0 },
    uvTransform: { value: /* @__PURE__ */ new fn() }
  },
  sprite: {
    diffuse: { value: /* @__PURE__ */ new ct(16777215) },
    opacity: { value: 1 },
    center: { value: /* @__PURE__ */ new Le(0.5, 0.5) },
    rotation: { value: 0 },
    map: { value: null },
    mapTransform: { value: /* @__PURE__ */ new fn() },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new fn() },
    alphaTest: { value: 0 }
  }
}, Es = {
  basic: {
    uniforms: /* @__PURE__ */ ws([
      gt.common,
      gt.specularmap,
      gt.envmap,
      gt.aomap,
      gt.lightmap,
      gt.fog
    ]),
    vertexShader: _n.meshbasic_vert,
    fragmentShader: _n.meshbasic_frag
  },
  lambert: {
    uniforms: /* @__PURE__ */ ws([
      gt.common,
      gt.specularmap,
      gt.envmap,
      gt.aomap,
      gt.lightmap,
      gt.emissivemap,
      gt.bumpmap,
      gt.normalmap,
      gt.displacementmap,
      gt.fog,
      gt.lights,
      {
        emissive: { value: /* @__PURE__ */ new ct(0) }
      }
    ]),
    vertexShader: _n.meshlambert_vert,
    fragmentShader: _n.meshlambert_frag
  },
  phong: {
    uniforms: /* @__PURE__ */ ws([
      gt.common,
      gt.specularmap,
      gt.envmap,
      gt.aomap,
      gt.lightmap,
      gt.emissivemap,
      gt.bumpmap,
      gt.normalmap,
      gt.displacementmap,
      gt.fog,
      gt.lights,
      {
        emissive: { value: /* @__PURE__ */ new ct(0) },
        specular: { value: /* @__PURE__ */ new ct(1118481) },
        shininess: { value: 30 }
      }
    ]),
    vertexShader: _n.meshphong_vert,
    fragmentShader: _n.meshphong_frag
  },
  standard: {
    uniforms: /* @__PURE__ */ ws([
      gt.common,
      gt.envmap,
      gt.aomap,
      gt.lightmap,
      gt.emissivemap,
      gt.bumpmap,
      gt.normalmap,
      gt.displacementmap,
      gt.roughnessmap,
      gt.metalnessmap,
      gt.fog,
      gt.lights,
      {
        emissive: { value: /* @__PURE__ */ new ct(0) },
        roughness: { value: 1 },
        metalness: { value: 0 },
        envMapIntensity: { value: 1 }
      }
    ]),
    vertexShader: _n.meshphysical_vert,
    fragmentShader: _n.meshphysical_frag
  },
  toon: {
    uniforms: /* @__PURE__ */ ws([
      gt.common,
      gt.aomap,
      gt.lightmap,
      gt.emissivemap,
      gt.bumpmap,
      gt.normalmap,
      gt.displacementmap,
      gt.gradientmap,
      gt.fog,
      gt.lights,
      {
        emissive: { value: /* @__PURE__ */ new ct(0) }
      }
    ]),
    vertexShader: _n.meshtoon_vert,
    fragmentShader: _n.meshtoon_frag
  },
  matcap: {
    uniforms: /* @__PURE__ */ ws([
      gt.common,
      gt.bumpmap,
      gt.normalmap,
      gt.displacementmap,
      gt.fog,
      {
        matcap: { value: null }
      }
    ]),
    vertexShader: _n.meshmatcap_vert,
    fragmentShader: _n.meshmatcap_frag
  },
  points: {
    uniforms: /* @__PURE__ */ ws([
      gt.points,
      gt.fog
    ]),
    vertexShader: _n.points_vert,
    fragmentShader: _n.points_frag
  },
  dashed: {
    uniforms: /* @__PURE__ */ ws([
      gt.common,
      gt.fog,
      {
        scale: { value: 1 },
        dashSize: { value: 1 },
        totalSize: { value: 2 }
      }
    ]),
    vertexShader: _n.linedashed_vert,
    fragmentShader: _n.linedashed_frag
  },
  depth: {
    uniforms: /* @__PURE__ */ ws([
      gt.common,
      gt.displacementmap
    ]),
    vertexShader: _n.depth_vert,
    fragmentShader: _n.depth_frag
  },
  normal: {
    uniforms: /* @__PURE__ */ ws([
      gt.common,
      gt.bumpmap,
      gt.normalmap,
      gt.displacementmap,
      {
        opacity: { value: 1 }
      }
    ]),
    vertexShader: _n.meshnormal_vert,
    fragmentShader: _n.meshnormal_frag
  },
  sprite: {
    uniforms: /* @__PURE__ */ ws([
      gt.sprite,
      gt.fog
    ]),
    vertexShader: _n.sprite_vert,
    fragmentShader: _n.sprite_frag
  },
  background: {
    uniforms: {
      uvTransform: { value: /* @__PURE__ */ new fn() },
      t2D: { value: null },
      backgroundIntensity: { value: 1 }
    },
    vertexShader: _n.background_vert,
    fragmentShader: _n.background_frag
  },
  backgroundCube: {
    uniforms: {
      envMap: { value: null },
      flipEnvMap: { value: -1 },
      backgroundBlurriness: { value: 0 },
      backgroundIntensity: { value: 1 },
      backgroundRotation: { value: /* @__PURE__ */ new fn() }
    },
    vertexShader: _n.backgroundCube_vert,
    fragmentShader: _n.backgroundCube_frag
  },
  cube: {
    uniforms: {
      tCube: { value: null },
      tFlip: { value: -1 },
      opacity: { value: 1 }
    },
    vertexShader: _n.cube_vert,
    fragmentShader: _n.cube_frag
  },
  equirect: {
    uniforms: {
      tEquirect: { value: null }
    },
    vertexShader: _n.equirect_vert,
    fragmentShader: _n.equirect_frag
  },
  distance: {
    uniforms: /* @__PURE__ */ ws([
      gt.common,
      gt.displacementmap,
      {
        referencePosition: { value: /* @__PURE__ */ new j() },
        nearDistance: { value: 1 },
        farDistance: { value: 1e3 }
      }
    ]),
    vertexShader: _n.distance_vert,
    fragmentShader: _n.distance_frag
  },
  shadow: {
    uniforms: /* @__PURE__ */ ws([
      gt.lights,
      gt.fog,
      {
        color: { value: /* @__PURE__ */ new ct(0) },
        opacity: { value: 1 }
      }
    ]),
    vertexShader: _n.shadow_vert,
    fragmentShader: _n.shadow_frag
  }
};
Es.physical = {
  uniforms: /* @__PURE__ */ ws([
    Es.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatMapTransform: { value: /* @__PURE__ */ new fn() },
      clearcoatNormalMap: { value: null },
      clearcoatNormalMapTransform: { value: /* @__PURE__ */ new fn() },
      clearcoatNormalScale: { value: /* @__PURE__ */ new Le(1, 1) },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatRoughnessMapTransform: { value: /* @__PURE__ */ new fn() },
      dispersion: { value: 0 },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceMapTransform: { value: /* @__PURE__ */ new fn() },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      iridescenceThicknessMapTransform: { value: /* @__PURE__ */ new fn() },
      sheen: { value: 0 },
      sheenColor: { value: /* @__PURE__ */ new ct(0) },
      sheenColorMap: { value: null },
      sheenColorMapTransform: { value: /* @__PURE__ */ new fn() },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      sheenRoughnessMapTransform: { value: /* @__PURE__ */ new fn() },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionMapTransform: { value: /* @__PURE__ */ new fn() },
      transmissionSamplerSize: { value: /* @__PURE__ */ new Le() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      thicknessMapTransform: { value: /* @__PURE__ */ new fn() },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: /* @__PURE__ */ new ct(0) },
      specularColor: { value: /* @__PURE__ */ new ct(1, 1, 1) },
      specularColorMap: { value: null },
      specularColorMapTransform: { value: /* @__PURE__ */ new fn() },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularIntensityMapTransform: { value: /* @__PURE__ */ new fn() },
      anisotropyVector: { value: /* @__PURE__ */ new Le() },
      anisotropyMap: { value: null },
      anisotropyMapTransform: { value: /* @__PURE__ */ new fn() }
    }
  ]),
  vertexShader: _n.meshphysical_vert,
  fragmentShader: _n.meshphysical_frag
};
const $m = { r: 0, b: 0, g: 0 }, Cc = /* @__PURE__ */ new Ir(), AG = /* @__PURE__ */ new Mt();
function pG(i, e, t, n, r, s, o) {
  const a = new ct(0);
  let l = s === !0 ? 0 : 1, u, c, A = null, m = 0, _ = null;
  function y(R) {
    let C = R.isScene === !0 ? R.background : null;
    return C && C.isTexture && (C = (R.backgroundBlurriness > 0 ? t : e).get(C)), C;
  }
  function T(R) {
    let C = !1;
    const L = y(R);
    L === null ? S(a, l) : L && L.isColor && (S(L, 1), C = !0);
    const D = i.xr.getEnvironmentBlendMode();
    D === "additive" ? n.buffers.color.setClear(0, 0, 0, 1, o) : D === "alpha-blend" && n.buffers.color.setClear(0, 0, 0, 0, o), (i.autoClear || C) && (n.buffers.depth.setTest(!0), n.buffers.depth.setMask(!0), n.buffers.color.setMask(!0), i.clear(i.autoClearColor, i.autoClearDepth, i.autoClearStencil));
  }
  function b(R, C) {
    const L = y(C);
    L && (L.isCubeTexture || L.mapping === Gl) ? (c === void 0 && (c = new Tn(
      new ul(1, 1, 1),
      new Fr({
        name: "BackgroundCubeMaterial",
        uniforms: kf(Es.backgroundCube.uniforms),
        vertexShader: Es.backgroundCube.vertexShader,
        fragmentShader: Es.backgroundCube.fragmentShader,
        side: si,
        depthTest: !1,
        depthWrite: !1,
        fog: !1,
        allowOverride: !1
      })
    ), c.geometry.deleteAttribute("normal"), c.geometry.deleteAttribute("uv"), c.onBeforeRender = function(D, B, U) {
      this.matrixWorld.copyPosition(U.matrixWorld);
    }, Object.defineProperty(c.material, "envMap", {
      get: function() {
        return this.uniforms.envMap.value;
      }
    }), r.update(c)), Cc.copy(C.backgroundRotation), Cc.x *= -1, Cc.y *= -1, Cc.z *= -1, L.isCubeTexture && L.isRenderTargetTexture === !1 && (Cc.y *= -1, Cc.z *= -1), c.material.uniforms.envMap.value = L, c.material.uniforms.flipEnvMap.value = L.isCubeTexture && L.isRenderTargetTexture === !1 ? -1 : 1, c.material.uniforms.backgroundBlurriness.value = C.backgroundBlurriness, c.material.uniforms.backgroundIntensity.value = C.backgroundIntensity, c.material.uniforms.backgroundRotation.value.setFromMatrix4(AG.makeRotationFromEuler(Cc)), c.material.toneMapped = Xt.getTransfer(L.colorSpace) !== vt, (A !== L || m !== L.version || _ !== i.toneMapping) && (c.material.needsUpdate = !0, A = L, m = L.version, _ = i.toneMapping), c.layers.enableAll(), R.unshift(c, c.geometry, c.material, 0, 0, null)) : L && L.isTexture && (u === void 0 && (u = new Tn(
      new td(2, 2),
      new Fr({
        name: "BackgroundMaterial",
        uniforms: kf(Es.background.uniforms),
        vertexShader: Es.background.vertexShader,
        fragmentShader: Es.background.fragmentShader,
        side: Zs,
        depthTest: !1,
        depthWrite: !1,
        fog: !1,
        allowOverride: !1
      })
    ), u.geometry.deleteAttribute("normal"), Object.defineProperty(u.material, "map", {
      get: function() {
        return this.uniforms.t2D.value;
      }
    }), r.update(u)), u.material.uniforms.t2D.value = L, u.material.uniforms.backgroundIntensity.value = C.backgroundIntensity, u.material.toneMapped = Xt.getTransfer(L.colorSpace) !== vt, L.matrixAutoUpdate === !0 && L.updateMatrix(), u.material.uniforms.uvTransform.value.copy(L.matrix), (A !== L || m !== L.version || _ !== i.toneMapping) && (u.material.needsUpdate = !0, A = L, m = L.version, _ = i.toneMapping), u.layers.enableAll(), R.unshift(u, u.geometry, u.material, 0, 0, null));
  }
  function S(R, C) {
    R.getRGB($m, $5(i)), n.buffers.color.setClear($m.r, $m.g, $m.b, C, o);
  }
  function E() {
    c !== void 0 && (c.geometry.dispose(), c.material.dispose(), c = void 0), u !== void 0 && (u.geometry.dispose(), u.material.dispose(), u = void 0);
  }
  return {
    getClearColor: function() {
      return a;
    },
    setClearColor: function(R, C = 1) {
      a.set(R), l = C, S(a, l);
    },
    getClearAlpha: function() {
      return l;
    },
    setClearAlpha: function(R) {
      l = R, S(a, l);
    },
    render: T,
    addToRenderList: b,
    dispose: E
  };
}
function mG(i, e) {
  const t = i.getParameter(i.MAX_VERTEX_ATTRIBS), n = {}, r = m(null);
  let s = r, o = !1;
  function a(O, G, H, Y, K) {
    let X = !1;
    const ee = A(Y, H, G);
    s !== ee && (s = ee, u(s.object)), X = _(O, Y, H, K), X && y(O, Y, H, K), K !== null && e.update(K, i.ELEMENT_ARRAY_BUFFER), (X || o) && (o = !1, C(O, G, H, Y), K !== null && i.bindBuffer(i.ELEMENT_ARRAY_BUFFER, e.get(K).buffer));
  }
  function l() {
    return i.createVertexArray();
  }
  function u(O) {
    return i.bindVertexArray(O);
  }
  function c(O) {
    return i.deleteVertexArray(O);
  }
  function A(O, G, H) {
    const Y = H.wireframe === !0;
    let K = n[O.id];
    K === void 0 && (K = {}, n[O.id] = K);
    let X = K[G.id];
    X === void 0 && (X = {}, K[G.id] = X);
    let ee = X[Y];
    return ee === void 0 && (ee = m(l()), X[Y] = ee), ee;
  }
  function m(O) {
    const G = [], H = [], Y = [];
    for (let K = 0; K < t; K++)
      G[K] = 0, H[K] = 0, Y[K] = 0;
    return {
      // for backward compatibility on non-VAO support browser
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: G,
      enabledAttributes: H,
      attributeDivisors: Y,
      object: O,
      attributes: {},
      index: null
    };
  }
  function _(O, G, H, Y) {
    const K = s.attributes, X = G.attributes;
    let ee = 0;
    const oe = H.getAttributes();
    for (const fe in oe)
      if (oe[fe].location >= 0) {
        const Te = K[fe];
        let Ce = X[fe];
        if (Ce === void 0 && (fe === "instanceMatrix" && O.instanceMatrix && (Ce = O.instanceMatrix), fe === "instanceColor" && O.instanceColor && (Ce = O.instanceColor)), Te === void 0 || Te.attribute !== Ce || Ce && Te.data !== Ce.data) return !0;
        ee++;
      }
    return s.attributesNum !== ee || s.index !== Y;
  }
  function y(O, G, H, Y) {
    const K = {}, X = G.attributes;
    let ee = 0;
    const oe = H.getAttributes();
    for (const fe in oe)
      if (oe[fe].location >= 0) {
        let Te = X[fe];
        Te === void 0 && (fe === "instanceMatrix" && O.instanceMatrix && (Te = O.instanceMatrix), fe === "instanceColor" && O.instanceColor && (Te = O.instanceColor));
        const Ce = {};
        Ce.attribute = Te, Te && Te.data && (Ce.data = Te.data), K[fe] = Ce, ee++;
      }
    s.attributes = K, s.attributesNum = ee, s.index = Y;
  }
  function T() {
    const O = s.newAttributes;
    for (let G = 0, H = O.length; G < H; G++)
      O[G] = 0;
  }
  function b(O) {
    S(O, 0);
  }
  function S(O, G) {
    const H = s.newAttributes, Y = s.enabledAttributes, K = s.attributeDivisors;
    H[O] = 1, Y[O] === 0 && (i.enableVertexAttribArray(O), Y[O] = 1), K[O] !== G && (i.vertexAttribDivisor(O, G), K[O] = G);
  }
  function E() {
    const O = s.newAttributes, G = s.enabledAttributes;
    for (let H = 0, Y = G.length; H < Y; H++)
      G[H] !== O[H] && (i.disableVertexAttribArray(H), G[H] = 0);
  }
  function R(O, G, H, Y, K, X, ee) {
    ee === !0 ? i.vertexAttribIPointer(O, G, H, K, X) : i.vertexAttribPointer(O, G, H, Y, K, X);
  }
  function C(O, G, H, Y) {
    T();
    const K = Y.attributes, X = H.getAttributes(), ee = G.defaultAttributeValues;
    for (const oe in X) {
      const fe = X[oe];
      if (fe.location >= 0) {
        let _e = K[oe];
        if (_e === void 0 && (oe === "instanceMatrix" && O.instanceMatrix && (_e = O.instanceMatrix), oe === "instanceColor" && O.instanceColor && (_e = O.instanceColor)), _e !== void 0) {
          const Te = _e.normalized, Ce = _e.itemSize, Je = e.get(_e);
          if (Je === void 0) continue;
          const Qe = Je.buffer, zt = Je.type, Tt = Je.bytesPerElement, Pe = zt === i.INT || zt === i.UNSIGNED_INT || _e.gpuType === _r;
          if (_e.isInterleavedBufferAttribute) {
            const ke = _e.data, at = ke.stride, wt = _e.offset;
            if (ke.isInstancedInterleavedBuffer) {
              for (let ot = 0; ot < fe.locationSize; ot++)
                S(fe.location + ot, ke.meshPerAttribute);
              O.isInstancedMesh !== !0 && Y._maxInstanceCount === void 0 && (Y._maxInstanceCount = ke.meshPerAttribute * ke.count);
            } else
              for (let ot = 0; ot < fe.locationSize; ot++)
                b(fe.location + ot);
            i.bindBuffer(i.ARRAY_BUFFER, Qe);
            for (let ot = 0; ot < fe.locationSize; ot++)
              R(
                fe.location + ot,
                Ce / fe.locationSize,
                zt,
                Te,
                at * Tt,
                (wt + Ce / fe.locationSize * ot) * Tt,
                Pe
              );
          } else {
            if (_e.isInstancedBufferAttribute) {
              for (let ke = 0; ke < fe.locationSize; ke++)
                S(fe.location + ke, _e.meshPerAttribute);
              O.isInstancedMesh !== !0 && Y._maxInstanceCount === void 0 && (Y._maxInstanceCount = _e.meshPerAttribute * _e.count);
            } else
              for (let ke = 0; ke < fe.locationSize; ke++)
                b(fe.location + ke);
            i.bindBuffer(i.ARRAY_BUFFER, Qe);
            for (let ke = 0; ke < fe.locationSize; ke++)
              R(
                fe.location + ke,
                Ce / fe.locationSize,
                zt,
                Te,
                Ce * Tt,
                Ce / fe.locationSize * ke * Tt,
                Pe
              );
          }
        } else if (ee !== void 0) {
          const Te = ee[oe];
          if (Te !== void 0)
            switch (Te.length) {
              case 2:
                i.vertexAttrib2fv(fe.location, Te);
                break;
              case 3:
                i.vertexAttrib3fv(fe.location, Te);
                break;
              case 4:
                i.vertexAttrib4fv(fe.location, Te);
                break;
              default:
                i.vertexAttrib1fv(fe.location, Te);
            }
        }
      }
    }
    E();
  }
  function L() {
    U();
    for (const O in n) {
      const G = n[O];
      for (const H in G) {
        const Y = G[H];
        for (const K in Y)
          c(Y[K].object), delete Y[K];
        delete G[H];
      }
      delete n[O];
    }
  }
  function D(O) {
    if (n[O.id] === void 0) return;
    const G = n[O.id];
    for (const H in G) {
      const Y = G[H];
      for (const K in Y)
        c(Y[K].object), delete Y[K];
      delete G[H];
    }
    delete n[O.id];
  }
  function B(O) {
    for (const G in n) {
      const H = n[G];
      if (H[O.id] === void 0) continue;
      const Y = H[O.id];
      for (const K in Y)
        c(Y[K].object), delete Y[K];
      delete H[O.id];
    }
  }
  function U() {
    N(), o = !0, s !== r && (s = r, u(s.object));
  }
  function N() {
    r.geometry = null, r.program = null, r.wireframe = !1;
  }
  return {
    setup: a,
    reset: U,
    resetDefaultState: N,
    dispose: L,
    releaseStatesOfGeometry: D,
    releaseStatesOfProgram: B,
    initAttributes: T,
    enableAttribute: b,
    disableUnusedAttributes: E
  };
}
function gG(i, e, t) {
  let n;
  function r(u) {
    n = u;
  }
  function s(u, c) {
    i.drawArrays(n, u, c), t.update(c, n, 1);
  }
  function o(u, c, A) {
    A !== 0 && (i.drawArraysInstanced(n, u, c, A), t.update(c, n, A));
  }
  function a(u, c, A) {
    if (A === 0) return;
    e.get("WEBGL_multi_draw").multiDrawArraysWEBGL(n, u, 0, c, 0, A);
    let _ = 0;
    for (let y = 0; y < A; y++)
      _ += c[y];
    t.update(_, n, 1);
  }
  function l(u, c, A, m) {
    if (A === 0) return;
    const _ = e.get("WEBGL_multi_draw");
    if (_ === null)
      for (let y = 0; y < u.length; y++)
        o(u[y], c[y], m[y]);
    else {
      _.multiDrawArraysInstancedWEBGL(n, u, 0, c, 0, m, 0, A);
      let y = 0;
      for (let T = 0; T < A; T++)
        y += c[T] * m[T];
      t.update(y, n, 1);
    }
  }
  this.setMode = r, this.render = s, this.renderInstances = o, this.renderMultiDraw = a, this.renderMultiDrawInstances = l;
}
function _G(i, e, t, n) {
  let r;
  function s() {
    if (r !== void 0) return r;
    if (e.has("EXT_texture_filter_anisotropic") === !0) {
      const B = e.get("EXT_texture_filter_anisotropic");
      r = i.getParameter(B.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else
      r = 0;
    return r;
  }
  function o(B) {
    return !(B !== Pi && n.convert(B) !== i.getParameter(i.IMPLEMENTATION_COLOR_READ_FORMAT));
  }
  function a(B) {
    const U = B === Ri && (e.has("EXT_color_buffer_half_float") || e.has("EXT_color_buffer_float"));
    return !(B !== Mi && n.convert(B) !== i.getParameter(i.IMPLEMENTATION_COLOR_READ_TYPE) && // Edge and Chrome Mac < 52 (#9513)
    B !== Ei && !U);
  }
  function l(B) {
    if (B === "highp") {
      if (i.getShaderPrecisionFormat(i.VERTEX_SHADER, i.HIGH_FLOAT).precision > 0 && i.getShaderPrecisionFormat(i.FRAGMENT_SHADER, i.HIGH_FLOAT).precision > 0)
        return "highp";
      B = "mediump";
    }
    return B === "mediump" && i.getShaderPrecisionFormat(i.VERTEX_SHADER, i.MEDIUM_FLOAT).precision > 0 && i.getShaderPrecisionFormat(i.FRAGMENT_SHADER, i.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp";
  }
  let u = t.precision !== void 0 ? t.precision : "highp";
  const c = l(u);
  c !== u && (Me("WebGLRenderer:", u, "not supported, using", c, "instead."), u = c);
  const A = t.logarithmicDepthBuffer === !0, m = t.reversedDepthBuffer === !0 && e.has("EXT_clip_control"), _ = i.getParameter(i.MAX_TEXTURE_IMAGE_UNITS), y = i.getParameter(i.MAX_VERTEX_TEXTURE_IMAGE_UNITS), T = i.getParameter(i.MAX_TEXTURE_SIZE), b = i.getParameter(i.MAX_CUBE_MAP_TEXTURE_SIZE), S = i.getParameter(i.MAX_VERTEX_ATTRIBS), E = i.getParameter(i.MAX_VERTEX_UNIFORM_VECTORS), R = i.getParameter(i.MAX_VARYING_VECTORS), C = i.getParameter(i.MAX_FRAGMENT_UNIFORM_VECTORS), L = i.getParameter(i.MAX_SAMPLES), D = i.getParameter(i.SAMPLES);
  return {
    isWebGL2: !0,
    // keeping this for backwards compatibility
    getMaxAnisotropy: s,
    getMaxPrecision: l,
    textureFormatReadable: o,
    textureTypeReadable: a,
    precision: u,
    logarithmicDepthBuffer: A,
    reversedDepthBuffer: m,
    maxTextures: _,
    maxVertexTextures: y,
    maxTextureSize: T,
    maxCubemapSize: b,
    maxAttributes: S,
    maxVertexUniforms: E,
    maxVaryings: R,
    maxFragmentUniforms: C,
    maxSamples: L,
    samples: D
  };
}
function xG(i) {
  const e = this;
  let t = null, n = 0, r = !1, s = !1;
  const o = new ca(), a = new fn(), l = { value: null, needsUpdate: !1 };
  this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function(A, m) {
    const _ = A.length !== 0 || m || // enable state of previous frame - the clipping code has to
    // run another frame in order to reset the state:
    n !== 0 || r;
    return r = m, n = A.length, _;
  }, this.beginShadows = function() {
    s = !0, c(null);
  }, this.endShadows = function() {
    s = !1;
  }, this.setGlobalState = function(A, m) {
    t = c(A, m, 0);
  }, this.setState = function(A, m, _) {
    const y = A.clippingPlanes, T = A.clipIntersection, b = A.clipShadows, S = i.get(A);
    if (!r || y === null || y.length === 0 || s && !b)
      s ? c(null) : u();
    else {
      const E = s ? 0 : n, R = E * 4;
      let C = S.clippingState || null;
      l.value = C, C = c(y, m, R, _);
      for (let L = 0; L !== R; ++L)
        C[L] = t[L];
      S.clippingState = C, this.numIntersection = T ? this.numPlanes : 0, this.numPlanes += E;
    }
  };
  function u() {
    l.value !== t && (l.value = t, l.needsUpdate = n > 0), e.numPlanes = n, e.numIntersection = 0;
  }
  function c(A, m, _, y) {
    const T = A !== null ? A.length : 0;
    let b = null;
    if (T !== 0) {
      if (b = l.value, y !== !0 || b === null) {
        const S = _ + T * 4, E = m.matrixWorldInverse;
        a.getNormalMatrix(E), (b === null || b.length < S) && (b = new Float32Array(S));
        for (let R = 0, C = _; R !== T; ++R, C += 4)
          o.copy(A[R]).applyMatrix4(E, a), o.normal.toArray(b, C), b[C + 3] = o.constant;
      }
      l.value = b, l.needsUpdate = !0;
    }
    return e.numPlanes = T, e.numIntersection = 0, b;
  }
}
function yG(i) {
  let e = /* @__PURE__ */ new WeakMap();
  function t(o, a) {
    return a === Gu ? o.mapping = no : a === zu && (o.mapping = qo), o;
  }
  function n(o) {
    if (o && o.isTexture) {
      const a = o.mapping;
      if (a === Gu || a === zu)
        if (e.has(o)) {
          const l = e.get(o).texture;
          return t(l, o.mapping);
        } else {
          const l = o.image;
          if (l && l.height > 0) {
            const u = new Q_(l.height);
            return u.fromEquirectangularTexture(i, o), e.set(o, u), o.addEventListener("dispose", r), t(u.texture, o.mapping);
          } else
            return null;
        }
    }
    return o;
  }
  function r(o) {
    const a = o.target;
    a.removeEventListener("dispose", r);
    const l = e.get(a);
    l !== void 0 && (e.delete(a), l.dispose());
  }
  function s() {
    e = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: n,
    dispose: s
  };
}
const Iu = 4, gE = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582], qc = 20, vG = 256, FA = /* @__PURE__ */ new ic(), _E = /* @__PURE__ */ new ct();
let Sy = null, Ty = 0, wy = 0, My = !1;
const bG = /* @__PURE__ */ new j();
let Wv = class {
  /**
   * Constructs a new PMREM generator.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   */
  constructor(e) {
    this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._sizeLods = [], this._sigmas = [], this._lodMeshes = [], this._backgroundBox = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._blurMaterial = null, this._ggxMaterial = null;
  }
  /**
   * Generates a PMREM from a supplied Scene, which can be faster than using an
   * image if networking bandwidth is low. Optional sigma specifies a blur radius
   * in radians to be applied to the scene before PMREM generation. Optional near
   * and far planes ensure the scene is rendered in its entirety.
   *
   * @param {Scene} scene - The scene to be captured.
   * @param {number} [sigma=0] - The blur radius in radians.
   * @param {number} [near=0.1] - The near plane distance.
   * @param {number} [far=100] - The far plane distance.
   * @param {Object} [options={}] - The configuration options.
   * @param {number} [options.size=256] - The texture size of the PMREM.
   * @param {Vector3} [options.position=origin] - The position of the internal cube camera that renders the scene.
   * @return {WebGLRenderTarget} The resulting PMREM.
   */
  fromScene(e, t = 0, n = 0.1, r = 100, s = {}) {
    const {
      size: o = 256,
      position: a = bG
    } = s;
    Sy = this._renderer.getRenderTarget(), Ty = this._renderer.getActiveCubeFace(), wy = this._renderer.getActiveMipmapLevel(), My = this._renderer.xr.enabled, this._renderer.xr.enabled = !1, this._setSize(o);
    const l = this._allocateTargets();
    return l.depthBuffer = !0, this._sceneToCubeUV(e, n, r, l, a), t > 0 && this._blur(l, 0, 0, t), this._applyPMREM(l), this._cleanup(l), l;
  }
  /**
   * Generates a PMREM from an equirectangular texture, which can be either LDR
   * or HDR. The ideal input image size is 1k (1024 x 512),
   * as this matches best with the 256 x 256 cubemap output.
   *
   * @param {Texture} equirectangular - The equirectangular texture to be converted.
   * @param {?WebGLRenderTarget} [renderTarget=null] - The render target to use.
   * @return {WebGLRenderTarget} The resulting PMREM.
   */
  fromEquirectangular(e, t = null) {
    return this._fromTexture(e, t);
  }
  /**
   * Generates a PMREM from an cubemap texture, which can be either LDR
   * or HDR. The ideal input cube size is 256 x 256,
   * as this matches best with the 256 x 256 cubemap output.
   *
   * @param {Texture} cubemap - The cubemap texture to be converted.
   * @param {?WebGLRenderTarget} [renderTarget=null] - The render target to use.
   * @return {WebGLRenderTarget} The resulting PMREM.
   */
  fromCubemap(e, t = null) {
    return this._fromTexture(e, t);
  }
  /**
   * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileCubemapShader() {
    this._cubemapMaterial === null && (this._cubemapMaterial = vE(), this._compileMaterial(this._cubemapMaterial));
  }
  /**
   * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileEquirectangularShader() {
    this._equirectMaterial === null && (this._equirectMaterial = yE(), this._compileMaterial(this._equirectMaterial));
  }
  /**
   * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
   * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
   * one of them will cause any others to also become unusable.
   */
  dispose() {
    this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose(), this._backgroundBox !== null && (this._backgroundBox.geometry.dispose(), this._backgroundBox.material.dispose());
  }
  // private interface
  _setSize(e) {
    this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax);
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(), this._ggxMaterial !== null && this._ggxMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
    for (let e = 0; e < this._lodMeshes.length; e++)
      this._lodMeshes[e].geometry.dispose();
  }
  _cleanup(e) {
    this._renderer.setRenderTarget(Sy, Ty, wy), this._renderer.xr.enabled = My, e.scissorTest = !1, Ud(e, 0, 0, e.width, e.height);
  }
  _fromTexture(e, t) {
    e.mapping === no || e.mapping === qo ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), Sy = this._renderer.getRenderTarget(), Ty = this._renderer.getActiveCubeFace(), wy = this._renderer.getActiveMipmapLevel(), My = this._renderer.xr.enabled, this._renderer.xr.enabled = !1;
    const n = t || this._allocateTargets();
    return this._textureToCubeUV(e, n), this._applyPMREM(n), this._cleanup(n), n;
  }
  _allocateTargets() {
    const e = 3 * Math.max(this._cubeSize, 112), t = 4 * this._cubeSize, n = {
      magFilter: qn,
      minFilter: qn,
      generateMipmaps: !1,
      type: Ri,
      format: Pi,
      colorSpace: Hl,
      depthBuffer: !1
    }, r = xE(e, t, n);
    if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) {
      this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = xE(e, t, n);
      const { _lodMax: s } = this;
      ({ lodMeshes: this._lodMeshes, sizeLods: this._sizeLods, sigmas: this._sigmas } = SG(s)), this._blurMaterial = wG(s, e, t), this._ggxMaterial = TG(s, e, t);
    }
    return r;
  }
  _compileMaterial(e) {
    const t = new Tn(new Yt(), e);
    this._renderer.compile(t, FA);
  }
  _sceneToCubeUV(e, t, n, r, s) {
    const l = new Ji(90, 1, t, n), u = [1, -1, 1, 1, 1, 1], c = [1, 1, 1, -1, -1, -1], A = this._renderer, m = A.autoClear, _ = A.toneMapping;
    A.getClearColor(_E), A.toneMapping = Dr, A.autoClear = !1, A.state.buffers.depth.getReversed() && (A.setRenderTarget(r), A.clearDepth(), A.setRenderTarget(null)), this._backgroundBox === null && (this._backgroundBox = new Tn(
      new ul(),
      new Nr({
        name: "PMREM.Background",
        side: si,
        depthWrite: !1,
        depthTest: !1
      })
    ));
    const T = this._backgroundBox, b = T.material;
    let S = !1;
    const E = e.background;
    E ? E.isColor && (b.color.copy(E), e.background = null, S = !0) : (b.color.copy(_E), S = !0);
    for (let R = 0; R < 6; R++) {
      const C = R % 3;
      C === 0 ? (l.up.set(0, u[R], 0), l.position.set(s.x, s.y, s.z), l.lookAt(s.x + c[R], s.y, s.z)) : C === 1 ? (l.up.set(0, 0, u[R]), l.position.set(s.x, s.y, s.z), l.lookAt(s.x, s.y + c[R], s.z)) : (l.up.set(0, u[R], 0), l.position.set(s.x, s.y, s.z), l.lookAt(s.x, s.y, s.z + c[R]));
      const L = this._cubeSize;
      Ud(r, C * L, R > 2 ? L : 0, L, L), A.setRenderTarget(r), S && A.render(T, l), A.render(e, l);
    }
    A.toneMapping = _, A.autoClear = m, e.background = E;
  }
  _textureToCubeUV(e, t) {
    const n = this._renderer, r = e.mapping === no || e.mapping === qo;
    r ? (this._cubemapMaterial === null && (this._cubemapMaterial = vE()), this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = yE());
    const s = r ? this._cubemapMaterial : this._equirectMaterial, o = this._lodMeshes[0];
    o.material = s;
    const a = s.uniforms;
    a.envMap.value = e;
    const l = this._cubeSize;
    Ud(t, 0, 0, 3 * l, 2 * l), n.setRenderTarget(t), n.render(o, FA);
  }
  _applyPMREM(e) {
    const t = this._renderer, n = t.autoClear;
    t.autoClear = !1;
    const r = this._lodMeshes.length;
    for (let s = 1; s < r; s++)
      this._applyGGXFilter(e, s - 1, s);
    t.autoClear = n;
  }
  /**
   * Applies GGX VNDF importance sampling filter to generate a prefiltered environment map.
   * Uses Monte Carlo integration with VNDF importance sampling to accurately represent the
   * GGX BRDF for physically-based rendering. Reads from the previous LOD level and
   * applies incremental roughness filtering to avoid over-blurring.
   *
   * @private
   * @param {WebGLRenderTarget} cubeUVRenderTarget
   * @param {number} lodIn - Source LOD level to read from
   * @param {number} lodOut - Target LOD level to write to
   */
  _applyGGXFilter(e, t, n) {
    const r = this._renderer, s = this._pingPongRenderTarget, o = this._ggxMaterial, a = this._lodMeshes[n];
    a.material = o;
    const l = o.uniforms, u = n / (this._lodMeshes.length - 1), c = t / (this._lodMeshes.length - 1), A = Math.sqrt(u * u - c * c), m = 0 + u * 1.25, _ = A * m, { _lodMax: y } = this, T = this._sizeLods[n], b = 3 * T * (n > y - Iu ? n - y + Iu : 0), S = 4 * (this._cubeSize - T);
    l.envMap.value = e.texture, l.roughness.value = _, l.mipInt.value = y - t, Ud(s, b, S, 3 * T, 2 * T), r.setRenderTarget(s), r.render(a, FA), l.envMap.value = s.texture, l.roughness.value = 0, l.mipInt.value = y - n, Ud(e, b, S, 3 * T, 2 * T), r.setRenderTarget(e), r.render(a, FA);
  }
  /**
   * This is a two-pass Gaussian blur for a cubemap. Normally this is done
   * vertically and horizontally, but this breaks down on a cube. Here we apply
   * the blur latitudinally (around the poles), and then longitudinally (towards
   * the poles) to approximate the orthogonally-separable blur. It is least
   * accurate at the poles, but still does a decent job.
   *
   * Used for initial scene blur in fromScene() method when sigma > 0.
   *
   * @private
   * @param {WebGLRenderTarget} cubeUVRenderTarget
   * @param {number} lodIn
   * @param {number} lodOut
   * @param {number} sigma
   * @param {Vector3} [poleAxis]
   */
  _blur(e, t, n, r, s) {
    const o = this._pingPongRenderTarget;
    this._halfBlur(
      e,
      o,
      t,
      n,
      r,
      "latitudinal",
      s
    ), this._halfBlur(
      o,
      e,
      n,
      n,
      r,
      "longitudinal",
      s
    );
  }
  _halfBlur(e, t, n, r, s, o, a) {
    const l = this._renderer, u = this._blurMaterial;
    o !== "latitudinal" && o !== "longitudinal" && Ie(
      "blur direction must be either latitudinal or longitudinal!"
    );
    const c = 3, A = this._lodMeshes[r];
    A.material = u;
    const m = u.uniforms, _ = this._sizeLods[n] - 1, y = isFinite(s) ? Math.PI / (2 * _) : 2 * Math.PI / (2 * qc - 1), T = s / y, b = isFinite(s) ? 1 + Math.floor(c * T) : qc;
    b > qc && Me(`sigmaRadians, ${s}, is too large and will clip, as it requested ${b} samples when the maximum is set to ${qc}`);
    const S = [];
    let E = 0;
    for (let B = 0; B < qc; ++B) {
      const U = B / T, N = Math.exp(-U * U / 2);
      S.push(N), B === 0 ? E += N : B < b && (E += 2 * N);
    }
    for (let B = 0; B < S.length; B++)
      S[B] = S[B] / E;
    m.envMap.value = e.texture, m.samples.value = b, m.weights.value = S, m.latitudinal.value = o === "latitudinal", a && (m.poleAxis.value = a);
    const { _lodMax: R } = this;
    m.dTheta.value = y, m.mipInt.value = R - n;
    const C = this._sizeLods[r], L = 3 * C * (r > R - Iu ? r - R + Iu : 0), D = 4 * (this._cubeSize - C);
    Ud(t, L, D, 3 * C, 2 * C), l.setRenderTarget(t), l.render(A, FA);
  }
};
function SG(i) {
  const e = [], t = [], n = [];
  let r = i;
  const s = i - Iu + 1 + gE.length;
  for (let o = 0; o < s; o++) {
    const a = Math.pow(2, r);
    e.push(a);
    let l = 1 / a;
    o > i - Iu ? l = gE[o - i + Iu - 1] : o === 0 && (l = 0), t.push(l);
    const u = 1 / (a - 2), c = -u, A = 1 + u, m = [c, c, A, c, A, A, c, c, A, A, c, A], _ = 6, y = 6, T = 3, b = 2, S = 1, E = new Float32Array(T * y * _), R = new Float32Array(b * y * _), C = new Float32Array(S * y * _);
    for (let D = 0; D < _; D++) {
      const B = D % 3 * 2 / 3 - 1, U = D > 2 ? 0 : -1, N = [
        B,
        U,
        0,
        B + 2 / 3,
        U,
        0,
        B + 2 / 3,
        U + 1,
        0,
        B,
        U,
        0,
        B + 2 / 3,
        U + 1,
        0,
        B,
        U + 1,
        0
      ];
      E.set(N, T * y * D), R.set(m, b * y * D);
      const O = [D, D, D, D, D, D];
      C.set(O, S * y * D);
    }
    const L = new Yt();
    L.setAttribute("position", new Dn(E, T)), L.setAttribute("uv", new Dn(R, b)), L.setAttribute("faceIndex", new Dn(C, S)), n.push(new Tn(L, null)), r > Iu && r--;
  }
  return { lodMeshes: n, sizeLods: e, sigmas: t };
}
function xE(i, e, t) {
  const n = new eo(i, e, t);
  return n.texture.mapping = Gl, n.texture.name = "PMREM.cubeUv", n.scissorTest = !0, n;
}
function Ud(i, e, t, n, r) {
  i.viewport.set(e, t, n, r), i.scissor.set(e, t, n, r);
}
function TG(i, e, t) {
  return new Fr({
    name: "PMREMGGXConvolution",
    defines: {
      GGX_SAMPLES: vG,
      CUBEUV_TEXEL_WIDTH: 1 / e,
      CUBEUV_TEXEL_HEIGHT: 1 / t,
      CUBEUV_MAX_MIP: `${i}.0`
    },
    uniforms: {
      envMap: { value: null },
      roughness: { value: 0 },
      mipInt: { value: 0 }
    },
    vertexShader: y2(),
    fragmentShader: (
      /* glsl */
      `

			precision highp float;
			precision highp int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform float roughness;
			uniform float mipInt;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			#define PI 3.14159265359

			// Van der Corput radical inverse
			float radicalInverse_VdC(uint bits) {
				bits = (bits << 16u) | (bits >> 16u);
				bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);
				bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);
				bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);
				bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);
				return float(bits) * 2.3283064365386963e-10; // / 0x100000000
			}

			// Hammersley sequence
			vec2 hammersley(uint i, uint N) {
				return vec2(float(i) / float(N), radicalInverse_VdC(i));
			}

			// GGX VNDF importance sampling (Eric Heitz 2018)
			// "Sampling the GGX Distribution of Visible Normals"
			// https://jcgt.org/published/0007/04/01/
			vec3 importanceSampleGGX_VNDF(vec2 Xi, vec3 V, float roughness) {
				float alpha = roughness * roughness;

				// Section 3.2: Transform view direction to hemisphere configuration
				vec3 Vh = normalize(vec3(alpha * V.x, alpha * V.y, V.z));

				// Section 4.1: Orthonormal basis
				float lensq = Vh.x * Vh.x + Vh.y * Vh.y;
				vec3 T1 = lensq > 0.0 ? vec3(-Vh.y, Vh.x, 0.0) / sqrt(lensq) : vec3(1.0, 0.0, 0.0);
				vec3 T2 = cross(Vh, T1);

				// Section 4.2: Parameterization of projected area
				float r = sqrt(Xi.x);
				float phi = 2.0 * PI * Xi.y;
				float t1 = r * cos(phi);
				float t2 = r * sin(phi);
				float s = 0.5 * (1.0 + Vh.z);
				t2 = (1.0 - s) * sqrt(1.0 - t1 * t1) + s * t2;

				// Section 4.3: Reprojection onto hemisphere
				vec3 Nh = t1 * T1 + t2 * T2 + sqrt(max(0.0, 1.0 - t1 * t1 - t2 * t2)) * Vh;

				// Section 3.4: Transform back to ellipsoid configuration
				return normalize(vec3(alpha * Nh.x, alpha * Nh.y, max(0.0, Nh.z)));
			}

			void main() {
				vec3 N = normalize(vOutputDirection);
				vec3 V = N; // Assume view direction equals normal for pre-filtering

				vec3 prefilteredColor = vec3(0.0);
				float totalWeight = 0.0;

				// For very low roughness, just sample the environment directly
				if (roughness < 0.001) {
					gl_FragColor = vec4(bilinearCubeUV(envMap, N, mipInt), 1.0);
					return;
				}

				// Tangent space basis for VNDF sampling
				vec3 up = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);
				vec3 tangent = normalize(cross(up, N));
				vec3 bitangent = cross(N, tangent);

				for(uint i = 0u; i < uint(GGX_SAMPLES); i++) {
					vec2 Xi = hammersley(i, uint(GGX_SAMPLES));

					// For PMREM, V = N, so in tangent space V is always (0, 0, 1)
					vec3 H_tangent = importanceSampleGGX_VNDF(Xi, vec3(0.0, 0.0, 1.0), roughness);

					// Transform H back to world space
					vec3 H = normalize(tangent * H_tangent.x + bitangent * H_tangent.y + N * H_tangent.z);
					vec3 L = normalize(2.0 * dot(V, H) * H - V);

					float NdotL = max(dot(N, L), 0.0);

					if(NdotL > 0.0) {
						// Sample environment at fixed mip level
						// VNDF importance sampling handles the distribution filtering
						vec3 sampleColor = bilinearCubeUV(envMap, L, mipInt);

						// Weight by NdotL for the split-sum approximation
						// VNDF PDF naturally accounts for the visible microfacet distribution
						prefilteredColor += sampleColor * NdotL;
						totalWeight += NdotL;
					}
				}

				if (totalWeight > 0.0) {
					prefilteredColor = prefilteredColor / totalWeight;
				}

				gl_FragColor = vec4(prefilteredColor, 1.0);
			}
		`
    ),
    blending: ms,
    depthTest: !1,
    depthWrite: !1
  });
}
function wG(i, e, t) {
  const n = new Float32Array(qc), r = new j(0, 1, 0);
  return new Fr({
    name: "SphericalGaussianBlur",
    defines: {
      n: qc,
      CUBEUV_TEXEL_WIDTH: 1 / e,
      CUBEUV_TEXEL_HEIGHT: 1 / t,
      CUBEUV_MAX_MIP: `${i}.0`
    },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: n },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: r }
    },
    vertexShader: y2(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`
    ),
    blending: ms,
    depthTest: !1,
    depthWrite: !1
  });
}
function yE() {
  return new Fr({
    name: "EquirectangularToCubeUV",
    uniforms: {
      envMap: { value: null }
    },
    vertexShader: y2(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`
    ),
    blending: ms,
    depthTest: !1,
    depthWrite: !1
  });
}
function vE() {
  return new Fr({
    name: "CubemapToCubeUV",
    uniforms: {
      envMap: { value: null },
      flipEnvMap: { value: -1 }
    },
    vertexShader: y2(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`
    ),
    blending: ms,
    depthTest: !1,
    depthWrite: !1
  });
}
function y2() {
  return (
    /* glsl */
    `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
  );
}
function MG(i) {
  let e = /* @__PURE__ */ new WeakMap(), t = null;
  function n(a) {
    if (a && a.isTexture) {
      const l = a.mapping, u = l === Gu || l === zu, c = l === no || l === qo;
      if (u || c) {
        let A = e.get(a);
        const m = A !== void 0 ? A.texture.pmremVersion : 0;
        if (a.isRenderTargetTexture && a.pmremVersion !== m)
          return t === null && (t = new Wv(i)), A = u ? t.fromEquirectangular(a, A) : t.fromCubemap(a, A), A.texture.pmremVersion = a.pmremVersion, e.set(a, A), A.texture;
        if (A !== void 0)
          return A.texture;
        {
          const _ = a.image;
          return u && _ && _.height > 0 || c && _ && r(_) ? (t === null && (t = new Wv(i)), A = u ? t.fromEquirectangular(a) : t.fromCubemap(a), A.texture.pmremVersion = a.pmremVersion, e.set(a, A), a.addEventListener("dispose", s), A.texture) : null;
        }
      }
    }
    return a;
  }
  function r(a) {
    let l = 0;
    const u = 6;
    for (let c = 0; c < u; c++)
      a[c] !== void 0 && l++;
    return l === u;
  }
  function s(a) {
    const l = a.target;
    l.removeEventListener("dispose", s);
    const u = e.get(l);
    u !== void 0 && (e.delete(l), u.dispose());
  }
  function o() {
    e = /* @__PURE__ */ new WeakMap(), t !== null && (t.dispose(), t = null);
  }
  return {
    get: n,
    dispose: o
  };
}
function EG(i) {
  const e = {};
  function t(n) {
    if (e[n] !== void 0)
      return e[n];
    const r = i.getExtension(n);
    return e[n] = r, r;
  }
  return {
    has: function(n) {
      return t(n) !== null;
    },
    init: function() {
      t("EXT_color_buffer_float"), t("WEBGL_clip_cull_distance"), t("OES_texture_float_linear"), t("EXT_color_buffer_half_float"), t("WEBGL_multisampled_render_to_texture"), t("WEBGL_render_shared_exponent");
    },
    get: function(n) {
      const r = t(n);
      return r === null && li("WebGLRenderer: " + n + " extension not supported."), r;
    }
  };
}
function RG(i, e, t, n) {
  const r = {}, s = /* @__PURE__ */ new WeakMap();
  function o(A) {
    const m = A.target;
    m.index !== null && e.remove(m.index);
    for (const y in m.attributes)
      e.remove(m.attributes[y]);
    m.removeEventListener("dispose", o), delete r[m.id];
    const _ = s.get(m);
    _ && (e.remove(_), s.delete(m)), n.releaseStatesOfGeometry(m), m.isInstancedBufferGeometry === !0 && delete m._maxInstanceCount, t.memory.geometries--;
  }
  function a(A, m) {
    return r[m.id] === !0 || (m.addEventListener("dispose", o), r[m.id] = !0, t.memory.geometries++), m;
  }
  function l(A) {
    const m = A.attributes;
    for (const _ in m)
      e.update(m[_], i.ARRAY_BUFFER);
  }
  function u(A) {
    const m = [], _ = A.index, y = A.attributes.position;
    let T = 0;
    if (_ !== null) {
      const E = _.array;
      T = _.version;
      for (let R = 0, C = E.length; R < C; R += 3) {
        const L = E[R + 0], D = E[R + 1], B = E[R + 2];
        m.push(L, D, D, B, B, L);
      }
    } else if (y !== void 0) {
      const E = y.array;
      T = y.version;
      for (let R = 0, C = E.length / 3 - 1; R < C; R += 3) {
        const L = R + 0, D = R + 1, B = R + 2;
        m.push(L, D, D, B, B, L);
      }
    } else
      return;
    const b = new (R3(m) ? Y_ : X_)(m, 1);
    b.version = T;
    const S = s.get(A);
    S && e.remove(S), s.set(A, b);
  }
  function c(A) {
    const m = s.get(A);
    if (m) {
      const _ = A.index;
      _ !== null && m.version < _.version && u(A);
    } else
      u(A);
    return s.get(A);
  }
  return {
    get: a,
    update: l,
    getWireframeAttribute: c
  };
}
function CG(i, e, t) {
  let n;
  function r(m) {
    n = m;
  }
  let s, o;
  function a(m) {
    s = m.type, o = m.bytesPerElement;
  }
  function l(m, _) {
    i.drawElements(n, _, s, m * o), t.update(_, n, 1);
  }
  function u(m, _, y) {
    y !== 0 && (i.drawElementsInstanced(n, _, s, m * o, y), t.update(_, n, y));
  }
  function c(m, _, y) {
    if (y === 0) return;
    e.get("WEBGL_multi_draw").multiDrawElementsWEBGL(n, _, 0, s, m, 0, y);
    let b = 0;
    for (let S = 0; S < y; S++)
      b += _[S];
    t.update(b, n, 1);
  }
  function A(m, _, y, T) {
    if (y === 0) return;
    const b = e.get("WEBGL_multi_draw");
    if (b === null)
      for (let S = 0; S < m.length; S++)
        u(m[S] / o, _[S], T[S]);
    else {
      b.multiDrawElementsInstancedWEBGL(n, _, 0, s, m, 0, T, 0, y);
      let S = 0;
      for (let E = 0; E < y; E++)
        S += _[E] * T[E];
      t.update(S, n, 1);
    }
  }
  this.setMode = r, this.setIndex = a, this.render = l, this.renderInstances = u, this.renderMultiDraw = c, this.renderMultiDrawInstances = A;
}
function PG(i) {
  const e = {
    geometries: 0,
    textures: 0
  }, t = {
    frame: 0,
    calls: 0,
    triangles: 0,
    points: 0,
    lines: 0
  };
  function n(s, o, a) {
    switch (t.calls++, o) {
      case i.TRIANGLES:
        t.triangles += a * (s / 3);
        break;
      case i.LINES:
        t.lines += a * (s / 2);
        break;
      case i.LINE_STRIP:
        t.lines += a * (s - 1);
        break;
      case i.LINE_LOOP:
        t.lines += a * s;
        break;
      case i.POINTS:
        t.points += a * s;
        break;
      default:
        Ie("WebGLInfo: Unknown draw mode:", o);
        break;
    }
  }
  function r() {
    t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0;
  }
  return {
    memory: e,
    render: t,
    programs: null,
    autoReset: !0,
    reset: r,
    update: n
  };
}
function NG(i, e, t) {
  const n = /* @__PURE__ */ new WeakMap(), r = new Kt();
  function s(o, a, l) {
    const u = o.morphTargetInfluences, c = a.morphAttributes.position || a.morphAttributes.normal || a.morphAttributes.color, A = c !== void 0 ? c.length : 0;
    let m = n.get(a);
    if (m === void 0 || m.count !== A) {
      let N = function() {
        B.dispose(), n.delete(a), a.removeEventListener("dispose", N);
      };
      m !== void 0 && m.texture.dispose();
      const _ = a.morphAttributes.position !== void 0, y = a.morphAttributes.normal !== void 0, T = a.morphAttributes.color !== void 0, b = a.morphAttributes.position || [], S = a.morphAttributes.normal || [], E = a.morphAttributes.color || [];
      let R = 0;
      _ === !0 && (R = 1), y === !0 && (R = 2), T === !0 && (R = 3);
      let C = a.attributes.position.count * R, L = 1;
      C > e.maxTextureSize && (L = Math.ceil(C / e.maxTextureSize), C = e.maxTextureSize);
      const D = new Float32Array(C * L * 4 * A), B = new y0(D, C, L, A);
      B.type = Ei, B.needsUpdate = !0;
      const U = R * 4;
      for (let O = 0; O < A; O++) {
        const G = b[O], H = S[O], Y = E[O], K = C * L * 4 * O;
        for (let X = 0; X < G.count; X++) {
          const ee = X * U;
          _ === !0 && (r.fromBufferAttribute(G, X), D[K + ee + 0] = r.x, D[K + ee + 1] = r.y, D[K + ee + 2] = r.z, D[K + ee + 3] = 0), y === !0 && (r.fromBufferAttribute(H, X), D[K + ee + 4] = r.x, D[K + ee + 5] = r.y, D[K + ee + 6] = r.z, D[K + ee + 7] = 0), T === !0 && (r.fromBufferAttribute(Y, X), D[K + ee + 8] = r.x, D[K + ee + 9] = r.y, D[K + ee + 10] = r.z, D[K + ee + 11] = Y.itemSize === 4 ? r.w : 1);
        }
      }
      m = {
        count: A,
        texture: B,
        size: new Le(C, L)
      }, n.set(a, m), a.addEventListener("dispose", N);
    }
    if (o.isInstancedMesh === !0 && o.morphTexture !== null)
      l.getUniforms().setValue(i, "morphTexture", o.morphTexture, t);
    else {
      let _ = 0;
      for (let T = 0; T < u.length; T++)
        _ += u[T];
      const y = a.morphTargetsRelative ? 1 : 1 - _;
      l.getUniforms().setValue(i, "morphTargetBaseInfluence", y), l.getUniforms().setValue(i, "morphTargetInfluences", u);
    }
    l.getUniforms().setValue(i, "morphTargetsTexture", m.texture, t), l.getUniforms().setValue(i, "morphTargetsTextureSize", m.size);
  }
  return {
    update: s
  };
}
function DG(i, e, t, n) {
  let r = /* @__PURE__ */ new WeakMap();
  function s(l) {
    const u = n.render.frame, c = l.geometry, A = e.get(l, c);
    if (r.get(A) !== u && (e.update(A), r.set(A, u)), l.isInstancedMesh && (l.hasEventListener("dispose", a) === !1 && l.addEventListener("dispose", a), r.get(l) !== u && (t.update(l.instanceMatrix, i.ARRAY_BUFFER), l.instanceColor !== null && t.update(l.instanceColor, i.ARRAY_BUFFER), r.set(l, u))), l.isSkinnedMesh) {
      const m = l.skeleton;
      r.get(m) !== u && (m.update(), r.set(m, u));
    }
    return A;
  }
  function o() {
    r = /* @__PURE__ */ new WeakMap();
  }
  function a(l) {
    const u = l.target;
    u.removeEventListener("dispose", a), t.remove(u.instanceMatrix), u.instanceColor !== null && t.remove(u.instanceColor);
  }
  return {
    update: s,
    dispose: o
  };
}
const LG = {
  [L_]: "LINEAR_TONE_MAPPING",
  [I_]: "REINHARD_TONE_MAPPING",
  [B_]: "CINEON_TONE_MAPPING",
  [F_]: "ACES_FILMIC_TONE_MAPPING",
  [U_]: "AGX_TONE_MAPPING",
  [O_]: "NEUTRAL_TONE_MAPPING",
  [T3]: "CUSTOM_TONE_MAPPING"
};
function IG(i, e, t, n, r) {
  const s = new eo(e, t, {
    type: i,
    depthBuffer: n,
    stencilBuffer: r
  }), o = new eo(e, t, {
    type: Ri,
    depthBuffer: !1,
    stencilBuffer: !1
  }), a = new Yt();
  a.setAttribute("position", new xt([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)), a.setAttribute("uv", new xt([0, 2, 0, 0, 2, 0], 2));
  const l = new $3({
    uniforms: {
      tDiffuse: { value: null }
    },
    vertexShader: (
      /* glsl */
      `
			precision highp float;

			uniform mat4 modelViewMatrix;
			uniform mat4 projectionMatrix;

			attribute vec3 position;
			attribute vec2 uv;

			varying vec2 vUv;

			void main() {
				vUv = uv;
				gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
			}`
    ),
    fragmentShader: (
      /* glsl */
      `
			precision highp float;

			uniform sampler2D tDiffuse;

			varying vec2 vUv;

			#include <tonemapping_pars_fragment>
			#include <colorspace_pars_fragment>

			void main() {
				gl_FragColor = texture2D( tDiffuse, vUv );

				#ifdef LINEAR_TONE_MAPPING
					gl_FragColor.rgb = LinearToneMapping( gl_FragColor.rgb );
				#elif defined( REINHARD_TONE_MAPPING )
					gl_FragColor.rgb = ReinhardToneMapping( gl_FragColor.rgb );
				#elif defined( CINEON_TONE_MAPPING )
					gl_FragColor.rgb = CineonToneMapping( gl_FragColor.rgb );
				#elif defined( ACES_FILMIC_TONE_MAPPING )
					gl_FragColor.rgb = ACESFilmicToneMapping( gl_FragColor.rgb );
				#elif defined( AGX_TONE_MAPPING )
					gl_FragColor.rgb = AgXToneMapping( gl_FragColor.rgb );
				#elif defined( NEUTRAL_TONE_MAPPING )
					gl_FragColor.rgb = NeutralToneMapping( gl_FragColor.rgb );
				#elif defined( CUSTOM_TONE_MAPPING )
					gl_FragColor.rgb = CustomToneMapping( gl_FragColor.rgb );
				#endif

				#ifdef SRGB_TRANSFER
					gl_FragColor = sRGBTransferOETF( gl_FragColor );
				#endif
			}`
    ),
    depthTest: !1,
    depthWrite: !1
  }), u = new Tn(a, l), c = new ic(-1, 1, 1, -1, 0, 1);
  let A = null, m = null, _ = !1, y, T = null, b = [], S = !1;
  this.setSize = function(E, R) {
    s.setSize(E, R), o.setSize(E, R);
    for (let C = 0; C < b.length; C++) {
      const L = b[C];
      L.setSize && L.setSize(E, R);
    }
  }, this.setEffects = function(E) {
    b = E, S = b.length > 0 && b[0].isRenderPass === !0;
    const R = s.width, C = s.height;
    for (let L = 0; L < b.length; L++) {
      const D = b[L];
      D.setSize && D.setSize(R, C);
    }
  }, this.begin = function(E, R) {
    if (_ || E.toneMapping === Dr && b.length === 0) return !1;
    if (T = R, R !== null) {
      const C = R.width, L = R.height;
      (s.width !== C || s.height !== L) && this.setSize(C, L);
    }
    return S === !1 && E.setRenderTarget(s), y = E.toneMapping, E.toneMapping = Dr, !0;
  }, this.hasRenderPass = function() {
    return S;
  }, this.end = function(E, R) {
    E.toneMapping = y, _ = !0;
    let C = s, L = o;
    for (let D = 0; D < b.length; D++) {
      const B = b[D];
      if (B.enabled !== !1 && (B.render(E, L, C, R), B.needsSwap !== !1)) {
        const U = C;
        C = L, L = U;
      }
    }
    if (A !== E.outputColorSpace || m !== E.toneMapping) {
      A = E.outputColorSpace, m = E.toneMapping, l.defines = {}, Xt.getTransfer(A) === vt && (l.defines.SRGB_TRANSFER = "");
      const D = LG[m];
      D && (l.defines[D] = ""), l.needsUpdate = !0;
    }
    l.uniforms.tDiffuse.value = C.texture, E.setRenderTarget(T), E.render(u, c), T = null, _ = !1;
  }, this.isCompositing = function() {
    return _;
  }, this.dispose = function() {
    s.dispose(), o.dispose(), a.dispose(), l.dispose();
  };
}
const w8 = /* @__PURE__ */ new Ii(), $v = /* @__PURE__ */ new Qr(1, 1), M8 = /* @__PURE__ */ new y0(), E8 = /* @__PURE__ */ new $_(), R8 = /* @__PURE__ */ new Ju(), bE = [], SE = [], TE = new Float32Array(16), wE = new Float32Array(9), ME = new Float32Array(4);
function uA(i, e, t) {
  const n = i[0];
  if (n <= 0 || n > 0) return i;
  const r = e * t;
  let s = bE[r];
  if (s === void 0 && (s = new Float32Array(r), bE[r] = s), e !== 0) {
    n.toArray(s, 0);
    for (let o = 1, a = 0; o !== e; ++o)
      a += t, i[o].toArray(s, a);
  }
  return s;
}
function yr(i, e) {
  if (i.length !== e.length) return !1;
  for (let t = 0, n = i.length; t < n; t++)
    if (i[t] !== e[t]) return !1;
  return !0;
}
function vr(i, e) {
  for (let t = 0, n = e.length; t < n; t++)
    i[t] = e[t];
}
function v2(i, e) {
  let t = SE[e];
  t === void 0 && (t = new Int32Array(e), SE[e] = t);
  for (let n = 0; n !== e; ++n)
    t[n] = i.allocateTextureUnit();
  return t;
}
function BG(i, e) {
  const t = this.cache;
  t[0] !== e && (i.uniform1f(this.addr, e), t[0] = e);
}
function FG(i, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) && (i.uniform2f(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
  else {
    if (yr(t, e)) return;
    i.uniform2fv(this.addr, e), vr(t, e);
  }
}
function UG(i, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (i.uniform3f(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
  else if (e.r !== void 0)
    (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) && (i.uniform3f(this.addr, e.r, e.g, e.b), t[0] = e.r, t[1] = e.g, t[2] = e.b);
  else {
    if (yr(t, e)) return;
    i.uniform3fv(this.addr, e), vr(t, e);
  }
}
function OG(i, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (i.uniform4f(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
  else {
    if (yr(t, e)) return;
    i.uniform4fv(this.addr, e), vr(t, e);
  }
}
function kG(i, e) {
  const t = this.cache, n = e.elements;
  if (n === void 0) {
    if (yr(t, e)) return;
    i.uniformMatrix2fv(this.addr, !1, e), vr(t, e);
  } else {
    if (yr(t, n)) return;
    ME.set(n), i.uniformMatrix2fv(this.addr, !1, ME), vr(t, n);
  }
}
function VG(i, e) {
  const t = this.cache, n = e.elements;
  if (n === void 0) {
    if (yr(t, e)) return;
    i.uniformMatrix3fv(this.addr, !1, e), vr(t, e);
  } else {
    if (yr(t, n)) return;
    wE.set(n), i.uniformMatrix3fv(this.addr, !1, wE), vr(t, n);
  }
}
function GG(i, e) {
  const t = this.cache, n = e.elements;
  if (n === void 0) {
    if (yr(t, e)) return;
    i.uniformMatrix4fv(this.addr, !1, e), vr(t, e);
  } else {
    if (yr(t, n)) return;
    TE.set(n), i.uniformMatrix4fv(this.addr, !1, TE), vr(t, n);
  }
}
function zG(i, e) {
  const t = this.cache;
  t[0] !== e && (i.uniform1i(this.addr, e), t[0] = e);
}
function qG(i, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) && (i.uniform2i(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
  else {
    if (yr(t, e)) return;
    i.uniform2iv(this.addr, e), vr(t, e);
  }
}
function HG(i, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (i.uniform3i(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
  else {
    if (yr(t, e)) return;
    i.uniform3iv(this.addr, e), vr(t, e);
  }
}
function WG(i, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (i.uniform4i(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
  else {
    if (yr(t, e)) return;
    i.uniform4iv(this.addr, e), vr(t, e);
  }
}
function $G(i, e) {
  const t = this.cache;
  t[0] !== e && (i.uniform1ui(this.addr, e), t[0] = e);
}
function jG(i, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) && (i.uniform2ui(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
  else {
    if (yr(t, e)) return;
    i.uniform2uiv(this.addr, e), vr(t, e);
  }
}
function XG(i, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (i.uniform3ui(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
  else {
    if (yr(t, e)) return;
    i.uniform3uiv(this.addr, e), vr(t, e);
  }
}
function YG(i, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (i.uniform4ui(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
  else {
    if (yr(t, e)) return;
    i.uniform4uiv(this.addr, e), vr(t, e);
  }
}
function QG(i, e, t) {
  const n = this.cache, r = t.allocateTextureUnit();
  n[0] !== r && (i.uniform1i(this.addr, r), n[0] = r);
  let s;
  this.type === i.SAMPLER_2D_SHADOW ? ($v.compareFunction = t.isReversedDepthBuffer() ? sA : rA, s = $v) : s = w8, t.setTexture2D(e || s, r);
}
function KG(i, e, t) {
  const n = this.cache, r = t.allocateTextureUnit();
  n[0] !== r && (i.uniform1i(this.addr, r), n[0] = r), t.setTexture3D(e || E8, r);
}
function ZG(i, e, t) {
  const n = this.cache, r = t.allocateTextureUnit();
  n[0] !== r && (i.uniform1i(this.addr, r), n[0] = r), t.setTextureCube(e || R8, r);
}
function JG(i, e, t) {
  const n = this.cache, r = t.allocateTextureUnit();
  n[0] !== r && (i.uniform1i(this.addr, r), n[0] = r), t.setTexture2DArray(e || M8, r);
}
function ez(i) {
  switch (i) {
    case 5126:
      return BG;
    // FLOAT
    case 35664:
      return FG;
    // _VEC2
    case 35665:
      return UG;
    // _VEC3
    case 35666:
      return OG;
    // _VEC4
    case 35674:
      return kG;
    // _MAT2
    case 35675:
      return VG;
    // _MAT3
    case 35676:
      return GG;
    // _MAT4
    case 5124:
    case 35670:
      return zG;
    // INT, BOOL
    case 35667:
    case 35671:
      return qG;
    // _VEC2
    case 35668:
    case 35672:
      return HG;
    // _VEC3
    case 35669:
    case 35673:
      return WG;
    // _VEC4
    case 5125:
      return $G;
    // UINT
    case 36294:
      return jG;
    // _VEC2
    case 36295:
      return XG;
    // _VEC3
    case 36296:
      return YG;
    // _VEC4
    case 35678:
    // SAMPLER_2D
    case 36198:
    // SAMPLER_EXTERNAL_OES
    case 36298:
    // INT_SAMPLER_2D
    case 36306:
    // UNSIGNED_INT_SAMPLER_2D
    case 35682:
      return QG;
    case 35679:
    // SAMPLER_3D
    case 36299:
    // INT_SAMPLER_3D
    case 36307:
      return KG;
    case 35680:
    // SAMPLER_CUBE
    case 36300:
    // INT_SAMPLER_CUBE
    case 36308:
    // UNSIGNED_INT_SAMPLER_CUBE
    case 36293:
      return ZG;
    case 36289:
    // SAMPLER_2D_ARRAY
    case 36303:
    // INT_SAMPLER_2D_ARRAY
    case 36311:
    // UNSIGNED_INT_SAMPLER_2D_ARRAY
    case 36292:
      return JG;
  }
}
function tz(i, e) {
  i.uniform1fv(this.addr, e);
}
function nz(i, e) {
  const t = uA(e, this.size, 2);
  i.uniform2fv(this.addr, t);
}
function iz(i, e) {
  const t = uA(e, this.size, 3);
  i.uniform3fv(this.addr, t);
}
function rz(i, e) {
  const t = uA(e, this.size, 4);
  i.uniform4fv(this.addr, t);
}
function sz(i, e) {
  const t = uA(e, this.size, 4);
  i.uniformMatrix2fv(this.addr, !1, t);
}
function oz(i, e) {
  const t = uA(e, this.size, 9);
  i.uniformMatrix3fv(this.addr, !1, t);
}
function az(i, e) {
  const t = uA(e, this.size, 16);
  i.uniformMatrix4fv(this.addr, !1, t);
}
function lz(i, e) {
  i.uniform1iv(this.addr, e);
}
function uz(i, e) {
  i.uniform2iv(this.addr, e);
}
function cz(i, e) {
  i.uniform3iv(this.addr, e);
}
function hz(i, e) {
  i.uniform4iv(this.addr, e);
}
function dz(i, e) {
  i.uniform1uiv(this.addr, e);
}
function fz(i, e) {
  i.uniform2uiv(this.addr, e);
}
function Az(i, e) {
  i.uniform3uiv(this.addr, e);
}
function pz(i, e) {
  i.uniform4uiv(this.addr, e);
}
function mz(i, e, t) {
  const n = this.cache, r = e.length, s = v2(t, r);
  yr(n, s) || (i.uniform1iv(this.addr, s), vr(n, s));
  let o;
  this.type === i.SAMPLER_2D_SHADOW ? o = $v : o = w8;
  for (let a = 0; a !== r; ++a)
    t.setTexture2D(e[a] || o, s[a]);
}
function gz(i, e, t) {
  const n = this.cache, r = e.length, s = v2(t, r);
  yr(n, s) || (i.uniform1iv(this.addr, s), vr(n, s));
  for (let o = 0; o !== r; ++o)
    t.setTexture3D(e[o] || E8, s[o]);
}
function _z(i, e, t) {
  const n = this.cache, r = e.length, s = v2(t, r);
  yr(n, s) || (i.uniform1iv(this.addr, s), vr(n, s));
  for (let o = 0; o !== r; ++o)
    t.setTextureCube(e[o] || R8, s[o]);
}
function xz(i, e, t) {
  const n = this.cache, r = e.length, s = v2(t, r);
  yr(n, s) || (i.uniform1iv(this.addr, s), vr(n, s));
  for (let o = 0; o !== r; ++o)
    t.setTexture2DArray(e[o] || M8, s[o]);
}
function yz(i) {
  switch (i) {
    case 5126:
      return tz;
    // FLOAT
    case 35664:
      return nz;
    // _VEC2
    case 35665:
      return iz;
    // _VEC3
    case 35666:
      return rz;
    // _VEC4
    case 35674:
      return sz;
    // _MAT2
    case 35675:
      return oz;
    // _MAT3
    case 35676:
      return az;
    // _MAT4
    case 5124:
    case 35670:
      return lz;
    // INT, BOOL
    case 35667:
    case 35671:
      return uz;
    // _VEC2
    case 35668:
    case 35672:
      return cz;
    // _VEC3
    case 35669:
    case 35673:
      return hz;
    // _VEC4
    case 5125:
      return dz;
    // UINT
    case 36294:
      return fz;
    // _VEC2
    case 36295:
      return Az;
    // _VEC3
    case 36296:
      return pz;
    // _VEC4
    case 35678:
    // SAMPLER_2D
    case 36198:
    // SAMPLER_EXTERNAL_OES
    case 36298:
    // INT_SAMPLER_2D
    case 36306:
    // UNSIGNED_INT_SAMPLER_2D
    case 35682:
      return mz;
    case 35679:
    // SAMPLER_3D
    case 36299:
    // INT_SAMPLER_3D
    case 36307:
      return gz;
    case 35680:
    // SAMPLER_CUBE
    case 36300:
    // INT_SAMPLER_CUBE
    case 36308:
    // UNSIGNED_INT_SAMPLER_CUBE
    case 36293:
      return _z;
    case 36289:
    // SAMPLER_2D_ARRAY
    case 36303:
    // INT_SAMPLER_2D_ARRAY
    case 36311:
    // UNSIGNED_INT_SAMPLER_2D_ARRAY
    case 36292:
      return xz;
  }
}
class vz {
  constructor(e, t, n) {
    this.id = e, this.addr = n, this.cache = [], this.type = t.type, this.setValue = ez(t.type);
  }
}
class bz {
  constructor(e, t, n) {
    this.id = e, this.addr = n, this.cache = [], this.type = t.type, this.size = t.size, this.setValue = yz(t.type);
  }
}
class Sz {
  constructor(e) {
    this.id = e, this.seq = [], this.map = {};
  }
  setValue(e, t, n) {
    const r = this.seq;
    for (let s = 0, o = r.length; s !== o; ++s) {
      const a = r[s];
      a.setValue(e, t[a.id], n);
    }
  }
}
const Ey = /(\w+)(\])?(\[|\.)?/g;
function EE(i, e) {
  i.seq.push(e), i.map[e.id] = e;
}
function Tz(i, e, t) {
  const n = i.name, r = n.length;
  for (Ey.lastIndex = 0; ; ) {
    const s = Ey.exec(n), o = Ey.lastIndex;
    let a = s[1];
    const l = s[2] === "]", u = s[3];
    if (l && (a = a | 0), u === void 0 || u === "[" && o + 2 === r) {
      EE(t, u === void 0 ? new vz(a, i, e) : new bz(a, i, e));
      break;
    } else {
      let A = t.map[a];
      A === void 0 && (A = new Sz(a), EE(t, A)), t = A;
    }
  }
}
class jg {
  constructor(e, t) {
    this.seq = [], this.map = {};
    const n = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
    for (let o = 0; o < n; ++o) {
      const a = e.getActiveUniform(t, o), l = e.getUniformLocation(t, a.name);
      Tz(a, l, this);
    }
    const r = [], s = [];
    for (const o of this.seq)
      o.type === e.SAMPLER_2D_SHADOW || o.type === e.SAMPLER_CUBE_SHADOW || o.type === e.SAMPLER_2D_ARRAY_SHADOW ? r.push(o) : s.push(o);
    r.length > 0 && (this.seq = r.concat(s));
  }
  setValue(e, t, n, r) {
    const s = this.map[t];
    s !== void 0 && s.setValue(e, n, r);
  }
  setOptional(e, t, n) {
    const r = t[n];
    r !== void 0 && this.setValue(e, n, r);
  }
  static upload(e, t, n, r) {
    for (let s = 0, o = t.length; s !== o; ++s) {
      const a = t[s], l = n[a.id];
      l.needsUpdate !== !1 && a.setValue(e, l.value, r);
    }
  }
  static seqWithValue(e, t) {
    const n = [];
    for (let r = 0, s = e.length; r !== s; ++r) {
      const o = e[r];
      o.id in t && n.push(o);
    }
    return n;
  }
}
function RE(i, e, t) {
  const n = i.createShader(e);
  return i.shaderSource(n, t), i.compileShader(n), n;
}
const wz = 37297;
let Mz = 0;
function Ez(i, e) {
  const t = i.split(`
`), n = [], r = Math.max(e - 6, 0), s = Math.min(e + 6, t.length);
  for (let o = r; o < s; o++) {
    const a = o + 1;
    n.push(`${a === e ? ">" : " "} ${a}: ${t[o]}`);
  }
  return n.join(`
`);
}
const CE = /* @__PURE__ */ new fn();
function Rz(i) {
  Xt._getMatrix(CE, Xt.workingColorSpace, i);
  const e = `mat3( ${CE.elements.map((t) => t.toFixed(4))} )`;
  switch (Xt.getTransfer(i)) {
    case Vh:
      return [e, "LinearTransferOETF"];
    case vt:
      return [e, "sRGBTransferOETF"];
    default:
      return Me("WebGLProgram: Unsupported color space: ", i), [e, "LinearTransferOETF"];
  }
}
function PE(i, e, t) {
  const n = i.getShaderParameter(e, i.COMPILE_STATUS), s = (i.getShaderInfoLog(e) || "").trim();
  if (n && s === "") return "";
  const o = /ERROR: 0:(\d+)/.exec(s);
  if (o) {
    const a = parseInt(o[1]);
    return t.toUpperCase() + `

` + s + `

` + Ez(i.getShaderSource(e), a);
  } else
    return s;
}
function Cz(i, e) {
  const t = Rz(e);
  return [
    `vec4 ${i}( vec4 value ) {`,
    `	return ${t[1]}( vec4( value.rgb * ${t[0]}, value.a ) );`,
    "}"
  ].join(`
`);
}
const Pz = {
  [L_]: "Linear",
  [I_]: "Reinhard",
  [B_]: "Cineon",
  [F_]: "ACESFilmic",
  [U_]: "AgX",
  [O_]: "Neutral",
  [T3]: "Custom"
};
function Nz(i, e) {
  const t = Pz[e];
  return t === void 0 ? (Me("WebGLProgram: Unsupported toneMapping:", e), "vec3 " + i + "( vec3 color ) { return LinearToneMapping( color ); }") : "vec3 " + i + "( vec3 color ) { return " + t + "ToneMapping( color ); }";
}
const jm = /* @__PURE__ */ new j();
function Dz() {
  Xt.getLuminanceCoefficients(jm);
  const i = jm.x.toFixed(4), e = jm.y.toFixed(4), t = jm.z.toFixed(4);
  return [
    "float luminance( const in vec3 rgb ) {",
    `	const vec3 weights = vec3( ${i}, ${e}, ${t} );`,
    "	return dot( weights, rgb );",
    "}"
  ].join(`
`);
}
function Lz(i) {
  return [
    i.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "",
    i.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""
  ].filter(cp).join(`
`);
}
function Iz(i) {
  const e = [];
  for (const t in i) {
    const n = i[t];
    n !== !1 && e.push("#define " + t + " " + n);
  }
  return e.join(`
`);
}
function Bz(i, e) {
  const t = {}, n = i.getProgramParameter(e, i.ACTIVE_ATTRIBUTES);
  for (let r = 0; r < n; r++) {
    const s = i.getActiveAttrib(e, r), o = s.name;
    let a = 1;
    s.type === i.FLOAT_MAT2 && (a = 2), s.type === i.FLOAT_MAT3 && (a = 3), s.type === i.FLOAT_MAT4 && (a = 4), t[o] = {
      type: s.type,
      location: i.getAttribLocation(e, o),
      locationSize: a
    };
  }
  return t;
}
function cp(i) {
  return i !== "";
}
function NE(i, e) {
  const t = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
  return i.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, t).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function DE(i, e) {
  return i.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection);
}
const Fz = /^[ \t]*#include +<([\w\d./]+)>/gm;
function jv(i) {
  return i.replace(Fz, Oz);
}
const Uz = /* @__PURE__ */ new Map();
function Oz(i, e) {
  let t = _n[e];
  if (t === void 0) {
    const n = Uz.get(e);
    if (n !== void 0)
      t = _n[n], Me('WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', e, n);
    else
      throw new Error("Can not resolve #include <" + e + ">");
  }
  return jv(t);
}
const kz = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function LE(i) {
  return i.replace(kz, Vz);
}
function Vz(i, e, t, n) {
  let r = "";
  for (let s = parseInt(e); s < parseInt(t); s++)
    r += n.replace(/\[\s*i\s*\]/g, "[ " + s + " ]").replace(/UNROLLED_LOOP_INDEX/g, s);
  return r;
}
function IE(i) {
  let e = `precision ${i.precision} float;
	precision ${i.precision} int;
	precision ${i.precision} sampler2D;
	precision ${i.precision} samplerCube;
	precision ${i.precision} sampler3D;
	precision ${i.precision} sampler2DArray;
	precision ${i.precision} sampler2DShadow;
	precision ${i.precision} samplerCubeShadow;
	precision ${i.precision} sampler2DArrayShadow;
	precision ${i.precision} isampler2D;
	precision ${i.precision} isampler3D;
	precision ${i.precision} isamplerCube;
	precision ${i.precision} isampler2DArray;
	precision ${i.precision} usampler2D;
	precision ${i.precision} usampler3D;
	precision ${i.precision} usamplerCube;
	precision ${i.precision} usampler2DArray;
	`;
  return i.precision === "highp" ? e += `
#define HIGH_PRECISION` : i.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : i.precision === "lowp" && (e += `
#define LOW_PRECISION`), e;
}
const Gz = {
  [Af]: "SHADOWMAP_TYPE_PCF",
  [$a]: "SHADOWMAP_TYPE_VSM"
};
function zz(i) {
  return Gz[i.shadowMapType] || "SHADOWMAP_TYPE_BASIC";
}
const qz = {
  [no]: "ENVMAP_TYPE_CUBE",
  [qo]: "ENVMAP_TYPE_CUBE",
  [Gl]: "ENVMAP_TYPE_CUBE_UV"
};
function Hz(i) {
  return i.envMap === !1 ? "ENVMAP_TYPE_CUBE" : qz[i.envMapMode] || "ENVMAP_TYPE_CUBE";
}
const Wz = {
  [qo]: "ENVMAP_MODE_REFRACTION"
};
function $z(i) {
  return i.envMap === !1 ? "ENVMAP_MODE_REFLECTION" : Wz[i.envMapMode] || "ENVMAP_MODE_REFLECTION";
}
const jz = {
  [tA]: "ENVMAP_BLENDING_MULTIPLY",
  [b3]: "ENVMAP_BLENDING_MIX",
  [S3]: "ENVMAP_BLENDING_ADD"
};
function Xz(i) {
  return i.envMap === !1 ? "ENVMAP_BLENDING_NONE" : jz[i.combine] || "ENVMAP_BLENDING_NONE";
}
function Yz(i) {
  const e = i.envMapCubeUVHeight;
  if (e === null) return null;
  const t = Math.log2(e) - 2, n = 1 / e;
  return { texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 112)), texelHeight: n, maxMip: t };
}
function Qz(i, e, t, n) {
  const r = i.getContext(), s = t.defines;
  let o = t.vertexShader, a = t.fragmentShader;
  const l = zz(t), u = Hz(t), c = $z(t), A = Xz(t), m = Yz(t), _ = Lz(t), y = Iz(s), T = r.createProgram();
  let b, S, E = t.glslVersion ? "#version " + t.glslVersion + `
` : "";
  t.isRawShaderMaterial ? (b = [
    "#define SHADER_TYPE " + t.shaderType,
    "#define SHADER_NAME " + t.shaderName,
    y
  ].filter(cp).join(`
`), b.length > 0 && (b += `
`), S = [
    "#define SHADER_TYPE " + t.shaderType,
    "#define SHADER_NAME " + t.shaderName,
    y
  ].filter(cp).join(`
`), S.length > 0 && (S += `
`)) : (b = [
    IE(t),
    "#define SHADER_TYPE " + t.shaderType,
    "#define SHADER_NAME " + t.shaderName,
    y,
    t.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "",
    t.batching ? "#define USE_BATCHING" : "",
    t.batchingColor ? "#define USE_BATCHING_COLOR" : "",
    t.instancing ? "#define USE_INSTANCING" : "",
    t.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
    t.instancingMorph ? "#define USE_INSTANCING_MORPH" : "",
    t.useFog && t.fog ? "#define USE_FOG" : "",
    t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
    t.map ? "#define USE_MAP" : "",
    t.envMap ? "#define USE_ENVMAP" : "",
    t.envMap ? "#define " + c : "",
    t.lightMap ? "#define USE_LIGHTMAP" : "",
    t.aoMap ? "#define USE_AOMAP" : "",
    t.bumpMap ? "#define USE_BUMPMAP" : "",
    t.normalMap ? "#define USE_NORMALMAP" : "",
    t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
    t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
    t.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
    t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    t.anisotropy ? "#define USE_ANISOTROPY" : "",
    t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
    t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
    t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
    t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
    t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
    t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
    t.specularMap ? "#define USE_SPECULARMAP" : "",
    t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
    t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
    t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    t.metalnessMap ? "#define USE_METALNESSMAP" : "",
    t.alphaMap ? "#define USE_ALPHAMAP" : "",
    t.alphaHash ? "#define USE_ALPHAHASH" : "",
    t.transmission ? "#define USE_TRANSMISSION" : "",
    t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
    t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
    t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
    t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
    //
    t.mapUv ? "#define MAP_UV " + t.mapUv : "",
    t.alphaMapUv ? "#define ALPHAMAP_UV " + t.alphaMapUv : "",
    t.lightMapUv ? "#define LIGHTMAP_UV " + t.lightMapUv : "",
    t.aoMapUv ? "#define AOMAP_UV " + t.aoMapUv : "",
    t.emissiveMapUv ? "#define EMISSIVEMAP_UV " + t.emissiveMapUv : "",
    t.bumpMapUv ? "#define BUMPMAP_UV " + t.bumpMapUv : "",
    t.normalMapUv ? "#define NORMALMAP_UV " + t.normalMapUv : "",
    t.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + t.displacementMapUv : "",
    t.metalnessMapUv ? "#define METALNESSMAP_UV " + t.metalnessMapUv : "",
    t.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + t.roughnessMapUv : "",
    t.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + t.anisotropyMapUv : "",
    t.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + t.clearcoatMapUv : "",
    t.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + t.clearcoatNormalMapUv : "",
    t.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + t.clearcoatRoughnessMapUv : "",
    t.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + t.iridescenceMapUv : "",
    t.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + t.iridescenceThicknessMapUv : "",
    t.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + t.sheenColorMapUv : "",
    t.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + t.sheenRoughnessMapUv : "",
    t.specularMapUv ? "#define SPECULARMAP_UV " + t.specularMapUv : "",
    t.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + t.specularColorMapUv : "",
    t.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + t.specularIntensityMapUv : "",
    t.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + t.transmissionMapUv : "",
    t.thicknessMapUv ? "#define THICKNESSMAP_UV " + t.thicknessMapUv : "",
    //
    t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "",
    t.vertexColors ? "#define USE_COLOR" : "",
    t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
    t.vertexUv1s ? "#define USE_UV1" : "",
    t.vertexUv2s ? "#define USE_UV2" : "",
    t.vertexUv3s ? "#define USE_UV3" : "",
    t.pointsUvs ? "#define USE_POINTS_UV" : "",
    t.flatShading ? "#define FLAT_SHADED" : "",
    t.skinning ? "#define USE_SKINNING" : "",
    t.morphTargets ? "#define USE_MORPHTARGETS" : "",
    t.morphNormals && t.flatShading === !1 ? "#define USE_MORPHNORMALS" : "",
    t.morphColors ? "#define USE_MORPHCOLORS" : "",
    t.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride : "",
    t.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount : "",
    t.doubleSided ? "#define DOUBLE_SIDED" : "",
    t.flipSided ? "#define FLIP_SIDED" : "",
    t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    t.shadowMapEnabled ? "#define " + l : "",
    t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
    t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
    t.logarithmicDepthBuffer ? "#define USE_LOGARITHMIC_DEPTH_BUFFER" : "",
    t.reversedDepthBuffer ? "#define USE_REVERSED_DEPTH_BUFFER" : "",
    "uniform mat4 modelMatrix;",
    "uniform mat4 modelViewMatrix;",
    "uniform mat4 projectionMatrix;",
    "uniform mat4 viewMatrix;",
    "uniform mat3 normalMatrix;",
    "uniform vec3 cameraPosition;",
    "uniform bool isOrthographic;",
    "#ifdef USE_INSTANCING",
    "	attribute mat4 instanceMatrix;",
    "#endif",
    "#ifdef USE_INSTANCING_COLOR",
    "	attribute vec3 instanceColor;",
    "#endif",
    "#ifdef USE_INSTANCING_MORPH",
    "	uniform sampler2D morphTexture;",
    "#endif",
    "attribute vec3 position;",
    "attribute vec3 normal;",
    "attribute vec2 uv;",
    "#ifdef USE_UV1",
    "	attribute vec2 uv1;",
    "#endif",
    "#ifdef USE_UV2",
    "	attribute vec2 uv2;",
    "#endif",
    "#ifdef USE_UV3",
    "	attribute vec2 uv3;",
    "#endif",
    "#ifdef USE_TANGENT",
    "	attribute vec4 tangent;",
    "#endif",
    "#if defined( USE_COLOR_ALPHA )",
    "	attribute vec4 color;",
    "#elif defined( USE_COLOR )",
    "	attribute vec3 color;",
    "#endif",
    "#ifdef USE_SKINNING",
    "	attribute vec4 skinIndex;",
    "	attribute vec4 skinWeight;",
    "#endif",
    `
`
  ].filter(cp).join(`
`), S = [
    IE(t),
    "#define SHADER_TYPE " + t.shaderType,
    "#define SHADER_NAME " + t.shaderName,
    y,
    t.useFog && t.fog ? "#define USE_FOG" : "",
    t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
    t.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "",
    t.map ? "#define USE_MAP" : "",
    t.matcap ? "#define USE_MATCAP" : "",
    t.envMap ? "#define USE_ENVMAP" : "",
    t.envMap ? "#define " + u : "",
    t.envMap ? "#define " + c : "",
    t.envMap ? "#define " + A : "",
    m ? "#define CUBEUV_TEXEL_WIDTH " + m.texelWidth : "",
    m ? "#define CUBEUV_TEXEL_HEIGHT " + m.texelHeight : "",
    m ? "#define CUBEUV_MAX_MIP " + m.maxMip + ".0" : "",
    t.lightMap ? "#define USE_LIGHTMAP" : "",
    t.aoMap ? "#define USE_AOMAP" : "",
    t.bumpMap ? "#define USE_BUMPMAP" : "",
    t.normalMap ? "#define USE_NORMALMAP" : "",
    t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
    t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
    t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
    t.anisotropy ? "#define USE_ANISOTROPY" : "",
    t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
    t.clearcoat ? "#define USE_CLEARCOAT" : "",
    t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
    t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
    t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
    t.dispersion ? "#define USE_DISPERSION" : "",
    t.iridescence ? "#define USE_IRIDESCENCE" : "",
    t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
    t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
    t.specularMap ? "#define USE_SPECULARMAP" : "",
    t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
    t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
    t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
    t.metalnessMap ? "#define USE_METALNESSMAP" : "",
    t.alphaMap ? "#define USE_ALPHAMAP" : "",
    t.alphaTest ? "#define USE_ALPHATEST" : "",
    t.alphaHash ? "#define USE_ALPHAHASH" : "",
    t.sheen ? "#define USE_SHEEN" : "",
    t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
    t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
    t.transmission ? "#define USE_TRANSMISSION" : "",
    t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
    t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
    t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "",
    t.vertexColors || t.instancingColor || t.batchingColor ? "#define USE_COLOR" : "",
    t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
    t.vertexUv1s ? "#define USE_UV1" : "",
    t.vertexUv2s ? "#define USE_UV2" : "",
    t.vertexUv3s ? "#define USE_UV3" : "",
    t.pointsUvs ? "#define USE_POINTS_UV" : "",
    t.gradientMap ? "#define USE_GRADIENTMAP" : "",
    t.flatShading ? "#define FLAT_SHADED" : "",
    t.doubleSided ? "#define DOUBLE_SIDED" : "",
    t.flipSided ? "#define FLIP_SIDED" : "",
    t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
    t.shadowMapEnabled ? "#define " + l : "",
    t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
    t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
    t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
    t.decodeVideoTextureEmissive ? "#define DECODE_VIDEO_TEXTURE_EMISSIVE" : "",
    t.logarithmicDepthBuffer ? "#define USE_LOGARITHMIC_DEPTH_BUFFER" : "",
    t.reversedDepthBuffer ? "#define USE_REVERSED_DEPTH_BUFFER" : "",
    "uniform mat4 viewMatrix;",
    "uniform vec3 cameraPosition;",
    "uniform bool isOrthographic;",
    t.toneMapping !== Dr ? "#define TONE_MAPPING" : "",
    t.toneMapping !== Dr ? _n.tonemapping_pars_fragment : "",
    // this code is required here because it is used by the toneMapping() function defined below
    t.toneMapping !== Dr ? Nz("toneMapping", t.toneMapping) : "",
    t.dithering ? "#define DITHERING" : "",
    t.opaque ? "#define OPAQUE" : "",
    _n.colorspace_pars_fragment,
    // this code is required here because it is used by the various encoding/decoding function defined below
    Cz("linearToOutputTexel", t.outputColorSpace),
    Dz(),
    t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "",
    `
`
  ].filter(cp).join(`
`)), o = jv(o), o = NE(o, t), o = DE(o, t), a = jv(a), a = NE(a, t), a = DE(a, t), o = LE(o), a = LE(a), t.isRawShaderMaterial !== !0 && (E = `#version 300 es
`, b = [
    _,
    "#define attribute in",
    "#define varying out",
    "#define texture2D texture"
  ].join(`
`) + `
` + b, S = [
    "#define varying in",
    t.glslVersion === Uv ? "" : "layout(location = 0) out highp vec4 pc_fragColor;",
    t.glslVersion === Uv ? "" : "#define gl_FragColor pc_fragColor",
    "#define gl_FragDepthEXT gl_FragDepth",
    "#define texture2D texture",
    "#define textureCube texture",
    "#define texture2DProj textureProj",
    "#define texture2DLodEXT textureLod",
    "#define texture2DProjLodEXT textureProjLod",
    "#define textureCubeLodEXT textureLod",
    "#define texture2DGradEXT textureGrad",
    "#define texture2DProjGradEXT textureProjGrad",
    "#define textureCubeGradEXT textureGrad"
  ].join(`
`) + `
` + S);
  const R = E + b + o, C = E + S + a, L = RE(r, r.VERTEX_SHADER, R), D = RE(r, r.FRAGMENT_SHADER, C);
  r.attachShader(T, L), r.attachShader(T, D), t.index0AttributeName !== void 0 ? r.bindAttribLocation(T, 0, t.index0AttributeName) : t.morphTargets === !0 && r.bindAttribLocation(T, 0, "position"), r.linkProgram(T);
  function B(G) {
    if (i.debug.checkShaderErrors) {
      const H = r.getProgramInfoLog(T) || "", Y = r.getShaderInfoLog(L) || "", K = r.getShaderInfoLog(D) || "", X = H.trim(), ee = Y.trim(), oe = K.trim();
      let fe = !0, _e = !0;
      if (r.getProgramParameter(T, r.LINK_STATUS) === !1)
        if (fe = !1, typeof i.debug.onShaderError == "function")
          i.debug.onShaderError(r, T, L, D);
        else {
          const Te = PE(r, L, "vertex"), Ce = PE(r, D, "fragment");
          Ie(
            "THREE.WebGLProgram: Shader Error " + r.getError() + " - VALIDATE_STATUS " + r.getProgramParameter(T, r.VALIDATE_STATUS) + `

Material Name: ` + G.name + `
Material Type: ` + G.type + `

Program Info Log: ` + X + `
` + Te + `
` + Ce
          );
        }
      else X !== "" ? Me("WebGLProgram: Program Info Log:", X) : (ee === "" || oe === "") && (_e = !1);
      _e && (G.diagnostics = {
        runnable: fe,
        programLog: X,
        vertexShader: {
          log: ee,
          prefix: b
        },
        fragmentShader: {
          log: oe,
          prefix: S
        }
      });
    }
    r.deleteShader(L), r.deleteShader(D), U = new jg(r, T), N = Bz(r, T);
  }
  let U;
  this.getUniforms = function() {
    return U === void 0 && B(this), U;
  };
  let N;
  this.getAttributes = function() {
    return N === void 0 && B(this), N;
  };
  let O = t.rendererExtensionParallelShaderCompile === !1;
  return this.isReady = function() {
    return O === !1 && (O = r.getProgramParameter(T, wz)), O;
  }, this.destroy = function() {
    n.releaseStatesOfProgram(this), r.deleteProgram(T), this.program = void 0;
  }, this.type = t.shaderType, this.name = t.shaderName, this.id = Mz++, this.cacheKey = e, this.usedTimes = 1, this.program = T, this.vertexShader = L, this.fragmentShader = D, this;
}
let Kz = 0;
class Zz {
  constructor() {
    this.shaderCache = /* @__PURE__ */ new Map(), this.materialCache = /* @__PURE__ */ new Map();
  }
  update(e) {
    const t = e.vertexShader, n = e.fragmentShader, r = this._getShaderStage(t), s = this._getShaderStage(n), o = this._getShaderCacheForMaterial(e);
    return o.has(r) === !1 && (o.add(r), r.usedTimes++), o.has(s) === !1 && (o.add(s), s.usedTimes++), this;
  }
  remove(e) {
    const t = this.materialCache.get(e);
    for (const n of t)
      n.usedTimes--, n.usedTimes === 0 && this.shaderCache.delete(n.code);
    return this.materialCache.delete(e), this;
  }
  getVertexShaderID(e) {
    return this._getShaderStage(e.vertexShader).id;
  }
  getFragmentShaderID(e) {
    return this._getShaderStage(e.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  _getShaderCacheForMaterial(e) {
    const t = this.materialCache;
    let n = t.get(e);
    return n === void 0 && (n = /* @__PURE__ */ new Set(), t.set(e, n)), n;
  }
  _getShaderStage(e) {
    const t = this.shaderCache;
    let n = t.get(e);
    return n === void 0 && (n = new Jz(e), t.set(e, n)), n;
  }
}
class Jz {
  constructor(e) {
    this.id = Kz++, this.code = e, this.usedTimes = 0;
  }
}
function eq(i, e, t, n, r, s, o) {
  const a = new j_(), l = new Zz(), u = /* @__PURE__ */ new Set(), c = [], A = /* @__PURE__ */ new Map(), m = r.logarithmicDepthBuffer;
  let _ = r.precision;
  const y = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distance",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite"
  };
  function T(N) {
    return u.add(N), N === 0 ? "uv" : `uv${N}`;
  }
  function b(N, O, G, H, Y) {
    const K = H.fog, X = Y.geometry, ee = N.isMeshStandardMaterial ? H.environment : null, oe = (N.isMeshStandardMaterial ? t : e).get(N.envMap || ee), fe = oe && oe.mapping === Gl ? oe.image.height : null, _e = y[N.type];
    N.precision !== null && (_ = r.getMaxPrecision(N.precision), _ !== N.precision && Me("WebGLProgram.getParameters:", N.precision, "not supported, using", _, "instead."));
    const Te = X.morphAttributes.position || X.morphAttributes.normal || X.morphAttributes.color, Ce = Te !== void 0 ? Te.length : 0;
    let Je = 0;
    X.morphAttributes.position !== void 0 && (Je = 1), X.morphAttributes.normal !== void 0 && (Je = 2), X.morphAttributes.color !== void 0 && (Je = 3);
    let Qe, zt, Tt, Pe;
    if (_e) {
      const $n = Es[_e];
      Qe = $n.vertexShader, zt = $n.fragmentShader;
    } else
      Qe = N.vertexShader, zt = N.fragmentShader, l.update(N), Tt = l.getVertexShaderID(N), Pe = l.getFragmentShaderID(N);
    const ke = i.getRenderTarget(), at = i.state.buffers.depth.getReversed(), wt = Y.isInstancedMesh === !0, ot = Y.isBatchedMesh === !0, Wt = !!N.map, en = !!N.matcap, z = !!oe, ue = !!N.aoMap, he = !!N.lightMap, Ee = !!N.bumpMap, Ye = !!N.normalMap, te = !!N.displacementMap, Et = !!N.emissiveMap, dt = !!N.metalnessMap, Nt = !!N.roughnessMap, rt = N.anisotropy > 0, ne = N.clearcoat > 0, W = N.dispersion > 0, ge = N.iridescence > 0, Fe = N.sheen > 0, We = N.transmission > 0, Oe = rt && !!N.anisotropyMap, kt = ne && !!N.clearcoatMap, ft = ne && !!N.clearcoatNormalMap, Ft = ne && !!N.clearcoatRoughnessMap, nn = ge && !!N.iridescenceMap, tt = ge && !!N.iridescenceThicknessMap, _t = Fe && !!N.sheenColorMap, Ut = Fe && !!N.sheenRoughnessMap, Vt = !!N.specularMap, pt = !!N.specularColorMap, Rn = !!N.specularIntensityMap, ie = We && !!N.transmissionMap, bt = We && !!N.thicknessMap, lt = !!N.gradientMap, Ct = !!N.alphaMap, it = N.alphaTest > 0, He = !!N.alphaHash, At = !!N.extensions;
    let pn = Dr;
    N.toneMapped && (ke === null || ke.isXRRenderTarget === !0) && (pn = i.toneMapping);
    const di = {
      shaderID: _e,
      shaderType: N.type,
      shaderName: N.name,
      vertexShader: Qe,
      fragmentShader: zt,
      defines: N.defines,
      customVertexShaderID: Tt,
      customFragmentShaderID: Pe,
      isRawShaderMaterial: N.isRawShaderMaterial === !0,
      glslVersion: N.glslVersion,
      precision: _,
      batching: ot,
      batchingColor: ot && Y._colorsTexture !== null,
      instancing: wt,
      instancingColor: wt && Y.instanceColor !== null,
      instancingMorph: wt && Y.morphTexture !== null,
      outputColorSpace: ke === null ? i.outputColorSpace : ke.isXRRenderTarget === !0 ? ke.texture.colorSpace : Hl,
      alphaToCoverage: !!N.alphaToCoverage,
      map: Wt,
      matcap: en,
      envMap: z,
      envMapMode: z && oe.mapping,
      envMapCubeUVHeight: fe,
      aoMap: ue,
      lightMap: he,
      bumpMap: Ee,
      normalMap: Ye,
      displacementMap: te,
      emissiveMap: Et,
      normalMapObjectSpace: Ye && N.normalMapType === M3,
      normalMapTangentSpace: Ye && N.normalMapType === xa,
      metalnessMap: dt,
      roughnessMap: Nt,
      anisotropy: rt,
      anisotropyMap: Oe,
      clearcoat: ne,
      clearcoatMap: kt,
      clearcoatNormalMap: ft,
      clearcoatRoughnessMap: Ft,
      dispersion: W,
      iridescence: ge,
      iridescenceMap: nn,
      iridescenceThicknessMap: tt,
      sheen: Fe,
      sheenColorMap: _t,
      sheenRoughnessMap: Ut,
      specularMap: Vt,
      specularColorMap: pt,
      specularIntensityMap: Rn,
      transmission: We,
      transmissionMap: ie,
      thicknessMap: bt,
      gradientMap: lt,
      opaque: N.transparent === !1 && N.blending === gs && N.alphaToCoverage === !1,
      alphaMap: Ct,
      alphaTest: it,
      alphaHash: He,
      combine: N.combine,
      //
      mapUv: Wt && T(N.map.channel),
      aoMapUv: ue && T(N.aoMap.channel),
      lightMapUv: he && T(N.lightMap.channel),
      bumpMapUv: Ee && T(N.bumpMap.channel),
      normalMapUv: Ye && T(N.normalMap.channel),
      displacementMapUv: te && T(N.displacementMap.channel),
      emissiveMapUv: Et && T(N.emissiveMap.channel),
      metalnessMapUv: dt && T(N.metalnessMap.channel),
      roughnessMapUv: Nt && T(N.roughnessMap.channel),
      anisotropyMapUv: Oe && T(N.anisotropyMap.channel),
      clearcoatMapUv: kt && T(N.clearcoatMap.channel),
      clearcoatNormalMapUv: ft && T(N.clearcoatNormalMap.channel),
      clearcoatRoughnessMapUv: Ft && T(N.clearcoatRoughnessMap.channel),
      iridescenceMapUv: nn && T(N.iridescenceMap.channel),
      iridescenceThicknessMapUv: tt && T(N.iridescenceThicknessMap.channel),
      sheenColorMapUv: _t && T(N.sheenColorMap.channel),
      sheenRoughnessMapUv: Ut && T(N.sheenRoughnessMap.channel),
      specularMapUv: Vt && T(N.specularMap.channel),
      specularColorMapUv: pt && T(N.specularColorMap.channel),
      specularIntensityMapUv: Rn && T(N.specularIntensityMap.channel),
      transmissionMapUv: ie && T(N.transmissionMap.channel),
      thicknessMapUv: bt && T(N.thicknessMap.channel),
      alphaMapUv: Ct && T(N.alphaMap.channel),
      //
      vertexTangents: !!X.attributes.tangent && (Ye || rt),
      vertexColors: N.vertexColors,
      vertexAlphas: N.vertexColors === !0 && !!X.attributes.color && X.attributes.color.itemSize === 4,
      pointsUvs: Y.isPoints === !0 && !!X.attributes.uv && (Wt || Ct),
      fog: !!K,
      useFog: N.fog === !0,
      fogExp2: !!K && K.isFogExp2,
      flatShading: N.flatShading === !0 && N.wireframe === !1,
      sizeAttenuation: N.sizeAttenuation === !0,
      logarithmicDepthBuffer: m,
      reversedDepthBuffer: at,
      skinning: Y.isSkinnedMesh === !0,
      morphTargets: X.morphAttributes.position !== void 0,
      morphNormals: X.morphAttributes.normal !== void 0,
      morphColors: X.morphAttributes.color !== void 0,
      morphTargetsCount: Ce,
      morphTextureStride: Je,
      numDirLights: O.directional.length,
      numPointLights: O.point.length,
      numSpotLights: O.spot.length,
      numSpotLightMaps: O.spotLightMap.length,
      numRectAreaLights: O.rectArea.length,
      numHemiLights: O.hemi.length,
      numDirLightShadows: O.directionalShadowMap.length,
      numPointLightShadows: O.pointShadowMap.length,
      numSpotLightShadows: O.spotShadowMap.length,
      numSpotLightShadowsWithMaps: O.numSpotLightShadowsWithMaps,
      numLightProbes: O.numLightProbes,
      numClippingPlanes: o.numPlanes,
      numClipIntersection: o.numIntersection,
      dithering: N.dithering,
      shadowMapEnabled: i.shadowMap.enabled && G.length > 0,
      shadowMapType: i.shadowMap.type,
      toneMapping: pn,
      decodeVideoTexture: Wt && N.map.isVideoTexture === !0 && Xt.getTransfer(N.map.colorSpace) === vt,
      decodeVideoTextureEmissive: Et && N.emissiveMap.isVideoTexture === !0 && Xt.getTransfer(N.emissiveMap.colorSpace) === vt,
      premultipliedAlpha: N.premultipliedAlpha,
      doubleSided: N.side === er,
      flipSided: N.side === si,
      useDepthPacking: N.depthPacking >= 0,
      depthPacking: N.depthPacking || 0,
      index0AttributeName: N.index0AttributeName,
      extensionClipCullDistance: At && N.extensions.clipCullDistance === !0 && n.has("WEBGL_clip_cull_distance"),
      extensionMultiDraw: (At && N.extensions.multiDraw === !0 || ot) && n.has("WEBGL_multi_draw"),
      rendererExtensionParallelShaderCompile: n.has("KHR_parallel_shader_compile"),
      customProgramCacheKey: N.customProgramCacheKey()
    };
    return di.vertexUv1s = u.has(1), di.vertexUv2s = u.has(2), di.vertexUv3s = u.has(3), u.clear(), di;
  }
  function S(N) {
    const O = [];
    if (N.shaderID ? O.push(N.shaderID) : (O.push(N.customVertexShaderID), O.push(N.customFragmentShaderID)), N.defines !== void 0)
      for (const G in N.defines)
        O.push(G), O.push(N.defines[G]);
    return N.isRawShaderMaterial === !1 && (E(O, N), R(O, N), O.push(i.outputColorSpace)), O.push(N.customProgramCacheKey), O.join();
  }
  function E(N, O) {
    N.push(O.precision), N.push(O.outputColorSpace), N.push(O.envMapMode), N.push(O.envMapCubeUVHeight), N.push(O.mapUv), N.push(O.alphaMapUv), N.push(O.lightMapUv), N.push(O.aoMapUv), N.push(O.bumpMapUv), N.push(O.normalMapUv), N.push(O.displacementMapUv), N.push(O.emissiveMapUv), N.push(O.metalnessMapUv), N.push(O.roughnessMapUv), N.push(O.anisotropyMapUv), N.push(O.clearcoatMapUv), N.push(O.clearcoatNormalMapUv), N.push(O.clearcoatRoughnessMapUv), N.push(O.iridescenceMapUv), N.push(O.iridescenceThicknessMapUv), N.push(O.sheenColorMapUv), N.push(O.sheenRoughnessMapUv), N.push(O.specularMapUv), N.push(O.specularColorMapUv), N.push(O.specularIntensityMapUv), N.push(O.transmissionMapUv), N.push(O.thicknessMapUv), N.push(O.combine), N.push(O.fogExp2), N.push(O.sizeAttenuation), N.push(O.morphTargetsCount), N.push(O.morphAttributeCount), N.push(O.numDirLights), N.push(O.numPointLights), N.push(O.numSpotLights), N.push(O.numSpotLightMaps), N.push(O.numHemiLights), N.push(O.numRectAreaLights), N.push(O.numDirLightShadows), N.push(O.numPointLightShadows), N.push(O.numSpotLightShadows), N.push(O.numSpotLightShadowsWithMaps), N.push(O.numLightProbes), N.push(O.shadowMapType), N.push(O.toneMapping), N.push(O.numClippingPlanes), N.push(O.numClipIntersection), N.push(O.depthPacking);
  }
  function R(N, O) {
    a.disableAll(), O.instancing && a.enable(0), O.instancingColor && a.enable(1), O.instancingMorph && a.enable(2), O.matcap && a.enable(3), O.envMap && a.enable(4), O.normalMapObjectSpace && a.enable(5), O.normalMapTangentSpace && a.enable(6), O.clearcoat && a.enable(7), O.iridescence && a.enable(8), O.alphaTest && a.enable(9), O.vertexColors && a.enable(10), O.vertexAlphas && a.enable(11), O.vertexUv1s && a.enable(12), O.vertexUv2s && a.enable(13), O.vertexUv3s && a.enable(14), O.vertexTangents && a.enable(15), O.anisotropy && a.enable(16), O.alphaHash && a.enable(17), O.batching && a.enable(18), O.dispersion && a.enable(19), O.batchingColor && a.enable(20), O.gradientMap && a.enable(21), N.push(a.mask), a.disableAll(), O.fog && a.enable(0), O.useFog && a.enable(1), O.flatShading && a.enable(2), O.logarithmicDepthBuffer && a.enable(3), O.reversedDepthBuffer && a.enable(4), O.skinning && a.enable(5), O.morphTargets && a.enable(6), O.morphNormals && a.enable(7), O.morphColors && a.enable(8), O.premultipliedAlpha && a.enable(9), O.shadowMapEnabled && a.enable(10), O.doubleSided && a.enable(11), O.flipSided && a.enable(12), O.useDepthPacking && a.enable(13), O.dithering && a.enable(14), O.transmission && a.enable(15), O.sheen && a.enable(16), O.opaque && a.enable(17), O.pointsUvs && a.enable(18), O.decodeVideoTexture && a.enable(19), O.decodeVideoTextureEmissive && a.enable(20), O.alphaToCoverage && a.enable(21), N.push(a.mask);
  }
  function C(N) {
    const O = y[N.type];
    let G;
    if (O) {
      const H = Es[O];
      G = v0.clone(H.uniforms);
    } else
      G = N.uniforms;
    return G;
  }
  function L(N, O) {
    let G = A.get(O);
    return G !== void 0 ? ++G.usedTimes : (G = new Qz(i, O, N, s), c.push(G), A.set(O, G)), G;
  }
  function D(N) {
    if (--N.usedTimes === 0) {
      const O = c.indexOf(N);
      c[O] = c[c.length - 1], c.pop(), A.delete(N.cacheKey), N.destroy();
    }
  }
  function B(N) {
    l.remove(N);
  }
  function U() {
    l.dispose();
  }
  return {
    getParameters: b,
    getProgramCacheKey: S,
    getUniforms: C,
    acquireProgram: L,
    releaseProgram: D,
    releaseShaderCache: B,
    // Exposed for resource monitoring & error feedback via renderer.info:
    programs: c,
    dispose: U
  };
}
function tq() {
  let i = /* @__PURE__ */ new WeakMap();
  function e(o) {
    return i.has(o);
  }
  function t(o) {
    let a = i.get(o);
    return a === void 0 && (a = {}, i.set(o, a)), a;
  }
  function n(o) {
    i.delete(o);
  }
  function r(o, a, l) {
    i.get(o)[a] = l;
  }
  function s() {
    i = /* @__PURE__ */ new WeakMap();
  }
  return {
    has: e,
    get: t,
    remove: n,
    update: r,
    dispose: s
  };
}
function nq(i, e) {
  return i.groupOrder !== e.groupOrder ? i.groupOrder - e.groupOrder : i.renderOrder !== e.renderOrder ? i.renderOrder - e.renderOrder : i.material.id !== e.material.id ? i.material.id - e.material.id : i.z !== e.z ? i.z - e.z : i.id - e.id;
}
function BE(i, e) {
  return i.groupOrder !== e.groupOrder ? i.groupOrder - e.groupOrder : i.renderOrder !== e.renderOrder ? i.renderOrder - e.renderOrder : i.z !== e.z ? e.z - i.z : i.id - e.id;
}
function FE() {
  const i = [];
  let e = 0;
  const t = [], n = [], r = [];
  function s() {
    e = 0, t.length = 0, n.length = 0, r.length = 0;
  }
  function o(A, m, _, y, T, b) {
    let S = i[e];
    return S === void 0 ? (S = {
      id: A.id,
      object: A,
      geometry: m,
      material: _,
      groupOrder: y,
      renderOrder: A.renderOrder,
      z: T,
      group: b
    }, i[e] = S) : (S.id = A.id, S.object = A, S.geometry = m, S.material = _, S.groupOrder = y, S.renderOrder = A.renderOrder, S.z = T, S.group = b), e++, S;
  }
  function a(A, m, _, y, T, b) {
    const S = o(A, m, _, y, T, b);
    _.transmission > 0 ? n.push(S) : _.transparent === !0 ? r.push(S) : t.push(S);
  }
  function l(A, m, _, y, T, b) {
    const S = o(A, m, _, y, T, b);
    _.transmission > 0 ? n.unshift(S) : _.transparent === !0 ? r.unshift(S) : t.unshift(S);
  }
  function u(A, m) {
    t.length > 1 && t.sort(A || nq), n.length > 1 && n.sort(m || BE), r.length > 1 && r.sort(m || BE);
  }
  function c() {
    for (let A = e, m = i.length; A < m; A++) {
      const _ = i[A];
      if (_.id === null) break;
      _.id = null, _.object = null, _.geometry = null, _.material = null, _.group = null;
    }
  }
  return {
    opaque: t,
    transmissive: n,
    transparent: r,
    init: s,
    push: a,
    unshift: l,
    finish: c,
    sort: u
  };
}
function iq() {
  let i = /* @__PURE__ */ new WeakMap();
  function e(n, r) {
    const s = i.get(n);
    let o;
    return s === void 0 ? (o = new FE(), i.set(n, [o])) : r >= s.length ? (o = new FE(), s.push(o)) : o = s[r], o;
  }
  function t() {
    i = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: e,
    dispose: t
  };
}
function rq() {
  const i = {};
  return {
    get: function(e) {
      if (i[e.id] !== void 0)
        return i[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = {
            direction: new j(),
            color: new ct()
          };
          break;
        case "SpotLight":
          t = {
            position: new j(),
            direction: new j(),
            color: new ct(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0
          };
          break;
        case "PointLight":
          t = {
            position: new j(),
            color: new ct(),
            distance: 0,
            decay: 0
          };
          break;
        case "HemisphereLight":
          t = {
            direction: new j(),
            skyColor: new ct(),
            groundColor: new ct()
          };
          break;
        case "RectAreaLight":
          t = {
            color: new ct(),
            position: new j(),
            halfWidth: new j(),
            halfHeight: new j()
          };
          break;
      }
      return i[e.id] = t, t;
    }
  };
}
function sq() {
  const i = {};
  return {
    get: function(e) {
      if (i[e.id] !== void 0)
        return i[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Le()
          };
          break;
        case "SpotLight":
          t = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Le()
          };
          break;
        case "PointLight":
          t = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Le(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3
          };
          break;
      }
      return i[e.id] = t, t;
    }
  };
}
let oq = 0;
function aq(i, e) {
  return (e.castShadow ? 2 : 0) - (i.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (i.map ? 1 : 0);
}
function lq(i) {
  const e = new rq(), t = sq(), n = {
    version: 0,
    hash: {
      directionalLength: -1,
      pointLength: -1,
      spotLength: -1,
      rectAreaLength: -1,
      hemiLength: -1,
      numDirectionalShadows: -1,
      numPointShadows: -1,
      numSpotShadows: -1,
      numSpotMaps: -1,
      numLightProbes: -1
    },
    ambient: [0, 0, 0],
    probe: [],
    directional: [],
    directionalShadow: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotLightMap: [],
    spotShadow: [],
    spotShadowMap: [],
    spotLightMatrix: [],
    rectArea: [],
    rectAreaLTC1: null,
    rectAreaLTC2: null,
    point: [],
    pointShadow: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: [],
    numSpotLightShadowsWithMaps: 0,
    numLightProbes: 0
  };
  for (let u = 0; u < 9; u++) n.probe.push(new j());
  const r = new j(), s = new Mt(), o = new Mt();
  function a(u) {
    let c = 0, A = 0, m = 0;
    for (let N = 0; N < 9; N++) n.probe[N].set(0, 0, 0);
    let _ = 0, y = 0, T = 0, b = 0, S = 0, E = 0, R = 0, C = 0, L = 0, D = 0, B = 0;
    u.sort(aq);
    for (let N = 0, O = u.length; N < O; N++) {
      const G = u[N], H = G.color, Y = G.intensity, K = G.distance;
      let X = null;
      if (G.shadow && G.shadow.map && (G.shadow.map.texture.format === fs ? X = G.shadow.map.texture : X = G.shadow.map.depthTexture || G.shadow.map.texture), G.isAmbientLight)
        c += H.r * Y, A += H.g * Y, m += H.b * Y;
      else if (G.isLightProbe) {
        for (let ee = 0; ee < 9; ee++)
          n.probe[ee].addScaledVector(G.sh.coefficients[ee], Y);
        B++;
      } else if (G.isDirectionalLight) {
        const ee = e.get(G);
        if (ee.color.copy(G.color).multiplyScalar(G.intensity), G.castShadow) {
          const oe = G.shadow, fe = t.get(G);
          fe.shadowIntensity = oe.intensity, fe.shadowBias = oe.bias, fe.shadowNormalBias = oe.normalBias, fe.shadowRadius = oe.radius, fe.shadowMapSize = oe.mapSize, n.directionalShadow[_] = fe, n.directionalShadowMap[_] = X, n.directionalShadowMatrix[_] = G.shadow.matrix, E++;
        }
        n.directional[_] = ee, _++;
      } else if (G.isSpotLight) {
        const ee = e.get(G);
        ee.position.setFromMatrixPosition(G.matrixWorld), ee.color.copy(H).multiplyScalar(Y), ee.distance = K, ee.coneCos = Math.cos(G.angle), ee.penumbraCos = Math.cos(G.angle * (1 - G.penumbra)), ee.decay = G.decay, n.spot[T] = ee;
        const oe = G.shadow;
        if (G.map && (n.spotLightMap[L] = G.map, L++, oe.updateMatrices(G), G.castShadow && D++), n.spotLightMatrix[T] = oe.matrix, G.castShadow) {
          const fe = t.get(G);
          fe.shadowIntensity = oe.intensity, fe.shadowBias = oe.bias, fe.shadowNormalBias = oe.normalBias, fe.shadowRadius = oe.radius, fe.shadowMapSize = oe.mapSize, n.spotShadow[T] = fe, n.spotShadowMap[T] = X, C++;
        }
        T++;
      } else if (G.isRectAreaLight) {
        const ee = e.get(G);
        ee.color.copy(H).multiplyScalar(Y), ee.halfWidth.set(G.width * 0.5, 0, 0), ee.halfHeight.set(0, G.height * 0.5, 0), n.rectArea[b] = ee, b++;
      } else if (G.isPointLight) {
        const ee = e.get(G);
        if (ee.color.copy(G.color).multiplyScalar(G.intensity), ee.distance = G.distance, ee.decay = G.decay, G.castShadow) {
          const oe = G.shadow, fe = t.get(G);
          fe.shadowIntensity = oe.intensity, fe.shadowBias = oe.bias, fe.shadowNormalBias = oe.normalBias, fe.shadowRadius = oe.radius, fe.shadowMapSize = oe.mapSize, fe.shadowCameraNear = oe.camera.near, fe.shadowCameraFar = oe.camera.far, n.pointShadow[y] = fe, n.pointShadowMap[y] = X, n.pointShadowMatrix[y] = G.shadow.matrix, R++;
        }
        n.point[y] = ee, y++;
      } else if (G.isHemisphereLight) {
        const ee = e.get(G);
        ee.skyColor.copy(G.color).multiplyScalar(Y), ee.groundColor.copy(G.groundColor).multiplyScalar(Y), n.hemi[S] = ee, S++;
      }
    }
    b > 0 && (i.has("OES_texture_float_linear") === !0 ? (n.rectAreaLTC1 = gt.LTC_FLOAT_1, n.rectAreaLTC2 = gt.LTC_FLOAT_2) : (n.rectAreaLTC1 = gt.LTC_HALF_1, n.rectAreaLTC2 = gt.LTC_HALF_2)), n.ambient[0] = c, n.ambient[1] = A, n.ambient[2] = m;
    const U = n.hash;
    (U.directionalLength !== _ || U.pointLength !== y || U.spotLength !== T || U.rectAreaLength !== b || U.hemiLength !== S || U.numDirectionalShadows !== E || U.numPointShadows !== R || U.numSpotShadows !== C || U.numSpotMaps !== L || U.numLightProbes !== B) && (n.directional.length = _, n.spot.length = T, n.rectArea.length = b, n.point.length = y, n.hemi.length = S, n.directionalShadow.length = E, n.directionalShadowMap.length = E, n.pointShadow.length = R, n.pointShadowMap.length = R, n.spotShadow.length = C, n.spotShadowMap.length = C, n.directionalShadowMatrix.length = E, n.pointShadowMatrix.length = R, n.spotLightMatrix.length = C + L - D, n.spotLightMap.length = L, n.numSpotLightShadowsWithMaps = D, n.numLightProbes = B, U.directionalLength = _, U.pointLength = y, U.spotLength = T, U.rectAreaLength = b, U.hemiLength = S, U.numDirectionalShadows = E, U.numPointShadows = R, U.numSpotShadows = C, U.numSpotMaps = L, U.numLightProbes = B, n.version = oq++);
  }
  function l(u, c) {
    let A = 0, m = 0, _ = 0, y = 0, T = 0;
    const b = c.matrixWorldInverse;
    for (let S = 0, E = u.length; S < E; S++) {
      const R = u[S];
      if (R.isDirectionalLight) {
        const C = n.directional[A];
        C.direction.setFromMatrixPosition(R.matrixWorld), r.setFromMatrixPosition(R.target.matrixWorld), C.direction.sub(r), C.direction.transformDirection(b), A++;
      } else if (R.isSpotLight) {
        const C = n.spot[_];
        C.position.setFromMatrixPosition(R.matrixWorld), C.position.applyMatrix4(b), C.direction.setFromMatrixPosition(R.matrixWorld), r.setFromMatrixPosition(R.target.matrixWorld), C.direction.sub(r), C.direction.transformDirection(b), _++;
      } else if (R.isRectAreaLight) {
        const C = n.rectArea[y];
        C.position.setFromMatrixPosition(R.matrixWorld), C.position.applyMatrix4(b), o.identity(), s.copy(R.matrixWorld), s.premultiply(b), o.extractRotation(s), C.halfWidth.set(R.width * 0.5, 0, 0), C.halfHeight.set(0, R.height * 0.5, 0), C.halfWidth.applyMatrix4(o), C.halfHeight.applyMatrix4(o), y++;
      } else if (R.isPointLight) {
        const C = n.point[m];
        C.position.setFromMatrixPosition(R.matrixWorld), C.position.applyMatrix4(b), m++;
      } else if (R.isHemisphereLight) {
        const C = n.hemi[T];
        C.direction.setFromMatrixPosition(R.matrixWorld), C.direction.transformDirection(b), T++;
      }
    }
  }
  return {
    setup: a,
    setupView: l,
    state: n
  };
}
function UE(i) {
  const e = new lq(i), t = [], n = [];
  function r(c) {
    u.camera = c, t.length = 0, n.length = 0;
  }
  function s(c) {
    t.push(c);
  }
  function o(c) {
    n.push(c);
  }
  function a() {
    e.setup(t);
  }
  function l(c) {
    e.setupView(t, c);
  }
  const u = {
    lightsArray: t,
    shadowsArray: n,
    camera: null,
    lights: e,
    transmissionRenderTarget: {}
  };
  return {
    init: r,
    state: u,
    setupLights: a,
    setupLightsView: l,
    pushLight: s,
    pushShadow: o
  };
}
function uq(i) {
  let e = /* @__PURE__ */ new WeakMap();
  function t(r, s = 0) {
    const o = e.get(r);
    let a;
    return o === void 0 ? (a = new UE(i), e.set(r, [a])) : s >= o.length ? (a = new UE(i), o.push(a)) : a = o[s], a;
  }
  function n() {
    e = /* @__PURE__ */ new WeakMap();
  }
  return {
    get: t,
    dispose: n
  };
}
const cq = `void main() {
	gl_Position = vec4( position, 1.0 );
}`, hq = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ).rg;
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ).r;
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( max( 0.0, squared_mean - mean * mean ) );
	gl_FragColor = vec4( mean, std_dev, 0.0, 1.0 );
}`, dq = [
  /* @__PURE__ */ new j(1, 0, 0),
  /* @__PURE__ */ new j(-1, 0, 0),
  /* @__PURE__ */ new j(0, 1, 0),
  /* @__PURE__ */ new j(0, -1, 0),
  /* @__PURE__ */ new j(0, 0, 1),
  /* @__PURE__ */ new j(0, 0, -1)
], fq = [
  /* @__PURE__ */ new j(0, -1, 0),
  /* @__PURE__ */ new j(0, -1, 0),
  /* @__PURE__ */ new j(0, 0, 1),
  /* @__PURE__ */ new j(0, 0, -1),
  /* @__PURE__ */ new j(0, -1, 0),
  /* @__PURE__ */ new j(0, -1, 0)
], OE = /* @__PURE__ */ new Mt(), UA = /* @__PURE__ */ new j(), Ry = /* @__PURE__ */ new j();
function Aq(i, e, t) {
  let n = new ec();
  const r = new Le(), s = new Le(), o = new Kt(), a = new Q3(), l = new K3(), u = {}, c = t.maxTextureSize, A = { [Zs]: si, [si]: Zs, [er]: er }, m = new Fr({
    defines: {
      VSM_SAMPLES: 8
    },
    uniforms: {
      shadow_pass: { value: null },
      resolution: { value: new Le() },
      radius: { value: 4 }
    },
    vertexShader: cq,
    fragmentShader: hq
  }), _ = m.clone();
  _.defines.HORIZONTAL_PASS = 1;
  const y = new Yt();
  y.setAttribute(
    "position",
    new Dn(
      new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]),
      3
    )
  );
  const T = new Tn(y, m), b = this;
  this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = Af;
  let S = this.type;
  this.render = function(D, B, U) {
    if (b.enabled === !1 || b.autoUpdate === !1 && b.needsUpdate === !1 || D.length === 0) return;
    D.type === p5 && (Me("WebGLShadowMap: PCFSoftShadowMap has been deprecated. Using PCFShadowMap instead."), D.type = Af);
    const N = i.getRenderTarget(), O = i.getActiveCubeFace(), G = i.getActiveMipmapLevel(), H = i.state;
    H.setBlending(ms), H.buffers.depth.getReversed() === !0 ? H.buffers.color.setClear(0, 0, 0, 0) : H.buffers.color.setClear(1, 1, 1, 1), H.buffers.depth.setTest(!0), H.setScissorTest(!1);
    const Y = S !== this.type;
    Y && B.traverse(function(K) {
      K.material && (Array.isArray(K.material) ? K.material.forEach((X) => X.needsUpdate = !0) : K.material.needsUpdate = !0);
    });
    for (let K = 0, X = D.length; K < X; K++) {
      const ee = D[K], oe = ee.shadow;
      if (oe === void 0) {
        Me("WebGLShadowMap:", ee, "has no shadow.");
        continue;
      }
      if (oe.autoUpdate === !1 && oe.needsUpdate === !1) continue;
      r.copy(oe.mapSize);
      const fe = oe.getFrameExtents();
      if (r.multiply(fe), s.copy(oe.mapSize), (r.x > c || r.y > c) && (r.x > c && (s.x = Math.floor(c / fe.x), r.x = s.x * fe.x, oe.mapSize.x = s.x), r.y > c && (s.y = Math.floor(c / fe.y), r.y = s.y * fe.y, oe.mapSize.y = s.y)), oe.map === null || Y === !0) {
        if (oe.map !== null && (oe.map.depthTexture !== null && (oe.map.depthTexture.dispose(), oe.map.depthTexture = null), oe.map.dispose()), this.type === $a) {
          if (ee.isPointLight) {
            Me("WebGLShadowMap: VSM shadow maps are not supported for PointLights. Use PCF or BasicShadowMap instead.");
            continue;
          }
          oe.map = new eo(r.x, r.y, {
            format: fs,
            type: Ri,
            minFilter: qn,
            magFilter: qn,
            generateMipmaps: !1
          }), oe.map.texture.name = ee.name + ".shadowMap", oe.map.depthTexture = new Qr(r.x, r.y, Ei), oe.map.depthTexture.name = ee.name + ".shadowMapDepth", oe.map.depthTexture.format = Lr, oe.map.depthTexture.compareFunction = null, oe.map.depthTexture.minFilter = ei, oe.map.depthTexture.magFilter = ei;
        } else {
          ee.isPointLight ? (oe.map = new Q_(r.x), oe.map.depthTexture = new B3(r.x, Jn)) : (oe.map = new eo(r.x, r.y), oe.map.depthTexture = new Qr(r.x, r.y, Jn)), oe.map.depthTexture.name = ee.name + ".shadowMap", oe.map.depthTexture.format = Lr;
          const Te = i.state.buffers.depth.getReversed();
          this.type === Af ? (oe.map.depthTexture.compareFunction = Te ? sA : rA, oe.map.depthTexture.minFilter = qn, oe.map.depthTexture.magFilter = qn) : (oe.map.depthTexture.compareFunction = null, oe.map.depthTexture.minFilter = ei, oe.map.depthTexture.magFilter = ei);
        }
        oe.camera.updateProjectionMatrix();
      }
      const _e = oe.map.isWebGLCubeRenderTarget ? 6 : 1;
      for (let Te = 0; Te < _e; Te++) {
        if (oe.map.isWebGLCubeRenderTarget)
          i.setRenderTarget(oe.map, Te), i.clear();
        else {
          Te === 0 && (i.setRenderTarget(oe.map), i.clear());
          const Ce = oe.getViewport(Te);
          o.set(
            s.x * Ce.x,
            s.y * Ce.y,
            s.x * Ce.z,
            s.y * Ce.w
          ), H.viewport(o);
        }
        if (ee.isPointLight) {
          const Ce = oe.camera, Je = oe.matrix, Qe = ee.distance || Ce.far;
          Qe !== Ce.far && (Ce.far = Qe, Ce.updateProjectionMatrix()), UA.setFromMatrixPosition(ee.matrixWorld), Ce.position.copy(UA), Ry.copy(Ce.position), Ry.add(dq[Te]), Ce.up.copy(fq[Te]), Ce.lookAt(Ry), Ce.updateMatrixWorld(), Je.makeTranslation(-UA.x, -UA.y, -UA.z), OE.multiplyMatrices(Ce.projectionMatrix, Ce.matrixWorldInverse), oe._frustum.setFromProjectionMatrix(OE, Ce.coordinateSystem, Ce.reversedDepth);
        } else
          oe.updateMatrices(ee);
        n = oe.getFrustum(), C(B, U, oe.camera, ee, this.type);
      }
      oe.isPointLightShadow !== !0 && this.type === $a && E(oe, U), oe.needsUpdate = !1;
    }
    S = this.type, b.needsUpdate = !1, i.setRenderTarget(N, O, G);
  };
  function E(D, B) {
    const U = e.update(T);
    m.defines.VSM_SAMPLES !== D.blurSamples && (m.defines.VSM_SAMPLES = D.blurSamples, _.defines.VSM_SAMPLES = D.blurSamples, m.needsUpdate = !0, _.needsUpdate = !0), D.mapPass === null && (D.mapPass = new eo(r.x, r.y, {
      format: fs,
      type: Ri
    })), m.uniforms.shadow_pass.value = D.map.depthTexture, m.uniforms.resolution.value = D.mapSize, m.uniforms.radius.value = D.radius, i.setRenderTarget(D.mapPass), i.clear(), i.renderBufferDirect(B, null, U, m, T, null), _.uniforms.shadow_pass.value = D.mapPass.texture, _.uniforms.resolution.value = D.mapSize, _.uniforms.radius.value = D.radius, i.setRenderTarget(D.map), i.clear(), i.renderBufferDirect(B, null, U, _, T, null);
  }
  function R(D, B, U, N) {
    let O = null;
    const G = U.isPointLight === !0 ? D.customDistanceMaterial : D.customDepthMaterial;
    if (G !== void 0)
      O = G;
    else if (O = U.isPointLight === !0 ? l : a, i.localClippingEnabled && B.clipShadows === !0 && Array.isArray(B.clippingPlanes) && B.clippingPlanes.length !== 0 || B.displacementMap && B.displacementScale !== 0 || B.alphaMap && B.alphaTest > 0 || B.map && B.alphaTest > 0 || B.alphaToCoverage === !0) {
      const H = O.uuid, Y = B.uuid;
      let K = u[H];
      K === void 0 && (K = {}, u[H] = K);
      let X = K[Y];
      X === void 0 && (X = O.clone(), K[Y] = X, B.addEventListener("dispose", L)), O = X;
    }
    if (O.visible = B.visible, O.wireframe = B.wireframe, N === $a ? O.side = B.shadowSide !== null ? B.shadowSide : B.side : O.side = B.shadowSide !== null ? B.shadowSide : A[B.side], O.alphaMap = B.alphaMap, O.alphaTest = B.alphaToCoverage === !0 ? 0.5 : B.alphaTest, O.map = B.map, O.clipShadows = B.clipShadows, O.clippingPlanes = B.clippingPlanes, O.clipIntersection = B.clipIntersection, O.displacementMap = B.displacementMap, O.displacementScale = B.displacementScale, O.displacementBias = B.displacementBias, O.wireframeLinewidth = B.wireframeLinewidth, O.linewidth = B.linewidth, U.isPointLight === !0 && O.isMeshDistanceMaterial === !0) {
      const H = i.properties.get(O);
      H.light = U;
    }
    return O;
  }
  function C(D, B, U, N, O) {
    if (D.visible === !1) return;
    if (D.layers.test(B.layers) && (D.isMesh || D.isLine || D.isPoints) && (D.castShadow || D.receiveShadow && O === $a) && (!D.frustumCulled || n.intersectsObject(D))) {
      D.modelViewMatrix.multiplyMatrices(U.matrixWorldInverse, D.matrixWorld);
      const Y = e.update(D), K = D.material;
      if (Array.isArray(K)) {
        const X = Y.groups;
        for (let ee = 0, oe = X.length; ee < oe; ee++) {
          const fe = X[ee], _e = K[fe.materialIndex];
          if (_e && _e.visible) {
            const Te = R(D, _e, N, O);
            D.onBeforeShadow(i, D, B, U, Y, Te, fe), i.renderBufferDirect(U, null, Y, Te, D, fe), D.onAfterShadow(i, D, B, U, Y, Te, fe);
          }
        }
      } else if (K.visible) {
        const X = R(D, K, N, O);
        D.onBeforeShadow(i, D, B, U, Y, X, null), i.renderBufferDirect(U, null, Y, X, D, null), D.onAfterShadow(i, D, B, U, Y, X, null);
      }
    }
    const H = D.children;
    for (let Y = 0, K = H.length; Y < K; Y++)
      C(H[Y], B, U, N, O);
  }
  function L(D) {
    D.target.removeEventListener("dispose", L);
    for (const U in u) {
      const N = u[U], O = D.target.uuid;
      O in N && (N[O].dispose(), delete N[O]);
    }
  }
}
const pq = {
  [Mf]: Ef,
  [Rf]: Nf,
  [Cf]: Df,
  [Vl]: Pf,
  [Ef]: Mf,
  [Nf]: Rf,
  [Df]: Cf,
  [Pf]: Vl
};
function mq(i, e) {
  function t() {
    let ie = !1;
    const bt = new Kt();
    let lt = null;
    const Ct = new Kt(0, 0, 0, 0);
    return {
      setMask: function(it) {
        lt !== it && !ie && (i.colorMask(it, it, it, it), lt = it);
      },
      setLocked: function(it) {
        ie = it;
      },
      setClear: function(it, He, At, pn, di) {
        di === !0 && (it *= pn, He *= pn, At *= pn), bt.set(it, He, At, pn), Ct.equals(bt) === !1 && (i.clearColor(it, He, At, pn), Ct.copy(bt));
      },
      reset: function() {
        ie = !1, lt = null, Ct.set(-1, 0, 0, 0);
      }
    };
  }
  function n() {
    let ie = !1, bt = !1, lt = null, Ct = null, it = null;
    return {
      setReversed: function(He) {
        if (bt !== He) {
          const At = e.get("EXT_clip_control");
          He ? At.clipControlEXT(At.LOWER_LEFT_EXT, At.ZERO_TO_ONE_EXT) : At.clipControlEXT(At.LOWER_LEFT_EXT, At.NEGATIVE_ONE_TO_ONE_EXT), bt = He;
          const pn = it;
          it = null, this.setClear(pn);
        }
      },
      getReversed: function() {
        return bt;
      },
      setTest: function(He) {
        He ? ke(i.DEPTH_TEST) : at(i.DEPTH_TEST);
      },
      setMask: function(He) {
        lt !== He && !ie && (i.depthMask(He), lt = He);
      },
      setFunc: function(He) {
        if (bt && (He = pq[He]), Ct !== He) {
          switch (He) {
            case Mf:
              i.depthFunc(i.NEVER);
              break;
            case Ef:
              i.depthFunc(i.ALWAYS);
              break;
            case Rf:
              i.depthFunc(i.LESS);
              break;
            case Vl:
              i.depthFunc(i.LEQUAL);
              break;
            case Cf:
              i.depthFunc(i.EQUAL);
              break;
            case Pf:
              i.depthFunc(i.GEQUAL);
              break;
            case Nf:
              i.depthFunc(i.GREATER);
              break;
            case Df:
              i.depthFunc(i.NOTEQUAL);
              break;
            default:
              i.depthFunc(i.LEQUAL);
          }
          Ct = He;
        }
      },
      setLocked: function(He) {
        ie = He;
      },
      setClear: function(He) {
        it !== He && (bt && (He = 1 - He), i.clearDepth(He), it = He);
      },
      reset: function() {
        ie = !1, lt = null, Ct = null, it = null, bt = !1;
      }
    };
  }
  function r() {
    let ie = !1, bt = null, lt = null, Ct = null, it = null, He = null, At = null, pn = null, di = null;
    return {
      setTest: function($n) {
        ie || ($n ? ke(i.STENCIL_TEST) : at(i.STENCIL_TEST));
      },
      setMask: function($n) {
        bt !== $n && !ie && (i.stencilMask($n), bt = $n);
      },
      setFunc: function($n, Os, es) {
        (lt !== $n || Ct !== Os || it !== es) && (i.stencilFunc($n, Os, es), lt = $n, Ct = Os, it = es);
      },
      setOp: function($n, Os, es) {
        (He !== $n || At !== Os || pn !== es) && (i.stencilOp($n, Os, es), He = $n, At = Os, pn = es);
      },
      setLocked: function($n) {
        ie = $n;
      },
      setClear: function($n) {
        di !== $n && (i.clearStencil($n), di = $n);
      },
      reset: function() {
        ie = !1, bt = null, lt = null, Ct = null, it = null, He = null, At = null, pn = null, di = null;
      }
    };
  }
  const s = new t(), o = new n(), a = new r(), l = /* @__PURE__ */ new WeakMap(), u = /* @__PURE__ */ new WeakMap();
  let c = {}, A = {}, m = /* @__PURE__ */ new WeakMap(), _ = [], y = null, T = !1, b = null, S = null, E = null, R = null, C = null, L = null, D = null, B = new ct(0, 0, 0), U = 0, N = !1, O = null, G = null, H = null, Y = null, K = null;
  const X = i.getParameter(i.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  let ee = !1, oe = 0;
  const fe = i.getParameter(i.VERSION);
  fe.indexOf("WebGL") !== -1 ? (oe = parseFloat(/^WebGL (\d)/.exec(fe)[1]), ee = oe >= 1) : fe.indexOf("OpenGL ES") !== -1 && (oe = parseFloat(/^OpenGL ES (\d)/.exec(fe)[1]), ee = oe >= 2);
  let _e = null, Te = {};
  const Ce = i.getParameter(i.SCISSOR_BOX), Je = i.getParameter(i.VIEWPORT), Qe = new Kt().fromArray(Ce), zt = new Kt().fromArray(Je);
  function Tt(ie, bt, lt, Ct) {
    const it = new Uint8Array(4), He = i.createTexture();
    i.bindTexture(ie, He), i.texParameteri(ie, i.TEXTURE_MIN_FILTER, i.NEAREST), i.texParameteri(ie, i.TEXTURE_MAG_FILTER, i.NEAREST);
    for (let At = 0; At < lt; At++)
      ie === i.TEXTURE_3D || ie === i.TEXTURE_2D_ARRAY ? i.texImage3D(bt, 0, i.RGBA, 1, 1, Ct, 0, i.RGBA, i.UNSIGNED_BYTE, it) : i.texImage2D(bt + At, 0, i.RGBA, 1, 1, 0, i.RGBA, i.UNSIGNED_BYTE, it);
    return He;
  }
  const Pe = {};
  Pe[i.TEXTURE_2D] = Tt(i.TEXTURE_2D, i.TEXTURE_2D, 1), Pe[i.TEXTURE_CUBE_MAP] = Tt(i.TEXTURE_CUBE_MAP, i.TEXTURE_CUBE_MAP_POSITIVE_X, 6), Pe[i.TEXTURE_2D_ARRAY] = Tt(i.TEXTURE_2D_ARRAY, i.TEXTURE_2D_ARRAY, 1, 1), Pe[i.TEXTURE_3D] = Tt(i.TEXTURE_3D, i.TEXTURE_3D, 1, 1), s.setClear(0, 0, 0, 1), o.setClear(1), a.setClear(0), ke(i.DEPTH_TEST), o.setFunc(Vl), Ee(!1), Ye(h1), ke(i.CULL_FACE), ue(ms);
  function ke(ie) {
    c[ie] !== !0 && (i.enable(ie), c[ie] = !0);
  }
  function at(ie) {
    c[ie] !== !1 && (i.disable(ie), c[ie] = !1);
  }
  function wt(ie, bt) {
    return A[ie] !== bt ? (i.bindFramebuffer(ie, bt), A[ie] = bt, ie === i.DRAW_FRAMEBUFFER && (A[i.FRAMEBUFFER] = bt), ie === i.FRAMEBUFFER && (A[i.DRAW_FRAMEBUFFER] = bt), !0) : !1;
  }
  function ot(ie, bt) {
    let lt = _, Ct = !1;
    if (ie) {
      lt = m.get(bt), lt === void 0 && (lt = [], m.set(bt, lt));
      const it = ie.textures;
      if (lt.length !== it.length || lt[0] !== i.COLOR_ATTACHMENT0) {
        for (let He = 0, At = it.length; He < At; He++)
          lt[He] = i.COLOR_ATTACHMENT0 + He;
        lt.length = it.length, Ct = !0;
      }
    } else
      lt[0] !== i.BACK && (lt[0] = i.BACK, Ct = !0);
    Ct && i.drawBuffers(lt);
  }
  function Wt(ie) {
    return y !== ie ? (i.useProgram(ie), y = ie, !0) : !1;
  }
  const en = {
    [Wr]: i.FUNC_ADD,
    [S_]: i.FUNC_SUBTRACT,
    [T_]: i.FUNC_REVERSE_SUBTRACT
  };
  en[y3] = i.MIN, en[v3] = i.MAX;
  const z = {
    [Ga]: i.ZERO,
    [w_]: i.ONE,
    [M_]: i.SRC_COLOR,
    [Tf]: i.SRC_ALPHA,
    [D_]: i.SRC_ALPHA_SATURATE,
    [P_]: i.DST_COLOR,
    [R_]: i.DST_ALPHA,
    [E_]: i.ONE_MINUS_SRC_COLOR,
    [wf]: i.ONE_MINUS_SRC_ALPHA,
    [N_]: i.ONE_MINUS_DST_COLOR,
    [C_]: i.ONE_MINUS_DST_ALPHA,
    [m5]: i.CONSTANT_COLOR,
    [g5]: i.ONE_MINUS_CONSTANT_COLOR,
    [_5]: i.CONSTANT_ALPHA,
    [x5]: i.ONE_MINUS_CONSTANT_ALPHA
  };
  function ue(ie, bt, lt, Ct, it, He, At, pn, di, $n) {
    if (ie === ms) {
      T === !0 && (at(i.BLEND), T = !1);
      return;
    }
    if (T === !1 && (ke(i.BLEND), T = !0), ie !== oh) {
      if (ie !== b || $n !== N) {
        if ((S !== Wr || C !== Wr) && (i.blendEquation(i.FUNC_ADD), S = Wr, C = Wr), $n)
          switch (ie) {
            case gs:
              i.blendFuncSeparate(i.ONE, i.ONE_MINUS_SRC_ALPHA, i.ONE, i.ONE_MINUS_SRC_ALPHA);
              break;
            case fh:
              i.blendFunc(i.ONE, i.ONE);
              break;
            case Ah:
              i.blendFuncSeparate(i.ZERO, i.ONE_MINUS_SRC_COLOR, i.ZERO, i.ONE);
              break;
            case ph:
              i.blendFuncSeparate(i.DST_COLOR, i.ONE_MINUS_SRC_ALPHA, i.ZERO, i.ONE);
              break;
            default:
              Ie("WebGLState: Invalid blending: ", ie);
              break;
          }
        else
          switch (ie) {
            case gs:
              i.blendFuncSeparate(i.SRC_ALPHA, i.ONE_MINUS_SRC_ALPHA, i.ONE, i.ONE_MINUS_SRC_ALPHA);
              break;
            case fh:
              i.blendFuncSeparate(i.SRC_ALPHA, i.ONE, i.ONE, i.ONE);
              break;
            case Ah:
              Ie("WebGLState: SubtractiveBlending requires material.premultipliedAlpha = true");
              break;
            case ph:
              Ie("WebGLState: MultiplyBlending requires material.premultipliedAlpha = true");
              break;
            default:
              Ie("WebGLState: Invalid blending: ", ie);
              break;
          }
        E = null, R = null, L = null, D = null, B.set(0, 0, 0), U = 0, b = ie, N = $n;
      }
      return;
    }
    it = it || bt, He = He || lt, At = At || Ct, (bt !== S || it !== C) && (i.blendEquationSeparate(en[bt], en[it]), S = bt, C = it), (lt !== E || Ct !== R || He !== L || At !== D) && (i.blendFuncSeparate(z[lt], z[Ct], z[He], z[At]), E = lt, R = Ct, L = He, D = At), (pn.equals(B) === !1 || di !== U) && (i.blendColor(pn.r, pn.g, pn.b, di), B.copy(pn), U = di), b = ie, N = !1;
  }
  function he(ie, bt) {
    ie.side === er ? at(i.CULL_FACE) : ke(i.CULL_FACE);
    let lt = ie.side === si;
    bt && (lt = !lt), Ee(lt), ie.blending === gs && ie.transparent === !1 ? ue(ms) : ue(ie.blending, ie.blendEquation, ie.blendSrc, ie.blendDst, ie.blendEquationAlpha, ie.blendSrcAlpha, ie.blendDstAlpha, ie.blendColor, ie.blendAlpha, ie.premultipliedAlpha), o.setFunc(ie.depthFunc), o.setTest(ie.depthTest), o.setMask(ie.depthWrite), s.setMask(ie.colorWrite);
    const Ct = ie.stencilWrite;
    a.setTest(Ct), Ct && (a.setMask(ie.stencilWriteMask), a.setFunc(ie.stencilFunc, ie.stencilRef, ie.stencilFuncMask), a.setOp(ie.stencilFail, ie.stencilZFail, ie.stencilZPass)), Et(ie.polygonOffset, ie.polygonOffsetFactor, ie.polygonOffsetUnits), ie.alphaToCoverage === !0 ? ke(i.SAMPLE_ALPHA_TO_COVERAGE) : at(i.SAMPLE_ALPHA_TO_COVERAGE);
  }
  function Ee(ie) {
    O !== ie && (ie ? i.frontFace(i.CW) : i.frontFace(i.CCW), O = ie);
  }
  function Ye(ie) {
    ie !== _3 ? (ke(i.CULL_FACE), ie !== G && (ie === h1 ? i.cullFace(i.BACK) : ie === x3 ? i.cullFace(i.FRONT) : i.cullFace(i.FRONT_AND_BACK))) : at(i.CULL_FACE), G = ie;
  }
  function te(ie) {
    ie !== H && (ee && i.lineWidth(ie), H = ie);
  }
  function Et(ie, bt, lt) {
    ie ? (ke(i.POLYGON_OFFSET_FILL), (Y !== bt || K !== lt) && (i.polygonOffset(bt, lt), Y = bt, K = lt)) : at(i.POLYGON_OFFSET_FILL);
  }
  function dt(ie) {
    ie ? ke(i.SCISSOR_TEST) : at(i.SCISSOR_TEST);
  }
  function Nt(ie) {
    ie === void 0 && (ie = i.TEXTURE0 + X - 1), _e !== ie && (i.activeTexture(ie), _e = ie);
  }
  function rt(ie, bt, lt) {
    lt === void 0 && (_e === null ? lt = i.TEXTURE0 + X - 1 : lt = _e);
    let Ct = Te[lt];
    Ct === void 0 && (Ct = { type: void 0, texture: void 0 }, Te[lt] = Ct), (Ct.type !== ie || Ct.texture !== bt) && (_e !== lt && (i.activeTexture(lt), _e = lt), i.bindTexture(ie, bt || Pe[ie]), Ct.type = ie, Ct.texture = bt);
  }
  function ne() {
    const ie = Te[_e];
    ie !== void 0 && ie.type !== void 0 && (i.bindTexture(ie.type, null), ie.type = void 0, ie.texture = void 0);
  }
  function W() {
    try {
      i.compressedTexImage2D(...arguments);
    } catch (ie) {
      Ie("WebGLState:", ie);
    }
  }
  function ge() {
    try {
      i.compressedTexImage3D(...arguments);
    } catch (ie) {
      Ie("WebGLState:", ie);
    }
  }
  function Fe() {
    try {
      i.texSubImage2D(...arguments);
    } catch (ie) {
      Ie("WebGLState:", ie);
    }
  }
  function We() {
    try {
      i.texSubImage3D(...arguments);
    } catch (ie) {
      Ie("WebGLState:", ie);
    }
  }
  function Oe() {
    try {
      i.compressedTexSubImage2D(...arguments);
    } catch (ie) {
      Ie("WebGLState:", ie);
    }
  }
  function kt() {
    try {
      i.compressedTexSubImage3D(...arguments);
    } catch (ie) {
      Ie("WebGLState:", ie);
    }
  }
  function ft() {
    try {
      i.texStorage2D(...arguments);
    } catch (ie) {
      Ie("WebGLState:", ie);
    }
  }
  function Ft() {
    try {
      i.texStorage3D(...arguments);
    } catch (ie) {
      Ie("WebGLState:", ie);
    }
  }
  function nn() {
    try {
      i.texImage2D(...arguments);
    } catch (ie) {
      Ie("WebGLState:", ie);
    }
  }
  function tt() {
    try {
      i.texImage3D(...arguments);
    } catch (ie) {
      Ie("WebGLState:", ie);
    }
  }
  function _t(ie) {
    Qe.equals(ie) === !1 && (i.scissor(ie.x, ie.y, ie.z, ie.w), Qe.copy(ie));
  }
  function Ut(ie) {
    zt.equals(ie) === !1 && (i.viewport(ie.x, ie.y, ie.z, ie.w), zt.copy(ie));
  }
  function Vt(ie, bt) {
    let lt = u.get(bt);
    lt === void 0 && (lt = /* @__PURE__ */ new WeakMap(), u.set(bt, lt));
    let Ct = lt.get(ie);
    Ct === void 0 && (Ct = i.getUniformBlockIndex(bt, ie.name), lt.set(ie, Ct));
  }
  function pt(ie, bt) {
    const Ct = u.get(bt).get(ie);
    l.get(bt) !== Ct && (i.uniformBlockBinding(bt, Ct, ie.__bindingPointIndex), l.set(bt, Ct));
  }
  function Rn() {
    i.disable(i.BLEND), i.disable(i.CULL_FACE), i.disable(i.DEPTH_TEST), i.disable(i.POLYGON_OFFSET_FILL), i.disable(i.SCISSOR_TEST), i.disable(i.STENCIL_TEST), i.disable(i.SAMPLE_ALPHA_TO_COVERAGE), i.blendEquation(i.FUNC_ADD), i.blendFunc(i.ONE, i.ZERO), i.blendFuncSeparate(i.ONE, i.ZERO, i.ONE, i.ZERO), i.blendColor(0, 0, 0, 0), i.colorMask(!0, !0, !0, !0), i.clearColor(0, 0, 0, 0), i.depthMask(!0), i.depthFunc(i.LESS), o.setReversed(!1), i.clearDepth(1), i.stencilMask(4294967295), i.stencilFunc(i.ALWAYS, 0, 4294967295), i.stencilOp(i.KEEP, i.KEEP, i.KEEP), i.clearStencil(0), i.cullFace(i.BACK), i.frontFace(i.CCW), i.polygonOffset(0, 0), i.activeTexture(i.TEXTURE0), i.bindFramebuffer(i.FRAMEBUFFER, null), i.bindFramebuffer(i.DRAW_FRAMEBUFFER, null), i.bindFramebuffer(i.READ_FRAMEBUFFER, null), i.useProgram(null), i.lineWidth(1), i.scissor(0, 0, i.canvas.width, i.canvas.height), i.viewport(0, 0, i.canvas.width, i.canvas.height), c = {}, _e = null, Te = {}, A = {}, m = /* @__PURE__ */ new WeakMap(), _ = [], y = null, T = !1, b = null, S = null, E = null, R = null, C = null, L = null, D = null, B = new ct(0, 0, 0), U = 0, N = !1, O = null, G = null, H = null, Y = null, K = null, Qe.set(0, 0, i.canvas.width, i.canvas.height), zt.set(0, 0, i.canvas.width, i.canvas.height), s.reset(), o.reset(), a.reset();
  }
  return {
    buffers: {
      color: s,
      depth: o,
      stencil: a
    },
    enable: ke,
    disable: at,
    bindFramebuffer: wt,
    drawBuffers: ot,
    useProgram: Wt,
    setBlending: ue,
    setMaterial: he,
    setFlipSided: Ee,
    setCullFace: Ye,
    setLineWidth: te,
    setPolygonOffset: Et,
    setScissorTest: dt,
    activeTexture: Nt,
    bindTexture: rt,
    unbindTexture: ne,
    compressedTexImage2D: W,
    compressedTexImage3D: ge,
    texImage2D: nn,
    texImage3D: tt,
    updateUBOMapping: Vt,
    uniformBlockBinding: pt,
    texStorage2D: ft,
    texStorage3D: Ft,
    texSubImage2D: Fe,
    texSubImage3D: We,
    compressedTexSubImage2D: Oe,
    compressedTexSubImage3D: kt,
    scissor: _t,
    viewport: Ut,
    reset: Rn
  };
}
function gq(i, e, t, n, r, s, o) {
  const a = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null, l = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent), u = new Le(), c = /* @__PURE__ */ new WeakMap();
  let A;
  const m = /* @__PURE__ */ new WeakMap();
  let _ = !1;
  try {
    _ = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch {
  }
  function y(ne, W) {
    return _ ? new OffscreenCanvas(ne, W) : Op("canvas");
  }
  function T(ne, W, ge) {
    let Fe = 1;
    const We = rt(ne);
    if ((We.width > ge || We.height > ge) && (Fe = ge / Math.max(We.width, We.height)), Fe < 1)
      if (typeof HTMLImageElement < "u" && ne instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && ne instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && ne instanceof ImageBitmap || typeof VideoFrame < "u" && ne instanceof VideoFrame) {
        const Oe = Math.floor(Fe * We.width), kt = Math.floor(Fe * We.height);
        A === void 0 && (A = y(Oe, kt));
        const ft = W ? y(Oe, kt) : A;
        return ft.width = Oe, ft.height = kt, ft.getContext("2d").drawImage(ne, 0, 0, Oe, kt), Me("WebGLRenderer: Texture has been resized from (" + We.width + "x" + We.height + ") to (" + Oe + "x" + kt + ")."), ft;
      } else
        return "data" in ne && Me("WebGLRenderer: Image in DataTexture is too big (" + We.width + "x" + We.height + ")."), ne;
    return ne;
  }
  function b(ne) {
    return ne.generateMipmaps;
  }
  function S(ne) {
    i.generateMipmap(ne);
  }
  function E(ne) {
    return ne.isWebGLCubeRenderTarget ? i.TEXTURE_CUBE_MAP : ne.isWebGL3DRenderTarget ? i.TEXTURE_3D : ne.isWebGLArrayRenderTarget || ne.isCompressedArrayTexture ? i.TEXTURE_2D_ARRAY : i.TEXTURE_2D;
  }
  function R(ne, W, ge, Fe, We = !1) {
    if (ne !== null) {
      if (i[ne] !== void 0) return i[ne];
      Me("WebGLRenderer: Attempt to use non-existing WebGL internal format '" + ne + "'");
    }
    let Oe = W;
    if (W === i.RED && (ge === i.FLOAT && (Oe = i.R32F), ge === i.HALF_FLOAT && (Oe = i.R16F), ge === i.UNSIGNED_BYTE && (Oe = i.R8)), W === i.RED_INTEGER && (ge === i.UNSIGNED_BYTE && (Oe = i.R8UI), ge === i.UNSIGNED_SHORT && (Oe = i.R16UI), ge === i.UNSIGNED_INT && (Oe = i.R32UI), ge === i.BYTE && (Oe = i.R8I), ge === i.SHORT && (Oe = i.R16I), ge === i.INT && (Oe = i.R32I)), W === i.RG && (ge === i.FLOAT && (Oe = i.RG32F), ge === i.HALF_FLOAT && (Oe = i.RG16F), ge === i.UNSIGNED_BYTE && (Oe = i.RG8)), W === i.RG_INTEGER && (ge === i.UNSIGNED_BYTE && (Oe = i.RG8UI), ge === i.UNSIGNED_SHORT && (Oe = i.RG16UI), ge === i.UNSIGNED_INT && (Oe = i.RG32UI), ge === i.BYTE && (Oe = i.RG8I), ge === i.SHORT && (Oe = i.RG16I), ge === i.INT && (Oe = i.RG32I)), W === i.RGB_INTEGER && (ge === i.UNSIGNED_BYTE && (Oe = i.RGB8UI), ge === i.UNSIGNED_SHORT && (Oe = i.RGB16UI), ge === i.UNSIGNED_INT && (Oe = i.RGB32UI), ge === i.BYTE && (Oe = i.RGB8I), ge === i.SHORT && (Oe = i.RGB16I), ge === i.INT && (Oe = i.RGB32I)), W === i.RGBA_INTEGER && (ge === i.UNSIGNED_BYTE && (Oe = i.RGBA8UI), ge === i.UNSIGNED_SHORT && (Oe = i.RGBA16UI), ge === i.UNSIGNED_INT && (Oe = i.RGBA32UI), ge === i.BYTE && (Oe = i.RGBA8I), ge === i.SHORT && (Oe = i.RGBA16I), ge === i.INT && (Oe = i.RGBA32I)), W === i.RGB && (ge === i.UNSIGNED_INT_5_9_9_9_REV && (Oe = i.RGB9_E5), ge === i.UNSIGNED_INT_10F_11F_11F_REV && (Oe = i.R11F_G11F_B10F)), W === i.RGBA) {
      const kt = We ? Vh : Xt.getTransfer(Fe);
      ge === i.FLOAT && (Oe = i.RGBA32F), ge === i.HALF_FLOAT && (Oe = i.RGBA16F), ge === i.UNSIGNED_BYTE && (Oe = kt === vt ? i.SRGB8_ALPHA8 : i.RGBA8), ge === i.UNSIGNED_SHORT_4_4_4_4 && (Oe = i.RGBA4), ge === i.UNSIGNED_SHORT_5_5_5_1 && (Oe = i.RGB5_A1);
    }
    return (Oe === i.R16F || Oe === i.R32F || Oe === i.RG16F || Oe === i.RG32F || Oe === i.RGBA16F || Oe === i.RGBA32F) && e.get("EXT_color_buffer_float"), Oe;
  }
  function C(ne, W) {
    let ge;
    return ne ? W === null || W === Jn || W === Js ? ge = i.DEPTH24_STENCIL8 : W === Ei ? ge = i.DEPTH32F_STENCIL8 : W === Oo && (ge = i.DEPTH24_STENCIL8, Me("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")) : W === null || W === Jn || W === Js ? ge = i.DEPTH_COMPONENT24 : W === Ei ? ge = i.DEPTH_COMPONENT32F : W === Oo && (ge = i.DEPTH_COMPONENT16), ge;
  }
  function L(ne, W) {
    return b(ne) === !0 || ne.isFramebufferTexture && ne.minFilter !== ei && ne.minFilter !== qn ? Math.log2(Math.max(W.width, W.height)) + 1 : ne.mipmaps !== void 0 && ne.mipmaps.length > 0 ? ne.mipmaps.length : ne.isCompressedTexture && Array.isArray(ne.image) ? W.mipmaps.length : 1;
  }
  function D(ne) {
    const W = ne.target;
    W.removeEventListener("dispose", D), U(W), W.isVideoTexture && c.delete(W);
  }
  function B(ne) {
    const W = ne.target;
    W.removeEventListener("dispose", B), O(W);
  }
  function U(ne) {
    const W = n.get(ne);
    if (W.__webglInit === void 0) return;
    const ge = ne.source, Fe = m.get(ge);
    if (Fe) {
      const We = Fe[W.__cacheKey];
      We.usedTimes--, We.usedTimes === 0 && N(ne), Object.keys(Fe).length === 0 && m.delete(ge);
    }
    n.remove(ne);
  }
  function N(ne) {
    const W = n.get(ne);
    i.deleteTexture(W.__webglTexture);
    const ge = ne.source, Fe = m.get(ge);
    delete Fe[W.__cacheKey], o.memory.textures--;
  }
  function O(ne) {
    const W = n.get(ne);
    if (ne.depthTexture && (ne.depthTexture.dispose(), n.remove(ne.depthTexture)), ne.isWebGLCubeRenderTarget)
      for (let Fe = 0; Fe < 6; Fe++) {
        if (Array.isArray(W.__webglFramebuffer[Fe]))
          for (let We = 0; We < W.__webglFramebuffer[Fe].length; We++) i.deleteFramebuffer(W.__webglFramebuffer[Fe][We]);
        else
          i.deleteFramebuffer(W.__webglFramebuffer[Fe]);
        W.__webglDepthbuffer && i.deleteRenderbuffer(W.__webglDepthbuffer[Fe]);
      }
    else {
      if (Array.isArray(W.__webglFramebuffer))
        for (let Fe = 0; Fe < W.__webglFramebuffer.length; Fe++) i.deleteFramebuffer(W.__webglFramebuffer[Fe]);
      else
        i.deleteFramebuffer(W.__webglFramebuffer);
      if (W.__webglDepthbuffer && i.deleteRenderbuffer(W.__webglDepthbuffer), W.__webglMultisampledFramebuffer && i.deleteFramebuffer(W.__webglMultisampledFramebuffer), W.__webglColorRenderbuffer)
        for (let Fe = 0; Fe < W.__webglColorRenderbuffer.length; Fe++)
          W.__webglColorRenderbuffer[Fe] && i.deleteRenderbuffer(W.__webglColorRenderbuffer[Fe]);
      W.__webglDepthRenderbuffer && i.deleteRenderbuffer(W.__webglDepthRenderbuffer);
    }
    const ge = ne.textures;
    for (let Fe = 0, We = ge.length; Fe < We; Fe++) {
      const Oe = n.get(ge[Fe]);
      Oe.__webglTexture && (i.deleteTexture(Oe.__webglTexture), o.memory.textures--), n.remove(ge[Fe]);
    }
    n.remove(ne);
  }
  let G = 0;
  function H() {
    G = 0;
  }
  function Y() {
    const ne = G;
    return ne >= r.maxTextures && Me("WebGLTextures: Trying to use " + ne + " texture units while this GPU supports only " + r.maxTextures), G += 1, ne;
  }
  function K(ne) {
    const W = [];
    return W.push(ne.wrapS), W.push(ne.wrapT), W.push(ne.wrapR || 0), W.push(ne.magFilter), W.push(ne.minFilter), W.push(ne.anisotropy), W.push(ne.internalFormat), W.push(ne.format), W.push(ne.type), W.push(ne.generateMipmaps), W.push(ne.premultiplyAlpha), W.push(ne.flipY), W.push(ne.unpackAlignment), W.push(ne.colorSpace), W.join();
  }
  function X(ne, W) {
    const ge = n.get(ne);
    if (ne.isVideoTexture && dt(ne), ne.isRenderTargetTexture === !1 && ne.isExternalTexture !== !0 && ne.version > 0 && ge.__version !== ne.version) {
      const Fe = ne.image;
      if (Fe === null)
        Me("WebGLRenderer: Texture marked for update but no image data found.");
      else if (Fe.complete === !1)
        Me("WebGLRenderer: Texture marked for update but image is incomplete");
      else {
        Pe(ge, ne, W);
        return;
      }
    } else ne.isExternalTexture && (ge.__webglTexture = ne.sourceTexture ? ne.sourceTexture : null);
    t.bindTexture(i.TEXTURE_2D, ge.__webglTexture, i.TEXTURE0 + W);
  }
  function ee(ne, W) {
    const ge = n.get(ne);
    if (ne.isRenderTargetTexture === !1 && ne.version > 0 && ge.__version !== ne.version) {
      Pe(ge, ne, W);
      return;
    } else ne.isExternalTexture && (ge.__webglTexture = ne.sourceTexture ? ne.sourceTexture : null);
    t.bindTexture(i.TEXTURE_2D_ARRAY, ge.__webglTexture, i.TEXTURE0 + W);
  }
  function oe(ne, W) {
    const ge = n.get(ne);
    if (ne.isRenderTargetTexture === !1 && ne.version > 0 && ge.__version !== ne.version) {
      Pe(ge, ne, W);
      return;
    }
    t.bindTexture(i.TEXTURE_3D, ge.__webglTexture, i.TEXTURE0 + W);
  }
  function fe(ne, W) {
    const ge = n.get(ne);
    if (ne.isCubeDepthTexture !== !0 && ne.version > 0 && ge.__version !== ne.version) {
      ke(ge, ne, W);
      return;
    }
    t.bindTexture(i.TEXTURE_CUBE_MAP, ge.__webglTexture, i.TEXTURE0 + W);
  }
  const _e = {
    [zl]: i.REPEAT,
    [xr]: i.CLAMP_TO_EDGE,
    [ql]: i.MIRRORED_REPEAT
  }, Te = {
    [ei]: i.NEAREST,
    [p0]: i.NEAREST_MIPMAP_NEAREST,
    [Aa]: i.NEAREST_MIPMAP_LINEAR,
    [qn]: i.LINEAR,
    [Uu]: i.LINEAR_MIPMAP_NEAREST,
    [$r]: i.LINEAR_MIPMAP_LINEAR
  }, Ce = {
    [G_]: i.NEVER,
    [W_]: i.ALWAYS,
    [iA]: i.LESS,
    [rA]: i.LEQUAL,
    [z_]: i.EQUAL,
    [sA]: i.GEQUAL,
    [q_]: i.GREATER,
    [H_]: i.NOTEQUAL
  };
  function Je(ne, W) {
    if (W.type === Ei && e.has("OES_texture_float_linear") === !1 && (W.magFilter === qn || W.magFilter === Uu || W.magFilter === Aa || W.magFilter === $r || W.minFilter === qn || W.minFilter === Uu || W.minFilter === Aa || W.minFilter === $r) && Me("WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."), i.texParameteri(ne, i.TEXTURE_WRAP_S, _e[W.wrapS]), i.texParameteri(ne, i.TEXTURE_WRAP_T, _e[W.wrapT]), (ne === i.TEXTURE_3D || ne === i.TEXTURE_2D_ARRAY) && i.texParameteri(ne, i.TEXTURE_WRAP_R, _e[W.wrapR]), i.texParameteri(ne, i.TEXTURE_MAG_FILTER, Te[W.magFilter]), i.texParameteri(ne, i.TEXTURE_MIN_FILTER, Te[W.minFilter]), W.compareFunction && (i.texParameteri(ne, i.TEXTURE_COMPARE_MODE, i.COMPARE_REF_TO_TEXTURE), i.texParameteri(ne, i.TEXTURE_COMPARE_FUNC, Ce[W.compareFunction])), e.has("EXT_texture_filter_anisotropic") === !0) {
      if (W.magFilter === ei || W.minFilter !== Aa && W.minFilter !== $r || W.type === Ei && e.has("OES_texture_float_linear") === !1) return;
      if (W.anisotropy > 1 || n.get(W).__currentAnisotropy) {
        const ge = e.get("EXT_texture_filter_anisotropic");
        i.texParameterf(ne, ge.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(W.anisotropy, r.getMaxAnisotropy())), n.get(W).__currentAnisotropy = W.anisotropy;
      }
    }
  }
  function Qe(ne, W) {
    let ge = !1;
    ne.__webglInit === void 0 && (ne.__webglInit = !0, W.addEventListener("dispose", D));
    const Fe = W.source;
    let We = m.get(Fe);
    We === void 0 && (We = {}, m.set(Fe, We));
    const Oe = K(W);
    if (Oe !== ne.__cacheKey) {
      We[Oe] === void 0 && (We[Oe] = {
        texture: i.createTexture(),
        usedTimes: 0
      }, o.memory.textures++, ge = !0), We[Oe].usedTimes++;
      const kt = We[ne.__cacheKey];
      kt !== void 0 && (We[ne.__cacheKey].usedTimes--, kt.usedTimes === 0 && N(W)), ne.__cacheKey = Oe, ne.__webglTexture = We[Oe].texture;
    }
    return ge;
  }
  function zt(ne, W, ge) {
    return Math.floor(Math.floor(ne / ge) / W);
  }
  function Tt(ne, W, ge, Fe) {
    const Oe = ne.updateRanges;
    if (Oe.length === 0)
      t.texSubImage2D(i.TEXTURE_2D, 0, 0, 0, W.width, W.height, ge, Fe, W.data);
    else {
      Oe.sort((tt, _t) => tt.start - _t.start);
      let kt = 0;
      for (let tt = 1; tt < Oe.length; tt++) {
        const _t = Oe[kt], Ut = Oe[tt], Vt = _t.start + _t.count, pt = zt(Ut.start, W.width, 4), Rn = zt(_t.start, W.width, 4);
        Ut.start <= Vt + 1 && pt === Rn && zt(Ut.start + Ut.count - 1, W.width, 4) === pt ? _t.count = Math.max(
          _t.count,
          Ut.start + Ut.count - _t.start
        ) : (++kt, Oe[kt] = Ut);
      }
      Oe.length = kt + 1;
      const ft = i.getParameter(i.UNPACK_ROW_LENGTH), Ft = i.getParameter(i.UNPACK_SKIP_PIXELS), nn = i.getParameter(i.UNPACK_SKIP_ROWS);
      i.pixelStorei(i.UNPACK_ROW_LENGTH, W.width);
      for (let tt = 0, _t = Oe.length; tt < _t; tt++) {
        const Ut = Oe[tt], Vt = Math.floor(Ut.start / 4), pt = Math.ceil(Ut.count / 4), Rn = Vt % W.width, ie = Math.floor(Vt / W.width), bt = pt, lt = 1;
        i.pixelStorei(i.UNPACK_SKIP_PIXELS, Rn), i.pixelStorei(i.UNPACK_SKIP_ROWS, ie), t.texSubImage2D(i.TEXTURE_2D, 0, Rn, ie, bt, lt, ge, Fe, W.data);
      }
      ne.clearUpdateRanges(), i.pixelStorei(i.UNPACK_ROW_LENGTH, ft), i.pixelStorei(i.UNPACK_SKIP_PIXELS, Ft), i.pixelStorei(i.UNPACK_SKIP_ROWS, nn);
    }
  }
  function Pe(ne, W, ge) {
    let Fe = i.TEXTURE_2D;
    (W.isDataArrayTexture || W.isCompressedArrayTexture) && (Fe = i.TEXTURE_2D_ARRAY), W.isData3DTexture && (Fe = i.TEXTURE_3D);
    const We = Qe(ne, W), Oe = W.source;
    t.bindTexture(Fe, ne.__webglTexture, i.TEXTURE0 + ge);
    const kt = n.get(Oe);
    if (Oe.version !== kt.__version || We === !0) {
      t.activeTexture(i.TEXTURE0 + ge);
      const ft = Xt.getPrimaries(Xt.workingColorSpace), Ft = W.colorSpace === Ds ? null : Xt.getPrimaries(W.colorSpace), nn = W.colorSpace === Ds || ft === Ft ? i.NONE : i.BROWSER_DEFAULT_WEBGL;
      i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL, W.flipY), i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL, W.premultiplyAlpha), i.pixelStorei(i.UNPACK_ALIGNMENT, W.unpackAlignment), i.pixelStorei(i.UNPACK_COLORSPACE_CONVERSION_WEBGL, nn);
      let tt = T(W.image, !1, r.maxTextureSize);
      tt = Nt(W, tt);
      const _t = s.convert(W.format, W.colorSpace), Ut = s.convert(W.type);
      let Vt = R(W.internalFormat, _t, Ut, W.colorSpace, W.isVideoTexture);
      Je(Fe, W);
      let pt;
      const Rn = W.mipmaps, ie = W.isVideoTexture !== !0, bt = kt.__version === void 0 || We === !0, lt = Oe.dataReady, Ct = L(W, tt);
      if (W.isDepthTexture)
        Vt = C(W.format === ds, W.type), bt && (ie ? t.texStorage2D(i.TEXTURE_2D, 1, Vt, tt.width, tt.height) : t.texImage2D(i.TEXTURE_2D, 0, Vt, tt.width, tt.height, 0, _t, Ut, null));
      else if (W.isDataTexture)
        if (Rn.length > 0) {
          ie && bt && t.texStorage2D(i.TEXTURE_2D, Ct, Vt, Rn[0].width, Rn[0].height);
          for (let it = 0, He = Rn.length; it < He; it++)
            pt = Rn[it], ie ? lt && t.texSubImage2D(i.TEXTURE_2D, it, 0, 0, pt.width, pt.height, _t, Ut, pt.data) : t.texImage2D(i.TEXTURE_2D, it, Vt, pt.width, pt.height, 0, _t, Ut, pt.data);
          W.generateMipmaps = !1;
        } else
          ie ? (bt && t.texStorage2D(i.TEXTURE_2D, Ct, Vt, tt.width, tt.height), lt && Tt(W, tt, _t, Ut)) : t.texImage2D(i.TEXTURE_2D, 0, Vt, tt.width, tt.height, 0, _t, Ut, tt.data);
      else if (W.isCompressedTexture)
        if (W.isCompressedArrayTexture) {
          ie && bt && t.texStorage3D(i.TEXTURE_2D_ARRAY, Ct, Vt, Rn[0].width, Rn[0].height, tt.depth);
          for (let it = 0, He = Rn.length; it < He; it++)
            if (pt = Rn[it], W.format !== Pi)
              if (_t !== null)
                if (ie) {
                  if (lt)
                    if (W.layerUpdates.size > 0) {
                      const At = y1(pt.width, pt.height, W.format, W.type);
                      for (const pn of W.layerUpdates) {
                        const di = pt.data.subarray(
                          pn * At / pt.data.BYTES_PER_ELEMENT,
                          (pn + 1) * At / pt.data.BYTES_PER_ELEMENT
                        );
                        t.compressedTexSubImage3D(i.TEXTURE_2D_ARRAY, it, 0, 0, pn, pt.width, pt.height, 1, _t, di);
                      }
                      W.clearLayerUpdates();
                    } else
                      t.compressedTexSubImage3D(i.TEXTURE_2D_ARRAY, it, 0, 0, 0, pt.width, pt.height, tt.depth, _t, pt.data);
                } else
                  t.compressedTexImage3D(i.TEXTURE_2D_ARRAY, it, Vt, pt.width, pt.height, tt.depth, 0, pt.data, 0, 0);
              else
                Me("WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
            else
              ie ? lt && t.texSubImage3D(i.TEXTURE_2D_ARRAY, it, 0, 0, 0, pt.width, pt.height, tt.depth, _t, Ut, pt.data) : t.texImage3D(i.TEXTURE_2D_ARRAY, it, Vt, pt.width, pt.height, tt.depth, 0, _t, Ut, pt.data);
        } else {
          ie && bt && t.texStorage2D(i.TEXTURE_2D, Ct, Vt, Rn[0].width, Rn[0].height);
          for (let it = 0, He = Rn.length; it < He; it++)
            pt = Rn[it], W.format !== Pi ? _t !== null ? ie ? lt && t.compressedTexSubImage2D(i.TEXTURE_2D, it, 0, 0, pt.width, pt.height, _t, pt.data) : t.compressedTexImage2D(i.TEXTURE_2D, it, Vt, pt.width, pt.height, 0, pt.data) : Me("WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : ie ? lt && t.texSubImage2D(i.TEXTURE_2D, it, 0, 0, pt.width, pt.height, _t, Ut, pt.data) : t.texImage2D(i.TEXTURE_2D, it, Vt, pt.width, pt.height, 0, _t, Ut, pt.data);
        }
      else if (W.isDataArrayTexture)
        if (ie) {
          if (bt && t.texStorage3D(i.TEXTURE_2D_ARRAY, Ct, Vt, tt.width, tt.height, tt.depth), lt)
            if (W.layerUpdates.size > 0) {
              const it = y1(tt.width, tt.height, W.format, W.type);
              for (const He of W.layerUpdates) {
                const At = tt.data.subarray(
                  He * it / tt.data.BYTES_PER_ELEMENT,
                  (He + 1) * it / tt.data.BYTES_PER_ELEMENT
                );
                t.texSubImage3D(i.TEXTURE_2D_ARRAY, 0, 0, 0, He, tt.width, tt.height, 1, _t, Ut, At);
              }
              W.clearLayerUpdates();
            } else
              t.texSubImage3D(i.TEXTURE_2D_ARRAY, 0, 0, 0, 0, tt.width, tt.height, tt.depth, _t, Ut, tt.data);
        } else
          t.texImage3D(i.TEXTURE_2D_ARRAY, 0, Vt, tt.width, tt.height, tt.depth, 0, _t, Ut, tt.data);
      else if (W.isData3DTexture)
        ie ? (bt && t.texStorage3D(i.TEXTURE_3D, Ct, Vt, tt.width, tt.height, tt.depth), lt && t.texSubImage3D(i.TEXTURE_3D, 0, 0, 0, 0, tt.width, tt.height, tt.depth, _t, Ut, tt.data)) : t.texImage3D(i.TEXTURE_3D, 0, Vt, tt.width, tt.height, tt.depth, 0, _t, Ut, tt.data);
      else if (W.isFramebufferTexture) {
        if (bt)
          if (ie)
            t.texStorage2D(i.TEXTURE_2D, Ct, Vt, tt.width, tt.height);
          else {
            let it = tt.width, He = tt.height;
            for (let At = 0; At < Ct; At++)
              t.texImage2D(i.TEXTURE_2D, At, Vt, it, He, 0, _t, Ut, null), it >>= 1, He >>= 1;
          }
      } else if (Rn.length > 0) {
        if (ie && bt) {
          const it = rt(Rn[0]);
          t.texStorage2D(i.TEXTURE_2D, Ct, Vt, it.width, it.height);
        }
        for (let it = 0, He = Rn.length; it < He; it++)
          pt = Rn[it], ie ? lt && t.texSubImage2D(i.TEXTURE_2D, it, 0, 0, _t, Ut, pt) : t.texImage2D(i.TEXTURE_2D, it, Vt, _t, Ut, pt);
        W.generateMipmaps = !1;
      } else if (ie) {
        if (bt) {
          const it = rt(tt);
          t.texStorage2D(i.TEXTURE_2D, Ct, Vt, it.width, it.height);
        }
        lt && t.texSubImage2D(i.TEXTURE_2D, 0, 0, 0, _t, Ut, tt);
      } else
        t.texImage2D(i.TEXTURE_2D, 0, Vt, _t, Ut, tt);
      b(W) && S(Fe), kt.__version = Oe.version, W.onUpdate && W.onUpdate(W);
    }
    ne.__version = W.version;
  }
  function ke(ne, W, ge) {
    if (W.image.length !== 6) return;
    const Fe = Qe(ne, W), We = W.source;
    t.bindTexture(i.TEXTURE_CUBE_MAP, ne.__webglTexture, i.TEXTURE0 + ge);
    const Oe = n.get(We);
    if (We.version !== Oe.__version || Fe === !0) {
      t.activeTexture(i.TEXTURE0 + ge);
      const kt = Xt.getPrimaries(Xt.workingColorSpace), ft = W.colorSpace === Ds ? null : Xt.getPrimaries(W.colorSpace), Ft = W.colorSpace === Ds || kt === ft ? i.NONE : i.BROWSER_DEFAULT_WEBGL;
      i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL, W.flipY), i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL, W.premultiplyAlpha), i.pixelStorei(i.UNPACK_ALIGNMENT, W.unpackAlignment), i.pixelStorei(i.UNPACK_COLORSPACE_CONVERSION_WEBGL, Ft);
      const nn = W.isCompressedTexture || W.image[0].isCompressedTexture, tt = W.image[0] && W.image[0].isDataTexture, _t = [];
      for (let He = 0; He < 6; He++)
        !nn && !tt ? _t[He] = T(W.image[He], !0, r.maxCubemapSize) : _t[He] = tt ? W.image[He].image : W.image[He], _t[He] = Nt(W, _t[He]);
      const Ut = _t[0], Vt = s.convert(W.format, W.colorSpace), pt = s.convert(W.type), Rn = R(W.internalFormat, Vt, pt, W.colorSpace), ie = W.isVideoTexture !== !0, bt = Oe.__version === void 0 || Fe === !0, lt = We.dataReady;
      let Ct = L(W, Ut);
      Je(i.TEXTURE_CUBE_MAP, W);
      let it;
      if (nn) {
        ie && bt && t.texStorage2D(i.TEXTURE_CUBE_MAP, Ct, Rn, Ut.width, Ut.height);
        for (let He = 0; He < 6; He++) {
          it = _t[He].mipmaps;
          for (let At = 0; At < it.length; At++) {
            const pn = it[At];
            W.format !== Pi ? Vt !== null ? ie ? lt && t.compressedTexSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + He, At, 0, 0, pn.width, pn.height, Vt, pn.data) : t.compressedTexImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + He, At, Rn, pn.width, pn.height, 0, pn.data) : Me("WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : ie ? lt && t.texSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + He, At, 0, 0, pn.width, pn.height, Vt, pt, pn.data) : t.texImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + He, At, Rn, pn.width, pn.height, 0, Vt, pt, pn.data);
          }
        }
      } else {
        if (it = W.mipmaps, ie && bt) {
          it.length > 0 && Ct++;
          const He = rt(_t[0]);
          t.texStorage2D(i.TEXTURE_CUBE_MAP, Ct, Rn, He.width, He.height);
        }
        for (let He = 0; He < 6; He++)
          if (tt) {
            ie ? lt && t.texSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + He, 0, 0, 0, _t[He].width, _t[He].height, Vt, pt, _t[He].data) : t.texImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + He, 0, Rn, _t[He].width, _t[He].height, 0, Vt, pt, _t[He].data);
            for (let At = 0; At < it.length; At++) {
              const di = it[At].image[He].image;
              ie ? lt && t.texSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + He, At + 1, 0, 0, di.width, di.height, Vt, pt, di.data) : t.texImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + He, At + 1, Rn, di.width, di.height, 0, Vt, pt, di.data);
            }
          } else {
            ie ? lt && t.texSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + He, 0, 0, 0, Vt, pt, _t[He]) : t.texImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + He, 0, Rn, Vt, pt, _t[He]);
            for (let At = 0; At < it.length; At++) {
              const pn = it[At];
              ie ? lt && t.texSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + He, At + 1, 0, 0, Vt, pt, pn.image[He]) : t.texImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + He, At + 1, Rn, Vt, pt, pn.image[He]);
            }
          }
      }
      b(W) && S(i.TEXTURE_CUBE_MAP), Oe.__version = We.version, W.onUpdate && W.onUpdate(W);
    }
    ne.__version = W.version;
  }
  function at(ne, W, ge, Fe, We, Oe) {
    const kt = s.convert(ge.format, ge.colorSpace), ft = s.convert(ge.type), Ft = R(ge.internalFormat, kt, ft, ge.colorSpace), nn = n.get(W), tt = n.get(ge);
    if (tt.__renderTarget = W, !nn.__hasExternalTextures) {
      const _t = Math.max(1, W.width >> Oe), Ut = Math.max(1, W.height >> Oe);
      We === i.TEXTURE_3D || We === i.TEXTURE_2D_ARRAY ? t.texImage3D(We, Oe, Ft, _t, Ut, W.depth, 0, kt, ft, null) : t.texImage2D(We, Oe, Ft, _t, Ut, 0, kt, ft, null);
    }
    t.bindFramebuffer(i.FRAMEBUFFER, ne), Et(W) ? a.framebufferTexture2DMultisampleEXT(i.FRAMEBUFFER, Fe, We, tt.__webglTexture, 0, te(W)) : (We === i.TEXTURE_2D || We >= i.TEXTURE_CUBE_MAP_POSITIVE_X && We <= i.TEXTURE_CUBE_MAP_NEGATIVE_Z) && i.framebufferTexture2D(i.FRAMEBUFFER, Fe, We, tt.__webglTexture, Oe), t.bindFramebuffer(i.FRAMEBUFFER, null);
  }
  function wt(ne, W, ge) {
    if (i.bindRenderbuffer(i.RENDERBUFFER, ne), W.depthBuffer) {
      const Fe = W.depthTexture, We = Fe && Fe.isDepthTexture ? Fe.type : null, Oe = C(W.stencilBuffer, We), kt = W.stencilBuffer ? i.DEPTH_STENCIL_ATTACHMENT : i.DEPTH_ATTACHMENT;
      Et(W) ? a.renderbufferStorageMultisampleEXT(i.RENDERBUFFER, te(W), Oe, W.width, W.height) : ge ? i.renderbufferStorageMultisample(i.RENDERBUFFER, te(W), Oe, W.width, W.height) : i.renderbufferStorage(i.RENDERBUFFER, Oe, W.width, W.height), i.framebufferRenderbuffer(i.FRAMEBUFFER, kt, i.RENDERBUFFER, ne);
    } else {
      const Fe = W.textures;
      for (let We = 0; We < Fe.length; We++) {
        const Oe = Fe[We], kt = s.convert(Oe.format, Oe.colorSpace), ft = s.convert(Oe.type), Ft = R(Oe.internalFormat, kt, ft, Oe.colorSpace);
        Et(W) ? a.renderbufferStorageMultisampleEXT(i.RENDERBUFFER, te(W), Ft, W.width, W.height) : ge ? i.renderbufferStorageMultisample(i.RENDERBUFFER, te(W), Ft, W.width, W.height) : i.renderbufferStorage(i.RENDERBUFFER, Ft, W.width, W.height);
      }
    }
    i.bindRenderbuffer(i.RENDERBUFFER, null);
  }
  function ot(ne, W, ge) {
    const Fe = W.isWebGLCubeRenderTarget === !0;
    if (t.bindFramebuffer(i.FRAMEBUFFER, ne), !(W.depthTexture && W.depthTexture.isDepthTexture))
      throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
    const We = n.get(W.depthTexture);
    if (We.__renderTarget = W, (!We.__webglTexture || W.depthTexture.image.width !== W.width || W.depthTexture.image.height !== W.height) && (W.depthTexture.image.width = W.width, W.depthTexture.image.height = W.height, W.depthTexture.needsUpdate = !0), Fe) {
      if (We.__webglInit === void 0 && (We.__webglInit = !0, W.depthTexture.addEventListener("dispose", D)), We.__webglTexture === void 0) {
        We.__webglTexture = i.createTexture(), t.bindTexture(i.TEXTURE_CUBE_MAP, We.__webglTexture), Je(i.TEXTURE_CUBE_MAP, W.depthTexture);
        const nn = s.convert(W.depthTexture.format), tt = s.convert(W.depthTexture.type);
        let _t;
        W.depthTexture.format === Lr ? _t = i.DEPTH_COMPONENT24 : W.depthTexture.format === ds && (_t = i.DEPTH24_STENCIL8);
        for (let Ut = 0; Ut < 6; Ut++)
          i.texImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + Ut, 0, _t, W.width, W.height, 0, nn, tt, null);
      }
    } else
      X(W.depthTexture, 0);
    const Oe = We.__webglTexture, kt = te(W), ft = Fe ? i.TEXTURE_CUBE_MAP_POSITIVE_X + ge : i.TEXTURE_2D, Ft = W.depthTexture.format === ds ? i.DEPTH_STENCIL_ATTACHMENT : i.DEPTH_ATTACHMENT;
    if (W.depthTexture.format === Lr)
      Et(W) ? a.framebufferTexture2DMultisampleEXT(i.FRAMEBUFFER, Ft, ft, Oe, 0, kt) : i.framebufferTexture2D(i.FRAMEBUFFER, Ft, ft, Oe, 0);
    else if (W.depthTexture.format === ds)
      Et(W) ? a.framebufferTexture2DMultisampleEXT(i.FRAMEBUFFER, Ft, ft, Oe, 0, kt) : i.framebufferTexture2D(i.FRAMEBUFFER, Ft, ft, Oe, 0);
    else
      throw new Error("Unknown depthTexture format");
  }
  function Wt(ne) {
    const W = n.get(ne), ge = ne.isWebGLCubeRenderTarget === !0;
    if (W.__boundDepthTexture !== ne.depthTexture) {
      const Fe = ne.depthTexture;
      if (W.__depthDisposeCallback && W.__depthDisposeCallback(), Fe) {
        const We = () => {
          delete W.__boundDepthTexture, delete W.__depthDisposeCallback, Fe.removeEventListener("dispose", We);
        };
        Fe.addEventListener("dispose", We), W.__depthDisposeCallback = We;
      }
      W.__boundDepthTexture = Fe;
    }
    if (ne.depthTexture && !W.__autoAllocateDepthBuffer)
      if (ge)
        for (let Fe = 0; Fe < 6; Fe++)
          ot(W.__webglFramebuffer[Fe], ne, Fe);
      else {
        const Fe = ne.texture.mipmaps;
        Fe && Fe.length > 0 ? ot(W.__webglFramebuffer[0], ne, 0) : ot(W.__webglFramebuffer, ne, 0);
      }
    else if (ge) {
      W.__webglDepthbuffer = [];
      for (let Fe = 0; Fe < 6; Fe++)
        if (t.bindFramebuffer(i.FRAMEBUFFER, W.__webglFramebuffer[Fe]), W.__webglDepthbuffer[Fe] === void 0)
          W.__webglDepthbuffer[Fe] = i.createRenderbuffer(), wt(W.__webglDepthbuffer[Fe], ne, !1);
        else {
          const We = ne.stencilBuffer ? i.DEPTH_STENCIL_ATTACHMENT : i.DEPTH_ATTACHMENT, Oe = W.__webglDepthbuffer[Fe];
          i.bindRenderbuffer(i.RENDERBUFFER, Oe), i.framebufferRenderbuffer(i.FRAMEBUFFER, We, i.RENDERBUFFER, Oe);
        }
    } else {
      const Fe = ne.texture.mipmaps;
      if (Fe && Fe.length > 0 ? t.bindFramebuffer(i.FRAMEBUFFER, W.__webglFramebuffer[0]) : t.bindFramebuffer(i.FRAMEBUFFER, W.__webglFramebuffer), W.__webglDepthbuffer === void 0)
        W.__webglDepthbuffer = i.createRenderbuffer(), wt(W.__webglDepthbuffer, ne, !1);
      else {
        const We = ne.stencilBuffer ? i.DEPTH_STENCIL_ATTACHMENT : i.DEPTH_ATTACHMENT, Oe = W.__webglDepthbuffer;
        i.bindRenderbuffer(i.RENDERBUFFER, Oe), i.framebufferRenderbuffer(i.FRAMEBUFFER, We, i.RENDERBUFFER, Oe);
      }
    }
    t.bindFramebuffer(i.FRAMEBUFFER, null);
  }
  function en(ne, W, ge) {
    const Fe = n.get(ne);
    W !== void 0 && at(Fe.__webglFramebuffer, ne, ne.texture, i.COLOR_ATTACHMENT0, i.TEXTURE_2D, 0), ge !== void 0 && Wt(ne);
  }
  function z(ne) {
    const W = ne.texture, ge = n.get(ne), Fe = n.get(W);
    ne.addEventListener("dispose", B);
    const We = ne.textures, Oe = ne.isWebGLCubeRenderTarget === !0, kt = We.length > 1;
    if (kt || (Fe.__webglTexture === void 0 && (Fe.__webglTexture = i.createTexture()), Fe.__version = W.version, o.memory.textures++), Oe) {
      ge.__webglFramebuffer = [];
      for (let ft = 0; ft < 6; ft++)
        if (W.mipmaps && W.mipmaps.length > 0) {
          ge.__webglFramebuffer[ft] = [];
          for (let Ft = 0; Ft < W.mipmaps.length; Ft++)
            ge.__webglFramebuffer[ft][Ft] = i.createFramebuffer();
        } else
          ge.__webglFramebuffer[ft] = i.createFramebuffer();
    } else {
      if (W.mipmaps && W.mipmaps.length > 0) {
        ge.__webglFramebuffer = [];
        for (let ft = 0; ft < W.mipmaps.length; ft++)
          ge.__webglFramebuffer[ft] = i.createFramebuffer();
      } else
        ge.__webglFramebuffer = i.createFramebuffer();
      if (kt)
        for (let ft = 0, Ft = We.length; ft < Ft; ft++) {
          const nn = n.get(We[ft]);
          nn.__webglTexture === void 0 && (nn.__webglTexture = i.createTexture(), o.memory.textures++);
        }
      if (ne.samples > 0 && Et(ne) === !1) {
        ge.__webglMultisampledFramebuffer = i.createFramebuffer(), ge.__webglColorRenderbuffer = [], t.bindFramebuffer(i.FRAMEBUFFER, ge.__webglMultisampledFramebuffer);
        for (let ft = 0; ft < We.length; ft++) {
          const Ft = We[ft];
          ge.__webglColorRenderbuffer[ft] = i.createRenderbuffer(), i.bindRenderbuffer(i.RENDERBUFFER, ge.__webglColorRenderbuffer[ft]);
          const nn = s.convert(Ft.format, Ft.colorSpace), tt = s.convert(Ft.type), _t = R(Ft.internalFormat, nn, tt, Ft.colorSpace, ne.isXRRenderTarget === !0), Ut = te(ne);
          i.renderbufferStorageMultisample(i.RENDERBUFFER, Ut, _t, ne.width, ne.height), i.framebufferRenderbuffer(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0 + ft, i.RENDERBUFFER, ge.__webglColorRenderbuffer[ft]);
        }
        i.bindRenderbuffer(i.RENDERBUFFER, null), ne.depthBuffer && (ge.__webglDepthRenderbuffer = i.createRenderbuffer(), wt(ge.__webglDepthRenderbuffer, ne, !0)), t.bindFramebuffer(i.FRAMEBUFFER, null);
      }
    }
    if (Oe) {
      t.bindTexture(i.TEXTURE_CUBE_MAP, Fe.__webglTexture), Je(i.TEXTURE_CUBE_MAP, W);
      for (let ft = 0; ft < 6; ft++)
        if (W.mipmaps && W.mipmaps.length > 0)
          for (let Ft = 0; Ft < W.mipmaps.length; Ft++)
            at(ge.__webglFramebuffer[ft][Ft], ne, W, i.COLOR_ATTACHMENT0, i.TEXTURE_CUBE_MAP_POSITIVE_X + ft, Ft);
        else
          at(ge.__webglFramebuffer[ft], ne, W, i.COLOR_ATTACHMENT0, i.TEXTURE_CUBE_MAP_POSITIVE_X + ft, 0);
      b(W) && S(i.TEXTURE_CUBE_MAP), t.unbindTexture();
    } else if (kt) {
      for (let ft = 0, Ft = We.length; ft < Ft; ft++) {
        const nn = We[ft], tt = n.get(nn);
        let _t = i.TEXTURE_2D;
        (ne.isWebGL3DRenderTarget || ne.isWebGLArrayRenderTarget) && (_t = ne.isWebGL3DRenderTarget ? i.TEXTURE_3D : i.TEXTURE_2D_ARRAY), t.bindTexture(_t, tt.__webglTexture), Je(_t, nn), at(ge.__webglFramebuffer, ne, nn, i.COLOR_ATTACHMENT0 + ft, _t, 0), b(nn) && S(_t);
      }
      t.unbindTexture();
    } else {
      let ft = i.TEXTURE_2D;
      if ((ne.isWebGL3DRenderTarget || ne.isWebGLArrayRenderTarget) && (ft = ne.isWebGL3DRenderTarget ? i.TEXTURE_3D : i.TEXTURE_2D_ARRAY), t.bindTexture(ft, Fe.__webglTexture), Je(ft, W), W.mipmaps && W.mipmaps.length > 0)
        for (let Ft = 0; Ft < W.mipmaps.length; Ft++)
          at(ge.__webglFramebuffer[Ft], ne, W, i.COLOR_ATTACHMENT0, ft, Ft);
      else
        at(ge.__webglFramebuffer, ne, W, i.COLOR_ATTACHMENT0, ft, 0);
      b(W) && S(ft), t.unbindTexture();
    }
    ne.depthBuffer && Wt(ne);
  }
  function ue(ne) {
    const W = ne.textures;
    for (let ge = 0, Fe = W.length; ge < Fe; ge++) {
      const We = W[ge];
      if (b(We)) {
        const Oe = E(ne), kt = n.get(We).__webglTexture;
        t.bindTexture(Oe, kt), S(Oe), t.unbindTexture();
      }
    }
  }
  const he = [], Ee = [];
  function Ye(ne) {
    if (ne.samples > 0) {
      if (Et(ne) === !1) {
        const W = ne.textures, ge = ne.width, Fe = ne.height;
        let We = i.COLOR_BUFFER_BIT;
        const Oe = ne.stencilBuffer ? i.DEPTH_STENCIL_ATTACHMENT : i.DEPTH_ATTACHMENT, kt = n.get(ne), ft = W.length > 1;
        if (ft)
          for (let nn = 0; nn < W.length; nn++)
            t.bindFramebuffer(i.FRAMEBUFFER, kt.__webglMultisampledFramebuffer), i.framebufferRenderbuffer(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0 + nn, i.RENDERBUFFER, null), t.bindFramebuffer(i.FRAMEBUFFER, kt.__webglFramebuffer), i.framebufferTexture2D(i.DRAW_FRAMEBUFFER, i.COLOR_ATTACHMENT0 + nn, i.TEXTURE_2D, null, 0);
        t.bindFramebuffer(i.READ_FRAMEBUFFER, kt.__webglMultisampledFramebuffer);
        const Ft = ne.texture.mipmaps;
        Ft && Ft.length > 0 ? t.bindFramebuffer(i.DRAW_FRAMEBUFFER, kt.__webglFramebuffer[0]) : t.bindFramebuffer(i.DRAW_FRAMEBUFFER, kt.__webglFramebuffer);
        for (let nn = 0; nn < W.length; nn++) {
          if (ne.resolveDepthBuffer && (ne.depthBuffer && (We |= i.DEPTH_BUFFER_BIT), ne.stencilBuffer && ne.resolveStencilBuffer && (We |= i.STENCIL_BUFFER_BIT)), ft) {
            i.framebufferRenderbuffer(i.READ_FRAMEBUFFER, i.COLOR_ATTACHMENT0, i.RENDERBUFFER, kt.__webglColorRenderbuffer[nn]);
            const tt = n.get(W[nn]).__webglTexture;
            i.framebufferTexture2D(i.DRAW_FRAMEBUFFER, i.COLOR_ATTACHMENT0, i.TEXTURE_2D, tt, 0);
          }
          i.blitFramebuffer(0, 0, ge, Fe, 0, 0, ge, Fe, We, i.NEAREST), l === !0 && (he.length = 0, Ee.length = 0, he.push(i.COLOR_ATTACHMENT0 + nn), ne.depthBuffer && ne.resolveDepthBuffer === !1 && (he.push(Oe), Ee.push(Oe), i.invalidateFramebuffer(i.DRAW_FRAMEBUFFER, Ee)), i.invalidateFramebuffer(i.READ_FRAMEBUFFER, he));
        }
        if (t.bindFramebuffer(i.READ_FRAMEBUFFER, null), t.bindFramebuffer(i.DRAW_FRAMEBUFFER, null), ft)
          for (let nn = 0; nn < W.length; nn++) {
            t.bindFramebuffer(i.FRAMEBUFFER, kt.__webglMultisampledFramebuffer), i.framebufferRenderbuffer(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0 + nn, i.RENDERBUFFER, kt.__webglColorRenderbuffer[nn]);
            const tt = n.get(W[nn]).__webglTexture;
            t.bindFramebuffer(i.FRAMEBUFFER, kt.__webglFramebuffer), i.framebufferTexture2D(i.DRAW_FRAMEBUFFER, i.COLOR_ATTACHMENT0 + nn, i.TEXTURE_2D, tt, 0);
          }
        t.bindFramebuffer(i.DRAW_FRAMEBUFFER, kt.__webglMultisampledFramebuffer);
      } else if (ne.depthBuffer && ne.resolveDepthBuffer === !1 && l) {
        const W = ne.stencilBuffer ? i.DEPTH_STENCIL_ATTACHMENT : i.DEPTH_ATTACHMENT;
        i.invalidateFramebuffer(i.DRAW_FRAMEBUFFER, [W]);
      }
    }
  }
  function te(ne) {
    return Math.min(r.maxSamples, ne.samples);
  }
  function Et(ne) {
    const W = n.get(ne);
    return ne.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && W.__useRenderToTexture !== !1;
  }
  function dt(ne) {
    const W = o.render.frame;
    c.get(ne) !== W && (c.set(ne, W), ne.update());
  }
  function Nt(ne, W) {
    const ge = ne.colorSpace, Fe = ne.format, We = ne.type;
    return ne.isCompressedTexture === !0 || ne.isVideoTexture === !0 || ge !== Hl && ge !== Ds && (Xt.getTransfer(ge) === vt ? (Fe !== Pi || We !== Mi) && Me("WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : Ie("WebGLTextures: Unsupported texture color space:", ge)), W;
  }
  function rt(ne) {
    return typeof HTMLImageElement < "u" && ne instanceof HTMLImageElement ? (u.width = ne.naturalWidth || ne.width, u.height = ne.naturalHeight || ne.height) : typeof VideoFrame < "u" && ne instanceof VideoFrame ? (u.width = ne.displayWidth, u.height = ne.displayHeight) : (u.width = ne.width, u.height = ne.height), u;
  }
  this.allocateTextureUnit = Y, this.resetTextureUnits = H, this.setTexture2D = X, this.setTexture2DArray = ee, this.setTexture3D = oe, this.setTextureCube = fe, this.rebindTextures = en, this.setupRenderTarget = z, this.updateRenderTargetMipmap = ue, this.updateMultisampleRenderTarget = Ye, this.setupDepthRenderbuffer = Wt, this.setupFrameBufferTexture = at, this.useMultisampledRTT = Et, this.isReversedDepthBuffer = function() {
    return t.buffers.depth.getReversed();
  };
}
function C8(i, e) {
  function t(n, r = Ds) {
    let s;
    const o = Xt.getTransfer(r);
    if (n === Mi) return i.UNSIGNED_BYTE;
    if (n === m0) return i.UNSIGNED_SHORT_4_4_4_4;
    if (n === g0) return i.UNSIGNED_SHORT_5_5_5_1;
    if (n === _0) return i.UNSIGNED_INT_5_9_9_9_REV;
    if (n === x0) return i.UNSIGNED_INT_10F_11F_11F_REV;
    if (n === Ou) return i.BYTE;
    if (n === ku) return i.SHORT;
    if (n === Oo) return i.UNSIGNED_SHORT;
    if (n === _r) return i.INT;
    if (n === Jn) return i.UNSIGNED_INT;
    if (n === Ei) return i.FLOAT;
    if (n === Ri) return i.HALF_FLOAT;
    if (n === k_) return i.ALPHA;
    if (n === nA) return i.RGB;
    if (n === Pi) return i.RGBA;
    if (n === Lr) return i.DEPTH_COMPONENT;
    if (n === ds) return i.DEPTH_STENCIL;
    if (n === Yh) return i.RED;
    if (n === Zu) return i.RED_INTEGER;
    if (n === fs) return i.RG;
    if (n === Qh) return i.RG_INTEGER;
    if (n === Kh) return i.RGBA_INTEGER;
    if (n === Rl || n === Cl || n === Pl || n === Nl)
      if (o === vt)
        if (s = e.get("WEBGL_compressed_texture_s3tc_srgb"), s !== null) {
          if (n === Rl) return s.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (n === Cl) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (n === Pl) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (n === Nl) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else
          return null;
      else if (s = e.get("WEBGL_compressed_texture_s3tc"), s !== null) {
        if (n === Rl) return s.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (n === Cl) return s.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (n === Pl) return s.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (n === Nl) return s.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else
        return null;
    if (n === Lf || n === If || n === Bf || n === Ff)
      if (s = e.get("WEBGL_compressed_texture_pvrtc"), s !== null) {
        if (n === Lf) return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (n === If) return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (n === Bf) return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (n === Ff) return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else
        return null;
    if (n === mh || n === gh || n === _h || n === xh || n === yh || n === qu || n === vh)
      if (s = e.get("WEBGL_compressed_texture_etc"), s !== null) {
        if (n === mh || n === gh) return o === vt ? s.COMPRESSED_SRGB8_ETC2 : s.COMPRESSED_RGB8_ETC2;
        if (n === _h) return o === vt ? s.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : s.COMPRESSED_RGBA8_ETC2_EAC;
        if (n === xh) return s.COMPRESSED_R11_EAC;
        if (n === yh) return s.COMPRESSED_SIGNED_R11_EAC;
        if (n === qu) return s.COMPRESSED_RG11_EAC;
        if (n === vh) return s.COMPRESSED_SIGNED_RG11_EAC;
      } else
        return null;
    if (n === bh || n === Sh || n === Th || n === wh || n === Mh || n === Eh || n === Rh || n === Ch || n === Ph || n === Nh || n === Dh || n === Lh || n === Ih || n === Bh)
      if (s = e.get("WEBGL_compressed_texture_astc"), s !== null) {
        if (n === bh) return o === vt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : s.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (n === Sh) return o === vt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : s.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (n === Th) return o === vt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : s.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (n === wh) return o === vt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : s.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (n === Mh) return o === vt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : s.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (n === Eh) return o === vt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : s.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (n === Rh) return o === vt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : s.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (n === Ch) return o === vt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : s.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (n === Ph) return o === vt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : s.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (n === Nh) return o === vt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : s.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (n === Dh) return o === vt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : s.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (n === Lh) return o === vt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : s.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (n === Ih) return o === vt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : s.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (n === Bh) return o === vt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : s.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else
        return null;
    if (n === Fh || n === d1 || n === f1)
      if (s = e.get("EXT_texture_compression_bptc"), s !== null) {
        if (n === Fh) return o === vt ? s.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : s.COMPRESSED_RGBA_BPTC_UNORM_EXT;
        if (n === d1) return s.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
        if (n === f1) return s.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
      } else
        return null;
    if (n === Uh || n === Oh || n === Hu || n === kh)
      if (s = e.get("EXT_texture_compression_rgtc"), s !== null) {
        if (n === Uh) return s.COMPRESSED_RED_RGTC1_EXT;
        if (n === Oh) return s.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (n === Hu) return s.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (n === kh) return s.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else
        return null;
    return n === Js ? i.UNSIGNED_INT_24_8 : i[n] !== void 0 ? i[n] : null;
  }
  return { convert: t };
}
const _q = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`, xq = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
class yq {
  /**
   * Constructs a new depth sensing module.
   */
  constructor() {
    this.texture = null, this.mesh = null, this.depthNear = 0, this.depthFar = 0;
  }
  /**
   * Inits the depth sensing module
   *
   * @param {XRWebGLDepthInformation} depthData - The XR depth data.
   * @param {XRRenderState} renderState - The XR render state.
   */
  init(e, t) {
    if (this.texture === null) {
      const n = new F3(e.texture);
      (e.depthNear !== t.depthNear || e.depthFar !== t.depthFar) && (this.depthNear = e.depthNear, this.depthFar = e.depthFar), this.texture = n;
    }
  }
  /**
   * Returns a plane mesh that visualizes the depth texture.
   *
   * @param {ArrayCamera} cameraXR - The XR camera.
   * @return {?Mesh} The plane mesh.
   */
  getMesh(e) {
    if (this.texture !== null && this.mesh === null) {
      const t = e.cameras[0].viewport, n = new Fr({
        vertexShader: _q,
        fragmentShader: xq,
        uniforms: {
          depthColor: { value: this.texture },
          depthWidth: { value: t.z },
          depthHeight: { value: t.w }
        }
      });
      this.mesh = new Tn(new td(20, 20), n);
    }
    return this.mesh;
  }
  /**
   * Resets the module
   */
  reset() {
    this.texture = null, this.mesh = null;
  }
  /**
   * Returns a texture representing the depth of the user's environment.
   *
   * @return {?ExternalTexture} The depth texture.
   */
  getDepthTexture() {
    return this.texture;
  }
}
class vq extends lo {
  /**
   * Constructs a new WebGL renderer.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGL2RenderingContext} gl - The rendering context.
   */
  constructor(e, t) {
    super();
    const n = this;
    let r = null, s = 1, o = null, a = "local-floor", l = 1, u = null, c = null, A = null, m = null, _ = null, y = null;
    const T = typeof XRWebGLBinding < "u", b = new yq(), S = {}, E = t.getContextAttributes();
    let R = null, C = null;
    const L = [], D = [], B = new Le();
    let U = null;
    const N = new Ji();
    N.viewport = new Kt();
    const O = new Ji();
    O.viewport = new Kt();
    const G = [N, O], H = new dS();
    let Y = null, K = null;
    this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(Pe) {
      let ke = L[Pe];
      return ke === void 0 && (ke = new bp(), L[Pe] = ke), ke.getTargetRaySpace();
    }, this.getControllerGrip = function(Pe) {
      let ke = L[Pe];
      return ke === void 0 && (ke = new bp(), L[Pe] = ke), ke.getGripSpace();
    }, this.getHand = function(Pe) {
      let ke = L[Pe];
      return ke === void 0 && (ke = new bp(), L[Pe] = ke), ke.getHandSpace();
    };
    function X(Pe) {
      const ke = D.indexOf(Pe.inputSource);
      if (ke === -1)
        return;
      const at = L[ke];
      at !== void 0 && (at.update(Pe.inputSource, Pe.frame, u || o), at.dispatchEvent({ type: Pe.type, data: Pe.inputSource }));
    }
    function ee() {
      r.removeEventListener("select", X), r.removeEventListener("selectstart", X), r.removeEventListener("selectend", X), r.removeEventListener("squeeze", X), r.removeEventListener("squeezestart", X), r.removeEventListener("squeezeend", X), r.removeEventListener("end", ee), r.removeEventListener("inputsourceschange", oe);
      for (let Pe = 0; Pe < L.length; Pe++) {
        const ke = D[Pe];
        ke !== null && (D[Pe] = null, L[Pe].disconnect(ke));
      }
      Y = null, K = null, b.reset();
      for (const Pe in S)
        delete S[Pe];
      e.setRenderTarget(R), _ = null, m = null, A = null, r = null, C = null, Tt.stop(), n.isPresenting = !1, e.setPixelRatio(U), e.setSize(B.width, B.height, !1), n.dispatchEvent({ type: "sessionend" });
    }
    this.setFramebufferScaleFactor = function(Pe) {
      s = Pe, n.isPresenting === !0 && Me("WebXRManager: Cannot change framebuffer scale while presenting.");
    }, this.setReferenceSpaceType = function(Pe) {
      a = Pe, n.isPresenting === !0 && Me("WebXRManager: Cannot change reference space type while presenting.");
    }, this.getReferenceSpace = function() {
      return u || o;
    }, this.setReferenceSpace = function(Pe) {
      u = Pe;
    }, this.getBaseLayer = function() {
      return m !== null ? m : _;
    }, this.getBinding = function() {
      return A === null && T && (A = new XRWebGLBinding(r, t)), A;
    }, this.getFrame = function() {
      return y;
    }, this.getSession = function() {
      return r;
    }, this.setSession = async function(Pe) {
      if (r = Pe, r !== null) {
        if (R = e.getRenderTarget(), r.addEventListener("select", X), r.addEventListener("selectstart", X), r.addEventListener("selectend", X), r.addEventListener("squeeze", X), r.addEventListener("squeezestart", X), r.addEventListener("squeezeend", X), r.addEventListener("end", ee), r.addEventListener("inputsourceschange", oe), E.xrCompatible !== !0 && await t.makeXRCompatible(), U = e.getPixelRatio(), e.getSize(B), T && "createProjectionLayer" in XRWebGLBinding.prototype) {
          let at = null, wt = null, ot = null;
          E.depth && (ot = E.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24, at = E.stencil ? ds : Lr, wt = E.stencil ? Js : Jn);
          const Wt = {
            colorFormat: t.RGBA8,
            depthFormat: ot,
            scaleFactor: s
          };
          A = this.getBinding(), m = A.createProjectionLayer(Wt), r.updateRenderState({ layers: [m] }), e.setPixelRatio(1), e.setSize(m.textureWidth, m.textureHeight, !1), C = new eo(
            m.textureWidth,
            m.textureHeight,
            {
              format: Pi,
              type: Mi,
              depthTexture: new Qr(m.textureWidth, m.textureHeight, wt, void 0, void 0, void 0, void 0, void 0, void 0, at),
              stencilBuffer: E.stencil,
              colorSpace: e.outputColorSpace,
              samples: E.antialias ? 4 : 0,
              resolveDepthBuffer: m.ignoreDepthValues === !1,
              resolveStencilBuffer: m.ignoreDepthValues === !1
            }
          );
        } else {
          const at = {
            antialias: E.antialias,
            alpha: !0,
            depth: E.depth,
            stencil: E.stencil,
            framebufferScaleFactor: s
          };
          _ = new XRWebGLLayer(r, t, at), r.updateRenderState({ baseLayer: _ }), e.setPixelRatio(1), e.setSize(_.framebufferWidth, _.framebufferHeight, !1), C = new eo(
            _.framebufferWidth,
            _.framebufferHeight,
            {
              format: Pi,
              type: Mi,
              colorSpace: e.outputColorSpace,
              stencilBuffer: E.stencil,
              resolveDepthBuffer: _.ignoreDepthValues === !1,
              resolveStencilBuffer: _.ignoreDepthValues === !1
            }
          );
        }
        C.isXRRenderTarget = !0, this.setFoveation(l), u = null, o = await r.requestReferenceSpace(a), Tt.setContext(r), Tt.start(), n.isPresenting = !0, n.dispatchEvent({ type: "sessionstart" });
      }
    }, this.getEnvironmentBlendMode = function() {
      if (r !== null)
        return r.environmentBlendMode;
    }, this.getDepthTexture = function() {
      return b.getDepthTexture();
    };
    function oe(Pe) {
      for (let ke = 0; ke < Pe.removed.length; ke++) {
        const at = Pe.removed[ke], wt = D.indexOf(at);
        wt >= 0 && (D[wt] = null, L[wt].disconnect(at));
      }
      for (let ke = 0; ke < Pe.added.length; ke++) {
        const at = Pe.added[ke];
        let wt = D.indexOf(at);
        if (wt === -1) {
          for (let Wt = 0; Wt < L.length; Wt++)
            if (Wt >= D.length) {
              D.push(at), wt = Wt;
              break;
            } else if (D[Wt] === null) {
              D[Wt] = at, wt = Wt;
              break;
            }
          if (wt === -1) break;
        }
        const ot = L[wt];
        ot && ot.connect(at);
      }
    }
    const fe = new j(), _e = new j();
    function Te(Pe, ke, at) {
      fe.setFromMatrixPosition(ke.matrixWorld), _e.setFromMatrixPosition(at.matrixWorld);
      const wt = fe.distanceTo(_e), ot = ke.projectionMatrix.elements, Wt = at.projectionMatrix.elements, en = ot[14] / (ot[10] - 1), z = ot[14] / (ot[10] + 1), ue = (ot[9] + 1) / ot[5], he = (ot[9] - 1) / ot[5], Ee = (ot[8] - 1) / ot[0], Ye = (Wt[8] + 1) / Wt[0], te = en * Ee, Et = en * Ye, dt = wt / (-Ee + Ye), Nt = dt * -Ee;
      if (ke.matrixWorld.decompose(Pe.position, Pe.quaternion, Pe.scale), Pe.translateX(Nt), Pe.translateZ(dt), Pe.matrixWorld.compose(Pe.position, Pe.quaternion, Pe.scale), Pe.matrixWorldInverse.copy(Pe.matrixWorld).invert(), ot[10] === -1)
        Pe.projectionMatrix.copy(ke.projectionMatrix), Pe.projectionMatrixInverse.copy(ke.projectionMatrixInverse);
      else {
        const rt = en + dt, ne = z + dt, W = te - Nt, ge = Et + (wt - Nt), Fe = ue * z / ne * rt, We = he * z / ne * rt;
        Pe.projectionMatrix.makePerspective(W, ge, Fe, We, rt, ne), Pe.projectionMatrixInverse.copy(Pe.projectionMatrix).invert();
      }
    }
    function Ce(Pe, ke) {
      ke === null ? Pe.matrixWorld.copy(Pe.matrix) : Pe.matrixWorld.multiplyMatrices(ke.matrixWorld, Pe.matrix), Pe.matrixWorldInverse.copy(Pe.matrixWorld).invert();
    }
    this.updateCamera = function(Pe) {
      if (r === null) return;
      let ke = Pe.near, at = Pe.far;
      b.texture !== null && (b.depthNear > 0 && (ke = b.depthNear), b.depthFar > 0 && (at = b.depthFar)), H.near = O.near = N.near = ke, H.far = O.far = N.far = at, (Y !== H.near || K !== H.far) && (r.updateRenderState({
        depthNear: H.near,
        depthFar: H.far
      }), Y = H.near, K = H.far), H.layers.mask = Pe.layers.mask | 6, N.layers.mask = H.layers.mask & 3, O.layers.mask = H.layers.mask & 5;
      const wt = Pe.parent, ot = H.cameras;
      Ce(H, wt);
      for (let Wt = 0; Wt < ot.length; Wt++)
        Ce(ot[Wt], wt);
      ot.length === 2 ? Te(H, N, O) : H.projectionMatrix.copy(N.projectionMatrix), Je(Pe, H, wt);
    };
    function Je(Pe, ke, at) {
      at === null ? Pe.matrix.copy(ke.matrixWorld) : (Pe.matrix.copy(at.matrixWorld), Pe.matrix.invert(), Pe.matrix.multiply(ke.matrixWorld)), Pe.matrix.decompose(Pe.position, Pe.quaternion, Pe.scale), Pe.updateMatrixWorld(!0), Pe.projectionMatrix.copy(ke.projectionMatrix), Pe.projectionMatrixInverse.copy(ke.projectionMatrixInverse), Pe.isPerspectiveCamera && (Pe.fov = Gh * 2 * Math.atan(1 / Pe.projectionMatrix.elements[5]), Pe.zoom = 1);
    }
    this.getCamera = function() {
      return H;
    }, this.getFoveation = function() {
      if (!(m === null && _ === null))
        return l;
    }, this.setFoveation = function(Pe) {
      l = Pe, m !== null && (m.fixedFoveation = Pe), _ !== null && _.fixedFoveation !== void 0 && (_.fixedFoveation = Pe);
    }, this.hasDepthSensing = function() {
      return b.texture !== null;
    }, this.getDepthSensingMesh = function() {
      return b.getMesh(H);
    }, this.getCameraTexture = function(Pe) {
      return S[Pe];
    };
    let Qe = null;
    function zt(Pe, ke) {
      if (c = ke.getViewerPose(u || o), y = ke, c !== null) {
        const at = c.views;
        _ !== null && (e.setRenderTargetFramebuffer(C, _.framebuffer), e.setRenderTarget(C));
        let wt = !1;
        at.length !== H.cameras.length && (H.cameras.length = 0, wt = !0);
        for (let z = 0; z < at.length; z++) {
          const ue = at[z];
          let he = null;
          if (_ !== null)
            he = _.getViewport(ue);
          else {
            const Ye = A.getViewSubImage(m, ue);
            he = Ye.viewport, z === 0 && (e.setRenderTargetTextures(
              C,
              Ye.colorTexture,
              Ye.depthStencilTexture
            ), e.setRenderTarget(C));
          }
          let Ee = G[z];
          Ee === void 0 && (Ee = new Ji(), Ee.layers.enable(z), Ee.viewport = new Kt(), G[z] = Ee), Ee.matrix.fromArray(ue.transform.matrix), Ee.matrix.decompose(Ee.position, Ee.quaternion, Ee.scale), Ee.projectionMatrix.fromArray(ue.projectionMatrix), Ee.projectionMatrixInverse.copy(Ee.projectionMatrix).invert(), Ee.viewport.set(he.x, he.y, he.width, he.height), z === 0 && (H.matrix.copy(Ee.matrix), H.matrix.decompose(H.position, H.quaternion, H.scale)), wt === !0 && H.cameras.push(Ee);
        }
        const ot = r.enabledFeatures;
        if (ot && ot.includes("depth-sensing") && r.depthUsage == "gpu-optimized" && T) {
          A = n.getBinding();
          const z = A.getDepthInformation(at[0]);
          z && z.isValid && z.texture && b.init(z, r.renderState);
        }
        if (ot && ot.includes("camera-access") && T) {
          e.state.unbindTexture(), A = n.getBinding();
          for (let z = 0; z < at.length; z++) {
            const ue = at[z].camera;
            if (ue) {
              let he = S[ue];
              he || (he = new F3(), S[ue] = he);
              const Ee = A.getCameraImage(ue);
              he.sourceTexture = Ee;
            }
          }
        }
      }
      for (let at = 0; at < L.length; at++) {
        const wt = D[at], ot = L[at];
        wt !== null && ot !== void 0 && ot.update(wt, ke, u || o);
      }
      Qe && Qe(Pe, ke), ke.detectedPlanes && n.dispatchEvent({ type: "planesdetected", data: ke }), y = null;
    }
    const Tt = new T8();
    Tt.setAnimationLoop(zt), this.setAnimationLoop = function(Pe) {
      Qe = Pe;
    }, this.dispose = function() {
    };
  }
}
const Pc = /* @__PURE__ */ new Ir(), bq = /* @__PURE__ */ new Mt();
function Sq(i, e) {
  function t(b, S) {
    b.matrixAutoUpdate === !0 && b.updateMatrix(), S.value.copy(b.matrix);
  }
  function n(b, S) {
    S.color.getRGB(b.fogColor.value, $5(i)), S.isFog ? (b.fogNear.value = S.near, b.fogFar.value = S.far) : S.isFogExp2 && (b.fogDensity.value = S.density);
  }
  function r(b, S, E, R, C) {
    S.isMeshBasicMaterial || S.isMeshLambertMaterial ? s(b, S) : S.isMeshToonMaterial ? (s(b, S), A(b, S)) : S.isMeshPhongMaterial ? (s(b, S), c(b, S)) : S.isMeshStandardMaterial ? (s(b, S), m(b, S), S.isMeshPhysicalMaterial && _(b, S, C)) : S.isMeshMatcapMaterial ? (s(b, S), y(b, S)) : S.isMeshDepthMaterial ? s(b, S) : S.isMeshDistanceMaterial ? (s(b, S), T(b, S)) : S.isMeshNormalMaterial ? s(b, S) : S.isLineBasicMaterial ? (o(b, S), S.isLineDashedMaterial && a(b, S)) : S.isPointsMaterial ? l(b, S, E, R) : S.isSpriteMaterial ? u(b, S) : S.isShadowMaterial ? (b.color.value.copy(S.color), b.opacity.value = S.opacity) : S.isShaderMaterial && (S.uniformsNeedUpdate = !1);
  }
  function s(b, S) {
    b.opacity.value = S.opacity, S.color && b.diffuse.value.copy(S.color), S.emissive && b.emissive.value.copy(S.emissive).multiplyScalar(S.emissiveIntensity), S.map && (b.map.value = S.map, t(S.map, b.mapTransform)), S.alphaMap && (b.alphaMap.value = S.alphaMap, t(S.alphaMap, b.alphaMapTransform)), S.bumpMap && (b.bumpMap.value = S.bumpMap, t(S.bumpMap, b.bumpMapTransform), b.bumpScale.value = S.bumpScale, S.side === si && (b.bumpScale.value *= -1)), S.normalMap && (b.normalMap.value = S.normalMap, t(S.normalMap, b.normalMapTransform), b.normalScale.value.copy(S.normalScale), S.side === si && b.normalScale.value.negate()), S.displacementMap && (b.displacementMap.value = S.displacementMap, t(S.displacementMap, b.displacementMapTransform), b.displacementScale.value = S.displacementScale, b.displacementBias.value = S.displacementBias), S.emissiveMap && (b.emissiveMap.value = S.emissiveMap, t(S.emissiveMap, b.emissiveMapTransform)), S.specularMap && (b.specularMap.value = S.specularMap, t(S.specularMap, b.specularMapTransform)), S.alphaTest > 0 && (b.alphaTest.value = S.alphaTest);
    const E = e.get(S), R = E.envMap, C = E.envMapRotation;
    R && (b.envMap.value = R, Pc.copy(C), Pc.x *= -1, Pc.y *= -1, Pc.z *= -1, R.isCubeTexture && R.isRenderTargetTexture === !1 && (Pc.y *= -1, Pc.z *= -1), b.envMapRotation.value.setFromMatrix4(bq.makeRotationFromEuler(Pc)), b.flipEnvMap.value = R.isCubeTexture && R.isRenderTargetTexture === !1 ? -1 : 1, b.reflectivity.value = S.reflectivity, b.ior.value = S.ior, b.refractionRatio.value = S.refractionRatio), S.lightMap && (b.lightMap.value = S.lightMap, b.lightMapIntensity.value = S.lightMapIntensity, t(S.lightMap, b.lightMapTransform)), S.aoMap && (b.aoMap.value = S.aoMap, b.aoMapIntensity.value = S.aoMapIntensity, t(S.aoMap, b.aoMapTransform));
  }
  function o(b, S) {
    b.diffuse.value.copy(S.color), b.opacity.value = S.opacity, S.map && (b.map.value = S.map, t(S.map, b.mapTransform));
  }
  function a(b, S) {
    b.dashSize.value = S.dashSize, b.totalSize.value = S.dashSize + S.gapSize, b.scale.value = S.scale;
  }
  function l(b, S, E, R) {
    b.diffuse.value.copy(S.color), b.opacity.value = S.opacity, b.size.value = S.size * E, b.scale.value = R * 0.5, S.map && (b.map.value = S.map, t(S.map, b.uvTransform)), S.alphaMap && (b.alphaMap.value = S.alphaMap, t(S.alphaMap, b.alphaMapTransform)), S.alphaTest > 0 && (b.alphaTest.value = S.alphaTest);
  }
  function u(b, S) {
    b.diffuse.value.copy(S.color), b.opacity.value = S.opacity, b.rotation.value = S.rotation, S.map && (b.map.value = S.map, t(S.map, b.mapTransform)), S.alphaMap && (b.alphaMap.value = S.alphaMap, t(S.alphaMap, b.alphaMapTransform)), S.alphaTest > 0 && (b.alphaTest.value = S.alphaTest);
  }
  function c(b, S) {
    b.specular.value.copy(S.specular), b.shininess.value = Math.max(S.shininess, 1e-4);
  }
  function A(b, S) {
    S.gradientMap && (b.gradientMap.value = S.gradientMap);
  }
  function m(b, S) {
    b.metalness.value = S.metalness, S.metalnessMap && (b.metalnessMap.value = S.metalnessMap, t(S.metalnessMap, b.metalnessMapTransform)), b.roughness.value = S.roughness, S.roughnessMap && (b.roughnessMap.value = S.roughnessMap, t(S.roughnessMap, b.roughnessMapTransform)), S.envMap && (b.envMapIntensity.value = S.envMapIntensity);
  }
  function _(b, S, E) {
    b.ior.value = S.ior, S.sheen > 0 && (b.sheenColor.value.copy(S.sheenColor).multiplyScalar(S.sheen), b.sheenRoughness.value = S.sheenRoughness, S.sheenColorMap && (b.sheenColorMap.value = S.sheenColorMap, t(S.sheenColorMap, b.sheenColorMapTransform)), S.sheenRoughnessMap && (b.sheenRoughnessMap.value = S.sheenRoughnessMap, t(S.sheenRoughnessMap, b.sheenRoughnessMapTransform))), S.clearcoat > 0 && (b.clearcoat.value = S.clearcoat, b.clearcoatRoughness.value = S.clearcoatRoughness, S.clearcoatMap && (b.clearcoatMap.value = S.clearcoatMap, t(S.clearcoatMap, b.clearcoatMapTransform)), S.clearcoatRoughnessMap && (b.clearcoatRoughnessMap.value = S.clearcoatRoughnessMap, t(S.clearcoatRoughnessMap, b.clearcoatRoughnessMapTransform)), S.clearcoatNormalMap && (b.clearcoatNormalMap.value = S.clearcoatNormalMap, t(S.clearcoatNormalMap, b.clearcoatNormalMapTransform), b.clearcoatNormalScale.value.copy(S.clearcoatNormalScale), S.side === si && b.clearcoatNormalScale.value.negate())), S.dispersion > 0 && (b.dispersion.value = S.dispersion), S.iridescence > 0 && (b.iridescence.value = S.iridescence, b.iridescenceIOR.value = S.iridescenceIOR, b.iridescenceThicknessMinimum.value = S.iridescenceThicknessRange[0], b.iridescenceThicknessMaximum.value = S.iridescenceThicknessRange[1], S.iridescenceMap && (b.iridescenceMap.value = S.iridescenceMap, t(S.iridescenceMap, b.iridescenceMapTransform)), S.iridescenceThicknessMap && (b.iridescenceThicknessMap.value = S.iridescenceThicknessMap, t(S.iridescenceThicknessMap, b.iridescenceThicknessMapTransform))), S.transmission > 0 && (b.transmission.value = S.transmission, b.transmissionSamplerMap.value = E.texture, b.transmissionSamplerSize.value.set(E.width, E.height), S.transmissionMap && (b.transmissionMap.value = S.transmissionMap, t(S.transmissionMap, b.transmissionMapTransform)), b.thickness.value = S.thickness, S.thicknessMap && (b.thicknessMap.value = S.thicknessMap, t(S.thicknessMap, b.thicknessMapTransform)), b.attenuationDistance.value = S.attenuationDistance, b.attenuationColor.value.copy(S.attenuationColor)), S.anisotropy > 0 && (b.anisotropyVector.value.set(S.anisotropy * Math.cos(S.anisotropyRotation), S.anisotropy * Math.sin(S.anisotropyRotation)), S.anisotropyMap && (b.anisotropyMap.value = S.anisotropyMap, t(S.anisotropyMap, b.anisotropyMapTransform))), b.specularIntensity.value = S.specularIntensity, b.specularColor.value.copy(S.specularColor), S.specularColorMap && (b.specularColorMap.value = S.specularColorMap, t(S.specularColorMap, b.specularColorMapTransform)), S.specularIntensityMap && (b.specularIntensityMap.value = S.specularIntensityMap, t(S.specularIntensityMap, b.specularIntensityMapTransform));
  }
  function y(b, S) {
    S.matcap && (b.matcap.value = S.matcap);
  }
  function T(b, S) {
    const E = e.get(S).light;
    b.referencePosition.value.setFromMatrixPosition(E.matrixWorld), b.nearDistance.value = E.shadow.camera.near, b.farDistance.value = E.shadow.camera.far;
  }
  return {
    refreshFogUniforms: n,
    refreshMaterialUniforms: r
  };
}
function Tq(i, e, t, n) {
  let r = {}, s = {}, o = [];
  const a = i.getParameter(i.MAX_UNIFORM_BUFFER_BINDINGS);
  function l(E, R) {
    const C = R.program;
    n.uniformBlockBinding(E, C);
  }
  function u(E, R) {
    let C = r[E.id];
    C === void 0 && (y(E), C = c(E), r[E.id] = C, E.addEventListener("dispose", b));
    const L = R.program;
    n.updateUBOMapping(E, L);
    const D = e.render.frame;
    s[E.id] !== D && (m(E), s[E.id] = D);
  }
  function c(E) {
    const R = A();
    E.__bindingPointIndex = R;
    const C = i.createBuffer(), L = E.__size, D = E.usage;
    return i.bindBuffer(i.UNIFORM_BUFFER, C), i.bufferData(i.UNIFORM_BUFFER, L, D), i.bindBuffer(i.UNIFORM_BUFFER, null), i.bindBufferBase(i.UNIFORM_BUFFER, R, C), C;
  }
  function A() {
    for (let E = 0; E < a; E++)
      if (o.indexOf(E) === -1)
        return o.push(E), E;
    return Ie("WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0;
  }
  function m(E) {
    const R = r[E.id], C = E.uniforms, L = E.__cache;
    i.bindBuffer(i.UNIFORM_BUFFER, R);
    for (let D = 0, B = C.length; D < B; D++) {
      const U = Array.isArray(C[D]) ? C[D] : [C[D]];
      for (let N = 0, O = U.length; N < O; N++) {
        const G = U[N];
        if (_(G, D, N, L) === !0) {
          const H = G.__offset, Y = Array.isArray(G.value) ? G.value : [G.value];
          let K = 0;
          for (let X = 0; X < Y.length; X++) {
            const ee = Y[X], oe = T(ee);
            typeof ee == "number" || typeof ee == "boolean" ? (G.__data[0] = ee, i.bufferSubData(i.UNIFORM_BUFFER, H + K, G.__data)) : ee.isMatrix3 ? (G.__data[0] = ee.elements[0], G.__data[1] = ee.elements[1], G.__data[2] = ee.elements[2], G.__data[3] = 0, G.__data[4] = ee.elements[3], G.__data[5] = ee.elements[4], G.__data[6] = ee.elements[5], G.__data[7] = 0, G.__data[8] = ee.elements[6], G.__data[9] = ee.elements[7], G.__data[10] = ee.elements[8], G.__data[11] = 0) : (ee.toArray(G.__data, K), K += oe.storage / Float32Array.BYTES_PER_ELEMENT);
          }
          i.bufferSubData(i.UNIFORM_BUFFER, H, G.__data);
        }
      }
    }
    i.bindBuffer(i.UNIFORM_BUFFER, null);
  }
  function _(E, R, C, L) {
    const D = E.value, B = R + "_" + C;
    if (L[B] === void 0)
      return typeof D == "number" || typeof D == "boolean" ? L[B] = D : L[B] = D.clone(), !0;
    {
      const U = L[B];
      if (typeof D == "number" || typeof D == "boolean") {
        if (U !== D)
          return L[B] = D, !0;
      } else if (U.equals(D) === !1)
        return U.copy(D), !0;
    }
    return !1;
  }
  function y(E) {
    const R = E.uniforms;
    let C = 0;
    const L = 16;
    for (let B = 0, U = R.length; B < U; B++) {
      const N = Array.isArray(R[B]) ? R[B] : [R[B]];
      for (let O = 0, G = N.length; O < G; O++) {
        const H = N[O], Y = Array.isArray(H.value) ? H.value : [H.value];
        for (let K = 0, X = Y.length; K < X; K++) {
          const ee = Y[K], oe = T(ee), fe = C % L, _e = fe % oe.boundary, Te = fe + _e;
          C += _e, Te !== 0 && L - Te < oe.storage && (C += L - Te), H.__data = new Float32Array(oe.storage / Float32Array.BYTES_PER_ELEMENT), H.__offset = C, C += oe.storage;
        }
      }
    }
    const D = C % L;
    return D > 0 && (C += L - D), E.__size = C, E.__cache = {}, this;
  }
  function T(E) {
    const R = {
      boundary: 0,
      // bytes
      storage: 0
      // bytes
    };
    return typeof E == "number" || typeof E == "boolean" ? (R.boundary = 4, R.storage = 4) : E.isVector2 ? (R.boundary = 8, R.storage = 8) : E.isVector3 || E.isColor ? (R.boundary = 16, R.storage = 12) : E.isVector4 ? (R.boundary = 16, R.storage = 16) : E.isMatrix3 ? (R.boundary = 48, R.storage = 48) : E.isMatrix4 ? (R.boundary = 64, R.storage = 64) : E.isTexture ? Me("WebGLRenderer: Texture samplers can not be part of an uniforms group.") : Me("WebGLRenderer: Unsupported uniform value type.", E), R;
  }
  function b(E) {
    const R = E.target;
    R.removeEventListener("dispose", b);
    const C = o.indexOf(R.__bindingPointIndex);
    o.splice(C, 1), i.deleteBuffer(r[R.id]), delete r[R.id], delete s[R.id];
  }
  function S() {
    for (const E in r)
      i.deleteBuffer(r[E]);
    o = [], r = {}, s = {};
  }
  return {
    bind: l,
    update: u,
    dispose: S
  };
}
const wq = new Uint16Array([
  12469,
  15057,
  12620,
  14925,
  13266,
  14620,
  13807,
  14376,
  14323,
  13990,
  14545,
  13625,
  14713,
  13328,
  14840,
  12882,
  14931,
  12528,
  14996,
  12233,
  15039,
  11829,
  15066,
  11525,
  15080,
  11295,
  15085,
  10976,
  15082,
  10705,
  15073,
  10495,
  13880,
  14564,
  13898,
  14542,
  13977,
  14430,
  14158,
  14124,
  14393,
  13732,
  14556,
  13410,
  14702,
  12996,
  14814,
  12596,
  14891,
  12291,
  14937,
  11834,
  14957,
  11489,
  14958,
  11194,
  14943,
  10803,
  14921,
  10506,
  14893,
  10278,
  14858,
  9960,
  14484,
  14039,
  14487,
  14025,
  14499,
  13941,
  14524,
  13740,
  14574,
  13468,
  14654,
  13106,
  14743,
  12678,
  14818,
  12344,
  14867,
  11893,
  14889,
  11509,
  14893,
  11180,
  14881,
  10751,
  14852,
  10428,
  14812,
  10128,
  14765,
  9754,
  14712,
  9466,
  14764,
  13480,
  14764,
  13475,
  14766,
  13440,
  14766,
  13347,
  14769,
  13070,
  14786,
  12713,
  14816,
  12387,
  14844,
  11957,
  14860,
  11549,
  14868,
  11215,
  14855,
  10751,
  14825,
  10403,
  14782,
  10044,
  14729,
  9651,
  14666,
  9352,
  14599,
  9029,
  14967,
  12835,
  14966,
  12831,
  14963,
  12804,
  14954,
  12723,
  14936,
  12564,
  14917,
  12347,
  14900,
  11958,
  14886,
  11569,
  14878,
  11247,
  14859,
  10765,
  14828,
  10401,
  14784,
  10011,
  14727,
  9600,
  14660,
  9289,
  14586,
  8893,
  14508,
  8533,
  15111,
  12234,
  15110,
  12234,
  15104,
  12216,
  15092,
  12156,
  15067,
  12010,
  15028,
  11776,
  14981,
  11500,
  14942,
  11205,
  14902,
  10752,
  14861,
  10393,
  14812,
  9991,
  14752,
  9570,
  14682,
  9252,
  14603,
  8808,
  14519,
  8445,
  14431,
  8145,
  15209,
  11449,
  15208,
  11451,
  15202,
  11451,
  15190,
  11438,
  15163,
  11384,
  15117,
  11274,
  15055,
  10979,
  14994,
  10648,
  14932,
  10343,
  14871,
  9936,
  14803,
  9532,
  14729,
  9218,
  14645,
  8742,
  14556,
  8381,
  14461,
  8020,
  14365,
  7603,
  15273,
  10603,
  15272,
  10607,
  15267,
  10619,
  15256,
  10631,
  15231,
  10614,
  15182,
  10535,
  15118,
  10389,
  15042,
  10167,
  14963,
  9787,
  14883,
  9447,
  14800,
  9115,
  14710,
  8665,
  14615,
  8318,
  14514,
  7911,
  14411,
  7507,
  14279,
  7198,
  15314,
  9675,
  15313,
  9683,
  15309,
  9712,
  15298,
  9759,
  15277,
  9797,
  15229,
  9773,
  15166,
  9668,
  15084,
  9487,
  14995,
  9274,
  14898,
  8910,
  14800,
  8539,
  14697,
  8234,
  14590,
  7790,
  14479,
  7409,
  14367,
  7067,
  14178,
  6621,
  15337,
  8619,
  15337,
  8631,
  15333,
  8677,
  15325,
  8769,
  15305,
  8871,
  15264,
  8940,
  15202,
  8909,
  15119,
  8775,
  15022,
  8565,
  14916,
  8328,
  14804,
  8009,
  14688,
  7614,
  14569,
  7287,
  14448,
  6888,
  14321,
  6483,
  14088,
  6171,
  15350,
  7402,
  15350,
  7419,
  15347,
  7480,
  15340,
  7613,
  15322,
  7804,
  15287,
  7973,
  15229,
  8057,
  15148,
  8012,
  15046,
  7846,
  14933,
  7611,
  14810,
  7357,
  14682,
  7069,
  14552,
  6656,
  14421,
  6316,
  14251,
  5948,
  14007,
  5528,
  15356,
  5942,
  15356,
  5977,
  15353,
  6119,
  15348,
  6294,
  15332,
  6551,
  15302,
  6824,
  15249,
  7044,
  15171,
  7122,
  15070,
  7050,
  14949,
  6861,
  14818,
  6611,
  14679,
  6349,
  14538,
  6067,
  14398,
  5651,
  14189,
  5311,
  13935,
  4958,
  15359,
  4123,
  15359,
  4153,
  15356,
  4296,
  15353,
  4646,
  15338,
  5160,
  15311,
  5508,
  15263,
  5829,
  15188,
  6042,
  15088,
  6094,
  14966,
  6001,
  14826,
  5796,
  14678,
  5543,
  14527,
  5287,
  14377,
  4985,
  14133,
  4586,
  13869,
  4257,
  15360,
  1563,
  15360,
  1642,
  15358,
  2076,
  15354,
  2636,
  15341,
  3350,
  15317,
  4019,
  15273,
  4429,
  15203,
  4732,
  15105,
  4911,
  14981,
  4932,
  14836,
  4818,
  14679,
  4621,
  14517,
  4386,
  14359,
  4156,
  14083,
  3795,
  13808,
  3437,
  15360,
  122,
  15360,
  137,
  15358,
  285,
  15355,
  636,
  15344,
  1274,
  15322,
  2177,
  15281,
  2765,
  15215,
  3223,
  15120,
  3451,
  14995,
  3569,
  14846,
  3567,
  14681,
  3466,
  14511,
  3305,
  14344,
  3121,
  14037,
  2800,
  13753,
  2467,
  15360,
  0,
  15360,
  1,
  15359,
  21,
  15355,
  89,
  15346,
  253,
  15325,
  479,
  15287,
  796,
  15225,
  1148,
  15133,
  1492,
  15008,
  1749,
  14856,
  1882,
  14685,
  1886,
  14506,
  1783,
  14324,
  1608,
  13996,
  1398,
  13702,
  1183
]);
let Na = null;
function Mq() {
  return Na === null && (Na = new wo(wq, 16, 16, fs, Ri), Na.name = "DFG_LUT", Na.minFilter = qn, Na.magFilter = qn, Na.wrapS = xr, Na.wrapT = xr, Na.generateMipmaps = !1, Na.needsUpdate = !0), Na;
}
class P8 {
  /**
   * Constructs a new WebGL renderer.
   *
   * @param {WebGLRenderer~Options} [parameters] - The configuration parameter.
   */
  constructor(e = {}) {
    const {
      canvas: t = C3(),
      context: n = null,
      depth: r = !0,
      stencil: s = !1,
      alpha: o = !1,
      antialias: a = !1,
      premultipliedAlpha: l = !0,
      preserveDrawingBuffer: u = !1,
      powerPreference: c = "default",
      failIfMajorPerformanceCaveat: A = !1,
      reversedDepthBuffer: m = !1,
      outputBufferType: _ = Mi
    } = e;
    this.isWebGLRenderer = !0;
    let y;
    if (n !== null) {
      if (typeof WebGLRenderingContext < "u" && n instanceof WebGLRenderingContext)
        throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");
      y = n.getContextAttributes().alpha;
    } else
      y = o;
    const T = _, b = /* @__PURE__ */ new Set([
      Kh,
      Qh,
      Zu
    ]), S = /* @__PURE__ */ new Set([
      Mi,
      Jn,
      Oo,
      Js,
      m0,
      g0
    ]), E = new Uint32Array(4), R = new Int32Array(4);
    let C = null, L = null;
    const D = [], B = [];
    let U = null;
    this.domElement = t, this.debug = {
      /**
       * Enables error checking and reporting when shader programs are being compiled.
       * @type {boolean}
       */
      checkShaderErrors: !0,
      /**
       * Callback for custom error reporting.
       * @type {?Function}
       */
      onShaderError: null
    }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.toneMapping = Dr, this.toneMappingExposure = 1, this.transmissionResolutionScale = 1;
    const N = this;
    let O = !1;
    this._outputColorSpace = gr;
    let G = 0, H = 0, Y = null, K = -1, X = null;
    const ee = new Kt(), oe = new Kt();
    let fe = null;
    const _e = new ct(0);
    let Te = 0, Ce = t.width, Je = t.height, Qe = 1, zt = null, Tt = null;
    const Pe = new Kt(0, 0, Ce, Je), ke = new Kt(0, 0, Ce, Je);
    let at = !1;
    const wt = new ec();
    let ot = !1, Wt = !1;
    const en = new Mt(), z = new j(), ue = new Kt(), he = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 };
    let Ee = !1;
    function Ye() {
      return Y === null ? Qe : 1;
    }
    let te = n;
    function Et(Z, ve) {
      return t.getContext(Z, ve);
    }
    try {
      const Z = {
        alpha: !0,
        depth: r,
        stencil: s,
        antialias: a,
        premultipliedAlpha: l,
        preserveDrawingBuffer: u,
        powerPreference: c,
        failIfMajorPerformanceCaveat: A
      };
      if ("setAttribute" in t && t.setAttribute("data-engine", `three.js r${Ku}`), t.addEventListener("webglcontextlost", pn, !1), t.addEventListener("webglcontextrestored", di, !1), t.addEventListener("webglcontextcreationerror", $n, !1), te === null) {
        const ve = "webgl2";
        if (te = Et(ve, Z), te === null)
          throw Et(ve) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
      }
    } catch (Z) {
      throw Ie("WebGLRenderer: " + Z.message), Z;
    }
    let dt, Nt, rt, ne, W, ge, Fe, We, Oe, kt, ft, Ft, nn, tt, _t, Ut, Vt, pt, Rn, ie, bt, lt, Ct, it;
    function He() {
      dt = new EG(te), dt.init(), lt = new C8(te, dt), Nt = new _G(te, dt, e, lt), rt = new mq(te, dt), Nt.reversedDepthBuffer && m && rt.buffers.depth.setReversed(!0), ne = new PG(te), W = new tq(), ge = new gq(te, dt, rt, W, Nt, lt, ne), Fe = new yG(N), We = new MG(N), Oe = new I9(te), Ct = new mG(te, Oe), kt = new RG(te, Oe, ne, Ct), ft = new DG(te, kt, Oe, ne), Rn = new NG(te, Nt, ge), Ut = new xG(W), Ft = new eq(N, Fe, We, dt, Nt, Ct, Ut), nn = new Sq(N, W), tt = new iq(), _t = new uq(dt), pt = new pG(N, Fe, We, rt, ft, y, l), Vt = new Aq(N, ft, Nt), it = new Tq(te, ne, Nt, rt), ie = new gG(te, dt, ne), bt = new CG(te, dt, ne), ne.programs = Ft.programs, N.capabilities = Nt, N.extensions = dt, N.properties = W, N.renderLists = tt, N.shadowMap = Vt, N.state = rt, N.info = ne;
    }
    He(), T !== Mi && (U = new IG(T, t.width, t.height, r, s));
    const At = new vq(N, te);
    this.xr = At, this.getContext = function() {
      return te;
    }, this.getContextAttributes = function() {
      return te.getContextAttributes();
    }, this.forceContextLoss = function() {
      const Z = dt.get("WEBGL_lose_context");
      Z && Z.loseContext();
    }, this.forceContextRestore = function() {
      const Z = dt.get("WEBGL_lose_context");
      Z && Z.restoreContext();
    }, this.getPixelRatio = function() {
      return Qe;
    }, this.setPixelRatio = function(Z) {
      Z !== void 0 && (Qe = Z, this.setSize(Ce, Je, !1));
    }, this.getSize = function(Z) {
      return Z.set(Ce, Je);
    }, this.setSize = function(Z, ve, Ne = !0) {
      if (At.isPresenting) {
        Me("WebGLRenderer: Can't change size while VR device is presenting.");
        return;
      }
      Ce = Z, Je = ve, t.width = Math.floor(Z * Qe), t.height = Math.floor(ve * Qe), Ne === !0 && (t.style.width = Z + "px", t.style.height = ve + "px"), U !== null && U.setSize(t.width, t.height), this.setViewport(0, 0, Z, ve);
    }, this.getDrawingBufferSize = function(Z) {
      return Z.set(Ce * Qe, Je * Qe).floor();
    }, this.setDrawingBufferSize = function(Z, ve, Ne) {
      Ce = Z, Je = ve, Qe = Ne, t.width = Math.floor(Z * Ne), t.height = Math.floor(ve * Ne), this.setViewport(0, 0, Z, ve);
    }, this.setEffects = function(Z) {
      if (T === Mi) {
        console.error("THREE.WebGLRenderer: setEffects() requires outputBufferType set to HalfFloatType or FloatType.");
        return;
      }
      if (Z) {
        for (let ve = 0; ve < Z.length; ve++)
          if (Z[ve].isOutputPass === !0) {
            console.warn("THREE.WebGLRenderer: OutputPass is not needed in setEffects(). Tone mapping and color space conversion are applied automatically.");
            break;
          }
      }
      U.setEffects(Z || []);
    }, this.getCurrentViewport = function(Z) {
      return Z.copy(ee);
    }, this.getViewport = function(Z) {
      return Z.copy(Pe);
    }, this.setViewport = function(Z, ve, Ne, xe) {
      Z.isVector4 ? Pe.set(Z.x, Z.y, Z.z, Z.w) : Pe.set(Z, ve, Ne, xe), rt.viewport(ee.copy(Pe).multiplyScalar(Qe).round());
    }, this.getScissor = function(Z) {
      return Z.copy(ke);
    }, this.setScissor = function(Z, ve, Ne, xe) {
      Z.isVector4 ? ke.set(Z.x, Z.y, Z.z, Z.w) : ke.set(Z, ve, Ne, xe), rt.scissor(oe.copy(ke).multiplyScalar(Qe).round());
    }, this.getScissorTest = function() {
      return at;
    }, this.setScissorTest = function(Z) {
      rt.setScissorTest(at = Z);
    }, this.setOpaqueSort = function(Z) {
      zt = Z;
    }, this.setTransparentSort = function(Z) {
      Tt = Z;
    }, this.getClearColor = function(Z) {
      return Z.copy(pt.getClearColor());
    }, this.setClearColor = function() {
      pt.setClearColor(...arguments);
    }, this.getClearAlpha = function() {
      return pt.getClearAlpha();
    }, this.setClearAlpha = function() {
      pt.setClearAlpha(...arguments);
    }, this.clear = function(Z = !0, ve = !0, Ne = !0) {
      let xe = 0;
      if (Z) {
        let V = !1;
        if (Y !== null) {
          const Ve = Y.texture.format;
          V = b.has(Ve);
        }
        if (V) {
          const Ve = Y.texture.type, Dt = S.has(Ve), yt = pt.getClearColor(), Bt = pt.getClearAlpha(), $t = yt.r, ln = yt.g, q = yt.b;
          Dt ? (E[0] = $t, E[1] = ln, E[2] = q, E[3] = Bt, te.clearBufferuiv(te.COLOR, 0, E)) : (R[0] = $t, R[1] = ln, R[2] = q, R[3] = Bt, te.clearBufferiv(te.COLOR, 0, R));
        } else
          xe |= te.COLOR_BUFFER_BIT;
      }
      ve && (xe |= te.DEPTH_BUFFER_BIT), Ne && (xe |= te.STENCIL_BUFFER_BIT, this.state.buffers.stencil.setMask(4294967295)), te.clear(xe);
    }, this.clearColor = function() {
      this.clear(!0, !1, !1);
    }, this.clearDepth = function() {
      this.clear(!1, !0, !1);
    }, this.clearStencil = function() {
      this.clear(!1, !1, !0);
    }, this.dispose = function() {
      t.removeEventListener("webglcontextlost", pn, !1), t.removeEventListener("webglcontextrestored", di, !1), t.removeEventListener("webglcontextcreationerror", $n, !1), pt.dispose(), tt.dispose(), _t.dispose(), W.dispose(), Fe.dispose(), We.dispose(), ft.dispose(), Ct.dispose(), it.dispose(), Ft.dispose(), At.dispose(), At.removeEventListener("sessionstart", f), At.removeEventListener("sessionend", $), Mn.stop();
    };
    function pn(Z) {
      Z.preventDefault(), Of("WebGLRenderer: Context Lost."), O = !0;
    }
    function di() {
      Of("WebGLRenderer: Context Restored."), O = !1;
      const Z = ne.autoReset, ve = Vt.enabled, Ne = Vt.autoUpdate, xe = Vt.needsUpdate, V = Vt.type;
      He(), ne.autoReset = Z, Vt.enabled = ve, Vt.autoUpdate = Ne, Vt.needsUpdate = xe, Vt.type = V;
    }
    function $n(Z) {
      Ie("WebGLRenderer: A WebGL context could not be created. Reason: ", Z.statusMessage);
    }
    function Os(Z) {
      const ve = Z.target;
      ve.removeEventListener("dispose", Os), es(ve);
    }
    function es(Z) {
      De(Z), W.remove(Z);
    }
    function De(Z) {
      const ve = W.get(Z).programs;
      ve !== void 0 && (ve.forEach(function(Ne) {
        Ft.releaseProgram(Ne);
      }), Z.isShaderMaterial && Ft.releaseShaderCache(Z));
    }
    this.renderBufferDirect = function(Z, ve, Ne, xe, V, Ve) {
      ve === null && (ve = he);
      const Dt = V.isMesh && V.matrixWorld.determinant() < 0, yt = ud(Z, ve, Ne, xe, V);
      rt.setMaterial(xe, Dt);
      let Bt = Ne.index, $t = 1;
      if (xe.wireframe === !0) {
        if (Bt = kt.getWireframeAttribute(Ne), Bt === void 0) return;
        $t = 2;
      }
      const ln = Ne.drawRange, q = Ne.attributes.position;
      let Cn = ln.start * $t, oi = (ln.start + ln.count) * $t;
      Ve !== null && (Cn = Math.max(Cn, Ve.start * $t), oi = Math.min(oi, (Ve.start + Ve.count) * $t)), Bt !== null ? (Cn = Math.max(Cn, 0), oi = Math.min(oi, Bt.count)) : q != null && (Cn = Math.max(Cn, 0), oi = Math.min(oi, q.count));
      const Fi = oi - Cn;
      if (Fi < 0 || Fi === 1 / 0) return;
      Ct.setup(V, xe, yt, Ne, Bt);
      let Ui, fi = ie;
      if (Bt !== null && (Ui = Oe.get(Bt), fi = bt, fi.setIndex(Ui)), V.isMesh)
        xe.wireframe === !0 ? (rt.setLineWidth(xe.wireframeLinewidth * Ye()), fi.setMode(te.LINES)) : fi.setMode(te.TRIANGLES);
      else if (V.isLine) {
        let Jt = xe.linewidth;
        Jt === void 0 && (Jt = 1), rt.setLineWidth(Jt * Ye()), V.isLineSegments ? fi.setMode(te.LINES) : V.isLineLoop ? fi.setMode(te.LINE_LOOP) : fi.setMode(te.LINE_STRIP);
      } else V.isPoints ? fi.setMode(te.POINTS) : V.isSprite && fi.setMode(te.TRIANGLES);
      if (V.isBatchedMesh)
        if (V._multiDrawInstances !== null)
          li("WebGLRenderer: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection."), fi.renderMultiDrawInstances(V._multiDrawStarts, V._multiDrawCounts, V._multiDrawCount, V._multiDrawInstances);
        else if (dt.get("WEBGL_multi_draw"))
          fi.renderMultiDraw(V._multiDrawStarts, V._multiDrawCounts, V._multiDrawCount);
        else {
          const Jt = V._multiDrawStarts, Kn = V._multiDrawCounts, Hn = V._multiDrawCount, ts = Bt ? Oe.get(Bt).bytesPerElement : 1, Or = W.get(xe).currentProgram.getUniforms();
          for (let Zn = 0; Zn < Hn; Zn++)
            Or.setValue(te, "_gl_DrawID", Zn), fi.render(Jt[Zn] / ts, Kn[Zn]);
        }
      else if (V.isInstancedMesh)
        fi.renderInstances(Cn, Fi, V.count);
      else if (Ne.isInstancedBufferGeometry) {
        const Jt = Ne._maxInstanceCount !== void 0 ? Ne._maxInstanceCount : 1 / 0, Kn = Math.min(Ne.instanceCount, Jt);
        fi.renderInstances(Cn, Fi, Kn);
      } else
        fi.render(Cn, Fi);
    };
    function ze(Z, ve, Ne) {
      Z.transparent === !0 && Z.side === er && Z.forceSinglePass === !1 ? (Z.side = si, Z.needsUpdate = !0, On(Z, ve, Ne), Z.side = Zs, Z.needsUpdate = !0, On(Z, ve, Ne), Z.side = er) : On(Z, ve, Ne);
    }
    this.compile = function(Z, ve, Ne = null) {
      Ne === null && (Ne = Z), L = _t.get(Ne), L.init(ve), B.push(L), Ne.traverseVisible(function(V) {
        V.isLight && V.layers.test(ve.layers) && (L.pushLight(V), V.castShadow && L.pushShadow(V));
      }), Z !== Ne && Z.traverseVisible(function(V) {
        V.isLight && V.layers.test(ve.layers) && (L.pushLight(V), V.castShadow && L.pushShadow(V));
      }), L.setupLights();
      const xe = /* @__PURE__ */ new Set();
      return Z.traverse(function(V) {
        if (!(V.isMesh || V.isPoints || V.isLine || V.isSprite))
          return;
        const Ve = V.material;
        if (Ve)
          if (Array.isArray(Ve))
            for (let Dt = 0; Dt < Ve.length; Dt++) {
              const yt = Ve[Dt];
              ze(yt, Ne, V), xe.add(yt);
            }
          else
            ze(Ve, Ne, V), xe.add(Ve);
      }), L = B.pop(), xe;
    }, this.compileAsync = function(Z, ve, Ne = null) {
      const xe = this.compile(Z, ve, Ne);
      return new Promise((V) => {
        function Ve() {
          if (xe.forEach(function(Dt) {
            W.get(Dt).currentProgram.isReady() && xe.delete(Dt);
          }), xe.size === 0) {
            V(Z);
            return;
          }
          setTimeout(Ve, 10);
        }
        dt.get("KHR_parallel_shader_compile") !== null ? Ve() : setTimeout(Ve, 10);
      });
    };
    let mt = null;
    function $e(Z) {
      mt && mt(Z);
    }
    function f() {
      Mn.stop();
    }
    function $() {
      Mn.start();
    }
    const Mn = new T8();
    Mn.setAnimationLoop($e), typeof self < "u" && Mn.setContext(self), this.setAnimationLoop = function(Z) {
      mt = Z, At.setAnimationLoop(Z), Z === null ? Mn.stop() : Mn.start();
    }, At.addEventListener("sessionstart", f), At.addEventListener("sessionend", $), this.render = function(Z, ve) {
      if (ve !== void 0 && ve.isCamera !== !0) {
        Ie("WebGLRenderer.render: camera is not an instance of THREE.Camera.");
        return;
      }
      if (O === !0) return;
      const Ne = At.enabled === !0 && At.isPresenting === !0, xe = U !== null && (Y === null || Ne) && U.begin(N, Y);
      if (Z.matrixWorldAutoUpdate === !0 && Z.updateMatrixWorld(), ve.parent === null && ve.matrixWorldAutoUpdate === !0 && ve.updateMatrixWorld(), At.enabled === !0 && At.isPresenting === !0 && (U === null || U.isCompositing() === !1) && (At.cameraAutoUpdate === !0 && At.updateCamera(ve), ve = At.getCamera()), Z.isScene === !0 && Z.onBeforeRender(N, Z, ve, Y), L = _t.get(Z, B.length), L.init(ve), B.push(L), en.multiplyMatrices(ve.projectionMatrix, ve.matrixWorldInverse), wt.setFromProjectionMatrix(en, jr, ve.reversedDepth), Wt = this.localClippingEnabled, ot = Ut.init(this.clippingPlanes, Wt), C = tt.get(Z, D.length), C.init(), D.push(C), At.enabled === !0 && At.isPresenting === !0) {
        const Dt = N.xr.getDepthSensingMesh();
        Dt !== null && jn(Dt, ve, -1 / 0, N.sortObjects);
      }
      jn(Z, ve, 0, N.sortObjects), C.finish(), N.sortObjects === !0 && C.sort(zt, Tt), Ee = At.enabled === !1 || At.isPresenting === !1 || At.hasDepthSensing() === !1, Ee && pt.addToRenderList(C, Z), this.info.render.frame++, ot === !0 && Ut.beginShadows();
      const V = L.state.shadowsArray;
      if (Vt.render(V, Z, ve), ot === !0 && Ut.endShadows(), this.info.autoReset === !0 && this.info.reset(), (xe && U.hasRenderPass()) === !1) {
        const Dt = C.opaque, yt = C.transmissive;
        if (L.setupLights(), ve.isArrayCamera) {
          const Bt = ve.cameras;
          if (yt.length > 0)
            for (let $t = 0, ln = Bt.length; $t < ln; $t++) {
              const q = Bt[$t];
              yn(Dt, yt, Z, q);
            }
          Ee && pt.render(Z);
          for (let $t = 0, ln = Bt.length; $t < ln; $t++) {
            const q = Bt[$t];
            nr(C, Z, q, q.viewport);
          }
        } else
          yt.length > 0 && yn(Dt, yt, Z, ve), Ee && pt.render(Z), nr(C, Z, ve);
      }
      Y !== null && H === 0 && (ge.updateMultisampleRenderTarget(Y), ge.updateRenderTargetMipmap(Y)), xe && U.end(N), Z.isScene === !0 && Z.onAfterRender(N, Z, ve), Ct.resetDefaultState(), K = -1, X = null, B.pop(), B.length > 0 ? (L = B[B.length - 1], ot === !0 && Ut.setGlobalState(N.clippingPlanes, L.state.camera)) : L = null, D.pop(), D.length > 0 ? C = D[D.length - 1] : C = null;
    };
    function jn(Z, ve, Ne, xe) {
      if (Z.visible === !1) return;
      if (Z.layers.test(ve.layers)) {
        if (Z.isGroup)
          Ne = Z.renderOrder;
        else if (Z.isLOD)
          Z.autoUpdate === !0 && Z.update(ve);
        else if (Z.isLight)
          L.pushLight(Z), Z.castShadow && L.pushShadow(Z);
        else if (Z.isSprite) {
          if (!Z.frustumCulled || wt.intersectsSprite(Z)) {
            xe && ue.setFromMatrixPosition(Z.matrixWorld).applyMatrix4(en);
            const Dt = ft.update(Z), yt = Z.material;
            yt.visible && C.push(Z, Dt, yt, Ne, ue.z, null);
          }
        } else if ((Z.isMesh || Z.isLine || Z.isPoints) && (!Z.frustumCulled || wt.intersectsObject(Z))) {
          const Dt = ft.update(Z), yt = Z.material;
          if (xe && (Z.boundingSphere !== void 0 ? (Z.boundingSphere === null && Z.computeBoundingSphere(), ue.copy(Z.boundingSphere.center)) : (Dt.boundingSphere === null && Dt.computeBoundingSphere(), ue.copy(Dt.boundingSphere.center)), ue.applyMatrix4(Z.matrixWorld).applyMatrix4(en)), Array.isArray(yt)) {
            const Bt = Dt.groups;
            for (let $t = 0, ln = Bt.length; $t < ln; $t++) {
              const q = Bt[$t], Cn = yt[q.materialIndex];
              Cn && Cn.visible && C.push(Z, Dt, Cn, Ne, ue.z, q);
            }
          } else yt.visible && C.push(Z, Dt, yt, Ne, ue.z, null);
        }
      }
      const Ve = Z.children;
      for (let Dt = 0, yt = Ve.length; Dt < yt; Dt++)
        jn(Ve[Dt], ve, Ne, xe);
    }
    function nr(Z, ve, Ne, xe) {
      const { opaque: V, transmissive: Ve, transparent: Dt } = Z;
      L.setupLightsView(Ne), ot === !0 && Ut.setGlobalState(N.clippingPlanes, Ne), xe && rt.viewport(ee.copy(xe)), V.length > 0 && Nn(V, ve, Ne), Ve.length > 0 && Nn(Ve, ve, Ne), Dt.length > 0 && Nn(Dt, ve, Ne), rt.buffers.depth.setTest(!0), rt.buffers.depth.setMask(!0), rt.buffers.color.setMask(!0), rt.setPolygonOffset(!1);
    }
    function yn(Z, ve, Ne, xe) {
      if ((Ne.isScene === !0 ? Ne.overrideMaterial : null) !== null)
        return;
      if (L.state.transmissionRenderTarget[xe.id] === void 0) {
        const Cn = dt.has("EXT_color_buffer_half_float") || dt.has("EXT_color_buffer_float");
        L.state.transmissionRenderTarget[xe.id] = new eo(1, 1, {
          generateMipmaps: !0,
          type: Cn ? Ri : Mi,
          minFilter: $r,
          samples: Nt.samples,
          stencilBuffer: s,
          resolveDepthBuffer: !1,
          resolveStencilBuffer: !1,
          colorSpace: Xt.workingColorSpace
        });
      }
      const Ve = L.state.transmissionRenderTarget[xe.id], Dt = xe.viewport || ee;
      Ve.setSize(Dt.z * N.transmissionResolutionScale, Dt.w * N.transmissionResolutionScale);
      const yt = N.getRenderTarget(), Bt = N.getActiveCubeFace(), $t = N.getActiveMipmapLevel();
      N.setRenderTarget(Ve), N.getClearColor(_e), Te = N.getClearAlpha(), Te < 1 && N.setClearColor(16777215, 0.5), N.clear(), Ee && pt.render(Ne);
      const ln = N.toneMapping;
      N.toneMapping = Dr;
      const q = xe.viewport;
      if (xe.viewport !== void 0 && (xe.viewport = void 0), L.setupLightsView(xe), ot === !0 && Ut.setGlobalState(N.clippingPlanes, xe), Nn(Z, Ne, xe), ge.updateMultisampleRenderTarget(Ve), ge.updateRenderTargetMipmap(Ve), dt.has("WEBGL_multisampled_render_to_texture") === !1) {
        let Cn = !1;
        for (let oi = 0, Fi = ve.length; oi < Fi; oi++) {
          const Ui = ve[oi], { object: fi, geometry: Jt, material: Kn, group: Hn } = Ui;
          if (Kn.side === er && fi.layers.test(xe.layers)) {
            const ts = Kn.side;
            Kn.side = si, Kn.needsUpdate = !0, ta(fi, Ne, xe, Jt, Kn, Hn), Kn.side = ts, Kn.needsUpdate = !0, Cn = !0;
          }
        }
        Cn === !0 && (ge.updateMultisampleRenderTarget(Ve), ge.updateRenderTargetMipmap(Ve));
      }
      N.setRenderTarget(yt, Bt, $t), N.setClearColor(_e, Te), q !== void 0 && (xe.viewport = q), N.toneMapping = ln;
    }
    function Nn(Z, ve, Ne) {
      const xe = ve.isScene === !0 ? ve.overrideMaterial : null;
      for (let V = 0, Ve = Z.length; V < Ve; V++) {
        const Dt = Z[V], { object: yt, geometry: Bt, group: $t } = Dt;
        let ln = Dt.material;
        ln.allowOverride === !0 && xe !== null && (ln = xe), yt.layers.test(Ne.layers) && ta(yt, ve, Ne, Bt, ln, $t);
      }
    }
    function ta(Z, ve, Ne, xe, V, Ve) {
      Z.onBeforeRender(N, ve, Ne, xe, V, Ve), Z.modelViewMatrix.multiplyMatrices(Ne.matrixWorldInverse, Z.matrixWorld), Z.normalMatrix.getNormalMatrix(Z.modelViewMatrix), V.onBeforeRender(N, ve, Ne, xe, Z, Ve), V.transparent === !0 && V.side === er && V.forceSinglePass === !1 ? (V.side = si, V.needsUpdate = !0, N.renderBufferDirect(Ne, ve, xe, V, Z, Ve), V.side = Zs, V.needsUpdate = !0, N.renderBufferDirect(Ne, ve, xe, V, Z, Ve), V.side = er) : N.renderBufferDirect(Ne, ve, xe, V, Z, Ve), Z.onAfterRender(N, ve, Ne, xe, V, Ve);
    }
    function On(Z, ve, Ne) {
      ve.isScene !== !0 && (ve = he);
      const xe = W.get(Z), V = L.state.lights, Ve = L.state.shadowsArray, Dt = V.state.version, yt = Ft.getParameters(Z, V.state, Ve, ve, Ne), Bt = Ft.getProgramCacheKey(yt);
      let $t = xe.programs;
      xe.environment = Z.isMeshStandardMaterial ? ve.environment : null, xe.fog = ve.fog, xe.envMap = (Z.isMeshStandardMaterial ? We : Fe).get(Z.envMap || xe.environment), xe.envMapRotation = xe.environment !== null && Z.envMap === null ? ve.environmentRotation : Z.envMapRotation, $t === void 0 && (Z.addEventListener("dispose", Os), $t = /* @__PURE__ */ new Map(), xe.programs = $t);
      let ln = $t.get(Bt);
      if (ln !== void 0) {
        if (xe.currentProgram === ln && xe.lightsStateVersion === Dt)
          return ys(Z, yt), ln;
      } else
        yt.uniforms = Ft.getUniforms(Z), Z.onBeforeCompile(yt, N), ln = Ft.acquireProgram(yt, Bt), $t.set(Bt, ln), xe.uniforms = yt.uniforms;
      const q = xe.uniforms;
      return (!Z.isShaderMaterial && !Z.isRawShaderMaterial || Z.clipping === !0) && (q.clippingPlanes = Ut.uniform), ys(Z, yt), xe.needsLights = mA(Z), xe.lightsStateVersion = Dt, xe.needsLights && (q.ambientLightColor.value = V.state.ambient, q.lightProbe.value = V.state.probe, q.directionalLights.value = V.state.directional, q.directionalLightShadows.value = V.state.directionalShadow, q.spotLights.value = V.state.spot, q.spotLightShadows.value = V.state.spotShadow, q.rectAreaLights.value = V.state.rectArea, q.ltc_1.value = V.state.rectAreaLTC1, q.ltc_2.value = V.state.rectAreaLTC2, q.pointLights.value = V.state.point, q.pointLightShadows.value = V.state.pointShadow, q.hemisphereLights.value = V.state.hemi, q.directionalShadowMap.value = V.state.directionalShadowMap, q.directionalShadowMatrix.value = V.state.directionalShadowMatrix, q.spotShadowMap.value = V.state.spotShadowMap, q.spotLightMatrix.value = V.state.spotLightMatrix, q.spotLightMap.value = V.state.spotLightMap, q.pointShadowMap.value = V.state.pointShadowMap, q.pointShadowMatrix.value = V.state.pointShadowMatrix), xe.currentProgram = ln, xe.uniformsList = null, ln;
    }
    function vn(Z) {
      if (Z.uniformsList === null) {
        const ve = Z.currentProgram.getUniforms();
        Z.uniformsList = jg.seqWithValue(ve.seq, Z.uniforms);
      }
      return Z.uniformsList;
    }
    function ys(Z, ve) {
      const Ne = W.get(Z);
      Ne.outputColorSpace = ve.outputColorSpace, Ne.batching = ve.batching, Ne.batchingColor = ve.batchingColor, Ne.instancing = ve.instancing, Ne.instancingColor = ve.instancingColor, Ne.instancingMorph = ve.instancingMorph, Ne.skinning = ve.skinning, Ne.morphTargets = ve.morphTargets, Ne.morphNormals = ve.morphNormals, Ne.morphColors = ve.morphColors, Ne.morphTargetsCount = ve.morphTargetsCount, Ne.numClippingPlanes = ve.numClippingPlanes, Ne.numIntersection = ve.numClipIntersection, Ne.vertexAlphas = ve.vertexAlphas, Ne.vertexTangents = ve.vertexTangents, Ne.toneMapping = ve.toneMapping;
    }
    function ud(Z, ve, Ne, xe, V) {
      ve.isScene !== !0 && (ve = he), ge.resetTextureUnits();
      const Ve = ve.fog, Dt = xe.isMeshStandardMaterial ? ve.environment : null, yt = Y === null ? N.outputColorSpace : Y.isXRRenderTarget === !0 ? Y.texture.colorSpace : Hl, Bt = (xe.isMeshStandardMaterial ? We : Fe).get(xe.envMap || Dt), $t = xe.vertexColors === !0 && !!Ne.attributes.color && Ne.attributes.color.itemSize === 4, ln = !!Ne.attributes.tangent && (!!xe.normalMap || xe.anisotropy > 0), q = !!Ne.morphAttributes.position, Cn = !!Ne.morphAttributes.normal, oi = !!Ne.morphAttributes.color;
      let Fi = Dr;
      xe.toneMapped && (Y === null || Y.isXRRenderTarget === !0) && (Fi = N.toneMapping);
      const Ui = Ne.morphAttributes.position || Ne.morphAttributes.normal || Ne.morphAttributes.color, fi = Ui !== void 0 ? Ui.length : 0, Jt = W.get(xe), Kn = L.state.lights;
      if (ot === !0 && (Wt === !0 || Z !== X)) {
        const kr = Z === X && xe.id === K;
        Ut.setState(xe, Z, kr);
      }
      let Hn = !1;
      xe.version === Jt.__version ? (Jt.needsLights && Jt.lightsStateVersion !== Kn.state.version || Jt.outputColorSpace !== yt || V.isBatchedMesh && Jt.batching === !1 || !V.isBatchedMesh && Jt.batching === !0 || V.isBatchedMesh && Jt.batchingColor === !0 && V.colorTexture === null || V.isBatchedMesh && Jt.batchingColor === !1 && V.colorTexture !== null || V.isInstancedMesh && Jt.instancing === !1 || !V.isInstancedMesh && Jt.instancing === !0 || V.isSkinnedMesh && Jt.skinning === !1 || !V.isSkinnedMesh && Jt.skinning === !0 || V.isInstancedMesh && Jt.instancingColor === !0 && V.instanceColor === null || V.isInstancedMesh && Jt.instancingColor === !1 && V.instanceColor !== null || V.isInstancedMesh && Jt.instancingMorph === !0 && V.morphTexture === null || V.isInstancedMesh && Jt.instancingMorph === !1 && V.morphTexture !== null || Jt.envMap !== Bt || xe.fog === !0 && Jt.fog !== Ve || Jt.numClippingPlanes !== void 0 && (Jt.numClippingPlanes !== Ut.numPlanes || Jt.numIntersection !== Ut.numIntersection) || Jt.vertexAlphas !== $t || Jt.vertexTangents !== ln || Jt.morphTargets !== q || Jt.morphNormals !== Cn || Jt.morphColors !== oi || Jt.toneMapping !== Fi || Jt.morphTargetsCount !== fi) && (Hn = !0) : (Hn = !0, Jt.__version = xe.version);
      let ts = Jt.currentProgram;
      Hn === !0 && (ts = On(xe, ve, V));
      let Or = !1, Zn = !1, hc = !1;
      const Ai = ts.getUniforms(), ns = Jt.uniforms;
      if (rt.useProgram(ts.program) && (Or = !0, Zn = !0, hc = !0), xe.id !== K && (K = xe.id, Zn = !0), Or || X !== Z) {
        rt.buffers.depth.getReversed() && Z.reversedDepth !== !0 && (Z._reversedDepth = !0, Z.updateProjectionMatrix()), Ai.setValue(te, "projectionMatrix", Z.projectionMatrix), Ai.setValue(te, "viewMatrix", Z.matrixWorldInverse);
        const Vr = Ai.map.cameraPosition;
        Vr !== void 0 && Vr.setValue(te, z.setFromMatrixPosition(Z.matrixWorld)), Nt.logarithmicDepthBuffer && Ai.setValue(
          te,
          "logDepthBufFC",
          2 / (Math.log(Z.far + 1) / Math.LN2)
        ), (xe.isMeshPhongMaterial || xe.isMeshToonMaterial || xe.isMeshLambertMaterial || xe.isMeshBasicMaterial || xe.isMeshStandardMaterial || xe.isShaderMaterial) && Ai.setValue(te, "isOrthographic", Z.isOrthographicCamera === !0), X !== Z && (X = Z, Zn = !0, hc = !0);
      }
      if (Jt.needsLights && (Kn.state.directionalShadowMap.length > 0 && Ai.setValue(te, "directionalShadowMap", Kn.state.directionalShadowMap, ge), Kn.state.spotShadowMap.length > 0 && Ai.setValue(te, "spotShadowMap", Kn.state.spotShadowMap, ge), Kn.state.pointShadowMap.length > 0 && Ai.setValue(te, "pointShadowMap", Kn.state.pointShadowMap, ge)), V.isSkinnedMesh) {
        Ai.setOptional(te, V, "bindMatrix"), Ai.setOptional(te, V, "bindMatrixInverse");
        const kr = V.skeleton;
        kr && (kr.boneTexture === null && kr.computeBoneTexture(), Ai.setValue(te, "boneTexture", kr.boneTexture, ge));
      }
      V.isBatchedMesh && (Ai.setOptional(te, V, "batchingTexture"), Ai.setValue(te, "batchingTexture", V._matricesTexture, ge), Ai.setOptional(te, V, "batchingIdTexture"), Ai.setValue(te, "batchingIdTexture", V._indirectTexture, ge), Ai.setOptional(te, V, "batchingColorTexture"), V._colorsTexture !== null && Ai.setValue(te, "batchingColorTexture", V._colorsTexture, ge));
      const is = Ne.morphAttributes;
      if ((is.position !== void 0 || is.normal !== void 0 || is.color !== void 0) && Rn.update(V, Ne, ts), (Zn || Jt.receiveShadow !== V.receiveShadow) && (Jt.receiveShadow = V.receiveShadow, Ai.setValue(te, "receiveShadow", V.receiveShadow)), xe.isMeshGouraudMaterial && xe.envMap !== null && (ns.envMap.value = Bt, ns.flipEnvMap.value = Bt.isCubeTexture && Bt.isRenderTargetTexture === !1 ? -1 : 1), xe.isMeshStandardMaterial && xe.envMap === null && ve.environment !== null && (ns.envMapIntensity.value = ve.environmentIntensity), ns.dfgLUT !== void 0 && (ns.dfgLUT.value = Mq()), Zn && (Ai.setValue(te, "toneMappingExposure", N.toneMappingExposure), Jt.needsLights && Ax(ns, hc), Ve && xe.fog === !0 && nn.refreshFogUniforms(ns, Ve), nn.refreshMaterialUniforms(ns, xe, Qe, Je, L.state.transmissionRenderTarget[Z.id]), jg.upload(te, vn(Jt), ns, ge)), xe.isShaderMaterial && xe.uniformsNeedUpdate === !0 && (jg.upload(te, vn(Jt), ns, ge), xe.uniformsNeedUpdate = !1), xe.isSpriteMaterial && Ai.setValue(te, "center", V.center), Ai.setValue(te, "modelViewMatrix", V.modelViewMatrix), Ai.setValue(te, "normalMatrix", V.normalMatrix), Ai.setValue(te, "modelMatrix", V.matrixWorld), xe.isShaderMaterial || xe.isRawShaderMaterial) {
        const kr = xe.uniformsGroups;
        for (let Vr = 0, gA = kr.length; Vr < gA; Vr++) {
          const dl = kr[Vr];
          it.update(dl, ts), it.bind(dl, ts);
        }
      }
      return ts;
    }
    function Ax(Z, ve) {
      Z.ambientLightColor.needsUpdate = ve, Z.lightProbe.needsUpdate = ve, Z.directionalLights.needsUpdate = ve, Z.directionalLightShadows.needsUpdate = ve, Z.pointLights.needsUpdate = ve, Z.pointLightShadows.needsUpdate = ve, Z.spotLights.needsUpdate = ve, Z.spotLightShadows.needsUpdate = ve, Z.rectAreaLights.needsUpdate = ve, Z.hemisphereLights.needsUpdate = ve;
    }
    function mA(Z) {
      return Z.isMeshLambertMaterial || Z.isMeshToonMaterial || Z.isMeshPhongMaterial || Z.isMeshStandardMaterial || Z.isShadowMaterial || Z.isShaderMaterial && Z.lights === !0;
    }
    this.getActiveCubeFace = function() {
      return G;
    }, this.getActiveMipmapLevel = function() {
      return H;
    }, this.getRenderTarget = function() {
      return Y;
    }, this.setRenderTargetTextures = function(Z, ve, Ne) {
      const xe = W.get(Z);
      xe.__autoAllocateDepthBuffer = Z.resolveDepthBuffer === !1, xe.__autoAllocateDepthBuffer === !1 && (xe.__useRenderToTexture = !1), W.get(Z.texture).__webglTexture = ve, W.get(Z.depthTexture).__webglTexture = xe.__autoAllocateDepthBuffer ? void 0 : Ne, xe.__hasExternalTextures = !0;
    }, this.setRenderTargetFramebuffer = function(Z, ve) {
      const Ne = W.get(Z);
      Ne.__webglFramebuffer = ve, Ne.__useDefaultFramebuffer = ve === void 0;
    };
    const ks = te.createFramebuffer();
    this.setRenderTarget = function(Z, ve = 0, Ne = 0) {
      Y = Z, G = ve, H = Ne;
      let xe = null, V = !1, Ve = !1;
      if (Z) {
        const yt = W.get(Z);
        if (yt.__useDefaultFramebuffer !== void 0) {
          rt.bindFramebuffer(te.FRAMEBUFFER, yt.__webglFramebuffer), ee.copy(Z.viewport), oe.copy(Z.scissor), fe = Z.scissorTest, rt.viewport(ee), rt.scissor(oe), rt.setScissorTest(fe), K = -1;
          return;
        } else if (yt.__webglFramebuffer === void 0)
          ge.setupRenderTarget(Z);
        else if (yt.__hasExternalTextures)
          ge.rebindTextures(Z, W.get(Z.texture).__webglTexture, W.get(Z.depthTexture).__webglTexture);
        else if (Z.depthBuffer) {
          const ln = Z.depthTexture;
          if (yt.__boundDepthTexture !== ln) {
            if (ln !== null && W.has(ln) && (Z.width !== ln.image.width || Z.height !== ln.image.height))
              throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");
            ge.setupDepthRenderbuffer(Z);
          }
        }
        const Bt = Z.texture;
        (Bt.isData3DTexture || Bt.isDataArrayTexture || Bt.isCompressedArrayTexture) && (Ve = !0);
        const $t = W.get(Z).__webglFramebuffer;
        Z.isWebGLCubeRenderTarget ? (Array.isArray($t[ve]) ? xe = $t[ve][Ne] : xe = $t[ve], V = !0) : Z.samples > 0 && ge.useMultisampledRTT(Z) === !1 ? xe = W.get(Z).__webglMultisampledFramebuffer : Array.isArray($t) ? xe = $t[Ne] : xe = $t, ee.copy(Z.viewport), oe.copy(Z.scissor), fe = Z.scissorTest;
      } else
        ee.copy(Pe).multiplyScalar(Qe).floor(), oe.copy(ke).multiplyScalar(Qe).floor(), fe = at;
      if (Ne !== 0 && (xe = ks), rt.bindFramebuffer(te.FRAMEBUFFER, xe) && rt.drawBuffers(Z, xe), rt.viewport(ee), rt.scissor(oe), rt.setScissorTest(fe), V) {
        const yt = W.get(Z.texture);
        te.framebufferTexture2D(te.FRAMEBUFFER, te.COLOR_ATTACHMENT0, te.TEXTURE_CUBE_MAP_POSITIVE_X + ve, yt.__webglTexture, Ne);
      } else if (Ve) {
        const yt = ve;
        for (let Bt = 0; Bt < Z.textures.length; Bt++) {
          const $t = W.get(Z.textures[Bt]);
          te.framebufferTextureLayer(te.FRAMEBUFFER, te.COLOR_ATTACHMENT0 + Bt, $t.__webglTexture, Ne, yt);
        }
      } else if (Z !== null && Ne !== 0) {
        const yt = W.get(Z.texture);
        te.framebufferTexture2D(te.FRAMEBUFFER, te.COLOR_ATTACHMENT0, te.TEXTURE_2D, yt.__webglTexture, Ne);
      }
      K = -1;
    }, this.readRenderTargetPixels = function(Z, ve, Ne, xe, V, Ve, Dt, yt = 0) {
      if (!(Z && Z.isWebGLRenderTarget)) {
        Ie("WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
        return;
      }
      let Bt = W.get(Z).__webglFramebuffer;
      if (Z.isWebGLCubeRenderTarget && Dt !== void 0 && (Bt = Bt[Dt]), Bt) {
        rt.bindFramebuffer(te.FRAMEBUFFER, Bt);
        try {
          const $t = Z.textures[yt], ln = $t.format, q = $t.type;
          if (!Nt.textureFormatReadable(ln)) {
            Ie("WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
            return;
          }
          if (!Nt.textureTypeReadable(q)) {
            Ie("WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
            return;
          }
          ve >= 0 && ve <= Z.width - xe && Ne >= 0 && Ne <= Z.height - V && (Z.textures.length > 1 && te.readBuffer(te.COLOR_ATTACHMENT0 + yt), te.readPixels(ve, Ne, xe, V, lt.convert(ln), lt.convert(q), Ve));
        } finally {
          const $t = Y !== null ? W.get(Y).__webglFramebuffer : null;
          rt.bindFramebuffer(te.FRAMEBUFFER, $t);
        }
      }
    }, this.readRenderTargetPixelsAsync = async function(Z, ve, Ne, xe, V, Ve, Dt, yt = 0) {
      if (!(Z && Z.isWebGLRenderTarget))
        throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
      let Bt = W.get(Z).__webglFramebuffer;
      if (Z.isWebGLCubeRenderTarget && Dt !== void 0 && (Bt = Bt[Dt]), Bt)
        if (ve >= 0 && ve <= Z.width - xe && Ne >= 0 && Ne <= Z.height - V) {
          rt.bindFramebuffer(te.FRAMEBUFFER, Bt);
          const $t = Z.textures[yt], ln = $t.format, q = $t.type;
          if (!Nt.textureFormatReadable(ln))
            throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");
          if (!Nt.textureTypeReadable(q))
            throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");
          const Cn = te.createBuffer();
          te.bindBuffer(te.PIXEL_PACK_BUFFER, Cn), te.bufferData(te.PIXEL_PACK_BUFFER, Ve.byteLength, te.STREAM_READ), Z.textures.length > 1 && te.readBuffer(te.COLOR_ATTACHMENT0 + yt), te.readPixels(ve, Ne, xe, V, lt.convert(ln), lt.convert(q), 0);
          const oi = Y !== null ? W.get(Y).__webglFramebuffer : null;
          rt.bindFramebuffer(te.FRAMEBUFFER, oi);
          const Fi = te.fenceSync(te.SYNC_GPU_COMMANDS_COMPLETE, 0);
          return te.flush(), await zF(te, Fi, 4), te.bindBuffer(te.PIXEL_PACK_BUFFER, Cn), te.getBufferSubData(te.PIXEL_PACK_BUFFER, 0, Ve), te.deleteBuffer(Cn), te.deleteSync(Fi), Ve;
        } else
          throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.");
    }, this.copyFramebufferToTexture = function(Z, ve = null, Ne = 0) {
      const xe = Math.pow(2, -Ne), V = Math.floor(Z.image.width * xe), Ve = Math.floor(Z.image.height * xe), Dt = ve !== null ? ve.x : 0, yt = ve !== null ? ve.y : 0;
      ge.setTexture2D(Z, 0), te.copyTexSubImage2D(te.TEXTURE_2D, Ne, 0, 0, Dt, yt, V, Ve), rt.unbindTexture();
    };
    const nu = te.createFramebuffer(), No = te.createFramebuffer();
    this.copyTextureToTexture = function(Z, ve, Ne = null, xe = null, V = 0, Ve = null) {
      Ve === null && (V !== 0 ? (li("WebGLRenderer: copyTextureToTexture function signature has changed to support src and dst mipmap levels."), Ve = V, V = 0) : Ve = 0);
      let Dt, yt, Bt, $t, ln, q, Cn, oi, Fi;
      const Ui = Z.isCompressedTexture ? Z.mipmaps[Ve] : Z.image;
      if (Ne !== null)
        Dt = Ne.max.x - Ne.min.x, yt = Ne.max.y - Ne.min.y, Bt = Ne.isBox3 ? Ne.max.z - Ne.min.z : 1, $t = Ne.min.x, ln = Ne.min.y, q = Ne.isBox3 ? Ne.min.z : 0;
      else {
        const is = Math.pow(2, -V);
        Dt = Math.floor(Ui.width * is), yt = Math.floor(Ui.height * is), Z.isDataArrayTexture ? Bt = Ui.depth : Z.isData3DTexture ? Bt = Math.floor(Ui.depth * is) : Bt = 1, $t = 0, ln = 0, q = 0;
      }
      xe !== null ? (Cn = xe.x, oi = xe.y, Fi = xe.z) : (Cn = 0, oi = 0, Fi = 0);
      const fi = lt.convert(ve.format), Jt = lt.convert(ve.type);
      let Kn;
      ve.isData3DTexture ? (ge.setTexture3D(ve, 0), Kn = te.TEXTURE_3D) : ve.isDataArrayTexture || ve.isCompressedArrayTexture ? (ge.setTexture2DArray(ve, 0), Kn = te.TEXTURE_2D_ARRAY) : (ge.setTexture2D(ve, 0), Kn = te.TEXTURE_2D), te.pixelStorei(te.UNPACK_FLIP_Y_WEBGL, ve.flipY), te.pixelStorei(te.UNPACK_PREMULTIPLY_ALPHA_WEBGL, ve.premultiplyAlpha), te.pixelStorei(te.UNPACK_ALIGNMENT, ve.unpackAlignment);
      const Hn = te.getParameter(te.UNPACK_ROW_LENGTH), ts = te.getParameter(te.UNPACK_IMAGE_HEIGHT), Or = te.getParameter(te.UNPACK_SKIP_PIXELS), Zn = te.getParameter(te.UNPACK_SKIP_ROWS), hc = te.getParameter(te.UNPACK_SKIP_IMAGES);
      te.pixelStorei(te.UNPACK_ROW_LENGTH, Ui.width), te.pixelStorei(te.UNPACK_IMAGE_HEIGHT, Ui.height), te.pixelStorei(te.UNPACK_SKIP_PIXELS, $t), te.pixelStorei(te.UNPACK_SKIP_ROWS, ln), te.pixelStorei(te.UNPACK_SKIP_IMAGES, q);
      const Ai = Z.isDataArrayTexture || Z.isData3DTexture, ns = ve.isDataArrayTexture || ve.isData3DTexture;
      if (Z.isDepthTexture) {
        const is = W.get(Z), kr = W.get(ve), Vr = W.get(is.__renderTarget), gA = W.get(kr.__renderTarget);
        rt.bindFramebuffer(te.READ_FRAMEBUFFER, Vr.__webglFramebuffer), rt.bindFramebuffer(te.DRAW_FRAMEBUFFER, gA.__webglFramebuffer);
        for (let dl = 0; dl < Bt; dl++)
          Ai && (te.framebufferTextureLayer(te.READ_FRAMEBUFFER, te.COLOR_ATTACHMENT0, W.get(Z).__webglTexture, V, q + dl), te.framebufferTextureLayer(te.DRAW_FRAMEBUFFER, te.COLOR_ATTACHMENT0, W.get(ve).__webglTexture, Ve, Fi + dl)), te.blitFramebuffer($t, ln, Dt, yt, Cn, oi, Dt, yt, te.DEPTH_BUFFER_BIT, te.NEAREST);
        rt.bindFramebuffer(te.READ_FRAMEBUFFER, null), rt.bindFramebuffer(te.DRAW_FRAMEBUFFER, null);
      } else if (V !== 0 || Z.isRenderTargetTexture || W.has(Z)) {
        const is = W.get(Z), kr = W.get(ve);
        rt.bindFramebuffer(te.READ_FRAMEBUFFER, nu), rt.bindFramebuffer(te.DRAW_FRAMEBUFFER, No);
        for (let Vr = 0; Vr < Bt; Vr++)
          Ai ? te.framebufferTextureLayer(te.READ_FRAMEBUFFER, te.COLOR_ATTACHMENT0, is.__webglTexture, V, q + Vr) : te.framebufferTexture2D(te.READ_FRAMEBUFFER, te.COLOR_ATTACHMENT0, te.TEXTURE_2D, is.__webglTexture, V), ns ? te.framebufferTextureLayer(te.DRAW_FRAMEBUFFER, te.COLOR_ATTACHMENT0, kr.__webglTexture, Ve, Fi + Vr) : te.framebufferTexture2D(te.DRAW_FRAMEBUFFER, te.COLOR_ATTACHMENT0, te.TEXTURE_2D, kr.__webglTexture, Ve), V !== 0 ? te.blitFramebuffer($t, ln, Dt, yt, Cn, oi, Dt, yt, te.COLOR_BUFFER_BIT, te.NEAREST) : ns ? te.copyTexSubImage3D(Kn, Ve, Cn, oi, Fi + Vr, $t, ln, Dt, yt) : te.copyTexSubImage2D(Kn, Ve, Cn, oi, $t, ln, Dt, yt);
        rt.bindFramebuffer(te.READ_FRAMEBUFFER, null), rt.bindFramebuffer(te.DRAW_FRAMEBUFFER, null);
      } else
        ns ? Z.isDataTexture || Z.isData3DTexture ? te.texSubImage3D(Kn, Ve, Cn, oi, Fi, Dt, yt, Bt, fi, Jt, Ui.data) : ve.isCompressedArrayTexture ? te.compressedTexSubImage3D(Kn, Ve, Cn, oi, Fi, Dt, yt, Bt, fi, Ui.data) : te.texSubImage3D(Kn, Ve, Cn, oi, Fi, Dt, yt, Bt, fi, Jt, Ui) : Z.isDataTexture ? te.texSubImage2D(te.TEXTURE_2D, Ve, Cn, oi, Dt, yt, fi, Jt, Ui.data) : Z.isCompressedTexture ? te.compressedTexSubImage2D(te.TEXTURE_2D, Ve, Cn, oi, Ui.width, Ui.height, fi, Ui.data) : te.texSubImage2D(te.TEXTURE_2D, Ve, Cn, oi, Dt, yt, fi, Jt, Ui);
      te.pixelStorei(te.UNPACK_ROW_LENGTH, Hn), te.pixelStorei(te.UNPACK_IMAGE_HEIGHT, ts), te.pixelStorei(te.UNPACK_SKIP_PIXELS, Or), te.pixelStorei(te.UNPACK_SKIP_ROWS, Zn), te.pixelStorei(te.UNPACK_SKIP_IMAGES, hc), Ve === 0 && ve.generateMipmaps && te.generateMipmap(Kn), rt.unbindTexture();
    }, this.initRenderTarget = function(Z) {
      W.get(Z).__webglFramebuffer === void 0 && ge.setupRenderTarget(Z);
    }, this.initTexture = function(Z) {
      Z.isCubeTexture ? ge.setTextureCube(Z, 0) : Z.isData3DTexture ? ge.setTexture3D(Z, 0) : Z.isDataArrayTexture || Z.isCompressedArrayTexture ? ge.setTexture2DArray(Z, 0) : ge.setTexture2D(Z, 0), rt.unbindTexture();
    }, this.resetState = function() {
      G = 0, H = 0, Y = null, rt.reset(), Ct.reset();
    }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  /**
   * Defines the coordinate system of the renderer.
   *
   * In `WebGLRenderer`, the value is always `WebGLCoordinateSystem`.
   *
   * @type {WebGLCoordinateSystem|WebGPUCoordinateSystem}
   * @default WebGLCoordinateSystem
   * @readonly
   */
  get coordinateSystem() {
    return jr;
  }
  /**
   * Defines the output color space of the renderer.
   *
   * @type {SRGBColorSpace|LinearSRGBColorSpace}
   * @default SRGBColorSpace
   */
  get outputColorSpace() {
    return this._outputColorSpace;
  }
  set outputColorSpace(e) {
    this._outputColorSpace = e;
    const t = this.getContext();
    t.drawingBufferColorSpace = Xt._getDrawingBufferColorSpace(e), t.unpackColorSpace = Xt._getUnpackColorSpace();
  }
}
const Eq = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ACESFilmicToneMapping: F_,
  AddEquation: Wr,
  AddOperation: S3,
  AdditiveAnimationBlendMode: w3,
  AdditiveBlending: fh,
  AgXToneMapping: U_,
  AlphaFormat: k_,
  AlwaysCompare: W_,
  AlwaysDepth: Ef,
  AlwaysStencilFunc: p1,
  AmbientLight: m2,
  AnimationAction: _8,
  AnimationClip: Hp,
  AnimationLoader: CO,
  AnimationMixer: i9,
  AnimationObjectGroup: t9,
  AnimationUtils: wO,
  ArcCurve: n8,
  ArrayCamera: dS,
  ArrowHelper: E9,
  AttachedBindMode: Bv,
  Audio: m8,
  AudioAnalyser: WO,
  AudioContext: hS,
  AudioListener: zO,
  AudioLoader: kO,
  AxesHelper: R9,
  BackSide: si,
  BasicDepthPacking: R5,
  BasicShadowMap: A5,
  BatchedMesh: Z5,
  Bone: L3,
  BooleanKeyframeTrack: nd,
  Box2: d9,
  Box3: dr,
  Box3Helper: w9,
  BoxGeometry: ul,
  BoxHelper: T9,
  BufferAttribute: Dn,
  BufferGeometry: Yt,
  BufferGeometryLoader: p8,
  ByteType: Ou,
  Cache: ja,
  Camera: Jh,
  CameraHelper: S9,
  CanvasTexture: XU,
  CapsuleGeometry: i2,
  CatmullRomCurve3: i8,
  CineonToneMapping: B_,
  CircleGeometry: lA,
  ClampToEdgeWrapping: xr,
  Clock: _2,
  Color: ct,
  ColorKeyframeTrack: nS,
  ColorManagement: Xt,
  CompressedArrayTexture: $U,
  CompressedCubeTexture: jU,
  CompressedTexture: n2,
  CompressedTextureLoader: PO,
  ConeGeometry: T0,
  ConstantAlphaFactor: _5,
  ConstantColorFactor: m5,
  Controls: x2,
  CubeCamera: D3,
  CubeDepthTexture: B3,
  CubeReflectionMapping: no,
  CubeRefractionMapping: qo,
  CubeTexture: Ju,
  CubeTextureLoader: NO,
  CubeUVReflectionMapping: Gl,
  CubicBezierCurve: O3,
  CubicBezierCurve3: k3,
  CubicInterpolant: h8,
  CullFaceBack: h1,
  CullFaceFront: x3,
  CullFaceFrontBack: bF,
  CullFaceNone: _3,
  Curve: Ko,
  CurvePath: s8,
  CustomBlending: oh,
  CustomToneMapping: T3,
  CylinderGeometry: ed,
  Cylindrical: h9,
  Data3DTexture: $_,
  DataArrayTexture: y0,
  DataTexture: wo,
  DataTextureLoader: DO,
  DataUtils: xU,
  DecrementStencilOp: L5,
  DecrementWrapStencilOp: B5,
  DefaultLoadingManager: A8,
  DepthFormat: Lr,
  DepthStencilFormat: ds,
  DepthTexture: Qr,
  DetachedBindMode: y5,
  DirectionalLight: p2,
  DirectionalLightHelper: b9,
  DiscreteInterpolant: d8,
  DodecahedronGeometry: r2,
  DoubleSide: er,
  DstAlphaFactor: R_,
  DstColorFactor: P_,
  DynamicCopyUsage: IF,
  DynamicDrawUsage: Du,
  DynamicReadUsage: NF,
  EdgesGeometry: t8,
  EllipseCurve: s2,
  EqualCompare: z_,
  EqualDepth: Cf,
  EqualStencilFunc: k5,
  EquirectangularReflectionMapping: Gu,
  EquirectangularRefractionMapping: zu,
  Euler: Ir,
  EventDispatcher: lo,
  ExternalTexture: F3,
  ExtrudeGeometry: w0,
  FileLoader: Wl,
  Float16BufferAttribute: N3,
  Float32BufferAttribute: xt,
  FloatType: Ei,
  Fog: Z_,
  FogExp2: K_,
  FramebufferTexture: t2,
  FrontSide: Zs,
  Frustum: ec,
  FrustumArray: b0,
  GLBufferAttribute: l9,
  GLSL1: FF,
  GLSL3: Uv,
  GreaterCompare: q_,
  GreaterDepth: Nf,
  GreaterEqualCompare: sA,
  GreaterEqualDepth: Pf,
  GreaterEqualStencilFunc: q5,
  GreaterStencilFunc: G5,
  GridHelper: y9,
  Group: As,
  HalfFloatType: Ri,
  HemisphereLight: rS,
  HemisphereLightHelper: x9,
  IcosahedronGeometry: o2,
  ImageBitmapLoader: OO,
  ImageLoader: Wp,
  ImageUtils: H5,
  IncrementStencilOp: D5,
  IncrementWrapStencilOp: I5,
  InstancedBufferAttribute: to,
  InstancedBufferGeometry: cS,
  InstancedInterleavedBuffer: $p,
  InstancedMesh: K5,
  Int16BufferAttribute: TU,
  Int32BufferAttribute: wU,
  Int8BufferAttribute: vU,
  IntType: _r,
  InterleavedBuffer: aA,
  InterleavedBufferAttribute: Bs,
  Interpolant: R0,
  InterpolateDiscrete: Fp,
  InterpolateLinear: A1,
  InterpolateSmooth: Wg,
  InterpolationSamplingMode: OF,
  InterpolationSamplingType: UF,
  InvertStencilOp: F5,
  KeepStencilOp: Tu,
  KeyframeTrack: Zo,
  LOD: Y5,
  LatheGeometry: a2,
  Layers: j_,
  LessCompare: iA,
  LessDepth: Rf,
  LessEqualCompare: rA,
  LessEqualDepth: Vl,
  LessEqualStencilFunc: V5,
  LessStencilFunc: O5,
  Light: nc,
  LightProbe: uS,
  Line: va,
  Line3: v8,
  LineBasicMaterial: br,
  LineCurve: V3,
  LineCurve3: r8,
  LineDashedMaterial: J3,
  LineLoop: J5,
  LineSegments: Qo,
  LinearFilter: qn,
  LinearInterpolant: tS,
  LinearMipMapLinearFilter: v5,
  LinearMipMapNearestFilter: wF,
  LinearMipmapLinearFilter: $r,
  LinearMipmapNearestFilter: Uu,
  LinearSRGBColorSpace: Hl,
  LinearToneMapping: L_,
  LinearTransfer: Vh,
  Loader: uo,
  LoaderUtils: zv,
  LoadingManager: iS,
  LoopOnce: S5,
  LoopPingPong: w5,
  LoopRepeat: T5,
  MOUSE: So,
  Material: Br,
  MaterialLoader: g2,
  MathUtils: zh,
  Matrix2: D0,
  Matrix3: fn,
  Matrix4: Mt,
  MaxEquation: v3,
  Mesh: Tn,
  MeshBasicMaterial: Nr,
  MeshDepthMaterial: Q3,
  MeshDistanceMaterial: K3,
  MeshLambertMaterial: Ea,
  MeshMatcapMaterial: Z3,
  MeshNormalMaterial: Y3,
  MeshPhongMaterial: A2,
  MeshPhysicalMaterial: j3,
  MeshStandardMaterial: f2,
  MeshToonMaterial: X3,
  MinEquation: y3,
  MirroredRepeatWrapping: ql,
  MixOperation: b3,
  MultiplyBlending: ph,
  MultiplyOperation: tA,
  NearestFilter: ei,
  NearestMipMapLinearFilter: TF,
  NearestMipMapNearestFilter: SF,
  NearestMipmapLinearFilter: Aa,
  NearestMipmapNearestFilter: p0,
  NeutralToneMapping: O_,
  NeverCompare: G_,
  NeverDepth: Mf,
  NeverStencilFunc: U5,
  NoBlending: ms,
  NoColorSpace: Ds,
  NoNormalPacking: $g,
  NoToneMapping: Dr,
  NormalAnimationBlendMode: V_,
  NormalBlending: gs,
  NormalGAPacking: C5,
  NormalRGPacking: E3,
  NotEqualCompare: H_,
  NotEqualDepth: Df,
  NotEqualStencilFunc: z5,
  NumberKeyframeTrack: zp,
  Object3D: Vn,
  ObjectLoader: FO,
  ObjectSpaceNormalMap: M3,
  OctahedronGeometry: M0,
  OneFactor: w_,
  OneMinusConstantAlphaFactor: x5,
  OneMinusConstantColorFactor: g5,
  OneMinusDstAlphaFactor: C_,
  OneMinusDstColorFactor: N_,
  OneMinusSrcAlphaFactor: wf,
  OneMinusSrcColorFactor: E_,
  OrthographicCamera: ic,
  PCFShadowMap: Af,
  PCFSoftShadowMap: p5,
  PMREMGenerator: Wv,
  Path: x1,
  PerspectiveCamera: Ji,
  Plane: ca,
  PlaneGeometry: td,
  PlaneHelper: M9,
  PointLight: oS,
  PointLightHelper: g9,
  Points: I3,
  PointsMaterial: S0,
  PolarGridHelper: v9,
  PolyhedronGeometry: tc,
  PositionalAudio: HO,
  PropertyBinding: Xn,
  PropertyMixer: g8,
  QuadraticBezierCurve: G3,
  QuadraticBezierCurve3: z3,
  Quaternion: hr,
  QuaternionKeyframeTrack: C0,
  QuaternionLinearInterpolant: f8,
  R11_EAC_Format: xh,
  RED_GREEN_RGTC2_Format: Hu,
  RED_RGTC1_Format: Uh,
  REVISION: Ku,
  RG11_EAC_Format: qu,
  RGBADepthPacking: MF,
  RGBAFormat: Pi,
  RGBAIntegerFormat: Kh,
  RGBA_ASTC_10x10_Format: Lh,
  RGBA_ASTC_10x5_Format: Ph,
  RGBA_ASTC_10x6_Format: Nh,
  RGBA_ASTC_10x8_Format: Dh,
  RGBA_ASTC_12x10_Format: Ih,
  RGBA_ASTC_12x12_Format: Bh,
  RGBA_ASTC_4x4_Format: bh,
  RGBA_ASTC_5x4_Format: Sh,
  RGBA_ASTC_5x5_Format: Th,
  RGBA_ASTC_6x5_Format: wh,
  RGBA_ASTC_6x6_Format: Mh,
  RGBA_ASTC_8x5_Format: Eh,
  RGBA_ASTC_8x6_Format: Rh,
  RGBA_ASTC_8x8_Format: Ch,
  RGBA_BPTC_Format: Fh,
  RGBA_ETC2_EAC_Format: _h,
  RGBA_PVRTC_2BPPV1_Format: Ff,
  RGBA_PVRTC_4BPPV1_Format: Bf,
  RGBA_S3TC_DXT1_Format: Cl,
  RGBA_S3TC_DXT3_Format: Pl,
  RGBA_S3TC_DXT5_Format: Nl,
  RGBDepthPacking: EF,
  RGBFormat: nA,
  RGBIntegerFormat: b5,
  RGB_BPTC_SIGNED_Format: d1,
  RGB_BPTC_UNSIGNED_Format: f1,
  RGB_ETC1_Format: mh,
  RGB_ETC2_Format: gh,
  RGB_PVRTC_2BPPV1_Format: If,
  RGB_PVRTC_4BPPV1_Format: Lf,
  RGB_S3TC_DXT1_Format: Rl,
  RGDepthPacking: RF,
  RGFormat: fs,
  RGIntegerFormat: Qh,
  RawShaderMaterial: $3,
  Ray: Zh,
  Raycaster: y8,
  RectAreaLight: aS,
  RedFormat: Yh,
  RedIntegerFormat: Zu,
  ReinhardToneMapping: I_,
  RenderTarget: Ma,
  RenderTarget3D: r9,
  RepeatWrapping: zl,
  ReplaceStencilOp: N5,
  ReverseSubtractEquation: T_,
  RingGeometry: l2,
  SIGNED_R11_EAC_Format: yh,
  SIGNED_RED_GREEN_RGTC2_Format: kh,
  SIGNED_RED_RGTC1_Format: Oh,
  SIGNED_RG11_EAC_Format: vh,
  SRGBColorSpace: gr,
  SRGBTransfer: vt,
  Scene: oA,
  ShaderChunk: _n,
  ShaderLib: Es,
  ShaderMaterial: Fr,
  ShadowMaterial: W3,
  Shape: lh,
  ShapeGeometry: u2,
  ShapePath: S8,
  ShapeUtils: ma,
  ShortType: ku,
  Skeleton: e2,
  SkeletonHelper: m9,
  SkinnedMesh: Q5,
  Source: Lu,
  Sphere: fr,
  SphereGeometry: Co,
  Spherical: Hv,
  SphericalHarmonics3: lS,
  SplineCurve: q3,
  SpotLight: N0,
  SpotLightHelper: p9,
  Sprite: X5,
  SpriteMaterial: J_,
  SrcAlphaFactor: Tf,
  SrcAlphaSaturateFactor: D_,
  SrcColorFactor: M_,
  StaticCopyUsage: LF,
  StaticDrawUsage: Wu,
  StaticReadUsage: PF,
  StereoCamera: VO,
  StreamCopyUsage: BF,
  StreamDrawUsage: CF,
  StreamReadUsage: DF,
  StringKeyframeTrack: id,
  SubtractEquation: S_,
  SubtractiveBlending: Ah,
  TOUCH: Qc,
  TangentSpaceNormalMap: xa,
  TetrahedronGeometry: c2,
  Texture: Ii,
  TextureLoader: P0,
  TextureUtils: L9,
  Timer: u9,
  TimestampQuery: pa,
  TorusGeometry: h2,
  TorusKnotGeometry: d2,
  Triangle: $s,
  TriangleFanDrawMode: Fv,
  TriangleStripDrawMode: E5,
  TrianglesDrawMode: M5,
  TubeGeometry: E0,
  UVMapping: A0,
  Uint16BufferAttribute: X_,
  Uint32BufferAttribute: Y_,
  Uint8BufferAttribute: bU,
  Uint8ClampedBufferAttribute: SU,
  Uniform: s9,
  UniformsGroup: a9,
  UniformsLib: gt,
  UniformsUtils: v0,
  UnsignedByteType: Mi,
  UnsignedInt101111Type: x0,
  UnsignedInt248Type: Js,
  UnsignedInt5999Type: _0,
  UnsignedIntType: Jn,
  UnsignedShort4444Type: m0,
  UnsignedShort5551Type: g0,
  UnsignedShortType: Oo,
  VSMShadowMap: $a,
  Vector2: Le,
  Vector3: j,
  Vector4: Kt,
  VectorKeyframeTrack: qp,
  VideoFrameTexture: WU,
  VideoTexture: e8,
  WebGL3DRenderTarget: uU,
  WebGLArrayRenderTarget: lU,
  WebGLCoordinateSystem: jr,
  WebGLCubeRenderTarget: Q_,
  WebGLRenderTarget: eo,
  WebGLRenderer: P8,
  WebGLUtils: C8,
  WebGPUCoordinateSystem: io,
  WebXRController: bp,
  WireframeGeometry: H3,
  WrapAroundEnding: Up,
  ZeroCurvatureEnding: Kc,
  ZeroFactor: Ga,
  ZeroSlopeEnding: Zc,
  ZeroStencilOp: P5,
  createCanvasElement: C3,
  error: Ie,
  getConsoleFunction: GF,
  log: Of,
  setConsoleFunction: VF,
  warn: Me,
  warnOnce: li
}, Symbol.toStringTag, { value: "Module" })), hp = (i) => {
  if (!i || typeof i != "object" || !("type" in i))
    return i;
  const { type: e, params: t } = i, n = Eq[e];
  if (typeof n != "function")
    return i;
  const r = n;
  return new r(t ?? {});
}, Rq = (i) => !!i && typeof i == "object" && "isMaterial" in i && i.isMaterial === !0, Cq = (i) => !!i && typeof i == "object" && "isTexture" in i && i.isTexture === !0, Pq = (i) => !i || Rq(i) ? i : hp(i), Nq = new P0(), kE = (i) => !i || Cq(i) ? i : typeof i == "string" ? Nq.load(i) : i;
function Dq() {
  const i = globalThis;
  i.GPUShaderStage || (i.GPUShaderStage = {
    VERTEX: 1,
    FRAGMENT: 2,
    COMPUTE: 4
  });
}
const Lq = `.float-tooltip-kap {
  position: absolute;
  width: max-content;
  max-width: max(50%, 150px);
  padding: 3px 5px;
  border-radius: 3px;
  font: 12px sans-serif;
  color: #eee;
  background: rgba(0,0,0,0.6);
  pointer-events: none;
}
`;
function Iq(i) {
  const e = i.getRootNode(), t = e instanceof ShadowRoot ? e : document.head ?? document.documentElement;
  if (!t || t.querySelector?.('[data-pyglobegl-tooltip="1"]'))
    return;
  const n = document.createElement("style");
  n.dataset.pyglobeglTooltip = "1", n.textContent = Lq, t.appendChild(n);
}
function Bq({ el: i, model: e }) {
  i.style.width = "100%", i.style.height = "auto", i.style.display = "flex", i.style.justifyContent = "center", i.style.alignItems = "center", Dq(), Iq(i);
  let t;
  return Promise.resolve().then(() => PAe).then(({ default: n }) => {
    const r = document.createElement("div");
    i.replaceChildren(r);
    const s = () => e.get("config"), o = s();
    globalThis.__pyglobegl_init_config = o?.init;
    const a = new n(r, o?.init);
    a.pointOfView({ lat: 0, lng: 0, altitude: 2.8 }, 0), a.atmosphereAltitude(0.05);
    const l = i.closest(".output-area");
    a.onGlobeReady(() => {
      globalThis.__pyglobegl_globe_ready = !0, globalThis.__pyglobegl_renderer_attributes = a.renderer().getContext().getContextAttributes(), e.send({ type: "globe_ready" });
    }), a.onGlobeClick((z) => {
      e.send({ type: "globe_click", payload: z });
    }), a.onGlobeRightClick((z) => {
      e.send({ type: "globe_right_click", payload: z });
    }), a.onPointClick(
      (z, ue, he) => {
        e.send({ type: "point_click", payload: { point: z, coords: he } });
      }
    ), a.onPointRightClick(
      (z, ue, he) => {
        e.send({ type: "point_right_click", payload: { point: z, coords: he } });
      }
    );
    const u = {
      point: !1,
      arc: !1,
      polygon: !1,
      path: !1,
      heatmap: !1,
      hexPolygon: !1,
      tile: !1,
      particle: !1,
      label: !1
    }, c = () => {
      const z = e.get("event_config");
      return !z || typeof z != "object" ? {} : z;
    }, A = () => {
      const z = c();
      z.pointHover && !u.point && (a.onPointHover(
        (ue, he) => {
          e.send({
            type: "point_hover",
            payload: { point: ue, prev_point: he }
          });
        }
      ), u.point = !0), z.arcHover && !u.arc && (a.onArcHover(
        (ue, he) => {
          e.send({
            type: "arc_hover",
            payload: { arc: ue, prev_arc: he }
          });
        }
      ), u.arc = !0), z.polygonHover && !u.polygon && (a.onPolygonHover(
        (ue, he) => {
          e.send({
            type: "polygon_hover",
            payload: { polygon: ue, prev_polygon: he }
          });
        }
      ), u.polygon = !0), z.pathHover && !u.path && (a.onPathHover(
        (ue, he) => {
          e.send({
            type: "path_hover",
            payload: { path: ue, prev_path: he }
          });
        }
      ), u.path = !0), z.heatmapHover && !u.heatmap && (a.onHeatmapHover(
        (ue, he) => {
          e.send({
            type: "heatmap_hover",
            payload: { heatmap: ue, prev_heatmap: he }
          });
        }
      ), u.heatmap = !0), z.hexPolygonHover && !u.hexPolygon && (a.onHexPolygonHover(
        (ue, he) => {
          e.send({
            type: "hex_polygon_hover",
            payload: {
              hex_polygon: ue,
              prev_hex_polygon: he
            }
          });
        }
      ), u.hexPolygon = !0), z.tileHover && !u.tile && (a.onTileHover(
        (ue, he) => {
          e.send({
            type: "tile_hover",
            payload: { tile: ue, prev_tile: he }
          });
        }
      ), u.tile = !0), z.particleHover && !u.particle && (a.onParticleHover(
        (ue, he) => {
          e.send({
            type: "particle_hover",
            payload: { particle: ue, prev_particle: he }
          });
        }
      ), u.particle = !0), z.labelHover && !u.label && (a.onLabelHover(
        (ue, he) => {
          e.send({
            type: "label_hover",
            payload: { label: ue, prev_label: he }
          });
        }
      ), u.label = !0);
    };
    a.onArcClick(
      (z, ue, he) => {
        e.send({ type: "arc_click", payload: { arc: z, coords: he } });
      }
    ), a.onArcRightClick(
      (z, ue, he) => {
        e.send({ type: "arc_right_click", payload: { arc: z, coords: he } });
      }
    ), a.onPolygonClick(
      (z, ue, he) => {
        e.send({ type: "polygon_click", payload: { polygon: z, coords: he } });
      }
    ), a.onPolygonRightClick(
      (z, ue, he) => {
        e.send({
          type: "polygon_right_click",
          payload: { polygon: z, coords: he }
        });
      }
    ), a.onPathClick(
      (z, ue, he) => {
        e.send({ type: "path_click", payload: { path: z, coords: he } });
      }
    ), a.onPathRightClick(
      (z, ue, he) => {
        e.send({ type: "path_right_click", payload: { path: z, coords: he } });
      }
    ), a.onHeatmapClick(
      (z, ue, he) => {
        e.send({ type: "heatmap_click", payload: { heatmap: z, coords: he } });
      }
    ), a.onHeatmapRightClick(
      (z, ue, he) => {
        e.send({
          type: "heatmap_right_click",
          payload: { heatmap: z, coords: he }
        });
      }
    ), a.onHexPolygonClick(
      (z, ue, he) => {
        e.send({
          type: "hex_polygon_click",
          payload: { hex_polygon: z, coords: he }
        });
      }
    ), a.onHexPolygonRightClick(
      (z, ue, he) => {
        e.send({
          type: "hex_polygon_right_click",
          payload: { hex_polygon: z, coords: he }
        });
      }
    ), a.onTileClick(
      (z, ue, he) => {
        e.send({ type: "tile_click", payload: { tile: z, coords: he } });
      }
    ), a.onTileRightClick(
      (z, ue, he) => {
        e.send({
          type: "tile_right_click",
          payload: { tile: z, coords: he }
        });
      }
    ), a.onParticleClick(
      (z, ue, he) => {
        e.send({
          type: "particle_click",
          payload: { particle: z, coords: he }
        });
      }
    ), a.onParticleRightClick(
      (z, ue, he) => {
        e.send({
          type: "particle_right_click",
          payload: { particle: z, coords: he }
        });
      }
    ), a.onLabelClick(
      (z, ue, he) => {
        e.send({ type: "label_click", payload: { label: z, coords: he } });
      }
    ), a.onLabelRightClick(
      (z, ue, he) => {
        e.send({
          type: "label_right_click",
          payload: { label: z, coords: he }
        });
      }
    ), A(), e.on("change:event_config", A);
    const m = (z) => z && typeof z == "object" && "path" in z ? z.path ?? z : z, _ = (z) => {
      if (Array.isArray(z)) {
        const ue = z[2];
        return typeof ue == "number" ? ue : 1e-3;
      }
      return 1e-3;
    };
    a.pathPoints(m), a.pathPointAlt(_);
    const y = /* @__PURE__ */ new Set([
      "globeImageUrl",
      "bumpImageUrl",
      "globeTileEngineUrl",
      "showGlobe",
      "showGraticules",
      "showAtmosphere",
      "atmosphereColor",
      "atmosphereAltitude",
      "globeCurvatureResolution",
      "globeMaterial"
    ]), T = /* @__PURE__ */ new Set([
      "pointLabel",
      "pointLat",
      "pointLng",
      "pointColor",
      "pointAltitude",
      "pointRadius",
      "pointResolution",
      "pointsMerge",
      "pointsTransitionDuration"
    ]), b = /* @__PURE__ */ new Set([
      "arcStartLat",
      "arcStartLng",
      "arcStartAltitude",
      "arcEndLat",
      "arcEndLng",
      "arcEndAltitude",
      "arcColor",
      "arcAltitude",
      "arcAltitudeAutoScale",
      "arcStroke",
      "arcCurveResolution",
      "arcCircularResolution",
      "arcDashLength",
      "arcDashGap",
      "arcDashInitialGap",
      "arcDashAnimateTime",
      "arcsTransitionDuration",
      "arcLabel"
    ]), S = /* @__PURE__ */ new Set([
      "polygonLabel",
      "polygonGeoJsonGeometry",
      "polygonCapColor",
      "polygonCapMaterial",
      "polygonSideColor",
      "polygonSideMaterial",
      "polygonStrokeColor",
      "polygonAltitude",
      "polygonCapCurvatureResolution",
      "polygonsTransitionDuration"
    ]), E = /* @__PURE__ */ new Set([
      "pathLabel",
      "pathResolution",
      "pathColor",
      "pathStroke",
      "pathDashLength",
      "pathDashGap",
      "pathDashInitialGap",
      "pathDashAnimateTime",
      "pathTransitionDuration"
    ]), R = /* @__PURE__ */ new Set([
      "heatmapPoints",
      "heatmapPointLat",
      "heatmapPointLng",
      "heatmapPointWeight",
      "heatmapBandwidth",
      "heatmapColorFn",
      "heatmapColorSaturation",
      "heatmapBaseAltitude",
      "heatmapTopAltitude",
      "heatmapsTransitionDuration"
    ]), C = /* @__PURE__ */ new Set([
      "hexPolygonGeoJsonGeometry",
      "hexPolygonColor",
      "hexPolygonAltitude",
      "hexPolygonResolution",
      "hexPolygonMargin",
      "hexPolygonUseDots",
      "hexPolygonCurvatureResolution",
      "hexPolygonDotResolution",
      "hexPolygonsTransitionDuration",
      "hexPolygonLabel"
    ]), L = /* @__PURE__ */ new Set([
      "tileLat",
      "tileLng",
      "tileAltitude",
      "tileWidth",
      "tileHeight",
      "tileUseGlobeProjection",
      "tileMaterial",
      "tileCurvatureResolution",
      "tilesTransitionDuration",
      "tileLabel"
    ]), D = /* @__PURE__ */ new Set([
      "particlesList",
      "particleLat",
      "particleLng",
      "particleAltitude",
      "particlesSize",
      "particlesSizeAttenuation",
      "particlesColor",
      "particlesTexture",
      "particleLabel"
    ]), B = /* @__PURE__ */ new Set([
      "ringLat",
      "ringLng",
      "ringAltitude",
      "ringColor",
      "ringResolution",
      "ringMaxRadius",
      "ringPropagationSpeed",
      "ringRepeatPeriod"
    ]), U = /* @__PURE__ */ new Set([
      "labelLat",
      "labelLng",
      "labelAltitude",
      "labelRotation",
      "labelText",
      "labelSize",
      "labelTypeFace",
      "labelColor",
      "labelResolution",
      "labelIncludeDot",
      "labelDotRadius",
      "labelDotOrientation",
      "labelsTransitionDuration",
      "labelLabel"
    ]), N = /* @__PURE__ */ new Set([
      "globeMaterial",
      "polygonCapMaterial",
      "polygonSideMaterial"
    ]), O = /* @__PURE__ */ new Set([
      "hexTopColor",
      "hexSideColor",
      "hexAltitude"
    ]), G = (z, ue, he) => {
      if (typeof ue != "string" || !z.has(ue))
        return;
      const Ee = a[ue];
      if (typeof Ee == "function") {
        const Ye = N.has(ue) ? hp(he) : O.has(ue) ? () => he : he;
        Ee(Ye);
      }
    }, H = (z, ue, he) => {
      const Ee = z() ?? [], Ye = new Map(
        Ee.map((te) => {
          const Et = te.id;
          return Et == null ? null : [String(Et), te];
        }).filter(
          (te) => te !== null
        )
      );
      for (const te of he) {
        if (!te || typeof te != "object")
          continue;
        const Et = te.id;
        if (Et == null)
          continue;
        const dt = Ye.get(String(Et));
        dt && Object.assign(dt, te);
      }
      ue(Ee);
    }, Y = (z) => z ? z.map((ue) => {
      if (!ue || typeof ue != "object")
        return ue;
      const he = Pq(
        ue.material
      );
      return { ...ue, material: he };
    }) : [], K = (z) => z ? z.map((ue) => {
      if (!ue || typeof ue != "object" || Array.isArray(ue))
        return ue;
      const he = ue.particles;
      if (Array.isArray(he)) {
        const Ye = he;
        return Object.entries(ue).forEach(([te, Et]) => {
          if (te === "particles")
            return;
          let dt = Et;
          te === "texture" && (dt = kE(Et)), Ye[te] = dt;
        }), Ye;
      }
      const Ee = kE(
        ue.texture
      );
      return { ...ue, texture: Ee };
    }) : [];
    e.on("msg:custom", (z) => {
      if (typeof z == "object" && z !== null && "type" in z && z.type === "globe_tile_engine_clear_cache" && a.globeTileEngineClearCache(), typeof z == "object" && z !== null && "type" in z && "payload" in z) {
        const { type: ue, payload: he } = z;
        ue === "points_set_data" ? a.pointsData(he?.data ?? []) : ue === "arcs_set_data" ? a.arcsData(he?.data ?? []) : ue === "polygons_set_data" ? a.polygonsData(he?.data ?? []) : ue === "paths_set_data" ? a.pathsData(he?.data ?? []) : ue === "heatmaps_set_data" ? a.heatmapsData(he?.data ?? []) : ue === "hex_polygons_set_data" ? a.hexPolygonsData(he?.data ?? []) : ue === "tiles_set_data" ? a.tilesData(Y(he?.data)) : ue === "particles_set_data" ? a.particlesData(K(he?.data)) : ue === "rings_set_data" ? a.ringsData(he?.data ?? []) : ue === "labels_set_data" ? a.labelsData(he?.data ?? []) : ue === "points_patch_data" ? H(
          () => a.pointsData() ?? [],
          (Ee) => a.pointsData(Ee),
          he?.patches ?? []
        ) : ue === "arcs_patch_data" ? H(
          () => a.arcsData() ?? [],
          (Ee) => a.arcsData(Ee),
          he?.patches ?? []
        ) : ue === "polygons_patch_data" ? H(
          () => a.polygonsData() ?? [],
          (Ee) => a.polygonsData(Ee),
          he?.patches ?? []
        ) : ue === "paths_patch_data" ? H(
          () => a.pathsData() ?? [],
          (Ee) => a.pathsData(Ee),
          he?.patches ?? []
        ) : ue === "heatmaps_patch_data" ? H(
          () => a.heatmapsData() ?? [],
          (Ee) => a.heatmapsData(Ee),
          he?.patches ?? []
        ) : ue === "hex_polygons_patch_data" ? H(
          () => a.hexPolygonsData() ?? [],
          (Ee) => a.hexPolygonsData(Ee),
          he?.patches ?? []
        ) : ue === "tiles_patch_data" ? H(
          () => a.tilesData() ?? [],
          (Ee) => a.tilesData(Y(Ee)),
          he?.patches ?? []
        ) : ue === "particles_patch_data" ? H(
          () => a.particlesData() ?? [],
          (Ee) => a.particlesData(K(Ee)),
          he?.patches ?? []
        ) : ue === "rings_patch_data" ? H(
          () => a.ringsData() ?? [],
          (Ee) => a.ringsData(Ee),
          he?.patches ?? []
        ) : ue === "labels_patch_data" ? H(
          () => a.labelsData() ?? [],
          (Ee) => a.labelsData(Ee),
          he?.patches ?? []
        ) : ue === "points_prop" ? G(T, he?.prop, he?.value) : ue === "arcs_prop" ? G(b, he?.prop, he?.value) : ue === "polygons_prop" ? G(S, he?.prop, he?.value) : ue === "paths_prop" ? G(E, he?.prop, he?.value) : ue === "heatmaps_prop" ? G(R, he?.prop, he?.value) : ue === "hex_polygons_prop" ? G(C, he?.prop, he?.value) : ue === "tiles_prop" ? G(L, he?.prop, he?.value) : ue === "particles_prop" ? G(D, he?.prop, he?.value) : ue === "rings_prop" ? G(B, he?.prop, he?.value) : ue === "labels_prop" ? G(U, he?.prop, he?.value) : ue === "globe_prop" && G(y, he?.prop, he?.value);
      }
    });
    const X = () => {
      const { width: z } = i.getBoundingClientRect();
      if (z <= 0)
        return;
      const ue = l || i.parentElement;
      let he = ue ? ue.clientHeight : 0, Ee = 0, Ye = 0;
      if (ue) {
        const rt = window.getComputedStyle(ue), ne = Number.parseFloat(rt.paddingTop), W = Number.parseFloat(rt.paddingBottom);
        Ee = ne + W;
        const ge = Number.parseFloat(rt.maxHeight);
        Number.isFinite(ge) && (Ye = ge), he > 0 && (he = Math.max(0, he - Ee));
      }
      const te = Ye > 0 ? Math.max(0, Ye - Ee) : he, Et = window.innerHeight || 0, dt = Math.min(
        z,
        te > 0 ? te : z,
        Et > 0 ? Et : z
      ), Nt = Math.max(0, Math.floor(dt * 0.75));
      i.style.width = "100%", i.style.height = `${te > 0 ? te : Nt}px`, i.style.margin = "0", r.style.width = `${Nt}px`, r.style.height = `${Nt}px`, a.width(Nt).height(Nt);
    }, ee = (z) => {
      const ue = z?.width, he = z?.height, Ee = typeof ue == "number" && Number.isFinite(ue), Ye = typeof he == "number" && Number.isFinite(he);
      return !Ee && !Ye ? !1 : (Ee && (r.style.width = `${ue}px`, a.width(ue)), Ye && (r.style.height = `${he}px`, i.style.height = `${he}px`, a.height(he)), Ee && !Ye && (r.style.height = `${ue}px`, i.style.height = `${ue}px`, a.height(ue)), Ye && !Ee && (r.style.width = `${he}px`, a.width(he)), !0);
    }, oe = (z) => {
      z && (z.globeOffset && a.globeOffset(z.globeOffset), z.backgroundColor && a.backgroundColor(z.backgroundColor), z.backgroundImageUrl && a.backgroundImageUrl(z.backgroundImageUrl));
    }, fe = (z) => {
      if (z) {
        if (z.globeImageUrl !== void 0 && a.globeImageUrl(z.globeImageUrl ?? null), z.bumpImageUrl !== void 0 && a.bumpImageUrl(z.bumpImageUrl ?? null), z.globeTileEngineUrl !== void 0) {
          const ue = z.globeTileEngineUrl;
          ue ? a.globeTileEngineUrl(
            (he, Ee, Ye) => ue.replaceAll("{x}", String(he)).replaceAll("{y}", String(Ee)).replaceAll("{l}", String(Ye)).replaceAll("{z}", String(Ye))
          ) : a.globeTileEngineUrl(null);
        }
        if (z.showGlobe !== void 0 && a.showGlobe(z.showGlobe), z.showGraticules !== void 0 && a.showGraticules(z.showGraticules), z.showAtmosphere !== void 0 && a.showAtmosphere(z.showAtmosphere), z.atmosphereColor !== void 0 && a.atmosphereColor(z.atmosphereColor), z.atmosphereAltitude !== void 0 && a.atmosphereAltitude(z.atmosphereAltitude), z.globeCurvatureResolution !== void 0 && a.globeCurvatureResolution(z.globeCurvatureResolution), z.globeMaterial !== void 0) {
          const ue = hp(z.globeMaterial);
          a.globeMaterial(ue);
        }
      }
    }, _e = (z) => {
      z && (z.pointsData !== void 0 && a.pointsData(z.pointsData ?? []), z.pointLabel !== void 0 && a.pointLabel(z.pointLabel ?? null), z.pointLat !== void 0 && a.pointLat(z.pointLat ?? null), z.pointLng !== void 0 && a.pointLng(z.pointLng ?? null), z.pointColor !== void 0 && a.pointColor(z.pointColor ?? null), z.pointAltitude !== void 0 && a.pointAltitude(z.pointAltitude ?? null), z.pointRadius !== void 0 && a.pointRadius(z.pointRadius ?? null), z.pointResolution !== void 0 && a.pointResolution(z.pointResolution), z.pointsMerge !== void 0 && a.pointsMerge(z.pointsMerge), z.pointsTransitionDuration !== void 0 && a.pointsTransitionDuration(z.pointsTransitionDuration));
    }, Te = (z) => {
      z && (z.arcsData !== void 0 && a.arcsData(z.arcsData ?? []), z.arcLabel !== void 0 && a.arcLabel(z.arcLabel ?? null), z.arcStartLat !== void 0 && a.arcStartLat(z.arcStartLat ?? null), z.arcStartLng !== void 0 && a.arcStartLng(z.arcStartLng ?? null), z.arcStartAltitude !== void 0 && a.arcStartAltitude(z.arcStartAltitude ?? null), z.arcEndLat !== void 0 && a.arcEndLat(z.arcEndLat ?? null), z.arcEndLng !== void 0 && a.arcEndLng(z.arcEndLng ?? null), z.arcEndAltitude !== void 0 && a.arcEndAltitude(z.arcEndAltitude ?? null), z.arcColor !== void 0 && a.arcColor(z.arcColor ?? null), z.arcAltitude !== void 0 && a.arcAltitude(z.arcAltitude ?? null), z.arcAltitudeAutoScale !== void 0 && a.arcAltitudeAutoScale(z.arcAltitudeAutoScale ?? null), z.arcStroke !== void 0 && a.arcStroke(z.arcStroke ?? null), z.arcCurveResolution !== void 0 && a.arcCurveResolution(z.arcCurveResolution), z.arcCircularResolution !== void 0 && a.arcCircularResolution(z.arcCircularResolution), z.arcDashLength !== void 0 && a.arcDashLength(z.arcDashLength ?? null), z.arcDashGap !== void 0 && a.arcDashGap(z.arcDashGap ?? null), z.arcDashInitialGap !== void 0 && a.arcDashInitialGap(z.arcDashInitialGap ?? null), z.arcDashAnimateTime !== void 0 && a.arcDashAnimateTime(z.arcDashAnimateTime ?? null), z.arcsTransitionDuration !== void 0 && a.arcsTransitionDuration(z.arcsTransitionDuration));
    }, Ce = (z) => {
      z && (z.polygonsData !== void 0 && a.polygonsData(z.polygonsData ?? []), z.polygonLabel !== void 0 && a.polygonLabel(z.polygonLabel ?? null), z.polygonGeoJsonGeometry !== void 0 && a.polygonGeoJsonGeometry(
        z.polygonGeoJsonGeometry ?? null
      ), z.polygonCapColor !== void 0 && a.polygonCapColor(z.polygonCapColor ?? null), z.polygonCapMaterial !== void 0 && a.polygonCapMaterial(
        hp(z.polygonCapMaterial)
      ), z.polygonSideColor !== void 0 && a.polygonSideColor(z.polygonSideColor ?? null), z.polygonSideMaterial !== void 0 && a.polygonSideMaterial(
        hp(z.polygonSideMaterial)
      ), z.polygonStrokeColor !== void 0 && a.polygonStrokeColor(z.polygonStrokeColor ?? null), z.polygonAltitude !== void 0 && a.polygonAltitude(z.polygonAltitude ?? null), z.polygonCapCurvatureResolution !== void 0 && a.polygonCapCurvatureResolution(
        z.polygonCapCurvatureResolution ?? null
      ), z.polygonsTransitionDuration !== void 0 && a.polygonsTransitionDuration(
        z.polygonsTransitionDuration
      ));
    }, Je = (z) => {
      z && (z.pathsData !== void 0 && a.pathsData(z.pathsData ?? []), z.pathLabel !== void 0 && a.pathLabel(z.pathLabel ?? null), z.pathResolution !== void 0 && a.pathResolution(z.pathResolution), z.pathColor !== void 0 && a.pathColor(z.pathColor ?? null), z.pathStroke !== void 0 && a.pathStroke(z.pathStroke ?? null), z.pathDashLength !== void 0 && a.pathDashLength(z.pathDashLength ?? null), z.pathDashGap !== void 0 && a.pathDashGap(z.pathDashGap ?? null), z.pathDashInitialGap !== void 0 && a.pathDashInitialGap(z.pathDashInitialGap ?? null), z.pathDashAnimateTime !== void 0 && a.pathDashAnimateTime(z.pathDashAnimateTime ?? null), z.pathTransitionDuration !== void 0 && a.pathTransitionDuration(z.pathTransitionDuration));
    }, Qe = (z) => {
      z && (z.heatmapsData !== void 0 && a.heatmapsData(z.heatmapsData ?? []), z.heatmapPoints !== void 0 && a.heatmapPoints(z.heatmapPoints ?? null), z.heatmapPointLat !== void 0 && a.heatmapPointLat(z.heatmapPointLat ?? null), z.heatmapPointLng !== void 0 && a.heatmapPointLng(z.heatmapPointLng ?? null), z.heatmapPointWeight !== void 0 && a.heatmapPointWeight(z.heatmapPointWeight ?? null), z.heatmapBandwidth !== void 0 && a.heatmapBandwidth(z.heatmapBandwidth ?? null), z.heatmapColorFn !== void 0 && a.heatmapColorFn(z.heatmapColorFn ?? null), z.heatmapColorSaturation !== void 0 && a.heatmapColorSaturation(
        z.heatmapColorSaturation ?? null
      ), z.heatmapBaseAltitude !== void 0 && a.heatmapBaseAltitude(z.heatmapBaseAltitude ?? null), z.heatmapTopAltitude !== void 0 && a.heatmapTopAltitude(z.heatmapTopAltitude ?? null), z.heatmapsTransitionDuration !== void 0 && a.heatmapsTransitionDuration(
        z.heatmapsTransitionDuration
      ));
    }, zt = (z) => {
      z && (z.hexPolygonsData !== void 0 && a.hexPolygonsData(z.hexPolygonsData ?? []), z.hexPolygonGeoJsonGeometry !== void 0 && a.hexPolygonGeoJsonGeometry(
        z.hexPolygonGeoJsonGeometry ?? null
      ), z.hexPolygonColor !== void 0 && a.hexPolygonColor(z.hexPolygonColor ?? null), z.hexPolygonAltitude !== void 0 && a.hexPolygonAltitude(z.hexPolygonAltitude ?? null), z.hexPolygonResolution !== void 0 && a.hexPolygonResolution(
        z.hexPolygonResolution ?? null
      ), z.hexPolygonMargin !== void 0 && a.hexPolygonMargin(z.hexPolygonMargin ?? null), z.hexPolygonUseDots !== void 0 && a.hexPolygonUseDots(z.hexPolygonUseDots), z.hexPolygonCurvatureResolution !== void 0 && a.hexPolygonCurvatureResolution(
        z.hexPolygonCurvatureResolution ?? null
      ), z.hexPolygonDotResolution !== void 0 && a.hexPolygonDotResolution(
        z.hexPolygonDotResolution ?? null
      ), z.hexPolygonsTransitionDuration !== void 0 && a.hexPolygonsTransitionDuration(
        z.hexPolygonsTransitionDuration
      ), z.hexPolygonLabel !== void 0 && a.hexPolygonLabel(z.hexPolygonLabel ?? null));
    }, Tt = (z) => {
      z && (z.tilesData !== void 0 && a.tilesData(Y(z.tilesData)), z.tileLat !== void 0 && a.tileLat(z.tileLat ?? null), z.tileLng !== void 0 && a.tileLng(z.tileLng ?? null), z.tileAltitude !== void 0 && a.tileAltitude(z.tileAltitude ?? null), z.tileWidth !== void 0 && a.tileWidth(z.tileWidth ?? null), z.tileHeight !== void 0 && a.tileHeight(z.tileHeight ?? null), z.tileUseGlobeProjection !== void 0 && a.tileUseGlobeProjection(z.tileUseGlobeProjection), z.tileMaterial !== void 0 && a.tileMaterial(z.tileMaterial ?? null), z.tileCurvatureResolution !== void 0 && a.tileCurvatureResolution(
        z.tileCurvatureResolution ?? null
      ), z.tilesTransitionDuration !== void 0 && a.tilesTransitionDuration(z.tilesTransitionDuration), z.tileLabel !== void 0 && a.tileLabel(z.tileLabel ?? null));
    }, Pe = (z) => {
      z && (z.particlesData !== void 0 && a.particlesData(
        K(z.particlesData)
      ), z.particlesList !== void 0 && a.particlesList(z.particlesList ?? null), z.particleLat !== void 0 && a.particleLat(z.particleLat ?? null), z.particleLng !== void 0 && a.particleLng(z.particleLng ?? null), z.particleAltitude !== void 0 && a.particleAltitude(z.particleAltitude ?? null), z.particlesSize !== void 0 && a.particlesSize(z.particlesSize ?? null), z.particlesSizeAttenuation !== void 0 && a.particlesSizeAttenuation(
        z.particlesSizeAttenuation ?? null
      ), z.particlesColor !== void 0 && a.particlesColor(z.particlesColor ?? null), z.particlesTexture !== void 0 && a.particlesTexture(z.particlesTexture ?? null), z.particleLabel !== void 0 && a.particleLabel(z.particleLabel ?? null));
    }, ke = (z) => {
      z && (z.ringsData !== void 0 && a.ringsData(z.ringsData ?? []), z.ringLat !== void 0 && a.ringLat(z.ringLat ?? null), z.ringLng !== void 0 && a.ringLng(z.ringLng ?? null), z.ringAltitude !== void 0 && a.ringAltitude(z.ringAltitude ?? null), z.ringColor !== void 0 && a.ringColor(z.ringColor ?? null), z.ringResolution !== void 0 && a.ringResolution(z.ringResolution), z.ringMaxRadius !== void 0 && a.ringMaxRadius(z.ringMaxRadius ?? null), z.ringPropagationSpeed !== void 0 && a.ringPropagationSpeed(z.ringPropagationSpeed ?? null), z.ringRepeatPeriod !== void 0 && a.ringRepeatPeriod(z.ringRepeatPeriod ?? null));
    }, at = (z) => {
      z && (z.labelsData !== void 0 && a.labelsData(z.labelsData ?? []), z.labelLat !== void 0 && a.labelLat(z.labelLat ?? null), z.labelLng !== void 0 && a.labelLng(z.labelLng ?? null), z.labelAltitude !== void 0 && a.labelAltitude(z.labelAltitude ?? null), z.labelRotation !== void 0 && a.labelRotation(z.labelRotation ?? null), z.labelText !== void 0 && a.labelText(z.labelText ?? null), z.labelSize !== void 0 && a.labelSize(z.labelSize ?? null), z.labelTypeFace !== void 0 && a.labelTypeFace(z.labelTypeFace ?? null), z.labelColor !== void 0 && a.labelColor(z.labelColor ?? null), z.labelResolution !== void 0 && a.labelResolution(z.labelResolution), z.labelIncludeDot !== void 0 && a.labelIncludeDot(z.labelIncludeDot), z.labelDotRadius !== void 0 && a.labelDotRadius(z.labelDotRadius ?? null), z.labelDotOrientation !== void 0 && a.labelDotOrientation(z.labelDotOrientation ?? null), z.labelsTransitionDuration !== void 0 && a.labelsTransitionDuration(z.labelsTransitionDuration), z.labelLabel !== void 0 && a.labelLabel(z.labelLabel ?? null));
    }, wt = (z) => {
      if (!z || !z.pointOfView)
        return;
      const ue = z.transitionMs ?? 0;
      a.pointOfView(z.pointOfView, ue), globalThis.__pyglobegl_pov = a.pointOfView();
    }, ot = () => {
      t || (X(), t = new ResizeObserver(X), t.observe(i));
    }, Wt = () => {
      t?.disconnect(), t = void 0;
    }, en = (z) => {
      const ue = z?.layout, he = z?.globe, Ee = z?.points, Ye = z?.arcs, te = z?.polygons, Et = z?.paths, dt = z?.heatmaps, Nt = z?.hexed_polygons, rt = z?.tiles, ne = z?.particles, W = z?.rings, ge = z?.labels, Fe = z?.view;
      ee(ue) ? Wt() : ot(), oe(ue), fe(he), _e(Ee), Te(Ye), Ce(te), Je(Et), Qe(dt), zt(Nt), Tt(rt), Pe(ne), ke(W), at(ge), wt(Fe);
    };
    en(o), e.on("change:config", () => {
      en(s());
    });
  }), () => {
    t?.disconnect();
    const n = globalThis;
    delete n.__pyglobegl_globe_ready, delete n.__pyglobegl_renderer_attributes, delete n.__pyglobegl_init_config, delete n.__pyglobegl_pov;
  };
}
const FAe = { render: Bq };
class Fq extends Vn {
  /**
   * Constructs a new CSS2D object.
   *
   * @param {HTMLElement} [element] - The DOM element.
   */
  constructor(e = document.createElement("div")) {
    super(), this.isCSS2DObject = !0, this.element = e, this.element.style.position = "absolute", this.element.style.userSelect = "none", this.element.setAttribute("draggable", !1), this.center = new Le(0.5, 0.5), this.addEventListener("removed", function() {
      this.traverse(function(t) {
        t.element && t.element instanceof t.element.ownerDocument.defaultView.Element && t.element.parentNode !== null && t.element.remove();
      });
    });
  }
  copy(e, t) {
    return super.copy(e, t), this.element = e.element.cloneNode(!0), this.center = e.center, this;
  }
}
const Od = new j(), VE = new Mt(), GE = new Mt(), zE = new j(), qE = new j();
class Uq {
  /**
   * Constructs a new CSS2D renderer.
   *
   * @param {CSS2DRenderer~Parameters} [parameters] - The parameters.
   */
  constructor(e = {}) {
    const t = this;
    let n, r, s, o;
    const a = {
      objects: /* @__PURE__ */ new WeakMap()
    }, l = e.element !== void 0 ? e.element : document.createElement("div");
    l.style.overflow = "hidden", this.domElement = l, this.sortObjects = !0, this.getSize = function() {
      return {
        width: n,
        height: r
      };
    }, this.render = function(y, T) {
      y.matrixWorldAutoUpdate === !0 && y.updateMatrixWorld(), T.parent === null && T.matrixWorldAutoUpdate === !0 && T.updateMatrixWorld(), VE.copy(T.matrixWorldInverse), GE.multiplyMatrices(T.projectionMatrix, VE), c(y, y, T), this.sortObjects && _(y);
    }, this.setSize = function(y, T) {
      n = y, r = T, s = n / 2, o = r / 2, l.style.width = y + "px", l.style.height = T + "px";
    };
    function u(y) {
      y.isCSS2DObject && (y.element.style.display = "none");
      for (let T = 0, b = y.children.length; T < b; T++)
        u(y.children[T]);
    }
    function c(y, T, b) {
      if (y.visible === !1) {
        u(y);
        return;
      }
      if (y.isCSS2DObject) {
        Od.setFromMatrixPosition(y.matrixWorld), Od.applyMatrix4(GE);
        const S = Od.z >= -1 && Od.z <= 1 && y.layers.test(b.layers) === !0, E = y.element;
        E.style.display = S === !0 ? "" : "none", S === !0 && (y.onBeforeRender(t, T, b), E.style.transform = "translate(" + -100 * y.center.x + "%," + -100 * y.center.y + "%)translate(" + (Od.x * s + s) + "px," + (-Od.y * o + o) + "px)", E.parentNode !== l && l.appendChild(E), y.onAfterRender(t, T, b));
        const R = {
          distanceToCameraSquared: A(b, y)
        };
        a.objects.set(y, R);
      }
      for (let S = 0, E = y.children.length; S < E; S++)
        c(y.children[S], T, b);
    }
    function A(y, T) {
      return zE.setFromMatrixPosition(y.matrixWorld), qE.setFromMatrixPosition(T.matrixWorld), zE.distanceToSquared(qE);
    }
    function m(y) {
      const T = [];
      return y.traverseVisible(function(b) {
        b.isCSS2DObject && T.push(b);
      }), T;
    }
    function _(y) {
      const T = m(y).sort(function(S, E) {
        if (S.renderOrder !== E.renderOrder)
          return E.renderOrder - S.renderOrder;
        const R = a.objects.get(S).distanceToCameraSquared, C = a.objects.get(E).distanceToCameraSquared;
        return R - C;
      }), b = T.length;
      for (let S = 0, E = T.length; S < E; S++)
        T[S].element.style.zIndex = b - S;
    }
  }
}
function Xv(i) {
  var e = typeof i;
  return i != null && (e == "object" || e == "function");
}
var Oq = typeof global == "object" && global && global.Object === Object && global, kq = typeof self == "object" && self && self.Object === Object && self, N8 = Oq || kq || Function("return this")(), Cy = function() {
  return N8.Date.now();
}, Vq = /\s/;
function Gq(i) {
  for (var e = i.length; e-- && Vq.test(i.charAt(e)); )
    ;
  return e;
}
var zq = /^\s+/;
function qq(i) {
  return i && i.slice(0, Gq(i) + 1).replace(zq, "");
}
var v1 = N8.Symbol, D8 = Object.prototype, Hq = D8.hasOwnProperty, Wq = D8.toString, OA = v1 ? v1.toStringTag : void 0;
function $q(i) {
  var e = Hq.call(i, OA), t = i[OA];
  try {
    i[OA] = void 0;
    var n = !0;
  } catch {
  }
  var r = Wq.call(i);
  return n && (e ? i[OA] = t : delete i[OA]), r;
}
var jq = Object.prototype, Xq = jq.toString;
function Yq(i) {
  return Xq.call(i);
}
var Qq = "[object Null]", Kq = "[object Undefined]", HE = v1 ? v1.toStringTag : void 0;
function Zq(i) {
  return i == null ? i === void 0 ? Kq : Qq : HE && HE in Object(i) ? $q(i) : Yq(i);
}
function Jq(i) {
  return i != null && typeof i == "object";
}
var eH = "[object Symbol]";
function tH(i) {
  return typeof i == "symbol" || Jq(i) && Zq(i) == eH;
}
var WE = NaN, nH = /^[-+]0x[0-9a-f]+$/i, iH = /^0b[01]+$/i, rH = /^0o[0-7]+$/i, sH = parseInt;
function $E(i) {
  if (typeof i == "number")
    return i;
  if (tH(i))
    return WE;
  if (Xv(i)) {
    var e = typeof i.valueOf == "function" ? i.valueOf() : i;
    i = Xv(e) ? e + "" : e;
  }
  if (typeof i != "string")
    return i === 0 ? i : +i;
  i = qq(i);
  var t = iH.test(i);
  return t || rH.test(i) ? sH(i.slice(2), t ? 2 : 8) : nH.test(i) ? WE : +i;
}
var oH = "Expected a function", aH = Math.max, lH = Math.min;
function uH(i, e, t) {
  var n, r, s, o, a, l, u = 0, c = !1, A = !1, m = !0;
  if (typeof i != "function")
    throw new TypeError(oH);
  e = $E(e) || 0, Xv(t) && (c = !!t.leading, A = "maxWait" in t, s = A ? aH($E(t.maxWait) || 0, e) : s, m = "trailing" in t ? !!t.trailing : m);
  function _(D) {
    var B = n, U = r;
    return n = r = void 0, u = D, o = i.apply(U, B), o;
  }
  function y(D) {
    return u = D, a = setTimeout(S, e), c ? _(D) : o;
  }
  function T(D) {
    var B = D - l, U = D - u, N = e - B;
    return A ? lH(N, s - U) : N;
  }
  function b(D) {
    var B = D - l, U = D - u;
    return l === void 0 || B >= e || B < 0 || A && U >= s;
  }
  function S() {
    var D = Cy();
    if (b(D))
      return E(D);
    a = setTimeout(S, T(D));
  }
  function E(D) {
    return a = void 0, m && n ? _(D) : (n = r = void 0, o);
  }
  function R() {
    a !== void 0 && clearTimeout(a), u = 0, n = l = r = a = void 0;
  }
  function C() {
    return a === void 0 ? o : E(Cy());
  }
  function L() {
    var D = Cy(), B = b(D);
    if (n = arguments, r = this, l = D, B) {
      if (a === void 0)
        return y(l);
      if (A)
        return clearTimeout(a), a = setTimeout(S, e), _(l);
    }
    return a === void 0 && (a = setTimeout(S, e)), o;
  }
  return L.cancel = R, L.flush = C, L;
}
function jE(i, e) {
  (e == null || e > i.length) && (e = i.length);
  for (var t = 0, n = Array(e); t < e; t++) n[t] = i[t];
  return n;
}
function cH(i) {
  if (Array.isArray(i)) return i;
}
function hH(i, e) {
  if (!(i instanceof e)) throw new TypeError("Cannot call a class as a function");
}
function dH(i, e, t) {
  return Object.defineProperty(i, "prototype", {
    writable: !1
  }), i;
}
function fH(i, e) {
  var t = i == null ? null : typeof Symbol < "u" && i[Symbol.iterator] || i["@@iterator"];
  if (t != null) {
    var n, r, s, o, a = [], l = !0, u = !1;
    try {
      if (s = (t = t.call(i)).next, e !== 0) for (; !(l = (n = s.call(t)).done) && (a.push(n.value), a.length !== e); l = !0) ;
    } catch (c) {
      u = !0, r = c;
    } finally {
      try {
        if (!l && t.return != null && (o = t.return(), Object(o) !== o)) return;
      } finally {
        if (u) throw r;
      }
    }
    return a;
  }
}
function AH() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function pH(i, e) {
  return cH(i) || fH(i, e) || mH(i, e) || AH();
}
function mH(i, e) {
  if (i) {
    if (typeof i == "string") return jE(i, e);
    var t = {}.toString.call(i).slice(8, -1);
    return t === "Object" && i.constructor && (t = i.constructor.name), t === "Map" || t === "Set" ? Array.from(i) : t === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? jE(i, e) : void 0;
  }
}
var gH = /* @__PURE__ */ dH(function i(e, t) {
  var n = t.default, r = n === void 0 ? null : n, s = t.triggerUpdate, o = s === void 0 ? !0 : s, a = t.onChange, l = a === void 0 ? function(u, c) {
  } : a;
  hH(this, i), this.name = e, this.defaultVal = r, this.triggerUpdate = o, this.onChange = l;
});
function Sr(i) {
  var e = i.stateInit, t = e === void 0 ? function() {
    return {};
  } : e, n = i.props, r = n === void 0 ? {} : n, s = i.methods, o = s === void 0 ? {} : s, a = i.aliases, l = a === void 0 ? {} : a, u = i.init, c = u === void 0 ? function() {
  } : u, A = i.update, m = A === void 0 ? function() {
  } : A, _ = Object.keys(r).map(function(y) {
    return new gH(y, r[y]);
  });
  return function y() {
    for (var T = arguments.length, b = new Array(T), S = 0; S < T; S++)
      b[S] = arguments[S];
    var E = !!(this instanceof y && this.constructor), R = E ? b.shift() : void 0, C = b[0], L = C === void 0 ? {} : C, D = Object.assign(
      {},
      t instanceof Function ? t(L) : t,
      // Support plain objects for backwards compatibility
      {
        initialised: !1
      }
    ), B = {};
    function U(G) {
      return N(G, L), O(), U;
    }
    var N = function(H, Y) {
      c.call(U, H, D, Y), D.initialised = !0;
    }, O = uH(function() {
      D.initialised && (m.call(U, D, B), B = {});
    }, 1);
    return _.forEach(function(G) {
      U[G.name] = H(G);
      function H(Y) {
        var K = Y.name, X = Y.triggerUpdate, ee = X === void 0 ? !1 : X, oe = Y.onChange, fe = oe === void 0 ? function(Ce, Je) {
        } : oe, _e = Y.defaultVal, Te = _e === void 0 ? null : _e;
        return function(Ce) {
          var Je = D[K];
          if (!arguments.length)
            return Je;
          var Qe = Ce === void 0 ? Te : Ce;
          return D[K] = Qe, fe.call(U, Qe, D, Je), !B.hasOwnProperty(K) && (B[K] = Je), ee && O(), U;
        };
      }
    }), Object.keys(o).forEach(function(G) {
      U[G] = function() {
        for (var H, Y = arguments.length, K = new Array(Y), X = 0; X < Y; X++)
          K[X] = arguments[X];
        return (H = o[G]).call.apply(H, [U, D].concat(K));
      };
    }), Object.entries(l).forEach(function(G) {
      var H = pH(G, 2), Y = H[0], K = H[1];
      return U[Y] = U[K];
    }), U.resetProps = function() {
      return _.forEach(function(G) {
        U[G.name](G.defaultVal);
      }), U;
    }, U.resetProps(), D._rerender = O, E && R && U(R), U;
  };
}
var Ar = Object.freeze({
  Linear: Object.freeze({
    None: function(i) {
      return i;
    },
    In: function(i) {
      return i;
    },
    Out: function(i) {
      return i;
    },
    InOut: function(i) {
      return i;
    }
  }),
  Quadratic: Object.freeze({
    In: function(i) {
      return i * i;
    },
    Out: function(i) {
      return i * (2 - i);
    },
    InOut: function(i) {
      return (i *= 2) < 1 ? 0.5 * i * i : -0.5 * (--i * (i - 2) - 1);
    }
  }),
  Cubic: Object.freeze({
    In: function(i) {
      return i * i * i;
    },
    Out: function(i) {
      return --i * i * i + 1;
    },
    InOut: function(i) {
      return (i *= 2) < 1 ? 0.5 * i * i * i : 0.5 * ((i -= 2) * i * i + 2);
    }
  }),
  Quartic: Object.freeze({
    In: function(i) {
      return i * i * i * i;
    },
    Out: function(i) {
      return 1 - --i * i * i * i;
    },
    InOut: function(i) {
      return (i *= 2) < 1 ? 0.5 * i * i * i * i : -0.5 * ((i -= 2) * i * i * i - 2);
    }
  }),
  Quintic: Object.freeze({
    In: function(i) {
      return i * i * i * i * i;
    },
    Out: function(i) {
      return --i * i * i * i * i + 1;
    },
    InOut: function(i) {
      return (i *= 2) < 1 ? 0.5 * i * i * i * i * i : 0.5 * ((i -= 2) * i * i * i * i + 2);
    }
  }),
  Sinusoidal: Object.freeze({
    In: function(i) {
      return 1 - Math.sin((1 - i) * Math.PI / 2);
    },
    Out: function(i) {
      return Math.sin(i * Math.PI / 2);
    },
    InOut: function(i) {
      return 0.5 * (1 - Math.sin(Math.PI * (0.5 - i)));
    }
  }),
  Exponential: Object.freeze({
    In: function(i) {
      return i === 0 ? 0 : Math.pow(1024, i - 1);
    },
    Out: function(i) {
      return i === 1 ? 1 : 1 - Math.pow(2, -10 * i);
    },
    InOut: function(i) {
      return i === 0 ? 0 : i === 1 ? 1 : (i *= 2) < 1 ? 0.5 * Math.pow(1024, i - 1) : 0.5 * (-Math.pow(2, -10 * (i - 1)) + 2);
    }
  }),
  Circular: Object.freeze({
    In: function(i) {
      return 1 - Math.sqrt(1 - i * i);
    },
    Out: function(i) {
      return Math.sqrt(1 - --i * i);
    },
    InOut: function(i) {
      return (i *= 2) < 1 ? -0.5 * (Math.sqrt(1 - i * i) - 1) : 0.5 * (Math.sqrt(1 - (i -= 2) * i) + 1);
    }
  }),
  Elastic: Object.freeze({
    In: function(i) {
      return i === 0 ? 0 : i === 1 ? 1 : -Math.pow(2, 10 * (i - 1)) * Math.sin((i - 1.1) * 5 * Math.PI);
    },
    Out: function(i) {
      return i === 0 ? 0 : i === 1 ? 1 : Math.pow(2, -10 * i) * Math.sin((i - 0.1) * 5 * Math.PI) + 1;
    },
    InOut: function(i) {
      return i === 0 ? 0 : i === 1 ? 1 : (i *= 2, i < 1 ? -0.5 * Math.pow(2, 10 * (i - 1)) * Math.sin((i - 1.1) * 5 * Math.PI) : 0.5 * Math.pow(2, -10 * (i - 1)) * Math.sin((i - 1.1) * 5 * Math.PI) + 1);
    }
  }),
  Back: Object.freeze({
    In: function(i) {
      var e = 1.70158;
      return i === 1 ? 1 : i * i * ((e + 1) * i - e);
    },
    Out: function(i) {
      var e = 1.70158;
      return i === 0 ? 0 : --i * i * ((e + 1) * i + e) + 1;
    },
    InOut: function(i) {
      var e = 2.5949095;
      return (i *= 2) < 1 ? 0.5 * (i * i * ((e + 1) * i - e)) : 0.5 * ((i -= 2) * i * ((e + 1) * i + e) + 2);
    }
  }),
  Bounce: Object.freeze({
    In: function(i) {
      return 1 - Ar.Bounce.Out(1 - i);
    },
    Out: function(i) {
      return i < 1 / 2.75 ? 7.5625 * i * i : i < 2 / 2.75 ? 7.5625 * (i -= 1.5 / 2.75) * i + 0.75 : i < 2.5 / 2.75 ? 7.5625 * (i -= 2.25 / 2.75) * i + 0.9375 : 7.5625 * (i -= 2.625 / 2.75) * i + 0.984375;
    },
    InOut: function(i) {
      return i < 0.5 ? Ar.Bounce.In(i * 2) * 0.5 : Ar.Bounce.Out(i * 2 - 1) * 0.5 + 0.5;
    }
  }),
  generatePow: function(i) {
    return i === void 0 && (i = 4), i = i < Number.EPSILON ? Number.EPSILON : i, i = i > 1e4 ? 1e4 : i, {
      In: function(e) {
        return Math.pow(e, i);
      },
      Out: function(e) {
        return 1 - Math.pow(1 - e, i);
      },
      InOut: function(e) {
        return e < 0.5 ? Math.pow(e * 2, i) / 2 : (1 - Math.pow(2 - e * 2, i)) / 2 + 0.5;
      }
    };
  }
}), dp = function() {
  return performance.now();
}, b2 = (
  /** @class */
  (function() {
    function i() {
      for (var e = [], t = 0; t < arguments.length; t++)
        e[t] = arguments[t];
      this._tweens = {}, this._tweensAddedDuringUpdate = {}, this.add.apply(this, e);
    }
    return i.prototype.getAll = function() {
      var e = this;
      return Object.keys(this._tweens).map(function(t) {
        return e._tweens[t];
      });
    }, i.prototype.removeAll = function() {
      this._tweens = {};
    }, i.prototype.add = function() {
      for (var e, t = [], n = 0; n < arguments.length; n++)
        t[n] = arguments[n];
      for (var r = 0, s = t; r < s.length; r++) {
        var o = s[r];
        (e = o._group) === null || e === void 0 || e.remove(o), o._group = this, this._tweens[o.getId()] = o, this._tweensAddedDuringUpdate[o.getId()] = o;
      }
    }, i.prototype.remove = function() {
      for (var e = [], t = 0; t < arguments.length; t++)
        e[t] = arguments[t];
      for (var n = 0, r = e; n < r.length; n++) {
        var s = r[n];
        s._group = void 0, delete this._tweens[s.getId()], delete this._tweensAddedDuringUpdate[s.getId()];
      }
    }, i.prototype.allStopped = function() {
      return this.getAll().every(function(e) {
        return !e.isPlaying();
      });
    }, i.prototype.update = function(e, t) {
      e === void 0 && (e = dp()), t === void 0 && (t = !0);
      var n = Object.keys(this._tweens);
      if (n.length !== 0)
        for (; n.length > 0; ) {
          this._tweensAddedDuringUpdate = {};
          for (var r = 0; r < n.length; r++) {
            var s = this._tweens[n[r]], o = !t;
            s && s.update(e, o) === !1 && !t && this.remove(s);
          }
          n = Object.keys(this._tweensAddedDuringUpdate);
        }
    }, i;
  })()
), Yv = {
  Linear: function(i, e) {
    var t = i.length - 1, n = t * e, r = Math.floor(n), s = Yv.Utils.Linear;
    return e < 0 ? s(i[0], i[1], n) : e > 1 ? s(i[t], i[t - 1], t - n) : s(i[r], i[r + 1 > t ? t : r + 1], n - r);
  },
  Utils: {
    Linear: function(i, e, t) {
      return (e - i) * t + i;
    }
  }
}, L8 = (
  /** @class */
  (function() {
    function i() {
    }
    return i.nextId = function() {
      return i._nextId++;
    }, i._nextId = 0, i;
  })()
), Qv = new b2(), xs = (
  /** @class */
  (function() {
    function i(e, t) {
      this._isPaused = !1, this._pauseStart = 0, this._valuesStart = {}, this._valuesEnd = {}, this._valuesStartRepeat = {}, this._duration = 1e3, this._isDynamic = !1, this._initialRepeat = 0, this._repeat = 0, this._yoyo = !1, this._isPlaying = !1, this._reversed = !1, this._delayTime = 0, this._startTime = 0, this._easingFunction = Ar.Linear.None, this._interpolationFunction = Yv.Linear, this._chainedTweens = [], this._onStartCallbackFired = !1, this._onEveryStartCallbackFired = !1, this._id = L8.nextId(), this._isChainStopped = !1, this._propertiesAreSetUp = !1, this._goToEnd = !1, this._object = e, typeof t == "object" ? (this._group = t, t.add(this)) : t === !0 && (this._group = Qv, Qv.add(this));
    }
    return i.prototype.getId = function() {
      return this._id;
    }, i.prototype.isPlaying = function() {
      return this._isPlaying;
    }, i.prototype.isPaused = function() {
      return this._isPaused;
    }, i.prototype.getDuration = function() {
      return this._duration;
    }, i.prototype.to = function(e, t) {
      if (t === void 0 && (t = 1e3), this._isPlaying)
        throw new Error("Can not call Tween.to() while Tween is already started or paused. Stop the Tween first.");
      return this._valuesEnd = e, this._propertiesAreSetUp = !1, this._duration = t < 0 ? 0 : t, this;
    }, i.prototype.duration = function(e) {
      return e === void 0 && (e = 1e3), this._duration = e < 0 ? 0 : e, this;
    }, i.prototype.dynamic = function(e) {
      return e === void 0 && (e = !1), this._isDynamic = e, this;
    }, i.prototype.start = function(e, t) {
      if (e === void 0 && (e = dp()), t === void 0 && (t = !1), this._isPlaying)
        return this;
      if (this._repeat = this._initialRepeat, this._reversed) {
        this._reversed = !1;
        for (var n in this._valuesStartRepeat)
          this._swapEndStartRepeatValues(n), this._valuesStart[n] = this._valuesStartRepeat[n];
      }
      if (this._isPlaying = !0, this._isPaused = !1, this._onStartCallbackFired = !1, this._onEveryStartCallbackFired = !1, this._isChainStopped = !1, this._startTime = e, this._startTime += this._delayTime, !this._propertiesAreSetUp || t) {
        if (this._propertiesAreSetUp = !0, !this._isDynamic) {
          var r = {};
          for (var s in this._valuesEnd)
            r[s] = this._valuesEnd[s];
          this._valuesEnd = r;
        }
        this._setupProperties(this._object, this._valuesStart, this._valuesEnd, this._valuesStartRepeat, t);
      }
      return this;
    }, i.prototype.startFromCurrentValues = function(e) {
      return this.start(e, !0);
    }, i.prototype._setupProperties = function(e, t, n, r, s) {
      for (var o in n) {
        var a = e[o], l = Array.isArray(a), u = l ? "array" : typeof a, c = !l && Array.isArray(n[o]);
        if (!(u === "undefined" || u === "function")) {
          if (c) {
            var A = n[o];
            if (A.length === 0)
              continue;
            for (var m = [a], _ = 0, y = A.length; _ < y; _ += 1) {
              var T = this._handleRelativeValue(a, A[_]);
              if (isNaN(T)) {
                c = !1, console.warn("Found invalid interpolation list. Skipping.");
                break;
              }
              m.push(T);
            }
            c && (n[o] = m);
          }
          if ((u === "object" || l) && a && !c) {
            t[o] = l ? [] : {};
            var b = a;
            for (var S in b)
              t[o][S] = b[S];
            r[o] = l ? [] : {};
            var A = n[o];
            if (!this._isDynamic) {
              var E = {};
              for (var S in A)
                E[S] = A[S];
              n[o] = A = E;
            }
            this._setupProperties(b, t[o], A, r[o], s);
          } else
            (typeof t[o] > "u" || s) && (t[o] = a), l || (t[o] *= 1), c ? r[o] = n[o].slice().reverse() : r[o] = t[o] || 0;
        }
      }
    }, i.prototype.stop = function() {
      return this._isChainStopped || (this._isChainStopped = !0, this.stopChainedTweens()), this._isPlaying ? (this._isPlaying = !1, this._isPaused = !1, this._onStopCallback && this._onStopCallback(this._object), this) : this;
    }, i.prototype.end = function() {
      return this._goToEnd = !0, this.update(this._startTime + this._duration), this;
    }, i.prototype.pause = function(e) {
      return e === void 0 && (e = dp()), this._isPaused || !this._isPlaying ? this : (this._isPaused = !0, this._pauseStart = e, this);
    }, i.prototype.resume = function(e) {
      return e === void 0 && (e = dp()), !this._isPaused || !this._isPlaying ? this : (this._isPaused = !1, this._startTime += e - this._pauseStart, this._pauseStart = 0, this);
    }, i.prototype.stopChainedTweens = function() {
      for (var e = 0, t = this._chainedTweens.length; e < t; e++)
        this._chainedTweens[e].stop();
      return this;
    }, i.prototype.group = function(e) {
      return e ? (e.add(this), this) : (console.warn("tween.group() without args has been removed, use group.add(tween) instead."), this);
    }, i.prototype.remove = function() {
      var e;
      return (e = this._group) === null || e === void 0 || e.remove(this), this;
    }, i.prototype.delay = function(e) {
      return e === void 0 && (e = 0), this._delayTime = e, this;
    }, i.prototype.repeat = function(e) {
      return e === void 0 && (e = 0), this._initialRepeat = e, this._repeat = e, this;
    }, i.prototype.repeatDelay = function(e) {
      return this._repeatDelayTime = e, this;
    }, i.prototype.yoyo = function(e) {
      return e === void 0 && (e = !1), this._yoyo = e, this;
    }, i.prototype.easing = function(e) {
      return e === void 0 && (e = Ar.Linear.None), this._easingFunction = e, this;
    }, i.prototype.interpolation = function(e) {
      return e === void 0 && (e = Yv.Linear), this._interpolationFunction = e, this;
    }, i.prototype.chain = function() {
      for (var e = [], t = 0; t < arguments.length; t++)
        e[t] = arguments[t];
      return this._chainedTweens = e, this;
    }, i.prototype.onStart = function(e) {
      return this._onStartCallback = e, this;
    }, i.prototype.onEveryStart = function(e) {
      return this._onEveryStartCallback = e, this;
    }, i.prototype.onUpdate = function(e) {
      return this._onUpdateCallback = e, this;
    }, i.prototype.onRepeat = function(e) {
      return this._onRepeatCallback = e, this;
    }, i.prototype.onComplete = function(e) {
      return this._onCompleteCallback = e, this;
    }, i.prototype.onStop = function(e) {
      return this._onStopCallback = e, this;
    }, i.prototype.update = function(e, t) {
      var n = this, r;
      if (e === void 0 && (e = dp()), t === void 0 && (t = i.autoStartOnUpdate), this._isPaused)
        return !0;
      var s;
      if (!this._goToEnd && !this._isPlaying)
        if (t)
          this.start(e, !0);
        else
          return !1;
      if (this._goToEnd = !1, e < this._startTime)
        return !0;
      this._onStartCallbackFired === !1 && (this._onStartCallback && this._onStartCallback(this._object), this._onStartCallbackFired = !0), this._onEveryStartCallbackFired === !1 && (this._onEveryStartCallback && this._onEveryStartCallback(this._object), this._onEveryStartCallbackFired = !0);
      var o = e - this._startTime, a = this._duration + ((r = this._repeatDelayTime) !== null && r !== void 0 ? r : this._delayTime), l = this._duration + this._repeat * a, u = function() {
        if (n._duration === 0 || o > l)
          return 1;
        var T = Math.trunc(o / a), b = o - T * a, S = Math.min(b / n._duration, 1);
        return S === 0 && o === n._duration ? 1 : S;
      }, c = u(), A = this._easingFunction(c);
      if (this._updateProperties(this._object, this._valuesStart, this._valuesEnd, A), this._onUpdateCallback && this._onUpdateCallback(this._object, c), this._duration === 0 || o >= this._duration)
        if (this._repeat > 0) {
          var m = Math.min(Math.trunc((o - this._duration) / a) + 1, this._repeat);
          isFinite(this._repeat) && (this._repeat -= m);
          for (s in this._valuesStartRepeat)
            !this._yoyo && typeof this._valuesEnd[s] == "string" && (this._valuesStartRepeat[s] = // eslint-disable-next-line
            // @ts-ignore FIXME?
            this._valuesStartRepeat[s] + parseFloat(this._valuesEnd[s])), this._yoyo && this._swapEndStartRepeatValues(s), this._valuesStart[s] = this._valuesStartRepeat[s];
          return this._yoyo && (this._reversed = !this._reversed), this._startTime += a * m, this._onRepeatCallback && this._onRepeatCallback(this._object), this._onEveryStartCallbackFired = !1, !0;
        } else {
          this._onCompleteCallback && this._onCompleteCallback(this._object);
          for (var _ = 0, y = this._chainedTweens.length; _ < y; _++)
            this._chainedTweens[_].start(this._startTime + this._duration, !1);
          return this._isPlaying = !1, !1;
        }
      return !0;
    }, i.prototype._updateProperties = function(e, t, n, r) {
      for (var s in n)
        if (t[s] !== void 0) {
          var o = t[s] || 0, a = n[s], l = Array.isArray(e[s]), u = Array.isArray(a), c = !l && u;
          c ? e[s] = this._interpolationFunction(a, r) : typeof a == "object" && a ? this._updateProperties(e[s], o, a, r) : (a = this._handleRelativeValue(o, a), typeof a == "number" && (e[s] = o + (a - o) * r));
        }
    }, i.prototype._handleRelativeValue = function(e, t) {
      return typeof t != "string" ? t : t.charAt(0) === "+" || t.charAt(0) === "-" ? e + parseFloat(t) : parseFloat(t);
    }, i.prototype._swapEndStartRepeatValues = function(e) {
      var t = this._valuesStartRepeat[e], n = this._valuesEnd[e];
      typeof n == "string" ? this._valuesStartRepeat[e] = this._valuesStartRepeat[e] + parseFloat(n) : this._valuesStartRepeat[e] = this._valuesEnd[e], this._valuesEnd[e] = t;
    }, i.autoStartOnUpdate = !1, i;
  })()
);
L8.nextId;
var rl = Qv;
rl.getAll.bind(rl);
rl.removeAll.bind(rl);
rl.add.bind(rl);
rl.remove.bind(rl);
rl.update.bind(rl);
function _H(i) {
  const e = +this._x.call(null, i), t = +this._y.call(null, i), n = +this._z.call(null, i);
  return I8(this.cover(e, t, n), e, t, n, i);
}
function I8(i, e, t, n, r) {
  if (isNaN(e) || isNaN(t) || isNaN(n)) return i;
  var s, o = i._root, a = { data: r }, l = i._x0, u = i._y0, c = i._z0, A = i._x1, m = i._y1, _ = i._z1, y, T, b, S, E, R, C, L, D, B, U;
  if (!o) return i._root = a, i;
  for (; o.length; )
    if ((C = e >= (y = (l + A) / 2)) ? l = y : A = y, (L = t >= (T = (u + m) / 2)) ? u = T : m = T, (D = n >= (b = (c + _) / 2)) ? c = b : _ = b, s = o, !(o = o[B = D << 2 | L << 1 | C])) return s[B] = a, i;
  if (S = +i._x.call(null, o.data), E = +i._y.call(null, o.data), R = +i._z.call(null, o.data), e === S && t === E && n === R) return a.next = o, s ? s[B] = a : i._root = a, i;
  do
    s = s ? s[B] = new Array(8) : i._root = new Array(8), (C = e >= (y = (l + A) / 2)) ? l = y : A = y, (L = t >= (T = (u + m) / 2)) ? u = T : m = T, (D = n >= (b = (c + _) / 2)) ? c = b : _ = b;
  while ((B = D << 2 | L << 1 | C) === (U = (R >= b) << 2 | (E >= T) << 1 | S >= y));
  return s[U] = o, s[B] = a, i;
}
function xH(i) {
  Array.isArray(i) || (i = Array.from(i));
  const e = i.length, t = new Float64Array(e), n = new Float64Array(e), r = new Float64Array(e);
  let s = 1 / 0, o = 1 / 0, a = 1 / 0, l = -1 / 0, u = -1 / 0, c = -1 / 0;
  for (let A = 0, m, _, y, T; A < e; ++A)
    isNaN(_ = +this._x.call(null, m = i[A])) || isNaN(y = +this._y.call(null, m)) || isNaN(T = +this._z.call(null, m)) || (t[A] = _, n[A] = y, r[A] = T, _ < s && (s = _), _ > l && (l = _), y < o && (o = y), y > u && (u = y), T < a && (a = T), T > c && (c = T));
  if (s > l || o > u || a > c) return this;
  this.cover(s, o, a).cover(l, u, c);
  for (let A = 0; A < e; ++A)
    I8(this, t[A], n[A], r[A], i[A]);
  return this;
}
function yH(i, e, t) {
  if (isNaN(i = +i) || isNaN(e = +e) || isNaN(t = +t)) return this;
  var n = this._x0, r = this._y0, s = this._z0, o = this._x1, a = this._y1, l = this._z1;
  if (isNaN(n))
    o = (n = Math.floor(i)) + 1, a = (r = Math.floor(e)) + 1, l = (s = Math.floor(t)) + 1;
  else {
    for (var u = o - n || 1, c = this._root, A, m; n > i || i >= o || r > e || e >= a || s > t || t >= l; )
      switch (m = (t < s) << 2 | (e < r) << 1 | i < n, A = new Array(8), A[m] = c, c = A, u *= 2, m) {
        case 0:
          o = n + u, a = r + u, l = s + u;
          break;
        case 1:
          n = o - u, a = r + u, l = s + u;
          break;
        case 2:
          o = n + u, r = a - u, l = s + u;
          break;
        case 3:
          n = o - u, r = a - u, l = s + u;
          break;
        case 4:
          o = n + u, a = r + u, s = l - u;
          break;
        case 5:
          n = o - u, a = r + u, s = l - u;
          break;
        case 6:
          o = n + u, r = a - u, s = l - u;
          break;
        case 7:
          n = o - u, r = a - u, s = l - u;
          break;
      }
    this._root && this._root.length && (this._root = c);
  }
  return this._x0 = n, this._y0 = r, this._z0 = s, this._x1 = o, this._y1 = a, this._z1 = l, this;
}
function vH() {
  var i = [];
  return this.visit(function(e) {
    if (!e.length) do
      i.push(e.data);
    while (e = e.next);
  }), i;
}
function bH(i) {
  return arguments.length ? this.cover(+i[0][0], +i[0][1], +i[0][2]).cover(+i[1][0], +i[1][1], +i[1][2]) : isNaN(this._x0) ? void 0 : [[this._x0, this._y0, this._z0], [this._x1, this._y1, this._z1]];
}
function wi(i, e, t, n, r, s, o) {
  this.node = i, this.x0 = e, this.y0 = t, this.z0 = n, this.x1 = r, this.y1 = s, this.z1 = o;
}
function SH(i, e, t, n) {
  var r, s = this._x0, o = this._y0, a = this._z0, l, u, c, A, m, _, y = this._x1, T = this._y1, b = this._z1, S = [], E = this._root, R, C;
  for (E && S.push(new wi(E, s, o, a, y, T, b)), n == null ? n = 1 / 0 : (s = i - n, o = e - n, a = t - n, y = i + n, T = e + n, b = t + n, n *= n); R = S.pop(); )
    if (!(!(E = R.node) || (l = R.x0) > y || (u = R.y0) > T || (c = R.z0) > b || (A = R.x1) < s || (m = R.y1) < o || (_ = R.z1) < a))
      if (E.length) {
        var L = (l + A) / 2, D = (u + m) / 2, B = (c + _) / 2;
        S.push(
          new wi(E[7], L, D, B, A, m, _),
          new wi(E[6], l, D, B, L, m, _),
          new wi(E[5], L, u, B, A, D, _),
          new wi(E[4], l, u, B, L, D, _),
          new wi(E[3], L, D, c, A, m, B),
          new wi(E[2], l, D, c, L, m, B),
          new wi(E[1], L, u, c, A, D, B),
          new wi(E[0], l, u, c, L, D, B)
        ), (C = (t >= B) << 2 | (e >= D) << 1 | i >= L) && (R = S[S.length - 1], S[S.length - 1] = S[S.length - 1 - C], S[S.length - 1 - C] = R);
      } else {
        var U = i - +this._x.call(null, E.data), N = e - +this._y.call(null, E.data), O = t - +this._z.call(null, E.data), G = U * U + N * N + O * O;
        if (G < n) {
          var H = Math.sqrt(n = G);
          s = i - H, o = e - H, a = t - H, y = i + H, T = e + H, b = t + H, r = E.data;
        }
      }
  return r;
}
const TH = (i, e, t, n, r, s) => Math.sqrt((i - n) ** 2 + (e - r) ** 2 + (t - s) ** 2);
function wH(i, e, t, n) {
  const r = [], s = i - n, o = e - n, a = t - n, l = i + n, u = e + n, c = t + n;
  return this.visit((A, m, _, y, T, b, S) => {
    if (!A.length)
      do {
        const E = A.data;
        TH(i, e, t, this._x(E), this._y(E), this._z(E)) <= n && r.push(E);
      } while (A = A.next);
    return m > l || _ > u || y > c || T < s || b < o || S < a;
  }), r;
}
function MH(i) {
  if (isNaN(m = +this._x.call(null, i)) || isNaN(_ = +this._y.call(null, i)) || isNaN(y = +this._z.call(null, i))) return this;
  var e, t = this._root, n, r, s, o = this._x0, a = this._y0, l = this._z0, u = this._x1, c = this._y1, A = this._z1, m, _, y, T, b, S, E, R, C, L, D;
  if (!t) return this;
  if (t.length) for (; ; ) {
    if ((E = m >= (T = (o + u) / 2)) ? o = T : u = T, (R = _ >= (b = (a + c) / 2)) ? a = b : c = b, (C = y >= (S = (l + A) / 2)) ? l = S : A = S, e = t, !(t = t[L = C << 2 | R << 1 | E])) return this;
    if (!t.length) break;
    (e[L + 1 & 7] || e[L + 2 & 7] || e[L + 3 & 7] || e[L + 4 & 7] || e[L + 5 & 7] || e[L + 6 & 7] || e[L + 7 & 7]) && (n = e, D = L);
  }
  for (; t.data !== i; ) if (r = t, !(t = t.next)) return this;
  return (s = t.next) && delete t.next, r ? (s ? r.next = s : delete r.next, this) : e ? (s ? e[L] = s : delete e[L], (t = e[0] || e[1] || e[2] || e[3] || e[4] || e[5] || e[6] || e[7]) && t === (e[7] || e[6] || e[5] || e[4] || e[3] || e[2] || e[1] || e[0]) && !t.length && (n ? n[D] = t : this._root = t), this) : (this._root = s, this);
}
function EH(i) {
  for (var e = 0, t = i.length; e < t; ++e) this.remove(i[e]);
  return this;
}
function RH() {
  return this._root;
}
function CH() {
  var i = 0;
  return this.visit(function(e) {
    if (!e.length) do
      ++i;
    while (e = e.next);
  }), i;
}
function PH(i) {
  var e = [], t, n = this._root, r, s, o, a, l, u, c;
  for (n && e.push(new wi(n, this._x0, this._y0, this._z0, this._x1, this._y1, this._z1)); t = e.pop(); )
    if (!i(n = t.node, s = t.x0, o = t.y0, a = t.z0, l = t.x1, u = t.y1, c = t.z1) && n.length) {
      var A = (s + l) / 2, m = (o + u) / 2, _ = (a + c) / 2;
      (r = n[7]) && e.push(new wi(r, A, m, _, l, u, c)), (r = n[6]) && e.push(new wi(r, s, m, _, A, u, c)), (r = n[5]) && e.push(new wi(r, A, o, _, l, m, c)), (r = n[4]) && e.push(new wi(r, s, o, _, A, m, c)), (r = n[3]) && e.push(new wi(r, A, m, a, l, u, _)), (r = n[2]) && e.push(new wi(r, s, m, a, A, u, _)), (r = n[1]) && e.push(new wi(r, A, o, a, l, m, _)), (r = n[0]) && e.push(new wi(r, s, o, a, A, m, _));
    }
  return this;
}
function NH(i) {
  var e = [], t = [], n;
  for (this._root && e.push(new wi(this._root, this._x0, this._y0, this._z0, this._x1, this._y1, this._z1)); n = e.pop(); ) {
    var r = n.node;
    if (r.length) {
      var s, o = n.x0, a = n.y0, l = n.z0, u = n.x1, c = n.y1, A = n.z1, m = (o + u) / 2, _ = (a + c) / 2, y = (l + A) / 2;
      (s = r[0]) && e.push(new wi(s, o, a, l, m, _, y)), (s = r[1]) && e.push(new wi(s, m, a, l, u, _, y)), (s = r[2]) && e.push(new wi(s, o, _, l, m, c, y)), (s = r[3]) && e.push(new wi(s, m, _, l, u, c, y)), (s = r[4]) && e.push(new wi(s, o, a, y, m, _, A)), (s = r[5]) && e.push(new wi(s, m, a, y, u, _, A)), (s = r[6]) && e.push(new wi(s, o, _, y, m, c, A)), (s = r[7]) && e.push(new wi(s, m, _, y, u, c, A));
    }
    t.push(n);
  }
  for (; n = t.pop(); )
    i(n.node, n.x0, n.y0, n.z0, n.x1, n.y1, n.z1);
  return this;
}
function DH(i) {
  return i[0];
}
function LH(i) {
  return arguments.length ? (this._x = i, this) : this._x;
}
function IH(i) {
  return i[1];
}
function BH(i) {
  return arguments.length ? (this._y = i, this) : this._y;
}
function FH(i) {
  return i[2];
}
function UH(i) {
  return arguments.length ? (this._z = i, this) : this._z;
}
function B8(i, e, t, n) {
  var r = new pS(e ?? DH, t ?? IH, n ?? FH, NaN, NaN, NaN, NaN, NaN, NaN);
  return i == null ? r : r.addAll(i);
}
function pS(i, e, t, n, r, s, o, a, l) {
  this._x = i, this._y = e, this._z = t, this._x0 = n, this._y0 = r, this._z0 = s, this._x1 = o, this._y1 = a, this._z1 = l, this._root = void 0;
}
function XE(i) {
  for (var e = { data: i.data }, t = e; i = i.next; ) t = t.next = { data: i.data };
  return e;
}
var Zr = B8.prototype = pS.prototype;
Zr.copy = function() {
  var i = new pS(this._x, this._y, this._z, this._x0, this._y0, this._z0, this._x1, this._y1, this._z1), e = this._root, t, n;
  if (!e) return i;
  if (!e.length) return i._root = XE(e), i;
  for (t = [{ source: e, target: i._root = new Array(8) }]; e = t.pop(); )
    for (var r = 0; r < 8; ++r)
      (n = e.source[r]) && (n.length ? t.push({ source: n, target: e.target[r] = new Array(8) }) : e.target[r] = XE(n));
  return i;
};
Zr.add = _H;
Zr.addAll = xH;
Zr.cover = yH;
Zr.data = vH;
Zr.extent = bH;
Zr.find = SH;
Zr.findAllWithinRadius = wH;
Zr.remove = MH;
Zr.removeAll = EH;
Zr.root = RH;
Zr.size = CH;
Zr.visit = PH;
Zr.visitAfter = NH;
Zr.x = LH;
Zr.y = BH;
Zr.z = UH;
function Xg(i, e) {
  return i == null || e == null ? NaN : i < e ? -1 : i > e ? 1 : i >= e ? 0 : NaN;
}
function OH(i, e) {
  return i == null || e == null ? NaN : e < i ? -1 : e > i ? 1 : e >= i ? 0 : NaN;
}
function F8(i) {
  let e, t, n;
  i.length !== 2 ? (e = Xg, t = (a, l) => Xg(i(a), l), n = (a, l) => i(a) - l) : (e = i === Xg || i === OH ? i : kH, t = i, n = i);
  function r(a, l, u = 0, c = a.length) {
    if (u < c) {
      if (e(l, l) !== 0) return c;
      do {
        const A = u + c >>> 1;
        t(a[A], l) < 0 ? u = A + 1 : c = A;
      } while (u < c);
    }
    return u;
  }
  function s(a, l, u = 0, c = a.length) {
    if (u < c) {
      if (e(l, l) !== 0) return c;
      do {
        const A = u + c >>> 1;
        t(a[A], l) <= 0 ? u = A + 1 : c = A;
      } while (u < c);
    }
    return u;
  }
  function o(a, l, u = 0, c = a.length) {
    const A = r(a, l, u, c - 1);
    return A > u && n(a[A - 1], l) > -n(a[A], l) ? A - 1 : A;
  }
  return { left: r, center: o, right: s };
}
function kH() {
  return 0;
}
function VH(i) {
  return i === null ? NaN : +i;
}
const GH = F8(Xg), U8 = GH.right;
F8(VH).center;
function b1(i, e) {
  let t, n;
  if (e === void 0)
    for (const r of i)
      r != null && (t === void 0 ? r >= r && (t = n = r) : (t > r && (t = r), n < r && (n = r)));
  else {
    let r = -1;
    for (let s of i)
      (s = e(s, ++r, i)) != null && (t === void 0 ? s >= s && (t = n = s) : (t > s && (t = s), n < s && (n = s)));
  }
  return [t, n];
}
class Ll {
  constructor() {
    this._partials = new Float64Array(32), this._n = 0;
  }
  add(e) {
    const t = this._partials;
    let n = 0;
    for (let r = 0; r < this._n && r < 32; r++) {
      const s = t[r], o = e + s, a = Math.abs(e) < Math.abs(s) ? e - (o - s) : s - (o - e);
      a && (t[n++] = a), e = o;
    }
    return t[n] = e, this._n = n + 1, this;
  }
  valueOf() {
    const e = this._partials;
    let t = this._n, n, r, s, o = 0;
    if (t > 0) {
      for (o = e[--t]; t > 0 && (n = o, r = e[--t], o = n + r, s = r - (o - n), !s); )
        ;
      t > 0 && (s < 0 && e[t - 1] < 0 || s > 0 && e[t - 1] > 0) && (r = s * 2, n = o + r, r == n - o && (o = n));
    }
    return o;
  }
}
const zH = Math.sqrt(50), qH = Math.sqrt(10), HH = Math.sqrt(2);
function S1(i, e, t) {
  const n = (e - i) / Math.max(0, t), r = Math.floor(Math.log10(n)), s = n / Math.pow(10, r), o = s >= zH ? 10 : s >= qH ? 5 : s >= HH ? 2 : 1;
  let a, l, u;
  return r < 0 ? (u = Math.pow(10, -r) / o, a = Math.round(i * u), l = Math.round(e * u), a / u < i && ++a, l / u > e && --l, u = -u) : (u = Math.pow(10, r) * o, a = Math.round(i / u), l = Math.round(e / u), a * u < i && ++a, l * u > e && --l), l < a && 0.5 <= t && t < 2 ? S1(i, e, t * 2) : [a, l, u];
}
function WH(i, e, t) {
  if (e = +e, i = +i, t = +t, !(t > 0)) return [];
  if (i === e) return [i];
  const n = e < i, [r, s, o] = n ? S1(e, i, t) : S1(i, e, t);
  if (!(s >= r)) return [];
  const a = s - r + 1, l = new Array(a);
  if (n)
    if (o < 0) for (let u = 0; u < a; ++u) l[u] = (s - u) / -o;
    else for (let u = 0; u < a; ++u) l[u] = (s - u) * o;
  else if (o < 0) for (let u = 0; u < a; ++u) l[u] = (r + u) / -o;
  else for (let u = 0; u < a; ++u) l[u] = (r + u) * o;
  return l;
}
function Kv(i, e, t) {
  return e = +e, i = +i, t = +t, S1(i, e, t)[2];
}
function $H(i, e, t) {
  e = +e, i = +i, t = +t;
  const n = e < i, r = n ? Kv(e, i, t) : Kv(i, e, t);
  return (n ? -1 : 1) * (r < 0 ? 1 / -r : r);
}
function jH(i, e) {
  let t;
  for (const n of i)
    n != null && (t < n || t === void 0 && n >= n) && (t = n);
  return t;
}
function XH(i, e) {
  let t = 0, n = 0;
  if (e === void 0)
    for (let r of i)
      r != null && (r = +r) >= r && (++t, n += r);
  else {
    let r = -1;
    for (let s of i)
      (s = e(s, ++r, i)) != null && (s = +s) >= s && (++t, n += s);
  }
  if (t) return n / t;
}
function* YH(i) {
  for (const e of i)
    yield* e;
}
function jp(i) {
  return Array.from(YH(i));
}
function lf(i, e, t) {
  i = +i, e = +e, t = (r = arguments.length) < 2 ? (e = i, i = 0, 1) : r < 3 ? 1 : +t;
  for (var n = -1, r = Math.max(0, Math.ceil((e - i) / t)) | 0, s = new Array(r); ++n < r; )
    s[n] = i + n * t;
  return s;
}
function QH(i, e) {
  let t = 0;
  for (let n of i)
    (n = +n) && (t += n);
  return t;
}
function O8(i, e) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(i);
      break;
    default:
      this.range(e).domain(i);
      break;
  }
  return this;
}
function mS(i, e, t) {
  i.prototype = e.prototype = t, t.constructor = i;
}
function k8(i, e) {
  var t = Object.create(i.prototype);
  for (var n in e) t[n] = e[n];
  return t;
}
function L0() {
}
var Xp = 0.7, T1 = 1 / Xp, mf = "\\s*([+-]?\\d+)\\s*", Yp = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", Qa = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", KH = /^#([0-9a-f]{3,8})$/, ZH = new RegExp(`^rgb\\(${mf},${mf},${mf}\\)$`), JH = new RegExp(`^rgb\\(${Qa},${Qa},${Qa}\\)$`), eW = new RegExp(`^rgba\\(${mf},${mf},${mf},${Yp}\\)$`), tW = new RegExp(`^rgba\\(${Qa},${Qa},${Qa},${Yp}\\)$`), nW = new RegExp(`^hsl\\(${Yp},${Qa},${Qa}\\)$`), iW = new RegExp(`^hsla\\(${Yp},${Qa},${Qa},${Yp}\\)$`), YE = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
mS(L0, Hh, {
  copy(i) {
    return Object.assign(new this.constructor(), this, i);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: QE,
  // Deprecated! Use color.formatHex.
  formatHex: QE,
  formatHex8: rW,
  formatHsl: sW,
  formatRgb: KE,
  toString: KE
});
function QE() {
  return this.rgb().formatHex();
}
function rW() {
  return this.rgb().formatHex8();
}
function sW() {
  return V8(this).formatHsl();
}
function KE() {
  return this.rgb().formatRgb();
}
function Hh(i) {
  var e, t;
  return i = (i + "").trim().toLowerCase(), (e = KH.exec(i)) ? (t = e[1].length, e = parseInt(e[1], 16), t === 6 ? ZE(e) : t === 3 ? new js(e >> 8 & 15 | e >> 4 & 240, e >> 4 & 15 | e & 240, (e & 15) << 4 | e & 15, 1) : t === 8 ? Xm(e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, (e & 255) / 255) : t === 4 ? Xm(e >> 12 & 15 | e >> 8 & 240, e >> 8 & 15 | e >> 4 & 240, e >> 4 & 15 | e & 240, ((e & 15) << 4 | e & 15) / 255) : null) : (e = ZH.exec(i)) ? new js(e[1], e[2], e[3], 1) : (e = JH.exec(i)) ? new js(e[1] * 255 / 100, e[2] * 255 / 100, e[3] * 255 / 100, 1) : (e = eW.exec(i)) ? Xm(e[1], e[2], e[3], e[4]) : (e = tW.exec(i)) ? Xm(e[1] * 255 / 100, e[2] * 255 / 100, e[3] * 255 / 100, e[4]) : (e = nW.exec(i)) ? t4(e[1], e[2] / 100, e[3] / 100, 1) : (e = iW.exec(i)) ? t4(e[1], e[2] / 100, e[3] / 100, e[4]) : YE.hasOwnProperty(i) ? ZE(YE[i]) : i === "transparent" ? new js(NaN, NaN, NaN, 0) : null;
}
function ZE(i) {
  return new js(i >> 16 & 255, i >> 8 & 255, i & 255, 1);
}
function Xm(i, e, t, n) {
  return n <= 0 && (i = e = t = NaN), new js(i, e, t, n);
}
function oW(i) {
  return i instanceof L0 || (i = Hh(i)), i ? (i = i.rgb(), new js(i.r, i.g, i.b, i.opacity)) : new js();
}
function Zv(i, e, t, n) {
  return arguments.length === 1 ? oW(i) : new js(i, e, t, n ?? 1);
}
function js(i, e, t, n) {
  this.r = +i, this.g = +e, this.b = +t, this.opacity = +n;
}
mS(js, Zv, k8(L0, {
  brighter(i) {
    return i = i == null ? T1 : Math.pow(T1, i), new js(this.r * i, this.g * i, this.b * i, this.opacity);
  },
  darker(i) {
    return i = i == null ? Xp : Math.pow(Xp, i), new js(this.r * i, this.g * i, this.b * i, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new js(uh(this.r), uh(this.g), uh(this.b), w1(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
  },
  hex: JE,
  // Deprecated! Use color.formatHex.
  formatHex: JE,
  formatHex8: aW,
  formatRgb: e4,
  toString: e4
}));
function JE() {
  return `#${eh(this.r)}${eh(this.g)}${eh(this.b)}`;
}
function aW() {
  return `#${eh(this.r)}${eh(this.g)}${eh(this.b)}${eh((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function e4() {
  const i = w1(this.opacity);
  return `${i === 1 ? "rgb(" : "rgba("}${uh(this.r)}, ${uh(this.g)}, ${uh(this.b)}${i === 1 ? ")" : `, ${i})`}`;
}
function w1(i) {
  return isNaN(i) ? 1 : Math.max(0, Math.min(1, i));
}
function uh(i) {
  return Math.max(0, Math.min(255, Math.round(i) || 0));
}
function eh(i) {
  return i = uh(i), (i < 16 ? "0" : "") + i.toString(16);
}
function t4(i, e, t, n) {
  return n <= 0 ? i = e = t = NaN : t <= 0 || t >= 1 ? i = e = NaN : e <= 0 && (i = NaN), new da(i, e, t, n);
}
function V8(i) {
  if (i instanceof da) return new da(i.h, i.s, i.l, i.opacity);
  if (i instanceof L0 || (i = Hh(i)), !i) return new da();
  if (i instanceof da) return i;
  i = i.rgb();
  var e = i.r / 255, t = i.g / 255, n = i.b / 255, r = Math.min(e, t, n), s = Math.max(e, t, n), o = NaN, a = s - r, l = (s + r) / 2;
  return a ? (e === s ? o = (t - n) / a + (t < n) * 6 : t === s ? o = (n - e) / a + 2 : o = (e - t) / a + 4, a /= l < 0.5 ? s + r : 2 - s - r, o *= 60) : a = l > 0 && l < 1 ? 0 : o, new da(o, a, l, i.opacity);
}
function lW(i, e, t, n) {
  return arguments.length === 1 ? V8(i) : new da(i, e, t, n ?? 1);
}
function da(i, e, t, n) {
  this.h = +i, this.s = +e, this.l = +t, this.opacity = +n;
}
mS(da, lW, k8(L0, {
  brighter(i) {
    return i = i == null ? T1 : Math.pow(T1, i), new da(this.h, this.s, this.l * i, this.opacity);
  },
  darker(i) {
    return i = i == null ? Xp : Math.pow(Xp, i), new da(this.h, this.s, this.l * i, this.opacity);
  },
  rgb() {
    var i = this.h % 360 + (this.h < 0) * 360, e = isNaN(i) || isNaN(this.s) ? 0 : this.s, t = this.l, n = t + (t < 0.5 ? t : 1 - t) * e, r = 2 * t - n;
    return new js(
      Py(i >= 240 ? i - 240 : i + 120, r, n),
      Py(i, r, n),
      Py(i < 120 ? i + 240 : i - 120, r, n),
      this.opacity
    );
  },
  clamp() {
    return new da(n4(this.h), Ym(this.s), Ym(this.l), w1(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
  },
  formatHsl() {
    const i = w1(this.opacity);
    return `${i === 1 ? "hsl(" : "hsla("}${n4(this.h)}, ${Ym(this.s) * 100}%, ${Ym(this.l) * 100}%${i === 1 ? ")" : `, ${i})`}`;
  }
}));
function n4(i) {
  return i = (i || 0) % 360, i < 0 ? i + 360 : i;
}
function Ym(i) {
  return Math.max(0, Math.min(1, i || 0));
}
function Py(i, e, t) {
  return (i < 60 ? e + (t - e) * i / 60 : i < 180 ? t : i < 240 ? e + (t - e) * (240 - i) / 60 : e) * 255;
}
const gS = (i) => () => i;
function uW(i, e) {
  return function(t) {
    return i + t * e;
  };
}
function cW(i, e, t) {
  return i = Math.pow(i, t), e = Math.pow(e, t) - i, t = 1 / t, function(n) {
    return Math.pow(i + n * e, t);
  };
}
function hW(i) {
  return (i = +i) == 1 ? G8 : function(e, t) {
    return t - e ? cW(e, t, i) : gS(isNaN(e) ? t : e);
  };
}
function G8(i, e) {
  var t = e - i;
  return t ? uW(i, t) : gS(isNaN(i) ? e : i);
}
const i4 = (function i(e) {
  var t = hW(e);
  function n(r, s) {
    var o = t((r = Zv(r)).r, (s = Zv(s)).r), a = t(r.g, s.g), l = t(r.b, s.b), u = G8(r.opacity, s.opacity);
    return function(c) {
      return r.r = o(c), r.g = a(c), r.b = l(c), r.opacity = u(c), r + "";
    };
  }
  return n.gamma = i, n;
})(1);
function z8(i, e) {
  e || (e = []);
  var t = i ? Math.min(e.length, i.length) : 0, n = e.slice(), r;
  return function(s) {
    for (r = 0; r < t; ++r) n[r] = i[r] * (1 - s) + e[r] * s;
    return n;
  };
}
function q8(i) {
  return ArrayBuffer.isView(i) && !(i instanceof DataView);
}
function dW(i, e) {
  return (q8(e) ? z8 : H8)(i, e);
}
function H8(i, e) {
  var t = e ? e.length : 0, n = i ? Math.min(t, i.length) : 0, r = new Array(n), s = new Array(t), o;
  for (o = 0; o < n; ++o) r[o] = _S(i[o], e[o]);
  for (; o < t; ++o) s[o] = e[o];
  return function(a) {
    for (o = 0; o < n; ++o) s[o] = r[o](a);
    return s;
  };
}
function fW(i, e) {
  var t = /* @__PURE__ */ new Date();
  return i = +i, e = +e, function(n) {
    return t.setTime(i * (1 - n) + e * n), t;
  };
}
function Qp(i, e) {
  return i = +i, e = +e, function(t) {
    return i * (1 - t) + e * t;
  };
}
function AW(i, e) {
  var t = {}, n = {}, r;
  (i === null || typeof i != "object") && (i = {}), (e === null || typeof e != "object") && (e = {});
  for (r in e)
    r in i ? t[r] = _S(i[r], e[r]) : n[r] = e[r];
  return function(s) {
    for (r in t) n[r] = t[r](s);
    return n;
  };
}
var Jv = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, Ny = new RegExp(Jv.source, "g");
function pW(i) {
  return function() {
    return i;
  };
}
function mW(i) {
  return function(e) {
    return i(e) + "";
  };
}
function gW(i, e) {
  var t = Jv.lastIndex = Ny.lastIndex = 0, n, r, s, o = -1, a = [], l = [];
  for (i = i + "", e = e + ""; (n = Jv.exec(i)) && (r = Ny.exec(e)); )
    (s = r.index) > t && (s = e.slice(t, s), a[o] ? a[o] += s : a[++o] = s), (n = n[0]) === (r = r[0]) ? a[o] ? a[o] += r : a[++o] = r : (a[++o] = null, l.push({ i: o, x: Qp(n, r) })), t = Ny.lastIndex;
  return t < e.length && (s = e.slice(t), a[o] ? a[o] += s : a[++o] = s), a.length < 2 ? l[0] ? mW(l[0].x) : pW(e) : (e = l.length, function(u) {
    for (var c = 0, A; c < e; ++c) a[(A = l[c]).i] = A.x(u);
    return a.join("");
  });
}
function _S(i, e) {
  var t = typeof e, n;
  return e == null || t === "boolean" ? gS(e) : (t === "number" ? Qp : t === "string" ? (n = Hh(e)) ? (e = n, i4) : gW : e instanceof Hh ? i4 : e instanceof Date ? fW : q8(e) ? z8 : Array.isArray(e) ? H8 : typeof e.valueOf != "function" && typeof e.toString != "function" || isNaN(e) ? AW : Qp)(i, e);
}
function _W(i, e) {
  return i = +i, e = +e, function(t) {
    return Math.round(i * (1 - t) + e * t);
  };
}
function xW(i) {
  return function() {
    return i;
  };
}
function yW(i) {
  return +i;
}
var r4 = [0, 1];
function uf(i) {
  return i;
}
function eb(i, e) {
  return (e -= i = +i) ? function(t) {
    return (t - i) / e;
  } : xW(isNaN(e) ? NaN : 0.5);
}
function vW(i, e) {
  var t;
  return i > e && (t = i, i = e, e = t), function(n) {
    return Math.max(i, Math.min(e, n));
  };
}
function bW(i, e, t) {
  var n = i[0], r = i[1], s = e[0], o = e[1];
  return r < n ? (n = eb(r, n), s = t(o, s)) : (n = eb(n, r), s = t(s, o)), function(a) {
    return s(n(a));
  };
}
function SW(i, e, t) {
  var n = Math.min(i.length, e.length) - 1, r = new Array(n), s = new Array(n), o = -1;
  for (i[n] < i[0] && (i = i.slice().reverse(), e = e.slice().reverse()); ++o < n; )
    r[o] = eb(i[o], i[o + 1]), s[o] = t(e[o], e[o + 1]);
  return function(a) {
    var l = U8(i, a, 1, n) - 1;
    return s[l](r[l](a));
  };
}
function TW(i, e) {
  return e.domain(i.domain()).range(i.range()).interpolate(i.interpolate()).clamp(i.clamp()).unknown(i.unknown());
}
function wW() {
  var i = r4, e = r4, t = _S, n, r, s, o = uf, a, l, u;
  function c() {
    var m = Math.min(i.length, e.length);
    return o !== uf && (o = vW(i[0], i[m - 1])), a = m > 2 ? SW : bW, l = u = null, A;
  }
  function A(m) {
    return m == null || isNaN(m = +m) ? s : (l || (l = a(i.map(n), e, t)))(n(o(m)));
  }
  return A.invert = function(m) {
    return o(r((u || (u = a(e, i.map(n), Qp)))(m)));
  }, A.domain = function(m) {
    return arguments.length ? (i = Array.from(m, yW), c()) : i.slice();
  }, A.range = function(m) {
    return arguments.length ? (e = Array.from(m), c()) : e.slice();
  }, A.rangeRound = function(m) {
    return e = Array.from(m), t = _W, c();
  }, A.clamp = function(m) {
    return arguments.length ? (o = m ? !0 : uf, c()) : o !== uf;
  }, A.interpolate = function(m) {
    return arguments.length ? (t = m, c()) : t;
  }, A.unknown = function(m) {
    return arguments.length ? (s = m, A) : s;
  }, function(m, _) {
    return n = m, r = _, c();
  };
}
function MW() {
  return wW()(uf, uf);
}
function EW(i) {
  return Math.abs(i = Math.round(i)) >= 1e21 ? i.toLocaleString("en").replace(/,/g, "") : i.toString(10);
}
function M1(i, e) {
  if (!isFinite(i) || i === 0) return null;
  var t = (i = e ? i.toExponential(e - 1) : i.toExponential()).indexOf("e"), n = i.slice(0, t);
  return [
    n.length > 1 ? n[0] + n.slice(2) : n,
    +i.slice(t + 1)
  ];
}
function Gf(i) {
  return i = M1(Math.abs(i)), i ? i[1] : NaN;
}
function RW(i, e) {
  return function(t, n) {
    for (var r = t.length, s = [], o = 0, a = i[0], l = 0; r > 0 && a > 0 && (l + a + 1 > n && (a = Math.max(1, n - l)), s.push(t.substring(r -= a, r + a)), !((l += a + 1) > n)); )
      a = i[o = (o + 1) % i.length];
    return s.reverse().join(e);
  };
}
function CW(i) {
  return function(e) {
    return e.replace(/[0-9]/g, function(t) {
      return i[+t];
    });
  };
}
var PW = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function E1(i) {
  if (!(e = PW.exec(i))) throw new Error("invalid format: " + i);
  var e;
  return new xS({
    fill: e[1],
    align: e[2],
    sign: e[3],
    symbol: e[4],
    zero: e[5],
    width: e[6],
    comma: e[7],
    precision: e[8] && e[8].slice(1),
    trim: e[9],
    type: e[10]
  });
}
E1.prototype = xS.prototype;
function xS(i) {
  this.fill = i.fill === void 0 ? " " : i.fill + "", this.align = i.align === void 0 ? ">" : i.align + "", this.sign = i.sign === void 0 ? "-" : i.sign + "", this.symbol = i.symbol === void 0 ? "" : i.symbol + "", this.zero = !!i.zero, this.width = i.width === void 0 ? void 0 : +i.width, this.comma = !!i.comma, this.precision = i.precision === void 0 ? void 0 : +i.precision, this.trim = !!i.trim, this.type = i.type === void 0 ? "" : i.type + "";
}
xS.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};
function NW(i) {
  e: for (var e = i.length, t = 1, n = -1, r; t < e; ++t)
    switch (i[t]) {
      case ".":
        n = r = t;
        break;
      case "0":
        n === 0 && (n = t), r = t;
        break;
      default:
        if (!+i[t]) break e;
        n > 0 && (n = 0);
        break;
    }
  return n > 0 ? i.slice(0, n) + i.slice(r + 1) : i;
}
var R1;
function DW(i, e) {
  var t = M1(i, e);
  if (!t) return R1 = void 0, i.toPrecision(e);
  var n = t[0], r = t[1], s = r - (R1 = Math.max(-8, Math.min(8, Math.floor(r / 3))) * 3) + 1, o = n.length;
  return s === o ? n : s > o ? n + new Array(s - o + 1).join("0") : s > 0 ? n.slice(0, s) + "." + n.slice(s) : "0." + new Array(1 - s).join("0") + M1(i, Math.max(0, e + s - 1))[0];
}
function s4(i, e) {
  var t = M1(i, e);
  if (!t) return i + "";
  var n = t[0], r = t[1];
  return r < 0 ? "0." + new Array(-r).join("0") + n : n.length > r + 1 ? n.slice(0, r + 1) + "." + n.slice(r + 1) : n + new Array(r - n.length + 2).join("0");
}
const o4 = {
  "%": (i, e) => (i * 100).toFixed(e),
  b: (i) => Math.round(i).toString(2),
  c: (i) => i + "",
  d: EW,
  e: (i, e) => i.toExponential(e),
  f: (i, e) => i.toFixed(e),
  g: (i, e) => i.toPrecision(e),
  o: (i) => Math.round(i).toString(8),
  p: (i, e) => s4(i * 100, e),
  r: s4,
  s: DW,
  X: (i) => Math.round(i).toString(16).toUpperCase(),
  x: (i) => Math.round(i).toString(16)
};
function a4(i) {
  return i;
}
var l4 = Array.prototype.map, u4 = ["y", "z", "a", "f", "p", "n", "", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function LW(i) {
  var e = i.grouping === void 0 || i.thousands === void 0 ? a4 : RW(l4.call(i.grouping, Number), i.thousands + ""), t = i.currency === void 0 ? "" : i.currency[0] + "", n = i.currency === void 0 ? "" : i.currency[1] + "", r = i.decimal === void 0 ? "." : i.decimal + "", s = i.numerals === void 0 ? a4 : CW(l4.call(i.numerals, String)), o = i.percent === void 0 ? "%" : i.percent + "", a = i.minus === void 0 ? "" : i.minus + "", l = i.nan === void 0 ? "NaN" : i.nan + "";
  function u(A, m) {
    A = E1(A);
    var _ = A.fill, y = A.align, T = A.sign, b = A.symbol, S = A.zero, E = A.width, R = A.comma, C = A.precision, L = A.trim, D = A.type;
    D === "n" ? (R = !0, D = "g") : o4[D] || (C === void 0 && (C = 12), L = !0, D = "g"), (S || _ === "0" && y === "=") && (S = !0, _ = "0", y = "=");
    var B = (m && m.prefix !== void 0 ? m.prefix : "") + (b === "$" ? t : b === "#" && /[boxX]/.test(D) ? "0" + D.toLowerCase() : ""), U = (b === "$" ? n : /[%p]/.test(D) ? o : "") + (m && m.suffix !== void 0 ? m.suffix : ""), N = o4[D], O = /[defgprs%]/.test(D);
    C = C === void 0 ? 6 : /[gprs]/.test(D) ? Math.max(1, Math.min(21, C)) : Math.max(0, Math.min(20, C));
    function G(H) {
      var Y = B, K = U, X, ee, oe;
      if (D === "c")
        K = N(H) + K, H = "";
      else {
        H = +H;
        var fe = H < 0 || 1 / H < 0;
        if (H = isNaN(H) ? l : N(Math.abs(H), C), L && (H = NW(H)), fe && +H == 0 && T !== "+" && (fe = !1), Y = (fe ? T === "(" ? T : a : T === "-" || T === "(" ? "" : T) + Y, K = (D === "s" && !isNaN(H) && R1 !== void 0 ? u4[8 + R1 / 3] : "") + K + (fe && T === "(" ? ")" : ""), O) {
          for (X = -1, ee = H.length; ++X < ee; )
            if (oe = H.charCodeAt(X), 48 > oe || oe > 57) {
              K = (oe === 46 ? r + H.slice(X + 1) : H.slice(X)) + K, H = H.slice(0, X);
              break;
            }
        }
      }
      R && !S && (H = e(H, 1 / 0));
      var _e = Y.length + H.length + K.length, Te = _e < E ? new Array(E - _e + 1).join(_) : "";
      switch (R && S && (H = e(Te + H, Te.length ? E - K.length : 1 / 0), Te = ""), y) {
        case "<":
          H = Y + H + K + Te;
          break;
        case "=":
          H = Y + Te + H + K;
          break;
        case "^":
          H = Te.slice(0, _e = Te.length >> 1) + Y + H + K + Te.slice(_e);
          break;
        default:
          H = Te + Y + H + K;
          break;
      }
      return s(H);
    }
    return G.toString = function() {
      return A + "";
    }, G;
  }
  function c(A, m) {
    var _ = Math.max(-8, Math.min(8, Math.floor(Gf(m) / 3))) * 3, y = Math.pow(10, -_), T = u((A = E1(A), A.type = "f", A), { suffix: u4[8 + _ / 3] });
    return function(b) {
      return T(y * b);
    };
  }
  return {
    format: u,
    formatPrefix: c
  };
}
var Qm, W8, $8;
IW({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function IW(i) {
  return Qm = LW(i), W8 = Qm.format, $8 = Qm.formatPrefix, Qm;
}
function BW(i) {
  return Math.max(0, -Gf(Math.abs(i)));
}
function FW(i, e) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(Gf(e) / 3))) * 3 - Gf(Math.abs(i)));
}
function UW(i, e) {
  return i = Math.abs(i), e = Math.abs(e) - i, Math.max(0, Gf(e) - Gf(i)) + 1;
}
function OW(i, e, t, n) {
  var r = $H(i, e, t), s;
  switch (n = E1(n ?? ",f"), n.type) {
    case "s": {
      var o = Math.max(Math.abs(i), Math.abs(e));
      return n.precision == null && !isNaN(s = FW(r, o)) && (n.precision = s), $8(n, o);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      n.precision == null && !isNaN(s = UW(r, Math.max(Math.abs(i), Math.abs(e)))) && (n.precision = s - (n.type === "e"));
      break;
    }
    case "f":
    case "%": {
      n.precision == null && !isNaN(s = BW(r)) && (n.precision = s - (n.type === "%") * 2);
      break;
    }
  }
  return W8(n);
}
function j8(i) {
  var e = i.domain;
  return i.ticks = function(t) {
    var n = e();
    return WH(n[0], n[n.length - 1], t ?? 10);
  }, i.tickFormat = function(t, n) {
    var r = e();
    return OW(r[0], r[r.length - 1], t ?? 10, n);
  }, i.nice = function(t) {
    t == null && (t = 10);
    var n = e(), r = 0, s = n.length - 1, o = n[r], a = n[s], l, u, c = 10;
    for (a < o && (u = o, o = a, a = u, u = r, r = s, s = u); c-- > 0; ) {
      if (u = Kv(o, a, t), u === l)
        return n[r] = o, n[s] = a, e(n);
      if (u > 0)
        o = Math.floor(o / u) * u, a = Math.ceil(a / u) * u;
      else if (u < 0)
        o = Math.ceil(o * u) / u, a = Math.floor(a * u) / u;
      else
        break;
      l = u;
    }
    return i;
  }, i;
}
function $l() {
  var i = MW();
  return i.copy = function() {
    return TW(i, $l());
  }, O8.apply(i, arguments), j8(i);
}
function X8() {
  var i = 0, e = 1, t = 1, n = [0.5], r = [0, 1], s;
  function o(l) {
    return l != null && l <= l ? r[U8(n, l, 0, t)] : s;
  }
  function a() {
    var l = -1;
    for (n = new Array(t); ++l < t; ) n[l] = ((l + 1) * e - (l - t) * i) / (t + 1);
    return o;
  }
  return o.domain = function(l) {
    return arguments.length ? ([i, e] = l, i = +i, e = +e, a()) : [i, e];
  }, o.range = function(l) {
    return arguments.length ? (t = (r = Array.from(l)).length - 1, a()) : r.slice();
  }, o.invertExtent = function(l) {
    var u = r.indexOf(l);
    return u < 0 ? [NaN, NaN] : u < 1 ? [i, n[0]] : u >= t ? [n[t - 1], e] : [n[u - 1], n[u]];
  }, o.unknown = function(l) {
    return arguments.length && (s = l), o;
  }, o.thresholds = function() {
    return n.slice();
  }, o.copy = function() {
    return X8().domain([i, e]).range(r).unknown(s);
  }, O8.apply(j8(o), arguments);
}
var Fn = 1e-6, C1 = 1e-12, Yn = Math.PI, Xs = Yn / 2, P1 = Yn / 4, Eo = Yn * 2, Zi = 180 / Yn, xn = Yn / 180, Si = Math.abs, yS = Math.atan, Ho = Math.atan2, Sn = Math.cos, Km = Math.ceil, kW = Math.exp, tb = Math.hypot, VW = Math.log, An = Math.sin, GW = Math.sign || function(i) {
  return i > 0 ? 1 : i < 0 ? -1 : 0;
}, jl = Math.sqrt, zW = Math.tan;
function qW(i) {
  return i > 1 ? 0 : i < -1 ? Yn : Math.acos(i);
}
function Xl(i) {
  return i > 1 ? Xs : i < -1 ? -Xs : Math.asin(i);
}
function c4(i) {
  return (i = An(i / 2)) * i;
}
function cs() {
}
function N1(i, e) {
  i && d4.hasOwnProperty(i.type) && d4[i.type](i, e);
}
var h4 = {
  Feature: function(i, e) {
    N1(i.geometry, e);
  },
  FeatureCollection: function(i, e) {
    for (var t = i.features, n = -1, r = t.length; ++n < r; ) N1(t[n].geometry, e);
  }
}, d4 = {
  Sphere: function(i, e) {
    e.sphere();
  },
  Point: function(i, e) {
    i = i.coordinates, e.point(i[0], i[1], i[2]);
  },
  MultiPoint: function(i, e) {
    for (var t = i.coordinates, n = -1, r = t.length; ++n < r; ) i = t[n], e.point(i[0], i[1], i[2]);
  },
  LineString: function(i, e) {
    nb(i.coordinates, e, 0);
  },
  MultiLineString: function(i, e) {
    for (var t = i.coordinates, n = -1, r = t.length; ++n < r; ) nb(t[n], e, 0);
  },
  Polygon: function(i, e) {
    f4(i.coordinates, e);
  },
  MultiPolygon: function(i, e) {
    for (var t = i.coordinates, n = -1, r = t.length; ++n < r; ) f4(t[n], e);
  },
  GeometryCollection: function(i, e) {
    for (var t = i.geometries, n = -1, r = t.length; ++n < r; ) N1(t[n], e);
  }
};
function nb(i, e, t) {
  var n = -1, r = i.length - t, s;
  for (e.lineStart(); ++n < r; ) s = i[n], e.point(s[0], s[1], s[2]);
  e.lineEnd();
}
function f4(i, e) {
  var t = -1, n = i.length;
  for (e.polygonStart(); ++t < n; ) nb(i[t], e, 1);
  e.polygonEnd();
}
function S2(i, e) {
  i && h4.hasOwnProperty(i.type) ? h4[i.type](i, e) : N1(i, e);
}
var D1 = new Ll(), A4 = new Ll(), Y8, Q8, ib, rb, sb, Yl = {
  point: cs,
  lineStart: cs,
  lineEnd: cs,
  polygonStart: function() {
    D1 = new Ll(), Yl.lineStart = HW, Yl.lineEnd = WW;
  },
  polygonEnd: function() {
    var i = +D1;
    A4.add(i < 0 ? Eo + i : i), this.lineStart = this.lineEnd = this.point = cs;
  },
  sphere: function() {
    A4.add(Eo);
  }
};
function HW() {
  Yl.point = $W;
}
function WW() {
  K8(Y8, Q8);
}
function $W(i, e) {
  Yl.point = K8, Y8 = i, Q8 = e, i *= xn, e *= xn, ib = i, rb = Sn(e = e / 2 + P1), sb = An(e);
}
function K8(i, e) {
  i *= xn, e *= xn, e = e / 2 + P1;
  var t = i - ib, n = t >= 0 ? 1 : -1, r = n * t, s = Sn(e), o = An(e), a = sb * o, l = rb * s + a * Sn(r), u = a * n * An(r);
  D1.add(Ho(u, l)), ib = i, rb = s, sb = o;
}
function L1(i) {
  return [Ho(i[1], i[0]), Xl(i[2])];
}
function Wh(i) {
  var e = i[0], t = i[1], n = Sn(t);
  return [n * Sn(e), n * An(e), An(t)];
}
function Zm(i, e) {
  return i[0] * e[0] + i[1] * e[1] + i[2] * e[2];
}
function zf(i, e) {
  return [i[1] * e[2] - i[2] * e[1], i[2] * e[0] - i[0] * e[2], i[0] * e[1] - i[1] * e[0]];
}
function Dy(i, e) {
  i[0] += e[0], i[1] += e[1], i[2] += e[2];
}
function Jm(i, e) {
  return [i[0] * e, i[1] * e, i[2] * e];
}
function I1(i) {
  var e = jl(i[0] * i[0] + i[1] * i[1] + i[2] * i[2]);
  i[0] /= e, i[1] /= e, i[2] /= e;
}
var Wi, Ws, Ki, bo, Gc, Z8, J8, gf, wp, wu, Ql, bl = {
  point: ob,
  lineStart: p4,
  lineEnd: m4,
  polygonStart: function() {
    bl.point = tP, bl.lineStart = jW, bl.lineEnd = XW, wp = new Ll(), Yl.polygonStart();
  },
  polygonEnd: function() {
    Yl.polygonEnd(), bl.point = ob, bl.lineStart = p4, bl.lineEnd = m4, D1 < 0 ? (Wi = -(Ki = 180), Ws = -(bo = 90)) : wp > Fn ? bo = 90 : wp < -Fn && (Ws = -90), Ql[0] = Wi, Ql[1] = Ki;
  },
  sphere: function() {
    Wi = -(Ki = 180), Ws = -(bo = 90);
  }
};
function ob(i, e) {
  wu.push(Ql = [Wi = i, Ki = i]), e < Ws && (Ws = e), e > bo && (bo = e);
}
function eP(i, e) {
  var t = Wh([i * xn, e * xn]);
  if (gf) {
    var n = zf(gf, t), r = [n[1], -n[0], 0], s = zf(r, n);
    I1(s), s = L1(s);
    var o = i - Gc, a = o > 0 ? 1 : -1, l = s[0] * Zi * a, u, c = Si(o) > 180;
    c ^ (a * Gc < l && l < a * i) ? (u = s[1] * Zi, u > bo && (bo = u)) : (l = (l + 360) % 360 - 180, c ^ (a * Gc < l && l < a * i) ? (u = -s[1] * Zi, u < Ws && (Ws = u)) : (e < Ws && (Ws = e), e > bo && (bo = e))), c ? i < Gc ? xo(Wi, i) > xo(Wi, Ki) && (Ki = i) : xo(i, Ki) > xo(Wi, Ki) && (Wi = i) : Ki >= Wi ? (i < Wi && (Wi = i), i > Ki && (Ki = i)) : i > Gc ? xo(Wi, i) > xo(Wi, Ki) && (Ki = i) : xo(i, Ki) > xo(Wi, Ki) && (Wi = i);
  } else
    wu.push(Ql = [Wi = i, Ki = i]);
  e < Ws && (Ws = e), e > bo && (bo = e), gf = t, Gc = i;
}
function p4() {
  bl.point = eP;
}
function m4() {
  Ql[0] = Wi, Ql[1] = Ki, bl.point = ob, gf = null;
}
function tP(i, e) {
  if (gf) {
    var t = i - Gc;
    wp.add(Si(t) > 180 ? t + (t > 0 ? 360 : -360) : t);
  } else
    Z8 = i, J8 = e;
  Yl.point(i, e), eP(i, e);
}
function jW() {
  Yl.lineStart();
}
function XW() {
  tP(Z8, J8), Yl.lineEnd(), Si(wp) > Fn && (Wi = -(Ki = 180)), Ql[0] = Wi, Ql[1] = Ki, gf = null;
}
function xo(i, e) {
  return (e -= i) < 0 ? e + 360 : e;
}
function YW(i, e) {
  return i[0] - e[0];
}
function g4(i, e) {
  return i[0] <= i[1] ? i[0] <= e && e <= i[1] : e < i[0] || i[1] < e;
}
function nP(i) {
  var e, t, n, r, s, o, a;
  if (bo = Ki = -(Wi = Ws = 1 / 0), wu = [], S2(i, bl), t = wu.length) {
    for (wu.sort(YW), e = 1, n = wu[0], s = [n]; e < t; ++e)
      r = wu[e], g4(n, r[0]) || g4(n, r[1]) ? (xo(n[0], r[1]) > xo(n[0], n[1]) && (n[1] = r[1]), xo(r[0], n[1]) > xo(n[0], n[1]) && (n[0] = r[0])) : s.push(n = r);
    for (o = -1 / 0, t = s.length - 1, e = 0, n = s[t]; e <= t; n = r, ++e)
      r = s[e], (a = xo(n[1], r[0])) > o && (o = a, Wi = r[0], Ki = n[1]);
  }
  return wu = Ql = null, Wi === 1 / 0 || Ws === 1 / 0 ? [[NaN, NaN], [NaN, NaN]] : [[Wi, Ws], [Ki, bo]];
}
var fp, B1, F1, U1, O1, k1, V1, G1, ab, lb, ub, iP, rP, Rs, Cs, Ps, ga = {
  sphere: cs,
  point: vS,
  lineStart: _4,
  lineEnd: x4,
  polygonStart: function() {
    ga.lineStart = ZW, ga.lineEnd = JW;
  },
  polygonEnd: function() {
    ga.lineStart = _4, ga.lineEnd = x4;
  }
};
function vS(i, e) {
  i *= xn, e *= xn;
  var t = Sn(e);
  I0(t * Sn(i), t * An(i), An(e));
}
function I0(i, e, t) {
  ++fp, F1 += (i - F1) / fp, U1 += (e - U1) / fp, O1 += (t - O1) / fp;
}
function _4() {
  ga.point = QW;
}
function QW(i, e) {
  i *= xn, e *= xn;
  var t = Sn(e);
  Rs = t * Sn(i), Cs = t * An(i), Ps = An(e), ga.point = KW, I0(Rs, Cs, Ps);
}
function KW(i, e) {
  i *= xn, e *= xn;
  var t = Sn(e), n = t * Sn(i), r = t * An(i), s = An(e), o = Ho(jl((o = Cs * s - Ps * r) * o + (o = Ps * n - Rs * s) * o + (o = Rs * r - Cs * n) * o), Rs * n + Cs * r + Ps * s);
  B1 += o, k1 += o * (Rs + (Rs = n)), V1 += o * (Cs + (Cs = r)), G1 += o * (Ps + (Ps = s)), I0(Rs, Cs, Ps);
}
function x4() {
  ga.point = vS;
}
function ZW() {
  ga.point = e$;
}
function JW() {
  sP(iP, rP), ga.point = vS;
}
function e$(i, e) {
  iP = i, rP = e, i *= xn, e *= xn, ga.point = sP;
  var t = Sn(e);
  Rs = t * Sn(i), Cs = t * An(i), Ps = An(e), I0(Rs, Cs, Ps);
}
function sP(i, e) {
  i *= xn, e *= xn;
  var t = Sn(e), n = t * Sn(i), r = t * An(i), s = An(e), o = Cs * s - Ps * r, a = Ps * n - Rs * s, l = Rs * r - Cs * n, u = tb(o, a, l), c = Xl(u), A = u && -c / u;
  ab.add(A * o), lb.add(A * a), ub.add(A * l), B1 += c, k1 += c * (Rs + (Rs = n)), V1 += c * (Cs + (Cs = r)), G1 += c * (Ps + (Ps = s)), I0(Rs, Cs, Ps);
}
function y4(i) {
  fp = B1 = F1 = U1 = O1 = k1 = V1 = G1 = 0, ab = new Ll(), lb = new Ll(), ub = new Ll(), S2(i, ga);
  var e = +ab, t = +lb, n = +ub, r = tb(e, t, n);
  return r < C1 && (e = k1, t = V1, n = G1, B1 < Fn && (e = F1, t = U1, n = O1), r = tb(e, t, n), r < C1) ? [NaN, NaN] : [Ho(t, e) * Zi, Xl(n / r) * Zi];
}
function cb(i, e) {
  function t(n, r) {
    return n = i(n, r), e(n[0], n[1]);
  }
  return i.invert && e.invert && (t.invert = function(n, r) {
    return n = e.invert(n, r), n && i.invert(n[0], n[1]);
  }), t;
}
function hb(i, e) {
  return Si(i) > Yn && (i -= Math.round(i / Eo) * Eo), [i, e];
}
hb.invert = hb;
function oP(i, e, t) {
  return (i %= Eo) ? e || t ? cb(b4(i), S4(e, t)) : b4(i) : e || t ? S4(e, t) : hb;
}
function v4(i) {
  return function(e, t) {
    return e += i, Si(e) > Yn && (e -= Math.round(e / Eo) * Eo), [e, t];
  };
}
function b4(i) {
  var e = v4(i);
  return e.invert = v4(-i), e;
}
function S4(i, e) {
  var t = Sn(i), n = An(i), r = Sn(e), s = An(e);
  function o(a, l) {
    var u = Sn(l), c = Sn(a) * u, A = An(a) * u, m = An(l), _ = m * t + c * n;
    return [
      Ho(A * r - _ * s, c * t - m * n),
      Xl(_ * r + A * s)
    ];
  }
  return o.invert = function(a, l) {
    var u = Sn(l), c = Sn(a) * u, A = An(a) * u, m = An(l), _ = m * r - A * s;
    return [
      Ho(A * r + m * s, c * t + _ * n),
      Xl(_ * t - c * n)
    ];
  }, o;
}
function t$(i) {
  i = oP(i[0] * xn, i[1] * xn, i.length > 2 ? i[2] * xn : 0);
  function e(t) {
    return t = i(t[0] * xn, t[1] * xn), t[0] *= Zi, t[1] *= Zi, t;
  }
  return e.invert = function(t) {
    return t = i.invert(t[0] * xn, t[1] * xn), t[0] *= Zi, t[1] *= Zi, t;
  }, e;
}
function n$(i, e, t, n, r, s) {
  if (t) {
    var o = Sn(e), a = An(e), l = n * t;
    r == null ? (r = e + n * Eo, s = e - l / 2) : (r = T4(o, r), s = T4(o, s), (n > 0 ? r < s : r > s) && (r += n * Eo));
    for (var u, c = r; n > 0 ? c > s : c < s; c -= l)
      u = L1([o, -a * Sn(c), -a * An(c)]), i.point(u[0], u[1]);
  }
}
function T4(i, e) {
  e = Wh(e), e[0] -= i, I1(e);
  var t = qW(-e[1]);
  return ((-e[2] < 0 ? -t : t) + Eo - Fn) % Eo;
}
function aP() {
  var i = [], e;
  return {
    point: function(t, n, r) {
      e.push([t, n, r]);
    },
    lineStart: function() {
      i.push(e = []);
    },
    lineEnd: cs,
    rejoin: function() {
      i.length > 1 && i.push(i.pop().concat(i.shift()));
    },
    result: function() {
      var t = i;
      return i = [], e = null, t;
    }
  };
}
function Yg(i, e) {
  return Si(i[0] - e[0]) < Fn && Si(i[1] - e[1]) < Fn;
}
function eg(i, e, t, n) {
  this.x = i, this.z = e, this.o = t, this.e = n, this.v = !1, this.n = this.p = null;
}
function lP(i, e, t, n, r) {
  var s = [], o = [], a, l;
  if (i.forEach(function(y) {
    if (!((T = y.length - 1) <= 0)) {
      var T, b = y[0], S = y[T], E;
      if (Yg(b, S)) {
        if (!b[2] && !S[2]) {
          for (r.lineStart(), a = 0; a < T; ++a) r.point((b = y[a])[0], b[1]);
          r.lineEnd();
          return;
        }
        S[0] += 2 * Fn;
      }
      s.push(E = new eg(b, y, null, !0)), o.push(E.o = new eg(b, null, E, !1)), s.push(E = new eg(S, y, null, !1)), o.push(E.o = new eg(S, null, E, !0));
    }
  }), !!s.length) {
    for (o.sort(e), w4(s), w4(o), a = 0, l = o.length; a < l; ++a)
      o[a].e = t = !t;
    for (var u = s[0], c, A; ; ) {
      for (var m = u, _ = !0; m.v; ) if ((m = m.n) === u) return;
      c = m.z, r.lineStart();
      do {
        if (m.v = m.o.v = !0, m.e) {
          if (_)
            for (a = 0, l = c.length; a < l; ++a) r.point((A = c[a])[0], A[1]);
          else
            n(m.x, m.n.x, 1, r);
          m = m.n;
        } else {
          if (_)
            for (c = m.p.z, a = c.length - 1; a >= 0; --a) r.point((A = c[a])[0], A[1]);
          else
            n(m.x, m.p.x, -1, r);
          m = m.p;
        }
        m = m.o, c = m.z, _ = !_;
      } while (!m.v);
      r.lineEnd();
    }
  }
}
function w4(i) {
  if (e = i.length) {
    for (var e, t = 0, n = i[0], r; ++t < e; )
      n.n = r = i[t], r.p = n, n = r;
    n.n = r = i[0], r.p = n;
  }
}
function Ly(i) {
  return Si(i[0]) <= Yn ? i[0] : GW(i[0]) * ((Si(i[0]) + Yn) % Eo - Yn);
}
function uP(i, e) {
  var t = Ly(e), n = e[1], r = An(n), s = [An(t), -Sn(t), 0], o = 0, a = 0, l = new Ll();
  r === 1 ? n = Xs + Fn : r === -1 && (n = -Xs - Fn);
  for (var u = 0, c = i.length; u < c; ++u)
    if (m = (A = i[u]).length)
      for (var A, m, _ = A[m - 1], y = Ly(_), T = _[1] / 2 + P1, b = An(T), S = Sn(T), E = 0; E < m; ++E, y = C, b = D, S = B, _ = R) {
        var R = A[E], C = Ly(R), L = R[1] / 2 + P1, D = An(L), B = Sn(L), U = C - y, N = U >= 0 ? 1 : -1, O = N * U, G = O > Yn, H = b * D;
        if (l.add(Ho(H * N * An(O), S * B + H * Sn(O))), o += G ? U + N * Eo : U, G ^ y >= t ^ C >= t) {
          var Y = zf(Wh(_), Wh(R));
          I1(Y);
          var K = zf(s, Y);
          I1(K);
          var X = (G ^ U >= 0 ? -1 : 1) * Xl(K[2]);
          (n > X || n === X && (Y[0] || Y[1])) && (a += G ^ U >= 0 ? 1 : -1);
        }
      }
  return (o < -Fn || o < Fn && l < -C1) ^ a & 1;
}
function cP(i, e, t, n) {
  return function(r) {
    var s = e(r), o = aP(), a = e(o), l = !1, u, c, A, m = {
      point: _,
      lineStart: T,
      lineEnd: b,
      polygonStart: function() {
        m.point = S, m.lineStart = E, m.lineEnd = R, c = [], u = [];
      },
      polygonEnd: function() {
        m.point = _, m.lineStart = T, m.lineEnd = b, c = jp(c);
        var C = uP(u, n);
        c.length ? (l || (r.polygonStart(), l = !0), lP(c, r$, C, t, r)) : C && (l || (r.polygonStart(), l = !0), r.lineStart(), t(null, null, 1, r), r.lineEnd()), l && (r.polygonEnd(), l = !1), c = u = null;
      },
      sphere: function() {
        r.polygonStart(), r.lineStart(), t(null, null, 1, r), r.lineEnd(), r.polygonEnd();
      }
    };
    function _(C, L) {
      i(C, L) && r.point(C, L);
    }
    function y(C, L) {
      s.point(C, L);
    }
    function T() {
      m.point = y, s.lineStart();
    }
    function b() {
      m.point = _, s.lineEnd();
    }
    function S(C, L) {
      A.push([C, L]), a.point(C, L);
    }
    function E() {
      a.lineStart(), A = [];
    }
    function R() {
      S(A[0][0], A[0][1]), a.lineEnd();
      var C = a.clean(), L = o.result(), D, B = L.length, U, N, O;
      if (A.pop(), u.push(A), A = null, !!B) {
        if (C & 1) {
          if (N = L[0], (U = N.length - 1) > 0) {
            for (l || (r.polygonStart(), l = !0), r.lineStart(), D = 0; D < U; ++D) r.point((O = N[D])[0], O[1]);
            r.lineEnd();
          }
          return;
        }
        B > 1 && C & 2 && L.push(L.pop().concat(L.shift())), c.push(L.filter(i$));
      }
    }
    return m;
  };
}
function i$(i) {
  return i.length > 1;
}
function r$(i, e) {
  return ((i = i.x)[0] < 0 ? i[1] - Xs - Fn : Xs - i[1]) - ((e = e.x)[0] < 0 ? e[1] - Xs - Fn : Xs - e[1]);
}
const M4 = cP(
  function() {
    return !0;
  },
  s$,
  a$,
  [-Yn, -Xs]
);
function s$(i) {
  var e = NaN, t = NaN, n = NaN, r;
  return {
    lineStart: function() {
      i.lineStart(), r = 1;
    },
    point: function(s, o) {
      var a = s > 0 ? Yn : -Yn, l = Si(s - e);
      Si(l - Yn) < Fn ? (i.point(e, t = (t + o) / 2 > 0 ? Xs : -Xs), i.point(n, t), i.lineEnd(), i.lineStart(), i.point(a, t), i.point(s, t), r = 0) : n !== a && l >= Yn && (Si(e - n) < Fn && (e -= n * Fn), Si(s - a) < Fn && (s -= a * Fn), t = o$(e, t, s, o), i.point(n, t), i.lineEnd(), i.lineStart(), i.point(a, t), r = 0), i.point(e = s, t = o), n = a;
    },
    lineEnd: function() {
      i.lineEnd(), e = t = NaN;
    },
    clean: function() {
      return 2 - r;
    }
  };
}
function o$(i, e, t, n) {
  var r, s, o = An(i - t);
  return Si(o) > Fn ? yS((An(e) * (s = Sn(n)) * An(t) - An(n) * (r = Sn(e)) * An(i)) / (r * s * o)) : (e + n) / 2;
}
function a$(i, e, t, n) {
  var r;
  if (i == null)
    r = t * Xs, n.point(-Yn, r), n.point(0, r), n.point(Yn, r), n.point(Yn, 0), n.point(Yn, -r), n.point(0, -r), n.point(-Yn, -r), n.point(-Yn, 0), n.point(-Yn, r);
  else if (Si(i[0] - e[0]) > Fn) {
    var s = i[0] < e[0] ? Yn : -Yn;
    r = t * s / 2, n.point(-s, r), n.point(0, r), n.point(s, r);
  } else
    n.point(e[0], e[1]);
}
function l$(i) {
  var e = Sn(i), t = 2 * xn, n = e > 0, r = Si(e) > Fn;
  function s(c, A, m, _) {
    n$(_, i, t, m, c, A);
  }
  function o(c, A) {
    return Sn(c) * Sn(A) > e;
  }
  function a(c) {
    var A, m, _, y, T;
    return {
      lineStart: function() {
        y = _ = !1, T = 1;
      },
      point: function(b, S) {
        var E = [b, S], R, C = o(b, S), L = n ? C ? 0 : u(b, S) : C ? u(b + (b < 0 ? Yn : -Yn), S) : 0;
        if (!A && (y = _ = C) && c.lineStart(), C !== _ && (R = l(A, E), (!R || Yg(A, R) || Yg(E, R)) && (E[2] = 1)), C !== _)
          T = 0, C ? (c.lineStart(), R = l(E, A), c.point(R[0], R[1])) : (R = l(A, E), c.point(R[0], R[1], 2), c.lineEnd()), A = R;
        else if (r && A && n ^ C) {
          var D;
          !(L & m) && (D = l(E, A, !0)) && (T = 0, n ? (c.lineStart(), c.point(D[0][0], D[0][1]), c.point(D[1][0], D[1][1]), c.lineEnd()) : (c.point(D[1][0], D[1][1]), c.lineEnd(), c.lineStart(), c.point(D[0][0], D[0][1], 3)));
        }
        C && (!A || !Yg(A, E)) && c.point(E[0], E[1]), A = E, _ = C, m = L;
      },
      lineEnd: function() {
        _ && c.lineEnd(), A = null;
      },
      // Rejoin first and last segments if there were intersections and the first
      // and last points were visible.
      clean: function() {
        return T | (y && _) << 1;
      }
    };
  }
  function l(c, A, m) {
    var _ = Wh(c), y = Wh(A), T = [1, 0, 0], b = zf(_, y), S = Zm(b, b), E = b[0], R = S - E * E;
    if (!R) return !m && c;
    var C = e * S / R, L = -e * E / R, D = zf(T, b), B = Jm(T, C), U = Jm(b, L);
    Dy(B, U);
    var N = D, O = Zm(B, N), G = Zm(N, N), H = O * O - G * (Zm(B, B) - 1);
    if (!(H < 0)) {
      var Y = jl(H), K = Jm(N, (-O - Y) / G);
      if (Dy(K, B), K = L1(K), !m) return K;
      var X = c[0], ee = A[0], oe = c[1], fe = A[1], _e;
      ee < X && (_e = X, X = ee, ee = _e);
      var Te = ee - X, Ce = Si(Te - Yn) < Fn, Je = Ce || Te < Fn;
      if (!Ce && fe < oe && (_e = oe, oe = fe, fe = _e), Je ? Ce ? oe + fe > 0 ^ K[1] < (Si(K[0] - X) < Fn ? oe : fe) : oe <= K[1] && K[1] <= fe : Te > Yn ^ (X <= K[0] && K[0] <= ee)) {
        var Qe = Jm(N, (-O + Y) / G);
        return Dy(Qe, B), [K, L1(Qe)];
      }
    }
  }
  function u(c, A) {
    var m = n ? i : Yn - i, _ = 0;
    return c < -m ? _ |= 1 : c > m && (_ |= 2), A < -m ? _ |= 4 : A > m && (_ |= 8), _;
  }
  return cP(o, a, s, n ? [0, -i] : [-Yn, i - Yn]);
}
function u$(i, e, t, n, r, s) {
  var o = i[0], a = i[1], l = e[0], u = e[1], c = 0, A = 1, m = l - o, _ = u - a, y;
  if (y = t - o, !(!m && y > 0)) {
    if (y /= m, m < 0) {
      if (y < c) return;
      y < A && (A = y);
    } else if (m > 0) {
      if (y > A) return;
      y > c && (c = y);
    }
    if (y = r - o, !(!m && y < 0)) {
      if (y /= m, m < 0) {
        if (y > A) return;
        y > c && (c = y);
      } else if (m > 0) {
        if (y < c) return;
        y < A && (A = y);
      }
      if (y = n - a, !(!_ && y > 0)) {
        if (y /= _, _ < 0) {
          if (y < c) return;
          y < A && (A = y);
        } else if (_ > 0) {
          if (y > A) return;
          y > c && (c = y);
        }
        if (y = s - a, !(!_ && y < 0)) {
          if (y /= _, _ < 0) {
            if (y > A) return;
            y > c && (c = y);
          } else if (_ > 0) {
            if (y < c) return;
            y < A && (A = y);
          }
          return c > 0 && (i[0] = o + c * m, i[1] = a + c * _), A < 1 && (e[0] = o + A * m, e[1] = a + A * _), !0;
        }
      }
    }
  }
}
var Ap = 1e9, tg = -Ap;
function c$(i, e, t, n) {
  function r(u, c) {
    return i <= u && u <= t && e <= c && c <= n;
  }
  function s(u, c, A, m) {
    var _ = 0, y = 0;
    if (u == null || (_ = o(u, A)) !== (y = o(c, A)) || l(u, c) < 0 ^ A > 0)
      do
        m.point(_ === 0 || _ === 3 ? i : t, _ > 1 ? n : e);
      while ((_ = (_ + A + 4) % 4) !== y);
    else
      m.point(c[0], c[1]);
  }
  function o(u, c) {
    return Si(u[0] - i) < Fn ? c > 0 ? 0 : 3 : Si(u[0] - t) < Fn ? c > 0 ? 2 : 1 : Si(u[1] - e) < Fn ? c > 0 ? 1 : 0 : c > 0 ? 3 : 2;
  }
  function a(u, c) {
    return l(u.x, c.x);
  }
  function l(u, c) {
    var A = o(u, 1), m = o(c, 1);
    return A !== m ? A - m : A === 0 ? c[1] - u[1] : A === 1 ? u[0] - c[0] : A === 2 ? u[1] - c[1] : c[0] - u[0];
  }
  return function(u) {
    var c = u, A = aP(), m, _, y, T, b, S, E, R, C, L, D, B = {
      point: U,
      lineStart: H,
      lineEnd: Y,
      polygonStart: O,
      polygonEnd: G
    };
    function U(X, ee) {
      r(X, ee) && c.point(X, ee);
    }
    function N() {
      for (var X = 0, ee = 0, oe = _.length; ee < oe; ++ee)
        for (var fe = _[ee], _e = 1, Te = fe.length, Ce = fe[0], Je, Qe, zt = Ce[0], Tt = Ce[1]; _e < Te; ++_e)
          Je = zt, Qe = Tt, Ce = fe[_e], zt = Ce[0], Tt = Ce[1], Qe <= n ? Tt > n && (zt - Je) * (n - Qe) > (Tt - Qe) * (i - Je) && ++X : Tt <= n && (zt - Je) * (n - Qe) < (Tt - Qe) * (i - Je) && --X;
      return X;
    }
    function O() {
      c = A, m = [], _ = [], D = !0;
    }
    function G() {
      var X = N(), ee = D && X, oe = (m = jp(m)).length;
      (ee || oe) && (u.polygonStart(), ee && (u.lineStart(), s(null, null, 1, u), u.lineEnd()), oe && lP(m, a, X, s, u), u.polygonEnd()), c = u, m = _ = y = null;
    }
    function H() {
      B.point = K, _ && _.push(y = []), L = !0, C = !1, E = R = NaN;
    }
    function Y() {
      m && (K(T, b), S && C && A.rejoin(), m.push(A.result())), B.point = U, C && c.lineEnd();
    }
    function K(X, ee) {
      var oe = r(X, ee);
      if (_ && y.push([X, ee]), L)
        T = X, b = ee, S = oe, L = !1, oe && (c.lineStart(), c.point(X, ee));
      else if (oe && C) c.point(X, ee);
      else {
        var fe = [E = Math.max(tg, Math.min(Ap, E)), R = Math.max(tg, Math.min(Ap, R))], _e = [X = Math.max(tg, Math.min(Ap, X)), ee = Math.max(tg, Math.min(Ap, ee))];
        u$(fe, _e, i, e, t, n) ? (C || (c.lineStart(), c.point(fe[0], fe[1])), c.point(_e[0], _e[1]), oe || c.lineEnd(), D = !1) : oe && (c.lineStart(), c.point(X, ee), D = !1);
      }
      E = X, R = ee, C = oe;
    }
    return B;
  };
}
var db, fb, Qg, Kg, qf = {
  sphere: cs,
  point: cs,
  lineStart: h$,
  lineEnd: cs,
  polygonStart: cs,
  polygonEnd: cs
};
function h$() {
  qf.point = f$, qf.lineEnd = d$;
}
function d$() {
  qf.point = qf.lineEnd = cs;
}
function f$(i, e) {
  i *= xn, e *= xn, fb = i, Qg = An(e), Kg = Sn(e), qf.point = A$;
}
function A$(i, e) {
  i *= xn, e *= xn;
  var t = An(e), n = Sn(e), r = Si(i - fb), s = Sn(r), o = An(r), a = n * o, l = Kg * t - Qg * n * s, u = Qg * t + Kg * n * s;
  db.add(Ho(jl(a * a + l * l), u)), fb = i, Qg = t, Kg = n;
}
function p$(i) {
  return db = new Ll(), S2(i, qf), +db;
}
var Ab = [null, null], m$ = { type: "LineString", coordinates: Ab };
function ju(i, e) {
  return Ab[0] = i, Ab[1] = e, p$(m$);
}
var E4 = {
  Feature: function(i, e) {
    return z1(i.geometry, e);
  },
  FeatureCollection: function(i, e) {
    for (var t = i.features, n = -1, r = t.length; ++n < r; ) if (z1(t[n].geometry, e)) return !0;
    return !1;
  }
}, R4 = {
  Sphere: function() {
    return !0;
  },
  Point: function(i, e) {
    return C4(i.coordinates, e);
  },
  MultiPoint: function(i, e) {
    for (var t = i.coordinates, n = -1, r = t.length; ++n < r; ) if (C4(t[n], e)) return !0;
    return !1;
  },
  LineString: function(i, e) {
    return P4(i.coordinates, e);
  },
  MultiLineString: function(i, e) {
    for (var t = i.coordinates, n = -1, r = t.length; ++n < r; ) if (P4(t[n], e)) return !0;
    return !1;
  },
  Polygon: function(i, e) {
    return N4(i.coordinates, e);
  },
  MultiPolygon: function(i, e) {
    for (var t = i.coordinates, n = -1, r = t.length; ++n < r; ) if (N4(t[n], e)) return !0;
    return !1;
  },
  GeometryCollection: function(i, e) {
    for (var t = i.geometries, n = -1, r = t.length; ++n < r; ) if (z1(t[n], e)) return !0;
    return !1;
  }
};
function z1(i, e) {
  return i && R4.hasOwnProperty(i.type) ? R4[i.type](i, e) : !1;
}
function C4(i, e) {
  return ju(i, e) === 0;
}
function P4(i, e) {
  for (var t, n, r, s = 0, o = i.length; s < o; s++) {
    if (n = ju(i[s], e), n === 0 || s > 0 && (r = ju(i[s], i[s - 1]), r > 0 && t <= r && n <= r && (t + n - r) * (1 - Math.pow((t - n) / r, 2)) < C1 * r))
      return !0;
    t = n;
  }
  return !1;
}
function N4(i, e) {
  return !!uP(i.map(g$), hP(e));
}
function g$(i) {
  return i = i.map(hP), i.pop(), i;
}
function hP(i) {
  return [i[0] * xn, i[1] * xn];
}
function _$(i, e) {
  return (i && E4.hasOwnProperty(i.type) ? E4[i.type] : z1)(i, e);
}
function D4(i, e, t) {
  var n = lf(i, e - Fn, t).concat(e);
  return function(r) {
    return n.map(function(s) {
      return [r, s];
    });
  };
}
function L4(i, e, t) {
  var n = lf(i, e - Fn, t).concat(e);
  return function(r) {
    return n.map(function(s) {
      return [s, r];
    });
  };
}
function x$() {
  var i, e, t, n, r, s, o, a, l = 10, u = l, c = 90, A = 360, m, _, y, T, b = 2.5;
  function S() {
    return { type: "MultiLineString", coordinates: E() };
  }
  function E() {
    return lf(Km(n / c) * c, t, c).map(y).concat(lf(Km(a / A) * A, o, A).map(T)).concat(lf(Km(e / l) * l, i, l).filter(function(R) {
      return Si(R % c) > Fn;
    }).map(m)).concat(lf(Km(s / u) * u, r, u).filter(function(R) {
      return Si(R % A) > Fn;
    }).map(_));
  }
  return S.lines = function() {
    return E().map(function(R) {
      return { type: "LineString", coordinates: R };
    });
  }, S.outline = function() {
    return {
      type: "Polygon",
      coordinates: [
        y(n).concat(
          T(o).slice(1),
          y(t).reverse().slice(1),
          T(a).reverse().slice(1)
        )
      ]
    };
  }, S.extent = function(R) {
    return arguments.length ? S.extentMajor(R).extentMinor(R) : S.extentMinor();
  }, S.extentMajor = function(R) {
    return arguments.length ? (n = +R[0][0], t = +R[1][0], a = +R[0][1], o = +R[1][1], n > t && (R = n, n = t, t = R), a > o && (R = a, a = o, o = R), S.precision(b)) : [[n, a], [t, o]];
  }, S.extentMinor = function(R) {
    return arguments.length ? (e = +R[0][0], i = +R[1][0], s = +R[0][1], r = +R[1][1], e > i && (R = e, e = i, i = R), s > r && (R = s, s = r, r = R), S.precision(b)) : [[e, s], [i, r]];
  }, S.step = function(R) {
    return arguments.length ? S.stepMajor(R).stepMinor(R) : S.stepMinor();
  }, S.stepMajor = function(R) {
    return arguments.length ? (c = +R[0], A = +R[1], S) : [c, A];
  }, S.stepMinor = function(R) {
    return arguments.length ? (l = +R[0], u = +R[1], S) : [l, u];
  }, S.precision = function(R) {
    return arguments.length ? (b = +R, m = D4(s, r, 90), _ = L4(e, i, b), y = D4(a, o, 90), T = L4(n, t, b), S) : b;
  }, S.extentMajor([[-180, -90 + Fn], [180, 90 - Fn]]).extentMinor([[-180, -80 - Fn], [180, 80 + Fn]]);
}
function y$() {
  return x$()();
}
function bS(i, e) {
  var t = i[0] * xn, n = i[1] * xn, r = e[0] * xn, s = e[1] * xn, o = Sn(n), a = An(n), l = Sn(s), u = An(s), c = o * Sn(t), A = o * An(t), m = l * Sn(r), _ = l * An(r), y = 2 * Xl(jl(c4(s - n) + o * l * c4(r - t))), T = An(y), b = y ? function(S) {
    var E = An(S *= y) / T, R = An(y - S) / T, C = R * c + E * m, L = R * A + E * _, D = R * a + E * u;
    return [
      Ho(L, C) * Zi,
      Ho(D, jl(C * C + L * L)) * Zi
    ];
  } : function() {
    return [t * Zi, n * Zi];
  };
  return b.distance = y, b;
}
const I4 = (i) => i;
var Hf = 1 / 0, q1 = Hf, Kp = -Hf, H1 = Kp, B4 = {
  point: v$,
  lineStart: cs,
  lineEnd: cs,
  polygonStart: cs,
  polygonEnd: cs,
  result: function() {
    var i = [[Hf, q1], [Kp, H1]];
    return Kp = H1 = -(q1 = Hf = 1 / 0), i;
  }
};
function v$(i, e) {
  i < Hf && (Hf = i), i > Kp && (Kp = i), e < q1 && (q1 = e), e > H1 && (H1 = e);
}
function SS(i) {
  return function(e) {
    var t = new pb();
    for (var n in i) t[n] = i[n];
    return t.stream = e, t;
  };
}
function pb() {
}
pb.prototype = {
  constructor: pb,
  point: function(i, e) {
    this.stream.point(i, e);
  },
  sphere: function() {
    this.stream.sphere();
  },
  lineStart: function() {
    this.stream.lineStart();
  },
  lineEnd: function() {
    this.stream.lineEnd();
  },
  polygonStart: function() {
    this.stream.polygonStart();
  },
  polygonEnd: function() {
    this.stream.polygonEnd();
  }
};
function TS(i, e, t) {
  var n = i.clipExtent && i.clipExtent();
  return i.scale(150).translate([0, 0]), n != null && i.clipExtent(null), S2(t, i.stream(B4)), e(B4.result()), n != null && i.clipExtent(n), i;
}
function dP(i, e, t) {
  return TS(i, function(n) {
    var r = e[1][0] - e[0][0], s = e[1][1] - e[0][1], o = Math.min(r / (n[1][0] - n[0][0]), s / (n[1][1] - n[0][1])), a = +e[0][0] + (r - o * (n[1][0] + n[0][0])) / 2, l = +e[0][1] + (s - o * (n[1][1] + n[0][1])) / 2;
    i.scale(150 * o).translate([a, l]);
  }, t);
}
function b$(i, e, t) {
  return dP(i, [[0, 0], e], t);
}
function S$(i, e, t) {
  return TS(i, function(n) {
    var r = +e, s = r / (n[1][0] - n[0][0]), o = (r - s * (n[1][0] + n[0][0])) / 2, a = -s * n[0][1];
    i.scale(150 * s).translate([o, a]);
  }, t);
}
function T$(i, e, t) {
  return TS(i, function(n) {
    var r = +e, s = r / (n[1][1] - n[0][1]), o = -s * n[0][0], a = (r - s * (n[1][1] + n[0][1])) / 2;
    i.scale(150 * s).translate([o, a]);
  }, t);
}
var F4 = 16, w$ = Sn(30 * xn);
function U4(i, e) {
  return +e ? E$(i, e) : M$(i);
}
function M$(i) {
  return SS({
    point: function(e, t) {
      e = i(e, t), this.stream.point(e[0], e[1]);
    }
  });
}
function E$(i, e) {
  function t(n, r, s, o, a, l, u, c, A, m, _, y, T, b) {
    var S = u - n, E = c - r, R = S * S + E * E;
    if (R > 4 * e && T--) {
      var C = o + m, L = a + _, D = l + y, B = jl(C * C + L * L + D * D), U = Xl(D /= B), N = Si(Si(D) - 1) < Fn || Si(s - A) < Fn ? (s + A) / 2 : Ho(L, C), O = i(N, U), G = O[0], H = O[1], Y = G - n, K = H - r, X = E * Y - S * K;
      (X * X / R > e || Si((S * Y + E * K) / R - 0.5) > 0.3 || o * m + a * _ + l * y < w$) && (t(n, r, s, o, a, l, G, H, N, C /= B, L /= B, D, T, b), b.point(G, H), t(G, H, N, C, L, D, u, c, A, m, _, y, T, b));
    }
  }
  return function(n) {
    var r, s, o, a, l, u, c, A, m, _, y, T, b = {
      point: S,
      lineStart: E,
      lineEnd: C,
      polygonStart: function() {
        n.polygonStart(), b.lineStart = L;
      },
      polygonEnd: function() {
        n.polygonEnd(), b.lineStart = E;
      }
    };
    function S(U, N) {
      U = i(U, N), n.point(U[0], U[1]);
    }
    function E() {
      A = NaN, b.point = R, n.lineStart();
    }
    function R(U, N) {
      var O = Wh([U, N]), G = i(U, N);
      t(A, m, c, _, y, T, A = G[0], m = G[1], c = U, _ = O[0], y = O[1], T = O[2], F4, n), n.point(A, m);
    }
    function C() {
      b.point = S, n.lineEnd();
    }
    function L() {
      E(), b.point = D, b.lineEnd = B;
    }
    function D(U, N) {
      R(r = U, N), s = A, o = m, a = _, l = y, u = T, b.point = R;
    }
    function B() {
      t(A, m, c, _, y, T, s, o, r, a, l, u, F4, n), b.lineEnd = C, C();
    }
    return b;
  };
}
var R$ = SS({
  point: function(i, e) {
    this.stream.point(i * xn, e * xn);
  }
});
function C$(i) {
  return SS({
    point: function(e, t) {
      var n = i(e, t);
      return this.stream.point(n[0], n[1]);
    }
  });
}
function P$(i, e, t, n, r) {
  function s(o, a) {
    return o *= n, a *= r, [e + i * o, t - i * a];
  }
  return s.invert = function(o, a) {
    return [(o - e) / i * n, (t - a) / i * r];
  }, s;
}
function O4(i, e, t, n, r, s) {
  if (!s) return P$(i, e, t, n, r);
  var o = Sn(s), a = An(s), l = o * i, u = a * i, c = o / i, A = a / i, m = (a * t - o * e) / i, _ = (a * e + o * t) / i;
  function y(T, b) {
    return T *= n, b *= r, [l * T - u * b + e, t - u * T - l * b];
  }
  return y.invert = function(T, b) {
    return [n * (c * T - A * b + m), r * (_ - A * T - c * b)];
  }, y;
}
function N$(i) {
  return D$(function() {
    return i;
  })();
}
function D$(i) {
  var e, t = 150, n = 480, r = 250, s = 0, o = 0, a = 0, l = 0, u = 0, c, A = 0, m = 1, _ = 1, y = null, T = M4, b = null, S, E, R, C = I4, L = 0.5, D, B, U, N, O;
  function G(X) {
    return U(X[0] * xn, X[1] * xn);
  }
  function H(X) {
    return X = U.invert(X[0], X[1]), X && [X[0] * Zi, X[1] * Zi];
  }
  G.stream = function(X) {
    return N && O === X ? N : N = R$(C$(c)(T(D(C(O = X)))));
  }, G.preclip = function(X) {
    return arguments.length ? (T = X, y = void 0, K()) : T;
  }, G.postclip = function(X) {
    return arguments.length ? (C = X, b = S = E = R = null, K()) : C;
  }, G.clipAngle = function(X) {
    return arguments.length ? (T = +X ? l$(y = X * xn) : (y = null, M4), K()) : y * Zi;
  }, G.clipExtent = function(X) {
    return arguments.length ? (C = X == null ? (b = S = E = R = null, I4) : c$(b = +X[0][0], S = +X[0][1], E = +X[1][0], R = +X[1][1]), K()) : b == null ? null : [[b, S], [E, R]];
  }, G.scale = function(X) {
    return arguments.length ? (t = +X, Y()) : t;
  }, G.translate = function(X) {
    return arguments.length ? (n = +X[0], r = +X[1], Y()) : [n, r];
  }, G.center = function(X) {
    return arguments.length ? (s = X[0] % 360 * xn, o = X[1] % 360 * xn, Y()) : [s * Zi, o * Zi];
  }, G.rotate = function(X) {
    return arguments.length ? (a = X[0] % 360 * xn, l = X[1] % 360 * xn, u = X.length > 2 ? X[2] % 360 * xn : 0, Y()) : [a * Zi, l * Zi, u * Zi];
  }, G.angle = function(X) {
    return arguments.length ? (A = X % 360 * xn, Y()) : A * Zi;
  }, G.reflectX = function(X) {
    return arguments.length ? (m = X ? -1 : 1, Y()) : m < 0;
  }, G.reflectY = function(X) {
    return arguments.length ? (_ = X ? -1 : 1, Y()) : _ < 0;
  }, G.precision = function(X) {
    return arguments.length ? (D = U4(B, L = X * X), K()) : jl(L);
  }, G.fitExtent = function(X, ee) {
    return dP(G, X, ee);
  }, G.fitSize = function(X, ee) {
    return b$(G, X, ee);
  }, G.fitWidth = function(X, ee) {
    return S$(G, X, ee);
  }, G.fitHeight = function(X, ee) {
    return T$(G, X, ee);
  };
  function Y() {
    var X = O4(t, 0, 0, m, _, A).apply(null, e(s, o)), ee = O4(t, n - X[0], r - X[1], m, _, A);
    return c = oP(a, l, u), B = cb(e, ee), U = cb(c, B), D = U4(B, L), K();
  }
  function K() {
    return N = O = null, G;
  }
  return function() {
    return e = i.apply(this, arguments), G.invert = e.invert && H, Y();
  };
}
function L$(i) {
  return function(e, t) {
    var n = jl(e * e + t * t), r = i(n), s = An(r), o = Sn(r);
    return [
      Ho(e * s, n * o),
      Xl(n && t * s / n)
    ];
  };
}
function wS(i, e) {
  return [i, VW(zW((Xs + e) / 2))];
}
wS.invert = function(i, e) {
  return [i, 2 * yS(kW(e)) - Xs];
};
function fP(i, e) {
  var t = Sn(e), n = 1 + Sn(i) * t;
  return [t * An(i) / n, An(e) / n];
}
fP.invert = L$(function(i) {
  return 2 * yS(i);
});
function I$() {
  return N$(fP).scale(250).clipAngle(142);
}
function mb(i, e) {
  (e == null || e > i.length) && (e = i.length);
  for (var t = 0, n = Array(e); t < e; t++) n[t] = i[t];
  return n;
}
function B$(i) {
  if (Array.isArray(i)) return i;
}
function F$(i) {
  if (Array.isArray(i)) return mb(i);
}
function Mp(i, e, t) {
  if (typeof i == "function" ? i === e : i.has(e)) return arguments.length < 3 ? e : t;
  throw new TypeError("Private element is not present on this object");
}
function U$(i) {
  if (i === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return i;
}
function O$(i, e, t) {
  return e = W1(e), X$(i, pP() ? Reflect.construct(e, [], W1(i).constructor) : e.apply(i, t));
}
function AP(i, e) {
  if (e.has(i)) throw new TypeError("Cannot initialize the same private elements twice on an object");
}
function k$(i, e) {
  if (!(i instanceof e)) throw new TypeError("Cannot call a class as a function");
}
function Ln(i, e) {
  return i.get(Mp(i, e));
}
function mu(i, e, t) {
  AP(i, e), e.set(i, t);
}
function gu(i, e, t) {
  return i.set(Mp(i, e), t), t;
}
function V$(i, e) {
  AP(i, e), e.add(i);
}
function G$(i, e) {
  for (var t = 0; t < e.length; t++) {
    var n = e[t];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(i, gP(n.key), n);
  }
}
function z$(i, e, t) {
  return e && G$(i.prototype, e), Object.defineProperty(i, "prototype", {
    writable: !1
  }), i;
}
function kd(i, e, t) {
  return (e = gP(e)) in i ? Object.defineProperty(i, e, {
    value: t,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : i[e] = t, i;
}
function W1(i) {
  return W1 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e) {
    return e.__proto__ || Object.getPrototypeOf(e);
  }, W1(i);
}
function q$(i, e) {
  if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function");
  i.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: i,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(i, "prototype", {
    writable: !1
  }), e && gb(i, e);
}
function pP() {
  try {
    var i = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (pP = function() {
    return !!i;
  })();
}
function H$(i) {
  if (typeof Symbol < "u" && i[Symbol.iterator] != null || i["@@iterator"] != null) return Array.from(i);
}
function W$(i, e) {
  var t = i == null ? null : typeof Symbol < "u" && i[Symbol.iterator] || i["@@iterator"];
  if (t != null) {
    var n, r, s, o, a = [], l = !0, u = !1;
    try {
      if (s = (t = t.call(i)).next, e !== 0) for (; !(l = (n = s.call(t)).done) && (a.push(n.value), a.length !== e); l = !0) ;
    } catch (c) {
      u = !0, r = c;
    } finally {
      try {
        if (!l && t.return != null && (o = t.return(), Object(o) !== o)) return;
      } finally {
        if (u) throw r;
      }
    }
    return a;
  }
}
function $$() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function j$() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function X$(i, e) {
  if (e && (typeof e == "object" || typeof e == "function")) return e;
  if (e !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
  return U$(i);
}
function gb(i, e) {
  return gb = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, n) {
    return t.__proto__ = n, t;
  }, gb(i, e);
}
function Zg(i, e) {
  return B$(i) || W$(i, e) || _P(i, e) || $$();
}
function mP(i) {
  return F$(i) || H$(i) || _P(i) || j$();
}
function Y$(i, e) {
  if (typeof i != "object" || !i) return i;
  var t = i[Symbol.toPrimitive];
  if (t !== void 0) {
    var n = t.call(i, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(i);
}
function gP(i) {
  var e = Y$(i, "string");
  return typeof e == "symbol" ? e : e + "";
}
function _P(i, e) {
  if (i) {
    if (typeof i == "string") return mb(i, e);
    var t = {}.toString.call(i).slice(8, -1);
    return t === "Object" && i.constructor && (t = i.constructor.name), t === "Map" || t === "Set" ? Array.from(i) : t === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? mb(i, e) : void 0;
  }
}
var xP = function(e) {
  e instanceof Array ? e.forEach(xP) : (e.map && e.map.dispose(), e.dispose());
}, yP = function(e) {
  e.geometry && e.geometry.dispose(), e.material && xP(e.material), e.texture && e.texture.dispose(), e.children && e.children.forEach(yP);
}, k4 = function(e) {
  if (e && e.children) for (; e.children.length; ) {
    var t = e.children[0];
    e.remove(t), yP(t);
  }
};
function vP(i, e, t) {
  var n = (90 - i) * Math.PI / 180, r = (90 - e) * Math.PI / 180;
  return {
    x: t * Math.sin(n) * Math.cos(r),
    y: t * Math.cos(n),
    z: t * Math.sin(n) * Math.sin(r)
  };
}
function Q$(i) {
  var e = i.x, t = i.y, n = i.z, r = Math.sqrt(e * e + t * t + n * n), s = Math.acos(t / r), o = Math.atan2(n, e);
  return {
    lat: 90 - s * 180 / Math.PI,
    lng: 90 - o * 180 / Math.PI - (o < -Math.PI / 2 ? 360 : 0),
    // keep within [-180, 180] boundaries
    r
  };
}
function Nc(i) {
  return i * Math.PI / 180;
}
var bP = function(e) {
  return 1 - (wS(0, (0.5 - e) * Math.PI)[1] / Math.PI + 1) / 2;
}, Iy = function(e) {
  return Math.max(0, Math.min(1, bP(e)));
}, V4 = function(e) {
  return 0.5 - wS.invert(0, (2 * (1 - e) - 1) * Math.PI)[1] / Math.PI;
}, K$ = function(e) {
  for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1, r = $l().domain([1, 0]).range([t, n]).clamp(!0), s = $l().domain([Iy(t), Iy(n)]).range([1, 0]).clamp(!0), o = function(A) {
    return s(Iy(r(A)));
  }, a = e.array, l = 0, u = a.length; l < u; l += 2)
    a[l + 1] = o(a[l + 1]);
  e.needsUpdate = !0;
}, G4 = function(e, t, n, r) {
  var s = Math.pow(2, e), o = Math.max(0, Math.min(s - 1, Math.floor((n + 180) * s / 360))), a = (90 - r) / 180;
  t && (a = Math.max(0, Math.min(1, bP(a))));
  var l = Math.floor(a * s);
  return [o, l];
}, _b = function(e, t) {
  for (var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, s = arguments.length > 4 ? arguments[4] : void 0, o = arguments.length > 5 ? arguments[5] : void 0, a = [], l = Math.pow(2, e), u = 360 / l, c = 180 / l, A = s === void 0 ? l - 1 : s, m = o === void 0 ? l - 1 : o, _ = n, y = Math.min(l - 1, A); _ <= y; _++)
    for (var T = r, b = Math.min(l - 1, m); T <= b; T++) {
      var S = T, E = c;
      if (t) {
        S = T === 0 ? T : V4(T / l) * l;
        var R = T + 1 === l ? T + 1 : V4((T + 1) / l) * l;
        E = (R - S) * 180 / l;
      }
      var C = -180 + (_ + 0.5) * u, L = 90 - (S * 180 / l + E / 2), D = E;
      a.push({
        x: _,
        y: T,
        lng: C,
        lat: L,
        latLen: D
      });
    }
  return a;
}, Z$ = 6, J$ = 7, ej = 3, tj = 90, za = /* @__PURE__ */ new WeakMap(), Eu = /* @__PURE__ */ new WeakMap(), By = /* @__PURE__ */ new WeakMap(), ng = /* @__PURE__ */ new WeakMap(), Bo = /* @__PURE__ */ new WeakMap(), $1 = /* @__PURE__ */ new WeakMap(), _f = /* @__PURE__ */ new WeakMap(), Dc = /* @__PURE__ */ new WeakMap(), ig = /* @__PURE__ */ new WeakSet(), nj = /* @__PURE__ */ (function(i) {
  function e(t) {
    var n, r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, s = r.tileUrl, o = r.minLevel, a = o === void 0 ? 0 : o, l = r.maxLevel, u = l === void 0 ? 17 : l, c = r.mercatorProjection, A = c === void 0 ? !0 : c;
    return k$(this, e), n = O$(this, e), V$(n, ig), mu(n, za, void 0), mu(n, Eu, void 0), mu(n, By, void 0), mu(n, ng, void 0), mu(n, Bo, {}), mu(n, $1, void 0), mu(n, _f, void 0), mu(n, Dc, void 0), kd(n, "minLevel", void 0), kd(n, "maxLevel", void 0), kd(n, "thresholds", mP(new Array(30)).map(function(m, _) {
      return 8 / Math.pow(2, _);
    })), kd(n, "curvatureResolution", 5), kd(n, "tileMargin", 0), kd(n, "clearTiles", function() {
      Object.values(Ln(Bo, n)).forEach(function(m) {
        m.forEach(function(_) {
          _.obj && (n.remove(_.obj), k4(_.obj), delete _.obj);
        });
      }), gu(Bo, n, {});
    }), gu(za, n, t), n.tileUrl = s, gu(Eu, n, A), n.minLevel = a, n.maxLevel = u, n.level = 0, n.add(gu(Dc, n, new Tn(new Co(Ln(za, n) * 0.99, 180, 90), new Nr({
      color: 0
    })))), Ln(Dc, n).visible = !1, Ln(Dc, n).material.polygonOffset = !0, Ln(Dc, n).material.polygonOffsetUnits = 3, Ln(Dc, n).material.polygonOffsetFactor = 1, n;
  }
  return q$(e, i), z$(e, [{
    key: "tileUrl",
    get: (
      // Public attributes
      function() {
        return Ln(By, this);
      }
    ),
    set: function(n) {
      gu(By, this, n), this.updatePov(Ln(_f, this));
    }
  }, {
    key: "level",
    get: function() {
      return Ln(ng, this);
    },
    set: function(n) {
      var r, s = this;
      Ln(Bo, this)[n] || Mp(ig, this, ij).call(this, n);
      var o = Ln(ng, this);
      if (gu(ng, this, n), !(n === o || o === void 0)) {
        if (Ln(Dc, this).visible = n > 0, Ln(Bo, this)[n].forEach(function(l) {
          return l.obj && (l.obj.material.depthWrite = !0);
        }), o < n && ((r = Ln(Bo, this)[o]) === null || r === void 0 || r.forEach(function(l) {
          return l.obj && (l.obj.material.depthWrite = !1);
        })), o > n)
          for (var a = n + 1; a <= o; a++)
            Ln(Bo, this)[a] && Ln(Bo, this)[a].forEach(function(l) {
              l.obj && (s.remove(l.obj), k4(l.obj), delete l.obj);
            });
        Mp(ig, this, z4).call(this);
      }
    }
    // Public methods
  }, {
    key: "updatePov",
    value: function(n) {
      var r = this;
      if (!(!n || !(n instanceof Jh))) {
        gu(_f, this, n);
        var s;
        if (gu($1, this, function(c) {
          if (!c.hullPnts) {
            var A = 360 / Math.pow(2, r.level), m = c.lng, _ = c.lat, y = c.latLen, T = m - A / 2, b = m + A / 2, S = _ - y / 2, E = _ + y / 2;
            c.hullPnts = [[_, m], [S, T], [E, T], [S, b], [E, b]].map(function(R) {
              var C = Zg(R, 2), L = C[0], D = C[1];
              return vP(L, D, Ln(za, r));
            }).map(function(R) {
              var C = R.x, L = R.y, D = R.z;
              return new j(C, L, D);
            });
          }
          return s || (s = new ec(), n.updateMatrix(), n.updateMatrixWorld(), s.setFromProjectionMatrix(new Mt().multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse))), c.hullPnts.some(function(R) {
            return s.containsPoint(R.clone().applyMatrix4(r.matrixWorld));
          });
        }), this.tileUrl) {
          var o = n.position.clone(), a = o.distanceTo(this.getWorldPosition(new j())), l = (a - Ln(za, this)) / Ln(za, this), u = this.thresholds.findIndex(function(c) {
            return c && c <= l;
          });
          this.level = Math.min(this.maxLevel, Math.max(this.minLevel, u < 0 ? this.thresholds.length : u)), Mp(ig, this, z4).call(this);
        }
      }
    }
  }]);
})(As);
function ij(i) {
  var e = this;
  if (i > J$) {
    Ln(Bo, this)[i] = [];
    return;
  }
  var t = Ln(Bo, this)[i] = _b(i, Ln(Eu, this));
  t.forEach(function(n) {
    return n.centroid = vP(n.lat, n.lng, Ln(za, e));
  }), t.octree = B8().x(function(n) {
    return n.centroid.x;
  }).y(function(n) {
    return n.centroid.y;
  }).z(function(n) {
    return n.centroid.z;
  }).addAll(t);
}
function z4() {
  var i = this;
  if (!(!this.tileUrl || this.level === void 0 || !Ln(Bo, this).hasOwnProperty(this.level)) && !(!Ln($1, this) && this.level > Z$)) {
    var e = Ln(Bo, this)[this.level];
    if (Ln(_f, this)) {
      var t = this.worldToLocal(Ln(_f, this).position.clone());
      if (e.octree) {
        var n, r = this.worldToLocal(Ln(_f, this).position.clone()), s = (r.length() - Ln(za, this)) * ej;
        e = (n = e.octree).findAllWithinRadius.apply(n, mP(r).concat([s]));
      } else {
        var o = Q$(t), a = (o.r / Ln(za, this) - 1) * tj, l = a / Math.cos(Nc(o.lat)), u = [o.lng - l, o.lng + l], c = [o.lat + a, o.lat - a], A = G4(this.level, Ln(Eu, this), u[0], c[0]), m = Zg(A, 2), _ = m[0], y = m[1], T = G4(this.level, Ln(Eu, this), u[1], c[1]), b = Zg(T, 2), S = b[0], E = b[1];
        !e.record && (e.record = {});
        var R = e.record;
        if (!R.hasOwnProperty("".concat(Math.round((_ + S) / 2), "_").concat(Math.round((y + E) / 2))))
          e = _b(this.level, Ln(Eu, this), _, y, S, E).map(function(U) {
            var N = "".concat(U.x, "_").concat(U.y);
            return R.hasOwnProperty(N) ? R[N] : (R[N] = U, e.push(U), U);
          });
        else {
          for (var C = [], L = _; L <= S; L++)
            for (var D = y; D <= E; D++) {
              var B = "".concat(L, "_").concat(D);
              R.hasOwnProperty(B) || (R[B] = _b(this.level, Ln(Eu, this), L, D, L, D)[0], e.push(R[B])), C.push(R[B]);
            }
          e = C;
        }
      }
    }
    e.filter(function(U) {
      return !U.obj;
    }).filter(Ln($1, this) || function() {
      return !0;
    }).forEach(function(U) {
      var N = U.x, O = U.y, G = U.lng, H = U.lat, Y = U.latLen, K = 360 / Math.pow(2, i.level);
      if (!U.obj) {
        var X = K * (1 - i.tileMargin), ee = Y * (1 - i.tileMargin), oe = Nc(G), fe = Nc(-H), _e = new Tn(new Co(Ln(za, i), Math.ceil(X / i.curvatureResolution), Math.ceil(ee / i.curvatureResolution), Nc(90 - X / 2) + oe, Nc(X), Nc(90 - ee / 2) + fe, Nc(ee)), new Ea());
        if (Ln(Eu, i)) {
          var Te = [H + Y / 2, H - Y / 2].map(function(zt) {
            return 0.5 - zt / 180;
          }), Ce = Zg(Te, 2), Je = Ce[0], Qe = Ce[1];
          K$(_e.geometry.attributes.uv, Je, Qe);
        }
        U.obj = _e;
      }
      U.loading || (U.loading = !0, new P0().load(i.tileUrl(N, O, i.level), function(zt) {
        var Tt = U.obj;
        Tt && (zt.colorSpace = gr, Tt.material.map = zt, Tt.material.color = null, Tt.material.needsUpdate = !0, i.add(Tt)), U.loading = !1;
      }));
    });
  }
}
function rj(i, e, t = 2) {
  const n = e && e.length, r = n ? e[0] * t : i.length;
  let s = SP(i, 0, r, t, !0);
  const o = [];
  if (!s || s.next === s.prev) return o;
  let a, l, u;
  if (n && (s = uj(i, e, s, t)), i.length > 80 * t) {
    a = i[0], l = i[1];
    let c = a, A = l;
    for (let m = t; m < r; m += t) {
      const _ = i[m], y = i[m + 1];
      _ < a && (a = _), y < l && (l = y), _ > c && (c = _), y > A && (A = y);
    }
    u = Math.max(c - a, A - l), u = u !== 0 ? 32767 / u : 0;
  }
  return Zp(s, o, t, a, l, u, 0), o;
}
function SP(i, e, t, n, r) {
  let s;
  if (r === yj(i, e, t, n) > 0)
    for (let o = e; o < t; o += n) s = q4(o / n | 0, i[o], i[o + 1], s);
  else
    for (let o = t - n; o >= e; o -= n) s = q4(o / n | 0, i[o], i[o + 1], s);
  return s && Wf(s, s.next) && (e0(s), s = s.next), s;
}
function $h(i, e) {
  if (!i) return i;
  e || (e = i);
  let t = i, n;
  do
    if (n = !1, !t.steiner && (Wf(t, t.next) || Xi(t.prev, t, t.next) === 0)) {
      if (e0(t), t = e = t.prev, t === t.next) break;
      n = !0;
    } else
      t = t.next;
  while (n || t !== e);
  return e;
}
function Zp(i, e, t, n, r, s, o) {
  if (!i) return;
  !o && s && Aj(i, n, r, s);
  let a = i;
  for (; i.prev !== i.next; ) {
    const l = i.prev, u = i.next;
    if (s ? oj(i, n, r, s) : sj(i)) {
      e.push(l.i, i.i, u.i), e0(i), i = u.next, a = u.next;
      continue;
    }
    if (i = u, i === a) {
      o ? o === 1 ? (i = aj($h(i), e), Zp(i, e, t, n, r, s, 2)) : o === 2 && lj(i, e, t, n, r, s) : Zp($h(i), e, t, n, r, s, 1);
      break;
    }
  }
}
function sj(i) {
  const e = i.prev, t = i, n = i.next;
  if (Xi(e, t, n) >= 0) return !1;
  const r = e.x, s = t.x, o = n.x, a = e.y, l = t.y, u = n.y, c = Math.min(r, s, o), A = Math.min(a, l, u), m = Math.max(r, s, o), _ = Math.max(a, l, u);
  let y = n.next;
  for (; y !== e; ) {
    if (y.x >= c && y.x <= m && y.y >= A && y.y <= _ && pp(r, a, s, l, o, u, y.x, y.y) && Xi(y.prev, y, y.next) >= 0) return !1;
    y = y.next;
  }
  return !0;
}
function oj(i, e, t, n) {
  const r = i.prev, s = i, o = i.next;
  if (Xi(r, s, o) >= 0) return !1;
  const a = r.x, l = s.x, u = o.x, c = r.y, A = s.y, m = o.y, _ = Math.min(a, l, u), y = Math.min(c, A, m), T = Math.max(a, l, u), b = Math.max(c, A, m), S = xb(_, y, e, t, n), E = xb(T, b, e, t, n);
  let R = i.prevZ, C = i.nextZ;
  for (; R && R.z >= S && C && C.z <= E; ) {
    if (R.x >= _ && R.x <= T && R.y >= y && R.y <= b && R !== r && R !== o && pp(a, c, l, A, u, m, R.x, R.y) && Xi(R.prev, R, R.next) >= 0 || (R = R.prevZ, C.x >= _ && C.x <= T && C.y >= y && C.y <= b && C !== r && C !== o && pp(a, c, l, A, u, m, C.x, C.y) && Xi(C.prev, C, C.next) >= 0)) return !1;
    C = C.nextZ;
  }
  for (; R && R.z >= S; ) {
    if (R.x >= _ && R.x <= T && R.y >= y && R.y <= b && R !== r && R !== o && pp(a, c, l, A, u, m, R.x, R.y) && Xi(R.prev, R, R.next) >= 0) return !1;
    R = R.prevZ;
  }
  for (; C && C.z <= E; ) {
    if (C.x >= _ && C.x <= T && C.y >= y && C.y <= b && C !== r && C !== o && pp(a, c, l, A, u, m, C.x, C.y) && Xi(C.prev, C, C.next) >= 0) return !1;
    C = C.nextZ;
  }
  return !0;
}
function aj(i, e) {
  let t = i;
  do {
    const n = t.prev, r = t.next.next;
    !Wf(n, r) && wP(n, t, t.next, r) && Jp(n, r) && Jp(r, n) && (e.push(n.i, t.i, r.i), e0(t), e0(t.next), t = i = r), t = t.next;
  } while (t !== i);
  return $h(t);
}
function lj(i, e, t, n, r, s) {
  let o = i;
  do {
    let a = o.next.next;
    for (; a !== o.prev; ) {
      if (o.i !== a.i && gj(o, a)) {
        let l = MP(o, a);
        o = $h(o, o.next), l = $h(l, l.next), Zp(o, e, t, n, r, s, 0), Zp(l, e, t, n, r, s, 0);
        return;
      }
      a = a.next;
    }
    o = o.next;
  } while (o !== i);
}
function uj(i, e, t, n) {
  const r = [];
  for (let s = 0, o = e.length; s < o; s++) {
    const a = e[s] * n, l = s < o - 1 ? e[s + 1] * n : i.length, u = SP(i, a, l, n, !1);
    u === u.next && (u.steiner = !0), r.push(mj(u));
  }
  r.sort(cj);
  for (let s = 0; s < r.length; s++)
    t = hj(r[s], t);
  return t;
}
function cj(i, e) {
  let t = i.x - e.x;
  if (t === 0 && (t = i.y - e.y, t === 0)) {
    const n = (i.next.y - i.y) / (i.next.x - i.x), r = (e.next.y - e.y) / (e.next.x - e.x);
    t = n - r;
  }
  return t;
}
function hj(i, e) {
  const t = dj(i, e);
  if (!t)
    return e;
  const n = MP(t, i);
  return $h(n, n.next), $h(t, t.next);
}
function dj(i, e) {
  let t = e;
  const n = i.x, r = i.y;
  let s = -1 / 0, o;
  if (Wf(i, t)) return t;
  do {
    if (Wf(i, t.next)) return t.next;
    if (r <= t.y && r >= t.next.y && t.next.y !== t.y) {
      const A = t.x + (r - t.y) * (t.next.x - t.x) / (t.next.y - t.y);
      if (A <= n && A > s && (s = A, o = t.x < t.next.x ? t : t.next, A === n))
        return o;
    }
    t = t.next;
  } while (t !== e);
  if (!o) return null;
  const a = o, l = o.x, u = o.y;
  let c = 1 / 0;
  t = o;
  do {
    if (n >= t.x && t.x >= l && n !== t.x && TP(r < u ? n : s, r, l, u, r < u ? s : n, r, t.x, t.y)) {
      const A = Math.abs(r - t.y) / (n - t.x);
      Jp(t, i) && (A < c || A === c && (t.x > o.x || t.x === o.x && fj(o, t))) && (o = t, c = A);
    }
    t = t.next;
  } while (t !== a);
  return o;
}
function fj(i, e) {
  return Xi(i.prev, i, e.prev) < 0 && Xi(e.next, i, i.next) < 0;
}
function Aj(i, e, t, n) {
  let r = i;
  do
    r.z === 0 && (r.z = xb(r.x, r.y, e, t, n)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next;
  while (r !== i);
  r.prevZ.nextZ = null, r.prevZ = null, pj(r);
}
function pj(i) {
  let e, t = 1;
  do {
    let n = i, r;
    i = null;
    let s = null;
    for (e = 0; n; ) {
      e++;
      let o = n, a = 0;
      for (let u = 0; u < t && (a++, o = o.nextZ, !!o); u++)
        ;
      let l = t;
      for (; a > 0 || l > 0 && o; )
        a !== 0 && (l === 0 || !o || n.z <= o.z) ? (r = n, n = n.nextZ, a--) : (r = o, o = o.nextZ, l--), s ? s.nextZ = r : i = r, r.prevZ = s, s = r;
      n = o;
    }
    s.nextZ = null, t *= 2;
  } while (e > 1);
  return i;
}
function xb(i, e, t, n, r) {
  return i = (i - t) * r | 0, e = (e - n) * r | 0, i = (i | i << 8) & 16711935, i = (i | i << 4) & 252645135, i = (i | i << 2) & 858993459, i = (i | i << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, i | e << 1;
}
function mj(i) {
  let e = i, t = i;
  do
    (e.x < t.x || e.x === t.x && e.y < t.y) && (t = e), e = e.next;
  while (e !== i);
  return t;
}
function TP(i, e, t, n, r, s, o, a) {
  return (r - o) * (e - a) >= (i - o) * (s - a) && (i - o) * (n - a) >= (t - o) * (e - a) && (t - o) * (s - a) >= (r - o) * (n - a);
}
function pp(i, e, t, n, r, s, o, a) {
  return !(i === o && e === a) && TP(i, e, t, n, r, s, o, a);
}
function gj(i, e) {
  return i.next.i !== e.i && i.prev.i !== e.i && !_j(i, e) && // doesn't intersect other edges
  (Jp(i, e) && Jp(e, i) && xj(i, e) && // locally visible
  (Xi(i.prev, i, e.prev) || Xi(i, e.prev, e)) || // does not create opposite-facing sectors
  Wf(i, e) && Xi(i.prev, i, i.next) > 0 && Xi(e.prev, e, e.next) > 0);
}
function Xi(i, e, t) {
  return (e.y - i.y) * (t.x - e.x) - (e.x - i.x) * (t.y - e.y);
}
function Wf(i, e) {
  return i.x === e.x && i.y === e.y;
}
function wP(i, e, t, n) {
  const r = sg(Xi(i, e, t)), s = sg(Xi(i, e, n)), o = sg(Xi(t, n, i)), a = sg(Xi(t, n, e));
  return !!(r !== s && o !== a || r === 0 && rg(i, t, e) || s === 0 && rg(i, n, e) || o === 0 && rg(t, i, n) || a === 0 && rg(t, e, n));
}
function rg(i, e, t) {
  return e.x <= Math.max(i.x, t.x) && e.x >= Math.min(i.x, t.x) && e.y <= Math.max(i.y, t.y) && e.y >= Math.min(i.y, t.y);
}
function sg(i) {
  return i > 0 ? 1 : i < 0 ? -1 : 0;
}
function _j(i, e) {
  let t = i;
  do {
    if (t.i !== i.i && t.next.i !== i.i && t.i !== e.i && t.next.i !== e.i && wP(t, t.next, i, e)) return !0;
    t = t.next;
  } while (t !== i);
  return !1;
}
function Jp(i, e) {
  return Xi(i.prev, i, i.next) < 0 ? Xi(i, e, i.next) >= 0 && Xi(i, i.prev, e) >= 0 : Xi(i, e, i.prev) < 0 || Xi(i, i.next, e) < 0;
}
function xj(i, e) {
  let t = i, n = !1;
  const r = (i.x + e.x) / 2, s = (i.y + e.y) / 2;
  do
    t.y > s != t.next.y > s && t.next.y !== t.y && r < (t.next.x - t.x) * (s - t.y) / (t.next.y - t.y) + t.x && (n = !n), t = t.next;
  while (t !== i);
  return n;
}
function MP(i, e) {
  const t = yb(i.i, i.x, i.y), n = yb(e.i, e.x, e.y), r = i.next, s = e.prev;
  return i.next = e, e.prev = i, t.next = r, r.prev = t, n.next = t, t.prev = n, s.next = n, n.prev = s, n;
}
function q4(i, e, t, n) {
  const r = yb(i, e, t);
  return n ? (r.next = n.next, r.prev = n, n.next.prev = r, n.next = r) : (r.prev = r, r.next = r), r;
}
function e0(i) {
  i.next.prev = i.prev, i.prev.next = i.next, i.prevZ && (i.prevZ.nextZ = i.nextZ), i.nextZ && (i.nextZ.prevZ = i.prevZ);
}
function yb(i, e, t) {
  return {
    i,
    // vertex index in coordinates array
    x: e,
    y: t,
    // vertex coordinates
    prev: null,
    // previous and next vertex nodes in a polygon ring
    next: null,
    z: 0,
    // z-order curve value
    prevZ: null,
    // previous and next nodes in z-order
    nextZ: null,
    steiner: !1
    // indicates whether this is a steiner point
  };
}
function yj(i, e, t, n) {
  let r = 0;
  for (let s = e, o = t - n; s < t; s += n)
    r += (i[o] - i[s]) * (i[s + 1] + i[o + 1]), o = s;
  return r;
}
function j1(i) {
  const e = [], t = [], n = i[0][0].length;
  let r = 0, s = 0;
  for (const o of i) {
    for (const a of o)
      for (let l = 0; l < n; l++) e.push(a[l]);
    s && (r += s, t.push(r)), s = o.length;
  }
  return { vertices: e, holes: t, dimensions: n };
}
function vb(i, e) {
  (e == null || e > i.length) && (e = i.length);
  for (var t = 0, n = Array(e); t < e; t++) n[t] = i[t];
  return n;
}
function vj(i) {
  if (Array.isArray(i)) return i;
}
function bj(i) {
  if (Array.isArray(i)) return vb(i);
}
function Sj(i) {
  if (i === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return i;
}
function Tj(i, e, t) {
  return e = X1(e), Lj(i, EP() ? Reflect.construct(e, [], X1(i).constructor) : e.apply(i, t));
}
function wj(i, e) {
  if (!(i instanceof e)) throw new TypeError("Cannot call a class as a function");
}
function Mj(i, e, t) {
  return Object.defineProperty(i, "prototype", {
    writable: !1
  }), i;
}
function Ej(i, e) {
  var t = typeof Symbol < "u" && i[Symbol.iterator] || i["@@iterator"];
  if (!t) {
    if (Array.isArray(i) || (t = MS(i)) || e) {
      t && (i = t);
      var n = 0, r = function() {
      };
      return {
        s: r,
        n: function() {
          return n >= i.length ? {
            done: !0
          } : {
            done: !1,
            value: i[n++]
          };
        },
        e: function(l) {
          throw l;
        },
        f: r
      };
    }
    throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  var s, o = !0, a = !1;
  return {
    s: function() {
      t = t.call(i);
    },
    n: function() {
      var l = t.next();
      return o = l.done, l;
    },
    e: function(l) {
      a = !0, s = l;
    },
    f: function() {
      try {
        o || t.return == null || t.return();
      } finally {
        if (a) throw s;
      }
    }
  };
}
function X1(i) {
  return X1 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e) {
    return e.__proto__ || Object.getPrototypeOf(e);
  }, X1(i);
}
function Rj(i, e) {
  if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function");
  i.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: i,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(i, "prototype", {
    writable: !1
  }), e && bb(i, e);
}
function EP() {
  try {
    var i = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (EP = function() {
    return !!i;
  })();
}
function Cj(i) {
  if (typeof Symbol < "u" && i[Symbol.iterator] != null || i["@@iterator"] != null) return Array.from(i);
}
function Pj(i, e) {
  var t = i == null ? null : typeof Symbol < "u" && i[Symbol.iterator] || i["@@iterator"];
  if (t != null) {
    var n, r, s, o, a = [], l = !0, u = !1;
    try {
      if (s = (t = t.call(i)).next, e === 0) {
        if (Object(t) !== t) return;
        l = !1;
      } else for (; !(l = (n = s.call(t)).done) && (a.push(n.value), a.length !== e); l = !0) ;
    } catch (c) {
      u = !0, r = c;
    } finally {
      try {
        if (!l && t.return != null && (o = t.return(), Object(o) !== o)) return;
      } finally {
        if (u) throw r;
      }
    }
    return a;
  }
}
function Nj() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Dj() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Lj(i, e) {
  if (e && (typeof e == "object" || typeof e == "function")) return e;
  if (e !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
  return Sj(i);
}
function bb(i, e) {
  return bb = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, n) {
    return t.__proto__ = n, t;
  }, bb(i, e);
}
function kA(i, e) {
  return vj(i) || Pj(i, e) || MS(i, e) || Nj();
}
function Ij(i) {
  return bj(i) || Cj(i) || MS(i) || Dj();
}
function MS(i, e) {
  if (i) {
    if (typeof i == "string") return vb(i, e);
    var t = {}.toString.call(i).slice(8, -1);
    return t === "Object" && i.constructor && (t = i.constructor.name), t === "Map" || t === "Set" ? Array.from(i) : t === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? vb(i, e) : void 0;
  }
}
var H4 = function() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1, n = [], r = null;
  return e.forEach(function(s) {
    if (r) {
      var o = ju(s, r) * 180 / Math.PI;
      if (o > t)
        for (var a = bS(r, s), l = r.length > 2 || s.length > 2 ? Qp(r[2] || 0, s[2] || 0) : null, u = l ? function(m) {
          return [].concat(Ij(a(m)), [l(m)]);
        } : a, c = 1 / Math.ceil(o / t), A = c; A < 1; )
          n.push(u(A)), A += c;
    }
    n.push(r = s);
  }), n;
}, Sb = typeof window < "u" && window.THREE ? window.THREE : {
  BufferGeometry: Yt,
  Float32BufferAttribute: xt
}, Bj = new Sb.BufferGeometry().setAttribute ? "setAttribute" : "addAttribute", RP = /* @__PURE__ */ (function(i) {
  function e(t) {
    var n, r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1, s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 5;
    wj(this, e), n = Tj(this, e), n.type = "GeoJsonGeometry", n.parameters = {
      geoJson: t,
      radius: r,
      resolution: s
    };
    var o = ({
      Point: c,
      MultiPoint: A,
      LineString: m,
      MultiLineString: _,
      Polygon: y,
      MultiPolygon: T
    }[t.type] || function() {
      return [];
    })(t.coordinates, r), a = [], l = [], u = 0;
    o.forEach(function(b) {
      var S = a.length;
      VA({
        indices: a,
        vertices: l
      }, b), n.addGroup(S, a.length - S, u++);
    }), a.length && n.setIndex(a), l.length && n[Bj]("position", new Sb.Float32BufferAttribute(l, 3));
    function c(b, S) {
      var E = Fy(b[1], b[0], S + (b[2] || 0)), R = [];
      return [{
        vertices: E,
        indices: R
      }];
    }
    function A(b, S) {
      var E = {
        vertices: [],
        indices: []
      };
      return b.map(function(R) {
        return c(R, S);
      }).forEach(function(R) {
        var C = kA(R, 1), L = C[0];
        VA(E, L);
      }), [E];
    }
    function m(b, S) {
      for (var E = H4(b, s).map(function(U) {
        var N = kA(U, 3), O = N[0], G = N[1], H = N[2], Y = H === void 0 ? 0 : H;
        return Fy(G, O, S + Y);
      }), R = j1([E]), C = R.vertices, L = Math.round(C.length / 3), D = [], B = 1; B < L; B++)
        D.push(B - 1, B);
      return [{
        vertices: C,
        indices: D
      }];
    }
    function _(b, S) {
      var E = {
        vertices: [],
        indices: []
      };
      return b.map(function(R) {
        return m(R, S);
      }).forEach(function(R) {
        var C = kA(R, 1), L = C[0];
        VA(E, L);
      }), [E];
    }
    function y(b, S) {
      for (var E = b.map(function(X) {
        return H4(X, s).map(function(ee) {
          var oe = kA(ee, 3), fe = oe[0], _e = oe[1], Te = oe[2], Ce = Te === void 0 ? 0 : Te;
          return Fy(_e, fe, S + Ce);
        });
      }), R = j1(E), C = R.vertices, L = R.holes, D = L[0] || 1 / 0, B = C.slice(0, D * 3), U = C.slice(D * 3), N = new Set(L), O = Math.round(C.length / 3), G = [], H = [], Y = 1; Y < O; Y++)
        N.has(Y) || (Y < D ? G.push(Y - 1, Y) : H.push(Y - 1 - D, Y - D));
      var K = [{
        indices: G,
        vertices: B
      }];
      return L.length && K.push({
        indices: H,
        vertices: U
      }), K;
    }
    function T(b, S) {
      var E = {
        vertices: [],
        indices: []
      }, R = {
        vertices: [],
        indices: []
      };
      b.map(function(L) {
        return y(L, S);
      }).forEach(function(L) {
        var D = kA(L, 2), B = D[0], U = D[1];
        VA(E, B), U && VA(R, U);
      });
      var C = [E];
      return R.vertices.length && C.push(R), C;
    }
    return n;
  }
  return Rj(e, i), Mj(e);
})(Sb.BufferGeometry);
function VA(i, e) {
  var t = Math.round(i.vertices.length / 3);
  W4(i.vertices, e.vertices), W4(i.indices, e.indices.map(function(n) {
    return n + t;
  }));
}
function W4(i, e) {
  var t = Ej(e), n;
  try {
    for (t.s(); !(n = t.n()).done; ) {
      var r = n.value;
      i.push(r);
    }
  } catch (s) {
    t.e(s);
  } finally {
    t.f();
  }
}
function Fy(i, e) {
  var t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, n = (90 - i) * Math.PI / 180, r = (90 - e) * Math.PI / 180;
  return [
    t * Math.sin(n) * Math.cos(r),
    // x
    t * Math.cos(n),
    // y
    t * Math.sin(n) * Math.sin(r)
    // z
  ];
}
function Fj(i, e, t = !0) {
  if (!e || !e.isReady)
    throw new Error("BufferGeometryUtils: Initialized MikkTSpace library required.");
  if (!i.hasAttribute("position") || !i.hasAttribute("normal") || !i.hasAttribute("uv"))
    throw new Error('BufferGeometryUtils: Tangents require "position", "normal", and "uv" attributes.');
  function n(o) {
    if (o.normalized || o.isInterleavedBufferAttribute) {
      const a = new Float32Array(o.count * o.itemSize);
      for (let l = 0, u = 0; l < o.count; l++)
        a[u++] = o.getX(l), a[u++] = o.getY(l), o.itemSize > 2 && (a[u++] = o.getZ(l));
      return a;
    }
    return o.array instanceof Float32Array ? o.array : new Float32Array(o.array);
  }
  const r = i.index ? i.toNonIndexed() : i, s = e.generateTangents(
    n(r.attributes.position),
    n(r.attributes.normal),
    n(r.attributes.uv)
  );
  if (t)
    for (let o = 3; o < s.length; o += 4)
      s[o] *= -1;
  return r.setAttribute("tangent", new Dn(s, 4)), i !== r && i.copy(r), i;
}
function Uj(i, e = !1) {
  const t = i[0].index !== null, n = new Set(Object.keys(i[0].attributes)), r = new Set(Object.keys(i[0].morphAttributes)), s = {}, o = {}, a = i[0].morphTargetsRelative, l = new Yt();
  let u = 0;
  for (let c = 0; c < i.length; ++c) {
    const A = i[c];
    let m = 0;
    if (t !== (A.index !== null))
      return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + c + ". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."), null;
    for (const _ in A.attributes) {
      if (!n.has(_))
        return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + c + '. All geometries must have compatible attributes; make sure "' + _ + '" attribute exists among all geometries, or in none of them.'), null;
      s[_] === void 0 && (s[_] = []), s[_].push(A.attributes[_]), m++;
    }
    if (m !== n.size)
      return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + c + ". Make sure all geometries have the same number of attributes."), null;
    if (a !== A.morphTargetsRelative)
      return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + c + ". .morphTargetsRelative must be consistent throughout all geometries."), null;
    for (const _ in A.morphAttributes) {
      if (!r.has(_))
        return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + c + ".  .morphAttributes must be consistent throughout all geometries."), null;
      o[_] === void 0 && (o[_] = []), o[_].push(A.morphAttributes[_]);
    }
    if (e) {
      let _;
      if (t)
        _ = A.index.count;
      else if (A.attributes.position !== void 0)
        _ = A.attributes.position.count;
      else
        return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + c + ". The geometry must have either an index or a position attribute"), null;
      l.addGroup(u, _, c), u += _;
    }
  }
  if (t) {
    let c = 0;
    const A = [];
    for (let m = 0; m < i.length; ++m) {
      const _ = i[m].index;
      for (let y = 0; y < _.count; ++y)
        A.push(_.getX(y) + c);
      c += i[m].attributes.position.count;
    }
    l.setIndex(A);
  }
  for (const c in s) {
    const A = Tb(s[c]);
    if (!A)
      return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the " + c + " attribute."), null;
    l.setAttribute(c, A);
  }
  for (const c in o) {
    const A = o[c][0].length;
    if (A === 0) break;
    l.morphAttributes = l.morphAttributes || {}, l.morphAttributes[c] = [];
    for (let m = 0; m < A; ++m) {
      const _ = [];
      for (let T = 0; T < o[c].length; ++T)
        _.push(o[c][T][m]);
      const y = Tb(_);
      if (!y)
        return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the " + c + " morphAttribute."), null;
      l.morphAttributes[c].push(y);
    }
  }
  return l;
}
function Tb(i) {
  let e, t, n, r = -1, s = 0;
  for (let u = 0; u < i.length; ++u) {
    const c = i[u];
    if (e === void 0 && (e = c.array.constructor), e !== c.array.constructor)
      return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."), null;
    if (t === void 0 && (t = c.itemSize), t !== c.itemSize)
      return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."), null;
    if (n === void 0 && (n = c.normalized), n !== c.normalized)
      return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."), null;
    if (r === -1 && (r = c.gpuType), r !== c.gpuType)
      return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes."), null;
    s += c.count * t;
  }
  const o = new e(s), a = new Dn(o, t, n);
  let l = 0;
  for (let u = 0; u < i.length; ++u) {
    const c = i[u];
    if (c.isInterleavedBufferAttribute) {
      const A = l / t;
      for (let m = 0, _ = c.count; m < _; m++)
        for (let y = 0; y < t; y++) {
          const T = c.getComponent(m, y);
          a.setComponent(m + A, y, T);
        }
    } else
      o.set(c.array, l);
    l += c.count * t;
  }
  return r !== void 0 && (a.gpuType = r), a;
}
function Oj(i) {
  return i.isInstancedInterleavedBufferAttribute || i.isInterleavedBufferAttribute ? Y1(i) : i.isInstancedBufferAttribute ? new to().copy(i) : new Dn().copy(i);
}
function kj(i) {
  let e, t = 0, n = 0;
  for (let u = 0, c = i.length; u < c; ++u) {
    const A = i[u];
    if (e === void 0 && (e = A.array.constructor), e !== A.array.constructor)
      return console.error("AttributeBuffers of different types cannot be interleaved"), null;
    t += A.array.length, n += A.itemSize;
  }
  const r = new aA(new e(t), n);
  let s = 0;
  const o = [], a = ["getX", "getY", "getZ", "getW"], l = ["setX", "setY", "setZ", "setW"];
  for (let u = 0, c = i.length; u < c; u++) {
    const A = i[u], m = A.itemSize, _ = A.count, y = new Bs(r, m, s, A.normalized);
    o.push(y), s += m;
    for (let T = 0; T < _; T++)
      for (let b = 0; b < m; b++)
        y[l[b]](T, A[a[b]](T));
  }
  return o;
}
function Y1(i) {
  const e = i.data.array.constructor, t = i.count, n = i.itemSize, r = i.normalized, s = new e(t * n);
  let o;
  i.isInstancedInterleavedBufferAttribute ? o = new to(s, n, r, i.meshPerAttribute) : o = new Dn(s, n, r);
  for (let a = 0; a < t; a++)
    o.setX(a, i.getX(a)), n >= 2 && o.setY(a, i.getY(a)), n >= 3 && o.setZ(a, i.getZ(a)), n >= 4 && o.setW(a, i.getW(a));
  return o;
}
function Vj(i) {
  const e = i.attributes, t = i.morphTargets, n = /* @__PURE__ */ new Map();
  for (const r in e) {
    const s = e[r];
    s.isInterleavedBufferAttribute && (n.has(s) || n.set(s, Y1(s)), e[r] = n.get(s));
  }
  for (const r in t) {
    const s = t[r];
    s.isInterleavedBufferAttribute && (n.has(s) || n.set(s, Y1(s)), t[r] = n.get(s));
  }
}
function Gj(i) {
  let e = 0;
  for (const n in i.attributes) {
    const r = i.getAttribute(n);
    e += r.count * r.itemSize * r.array.BYTES_PER_ELEMENT;
  }
  const t = i.getIndex();
  return e += t ? t.count * t.itemSize * t.array.BYTES_PER_ELEMENT : 0, e;
}
function zj(i, e = 1e-4) {
  e = Math.max(e, Number.EPSILON);
  const t = {}, n = i.getIndex(), r = i.getAttribute("position"), s = n ? n.count : r.count;
  let o = 0;
  const a = Object.keys(i.attributes), l = {}, u = {}, c = [], A = ["getX", "getY", "getZ", "getW"], m = ["setX", "setY", "setZ", "setW"];
  for (let E = 0, R = a.length; E < R; E++) {
    const C = a[E], L = i.attributes[C];
    l[C] = new L.constructor(
      new L.array.constructor(L.count * L.itemSize),
      L.itemSize,
      L.normalized
    );
    const D = i.morphAttributes[C];
    D && (u[C] || (u[C] = []), D.forEach((B, U) => {
      const N = new B.array.constructor(B.count * B.itemSize);
      u[C][U] = new B.constructor(N, B.itemSize, B.normalized);
    }));
  }
  const _ = e * 0.5, y = Math.log10(1 / e), T = Math.pow(10, y), b = _ * T;
  for (let E = 0; E < s; E++) {
    const R = n ? n.getX(E) : E;
    let C = "";
    for (let L = 0, D = a.length; L < D; L++) {
      const B = a[L], U = i.getAttribute(B), N = U.itemSize;
      for (let O = 0; O < N; O++)
        C += `${~~(U[A[O]](R) * T + b)},`;
    }
    if (C in t)
      c.push(t[C]);
    else {
      for (let L = 0, D = a.length; L < D; L++) {
        const B = a[L], U = i.getAttribute(B), N = i.morphAttributes[B], O = U.itemSize, G = l[B], H = u[B];
        for (let Y = 0; Y < O; Y++) {
          const K = A[Y], X = m[Y];
          if (G[X](o, U[K](R)), N)
            for (let ee = 0, oe = N.length; ee < oe; ee++)
              H[ee][X](o, N[ee][K](R));
        }
      }
      t[C] = o, c.push(o), o++;
    }
  }
  const S = i.clone();
  for (const E in i.attributes) {
    const R = l[E];
    if (S.setAttribute(E, new R.constructor(
      R.array.slice(0, o * R.itemSize),
      R.itemSize,
      R.normalized
    )), E in u)
      for (let C = 0; C < u[E].length; C++) {
        const L = u[E][C];
        S.morphAttributes[E][C] = new L.constructor(
          L.array.slice(0, o * L.itemSize),
          L.itemSize,
          L.normalized
        );
      }
  }
  return S.setIndex(c), S;
}
function qj(i, e) {
  if (e === M5)
    return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."), i;
  if (e === Fv || e === E5) {
    let t = i.getIndex();
    if (t === null) {
      const o = [], a = i.getAttribute("position");
      if (a !== void 0) {
        for (let l = 0; l < a.count; l++)
          o.push(l);
        i.setIndex(o), t = i.getIndex();
      } else
        return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), i;
    }
    const n = t.count - 2, r = [];
    if (e === Fv)
      for (let o = 1; o <= n; o++)
        r.push(t.getX(0)), r.push(t.getX(o)), r.push(t.getX(o + 1));
    else
      for (let o = 0; o < n; o++)
        o % 2 === 0 ? (r.push(t.getX(o)), r.push(t.getX(o + 1)), r.push(t.getX(o + 2))) : (r.push(t.getX(o + 2)), r.push(t.getX(o + 1)), r.push(t.getX(o)));
    r.length / 3 !== n && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
    const s = i.clone();
    return s.setIndex(r), s.clearGroups(), s;
  } else
    return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", e), i;
}
function Hj(i) {
  const e = new j(), t = new j(), n = new j(), r = new j(), s = new j(), o = new j(), a = new j(), l = new j(), u = new j();
  function c(_e, Te, Ce, Je, Qe, zt, Tt, Pe) {
    e.fromBufferAttribute(Te, Qe), t.fromBufferAttribute(Te, zt), n.fromBufferAttribute(Te, Tt);
    const ke = _e.morphTargetInfluences;
    if (Ce && ke) {
      a.set(0, 0, 0), l.set(0, 0, 0), u.set(0, 0, 0);
      for (let at = 0, wt = Ce.length; at < wt; at++) {
        const ot = ke[at], Wt = Ce[at];
        ot !== 0 && (r.fromBufferAttribute(Wt, Qe), s.fromBufferAttribute(Wt, zt), o.fromBufferAttribute(Wt, Tt), Je ? (a.addScaledVector(r, ot), l.addScaledVector(s, ot), u.addScaledVector(o, ot)) : (a.addScaledVector(r.sub(e), ot), l.addScaledVector(s.sub(t), ot), u.addScaledVector(o.sub(n), ot)));
      }
      e.add(a), t.add(l), n.add(u);
    }
    _e.isSkinnedMesh && (_e.applyBoneTransform(Qe, e), _e.applyBoneTransform(zt, t), _e.applyBoneTransform(Tt, n)), Pe[Qe * 3 + 0] = e.x, Pe[Qe * 3 + 1] = e.y, Pe[Qe * 3 + 2] = e.z, Pe[zt * 3 + 0] = t.x, Pe[zt * 3 + 1] = t.y, Pe[zt * 3 + 2] = t.z, Pe[Tt * 3 + 0] = n.x, Pe[Tt * 3 + 1] = n.y, Pe[Tt * 3 + 2] = n.z;
  }
  const A = i.geometry, m = i.material;
  let _, y, T;
  const b = A.index, S = A.attributes.position, E = A.morphAttributes.position, R = A.morphTargetsRelative, C = A.attributes.normal, L = A.morphAttributes.position, D = A.groups, B = A.drawRange;
  let U, N, O, G, H, Y, K;
  const X = new Float32Array(S.count * S.itemSize), ee = new Float32Array(C.count * C.itemSize);
  if (b !== null)
    if (Array.isArray(m))
      for (U = 0, O = D.length; U < O; U++)
        for (H = D[U], Y = Math.max(H.start, B.start), K = Math.min(H.start + H.count, B.start + B.count), N = Y, G = K; N < G; N += 3)
          _ = b.getX(N), y = b.getX(N + 1), T = b.getX(N + 2), c(
            i,
            S,
            E,
            R,
            _,
            y,
            T,
            X
          ), c(
            i,
            C,
            L,
            R,
            _,
            y,
            T,
            ee
          );
    else
      for (Y = Math.max(0, B.start), K = Math.min(b.count, B.start + B.count), U = Y, O = K; U < O; U += 3)
        _ = b.getX(U), y = b.getX(U + 1), T = b.getX(U + 2), c(
          i,
          S,
          E,
          R,
          _,
          y,
          T,
          X
        ), c(
          i,
          C,
          L,
          R,
          _,
          y,
          T,
          ee
        );
  else if (Array.isArray(m))
    for (U = 0, O = D.length; U < O; U++)
      for (H = D[U], Y = Math.max(H.start, B.start), K = Math.min(H.start + H.count, B.start + B.count), N = Y, G = K; N < G; N += 3)
        _ = N, y = N + 1, T = N + 2, c(
          i,
          S,
          E,
          R,
          _,
          y,
          T,
          X
        ), c(
          i,
          C,
          L,
          R,
          _,
          y,
          T,
          ee
        );
  else
    for (Y = Math.max(0, B.start), K = Math.min(S.count, B.start + B.count), U = Y, O = K; U < O; U += 3)
      _ = U, y = U + 1, T = U + 2, c(
        i,
        S,
        E,
        R,
        _,
        y,
        T,
        X
      ), c(
        i,
        C,
        L,
        R,
        _,
        y,
        T,
        ee
      );
  const oe = new xt(X, 3), fe = new xt(ee, 3);
  return {
    positionAttribute: S,
    normalAttribute: C,
    morphedPositionAttribute: oe,
    morphedNormalAttribute: fe
  };
}
function Wj(i) {
  if (i.groups.length === 0)
    return console.warn("THREE.BufferGeometryUtils.mergeGroups(): No groups are defined. Nothing to merge."), i;
  let e = i.groups;
  if (e = e.sort((o, a) => o.materialIndex !== a.materialIndex ? o.materialIndex - a.materialIndex : o.start - a.start), i.getIndex() === null) {
    const o = i.getAttribute("position"), a = [];
    for (let l = 0; l < o.count; l += 3)
      a.push(l, l + 1, l + 2);
    i.setIndex(a);
  }
  const t = i.getIndex(), n = [];
  for (let o = 0; o < e.length; o++) {
    const a = e[o], l = a.start, u = l + a.count;
    for (let c = l; c < u; c++)
      n.push(t.getX(c));
  }
  i.dispose(), i.setIndex(n);
  let r = 0;
  for (let o = 0; o < e.length; o++) {
    const a = e[o];
    a.start = r, r += a.count;
  }
  let s = e[0];
  i.groups = [s];
  for (let o = 1; o < e.length; o++) {
    const a = e[o];
    s.materialIndex === a.materialIndex ? s.count += a.count : (s = a, i.groups.push(s));
  }
  return i;
}
function $j(i, e = Math.PI / 3) {
  const t = Math.cos(e), n = (1 + 1e-10) * 100, r = [new j(), new j(), new j()], s = new j(), o = new j(), a = new j(), l = new j();
  function u(T) {
    const b = ~~(T.x * n), S = ~~(T.y * n), E = ~~(T.z * n);
    return `${b},${S},${E}`;
  }
  const c = i.index ? i.toNonIndexed() : i, A = c.attributes.position, m = {};
  for (let T = 0, b = A.count / 3; T < b; T++) {
    const S = 3 * T, E = r[0].fromBufferAttribute(A, S + 0), R = r[1].fromBufferAttribute(A, S + 1), C = r[2].fromBufferAttribute(A, S + 2);
    s.subVectors(C, R), o.subVectors(E, R);
    const L = new j().crossVectors(s, o).normalize();
    for (let D = 0; D < 3; D++) {
      const B = r[D], U = u(B);
      U in m || (m[U] = []), m[U].push(L);
    }
  }
  const _ = new Float32Array(A.count * 3), y = new Dn(_, 3, !1);
  for (let T = 0, b = A.count / 3; T < b; T++) {
    const S = 3 * T, E = r[0].fromBufferAttribute(A, S + 0), R = r[1].fromBufferAttribute(A, S + 1), C = r[2].fromBufferAttribute(A, S + 2);
    s.subVectors(C, R), o.subVectors(E, R), a.crossVectors(s, o).normalize();
    for (let L = 0; L < 3; L++) {
      const D = r[L], B = u(D), U = m[B];
      l.set(0, 0, 0);
      for (let N = 0, O = U.length; N < O; N++) {
        const G = U[N];
        a.dot(G) > t && l.add(G);
      }
      l.normalize(), y.setXYZ(S + L, l.x, l.y, l.z);
    }
  }
  return c.setAttribute("normal", y), c;
}
const ES = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  computeMikkTSpaceTangents: Fj,
  computeMorphedAttributes: Hj,
  deepCloneAttribute: Oj,
  deinterleaveAttribute: Y1,
  deinterleaveGeometry: Vj,
  estimateBytesUsed: Gj,
  interleaveAttributes: kj,
  mergeAttributes: Tb,
  mergeGeometries: Uj,
  mergeGroups: Wj,
  mergeVertices: zj,
  toCreasedNormals: $j,
  toTrianglesDrawMode: qj
}, Symbol.toStringTag, { value: "Module" }));
var je = (function(i) {
  return typeof i == "function" ? i : typeof i == "string" ? function(e) {
    return e[i];
  } : function(e) {
    return i;
  };
});
function Q1(i) {
  "@babel/helpers - typeof";
  return Q1 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, Q1(i);
}
var jj = /^\s+/, Xj = /\s+$/;
function Zt(i, e) {
  if (i = i || "", e = e || {}, i instanceof Zt)
    return i;
  if (!(this instanceof Zt))
    return new Zt(i, e);
  var t = Yj(i);
  this._originalInput = i, this._r = t.r, this._g = t.g, this._b = t.b, this._a = t.a, this._roundA = Math.round(100 * this._a) / 100, this._format = e.format || t.format, this._gradientType = e.gradientType, this._r < 1 && (this._r = Math.round(this._r)), this._g < 1 && (this._g = Math.round(this._g)), this._b < 1 && (this._b = Math.round(this._b)), this._ok = t.ok;
}
Zt.prototype = {
  isDark: function() {
    return this.getBrightness() < 128;
  },
  isLight: function() {
    return !this.isDark();
  },
  isValid: function() {
    return this._ok;
  },
  getOriginalInput: function() {
    return this._originalInput;
  },
  getFormat: function() {
    return this._format;
  },
  getAlpha: function() {
    return this._a;
  },
  getBrightness: function() {
    var e = this.toRgb();
    return (e.r * 299 + e.g * 587 + e.b * 114) / 1e3;
  },
  getLuminance: function() {
    var e = this.toRgb(), t, n, r, s, o, a;
    return t = e.r / 255, n = e.g / 255, r = e.b / 255, t <= 0.03928 ? s = t / 12.92 : s = Math.pow((t + 0.055) / 1.055, 2.4), n <= 0.03928 ? o = n / 12.92 : o = Math.pow((n + 0.055) / 1.055, 2.4), r <= 0.03928 ? a = r / 12.92 : a = Math.pow((r + 0.055) / 1.055, 2.4), 0.2126 * s + 0.7152 * o + 0.0722 * a;
  },
  setAlpha: function(e) {
    return this._a = CP(e), this._roundA = Math.round(100 * this._a) / 100, this;
  },
  toHsv: function() {
    var e = j4(this._r, this._g, this._b);
    return {
      h: e.h * 360,
      s: e.s,
      v: e.v,
      a: this._a
    };
  },
  toHsvString: function() {
    var e = j4(this._r, this._g, this._b), t = Math.round(e.h * 360), n = Math.round(e.s * 100), r = Math.round(e.v * 100);
    return this._a == 1 ? "hsv(" + t + ", " + n + "%, " + r + "%)" : "hsva(" + t + ", " + n + "%, " + r + "%, " + this._roundA + ")";
  },
  toHsl: function() {
    var e = $4(this._r, this._g, this._b);
    return {
      h: e.h * 360,
      s: e.s,
      l: e.l,
      a: this._a
    };
  },
  toHslString: function() {
    var e = $4(this._r, this._g, this._b), t = Math.round(e.h * 360), n = Math.round(e.s * 100), r = Math.round(e.l * 100);
    return this._a == 1 ? "hsl(" + t + ", " + n + "%, " + r + "%)" : "hsla(" + t + ", " + n + "%, " + r + "%, " + this._roundA + ")";
  },
  toHex: function(e) {
    return X4(this._r, this._g, this._b, e);
  },
  toHexString: function(e) {
    return "#" + this.toHex(e);
  },
  toHex8: function(e) {
    return Jj(this._r, this._g, this._b, this._a, e);
  },
  toHex8String: function(e) {
    return "#" + this.toHex8(e);
  },
  toRgb: function() {
    return {
      r: Math.round(this._r),
      g: Math.round(this._g),
      b: Math.round(this._b),
      a: this._a
    };
  },
  toRgbString: function() {
    return this._a == 1 ? "rgb(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ")" : "rgba(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ", " + this._roundA + ")";
  },
  toPercentageRgb: function() {
    return {
      r: Math.round(ki(this._r, 255) * 100) + "%",
      g: Math.round(ki(this._g, 255) * 100) + "%",
      b: Math.round(ki(this._b, 255) * 100) + "%",
      a: this._a
    };
  },
  toPercentageRgbString: function() {
    return this._a == 1 ? "rgb(" + Math.round(ki(this._r, 255) * 100) + "%, " + Math.round(ki(this._g, 255) * 100) + "%, " + Math.round(ki(this._b, 255) * 100) + "%)" : "rgba(" + Math.round(ki(this._r, 255) * 100) + "%, " + Math.round(ki(this._g, 255) * 100) + "%, " + Math.round(ki(this._b, 255) * 100) + "%, " + this._roundA + ")";
  },
  toName: function() {
    return this._a === 0 ? "transparent" : this._a < 1 ? !1 : hX[X4(this._r, this._g, this._b, !0)] || !1;
  },
  toFilter: function(e) {
    var t = "#" + Y4(this._r, this._g, this._b, this._a), n = t, r = this._gradientType ? "GradientType = 1, " : "";
    if (e) {
      var s = Zt(e);
      n = "#" + Y4(s._r, s._g, s._b, s._a);
    }
    return "progid:DXImageTransform.Microsoft.gradient(" + r + "startColorstr=" + t + ",endColorstr=" + n + ")";
  },
  toString: function(e) {
    var t = !!e;
    e = e || this._format;
    var n = !1, r = this._a < 1 && this._a >= 0, s = !t && r && (e === "hex" || e === "hex6" || e === "hex3" || e === "hex4" || e === "hex8" || e === "name");
    return s ? e === "name" && this._a === 0 ? this.toName() : this.toRgbString() : (e === "rgb" && (n = this.toRgbString()), e === "prgb" && (n = this.toPercentageRgbString()), (e === "hex" || e === "hex6") && (n = this.toHexString()), e === "hex3" && (n = this.toHexString(!0)), e === "hex4" && (n = this.toHex8String(!0)), e === "hex8" && (n = this.toHex8String()), e === "name" && (n = this.toName()), e === "hsl" && (n = this.toHslString()), e === "hsv" && (n = this.toHsvString()), n || this.toHexString());
  },
  clone: function() {
    return Zt(this.toString());
  },
  _applyModification: function(e, t) {
    var n = e.apply(null, [this].concat([].slice.call(t)));
    return this._r = n._r, this._g = n._g, this._b = n._b, this.setAlpha(n._a), this;
  },
  lighten: function() {
    return this._applyModification(iX, arguments);
  },
  brighten: function() {
    return this._applyModification(rX, arguments);
  },
  darken: function() {
    return this._applyModification(sX, arguments);
  },
  desaturate: function() {
    return this._applyModification(eX, arguments);
  },
  saturate: function() {
    return this._applyModification(tX, arguments);
  },
  greyscale: function() {
    return this._applyModification(nX, arguments);
  },
  spin: function() {
    return this._applyModification(oX, arguments);
  },
  _applyCombination: function(e, t) {
    return e.apply(null, [this].concat([].slice.call(t)));
  },
  analogous: function() {
    return this._applyCombination(uX, arguments);
  },
  complement: function() {
    return this._applyCombination(aX, arguments);
  },
  monochromatic: function() {
    return this._applyCombination(cX, arguments);
  },
  splitcomplement: function() {
    return this._applyCombination(lX, arguments);
  },
  // Disabled until https://github.com/bgrins/TinyColor/issues/254
  // polyad: function (number) {
  //   return this._applyCombination(polyad, [number]);
  // },
  triad: function() {
    return this._applyCombination(Q4, [3]);
  },
  tetrad: function() {
    return this._applyCombination(Q4, [4]);
  }
};
Zt.fromRatio = function(i, e) {
  if (Q1(i) == "object") {
    var t = {};
    for (var n in i)
      i.hasOwnProperty(n) && (n === "a" ? t[n] = i[n] : t[n] = mp(i[n]));
    i = t;
  }
  return Zt(i, e);
};
function Yj(i) {
  var e = {
    r: 0,
    g: 0,
    b: 0
  }, t = 1, n = null, r = null, s = null, o = !1, a = !1;
  return typeof i == "string" && (i = pX(i)), Q1(i) == "object" && (yl(i.r) && yl(i.g) && yl(i.b) ? (e = Qj(i.r, i.g, i.b), o = !0, a = String(i.r).substr(-1) === "%" ? "prgb" : "rgb") : yl(i.h) && yl(i.s) && yl(i.v) ? (n = mp(i.s), r = mp(i.v), e = Zj(i.h, n, r), o = !0, a = "hsv") : yl(i.h) && yl(i.s) && yl(i.l) && (n = mp(i.s), s = mp(i.l), e = Kj(i.h, n, s), o = !0, a = "hsl"), i.hasOwnProperty("a") && (t = i.a)), t = CP(t), {
    ok: o,
    format: i.format || a,
    r: Math.min(255, Math.max(e.r, 0)),
    g: Math.min(255, Math.max(e.g, 0)),
    b: Math.min(255, Math.max(e.b, 0)),
    a: t
  };
}
function Qj(i, e, t) {
  return {
    r: ki(i, 255) * 255,
    g: ki(e, 255) * 255,
    b: ki(t, 255) * 255
  };
}
function $4(i, e, t) {
  i = ki(i, 255), e = ki(e, 255), t = ki(t, 255);
  var n = Math.max(i, e, t), r = Math.min(i, e, t), s, o, a = (n + r) / 2;
  if (n == r)
    s = o = 0;
  else {
    var l = n - r;
    switch (o = a > 0.5 ? l / (2 - n - r) : l / (n + r), n) {
      case i:
        s = (e - t) / l + (e < t ? 6 : 0);
        break;
      case e:
        s = (t - i) / l + 2;
        break;
      case t:
        s = (i - e) / l + 4;
        break;
    }
    s /= 6;
  }
  return {
    h: s,
    s: o,
    l: a
  };
}
function Kj(i, e, t) {
  var n, r, s;
  i = ki(i, 360), e = ki(e, 100), t = ki(t, 100);
  function o(u, c, A) {
    return A < 0 && (A += 1), A > 1 && (A -= 1), A < 1 / 6 ? u + (c - u) * 6 * A : A < 1 / 2 ? c : A < 2 / 3 ? u + (c - u) * (2 / 3 - A) * 6 : u;
  }
  if (e === 0)
    n = r = s = t;
  else {
    var a = t < 0.5 ? t * (1 + e) : t + e - t * e, l = 2 * t - a;
    n = o(l, a, i + 1 / 3), r = o(l, a, i), s = o(l, a, i - 1 / 3);
  }
  return {
    r: n * 255,
    g: r * 255,
    b: s * 255
  };
}
function j4(i, e, t) {
  i = ki(i, 255), e = ki(e, 255), t = ki(t, 255);
  var n = Math.max(i, e, t), r = Math.min(i, e, t), s, o, a = n, l = n - r;
  if (o = n === 0 ? 0 : l / n, n == r)
    s = 0;
  else {
    switch (n) {
      case i:
        s = (e - t) / l + (e < t ? 6 : 0);
        break;
      case e:
        s = (t - i) / l + 2;
        break;
      case t:
        s = (i - e) / l + 4;
        break;
    }
    s /= 6;
  }
  return {
    h: s,
    s: o,
    v: a
  };
}
function Zj(i, e, t) {
  i = ki(i, 360) * 6, e = ki(e, 100), t = ki(t, 100);
  var n = Math.floor(i), r = i - n, s = t * (1 - e), o = t * (1 - r * e), a = t * (1 - (1 - r) * e), l = n % 6, u = [t, o, s, s, a, t][l], c = [a, t, t, o, s, s][l], A = [s, s, a, t, t, o][l];
  return {
    r: u * 255,
    g: c * 255,
    b: A * 255
  };
}
function X4(i, e, t, n) {
  var r = [_a(Math.round(i).toString(16)), _a(Math.round(e).toString(16)), _a(Math.round(t).toString(16))];
  return n && r[0].charAt(0) == r[0].charAt(1) && r[1].charAt(0) == r[1].charAt(1) && r[2].charAt(0) == r[2].charAt(1) ? r[0].charAt(0) + r[1].charAt(0) + r[2].charAt(0) : r.join("");
}
function Jj(i, e, t, n, r) {
  var s = [_a(Math.round(i).toString(16)), _a(Math.round(e).toString(16)), _a(Math.round(t).toString(16)), _a(PP(n))];
  return r && s[0].charAt(0) == s[0].charAt(1) && s[1].charAt(0) == s[1].charAt(1) && s[2].charAt(0) == s[2].charAt(1) && s[3].charAt(0) == s[3].charAt(1) ? s[0].charAt(0) + s[1].charAt(0) + s[2].charAt(0) + s[3].charAt(0) : s.join("");
}
function Y4(i, e, t, n) {
  var r = [_a(PP(n)), _a(Math.round(i).toString(16)), _a(Math.round(e).toString(16)), _a(Math.round(t).toString(16))];
  return r.join("");
}
Zt.equals = function(i, e) {
  return !i || !e ? !1 : Zt(i).toRgbString() == Zt(e).toRgbString();
};
Zt.random = function() {
  return Zt.fromRatio({
    r: Math.random(),
    g: Math.random(),
    b: Math.random()
  });
};
function eX(i, e) {
  e = e === 0 ? 0 : e || 10;
  var t = Zt(i).toHsl();
  return t.s -= e / 100, t.s = T2(t.s), Zt(t);
}
function tX(i, e) {
  e = e === 0 ? 0 : e || 10;
  var t = Zt(i).toHsl();
  return t.s += e / 100, t.s = T2(t.s), Zt(t);
}
function nX(i) {
  return Zt(i).desaturate(100);
}
function iX(i, e) {
  e = e === 0 ? 0 : e || 10;
  var t = Zt(i).toHsl();
  return t.l += e / 100, t.l = T2(t.l), Zt(t);
}
function rX(i, e) {
  e = e === 0 ? 0 : e || 10;
  var t = Zt(i).toRgb();
  return t.r = Math.max(0, Math.min(255, t.r - Math.round(255 * -(e / 100)))), t.g = Math.max(0, Math.min(255, t.g - Math.round(255 * -(e / 100)))), t.b = Math.max(0, Math.min(255, t.b - Math.round(255 * -(e / 100)))), Zt(t);
}
function sX(i, e) {
  e = e === 0 ? 0 : e || 10;
  var t = Zt(i).toHsl();
  return t.l -= e / 100, t.l = T2(t.l), Zt(t);
}
function oX(i, e) {
  var t = Zt(i).toHsl(), n = (t.h + e) % 360;
  return t.h = n < 0 ? 360 + n : n, Zt(t);
}
function aX(i) {
  var e = Zt(i).toHsl();
  return e.h = (e.h + 180) % 360, Zt(e);
}
function Q4(i, e) {
  if (isNaN(e) || e <= 0)
    throw new Error("Argument to polyad must be a positive number");
  for (var t = Zt(i).toHsl(), n = [Zt(i)], r = 360 / e, s = 1; s < e; s++)
    n.push(Zt({
      h: (t.h + s * r) % 360,
      s: t.s,
      l: t.l
    }));
  return n;
}
function lX(i) {
  var e = Zt(i).toHsl(), t = e.h;
  return [Zt(i), Zt({
    h: (t + 72) % 360,
    s: e.s,
    l: e.l
  }), Zt({
    h: (t + 216) % 360,
    s: e.s,
    l: e.l
  })];
}
function uX(i, e, t) {
  e = e || 6, t = t || 30;
  var n = Zt(i).toHsl(), r = 360 / t, s = [Zt(i)];
  for (n.h = (n.h - (r * e >> 1) + 720) % 360; --e; )
    n.h = (n.h + r) % 360, s.push(Zt(n));
  return s;
}
function cX(i, e) {
  e = e || 6;
  for (var t = Zt(i).toHsv(), n = t.h, r = t.s, s = t.v, o = [], a = 1 / e; e--; )
    o.push(Zt({
      h: n,
      s: r,
      v: s
    })), s = (s + a) % 1;
  return o;
}
Zt.mix = function(i, e, t) {
  t = t === 0 ? 0 : t || 50;
  var n = Zt(i).toRgb(), r = Zt(e).toRgb(), s = t / 100, o = {
    r: (r.r - n.r) * s + n.r,
    g: (r.g - n.g) * s + n.g,
    b: (r.b - n.b) * s + n.b,
    a: (r.a - n.a) * s + n.a
  };
  return Zt(o);
};
Zt.readability = function(i, e) {
  var t = Zt(i), n = Zt(e);
  return (Math.max(t.getLuminance(), n.getLuminance()) + 0.05) / (Math.min(t.getLuminance(), n.getLuminance()) + 0.05);
};
Zt.isReadable = function(i, e, t) {
  var n = Zt.readability(i, e), r, s;
  switch (s = !1, r = mX(t), r.level + r.size) {
    case "AAsmall":
    case "AAAlarge":
      s = n >= 4.5;
      break;
    case "AAlarge":
      s = n >= 3;
      break;
    case "AAAsmall":
      s = n >= 7;
      break;
  }
  return s;
};
Zt.mostReadable = function(i, e, t) {
  var n = null, r = 0, s, o, a, l;
  t = t || {}, o = t.includeFallbackColors, a = t.level, l = t.size;
  for (var u = 0; u < e.length; u++)
    s = Zt.readability(i, e[u]), s > r && (r = s, n = Zt(e[u]));
  return Zt.isReadable(i, n, {
    level: a,
    size: l
  }) || !o ? n : (t.includeFallbackColors = !1, Zt.mostReadable(i, ["#fff", "#000"], t));
};
var wb = Zt.names = {
  aliceblue: "f0f8ff",
  antiquewhite: "faebd7",
  aqua: "0ff",
  aquamarine: "7fffd4",
  azure: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "000",
  blanchedalmond: "ffebcd",
  blue: "00f",
  blueviolet: "8a2be2",
  brown: "a52a2a",
  burlywood: "deb887",
  burntsienna: "ea7e5d",
  cadetblue: "5f9ea0",
  chartreuse: "7fff00",
  chocolate: "d2691e",
  coral: "ff7f50",
  cornflowerblue: "6495ed",
  cornsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "0ff",
  darkblue: "00008b",
  darkcyan: "008b8b",
  darkgoldenrod: "b8860b",
  darkgray: "a9a9a9",
  darkgreen: "006400",
  darkgrey: "a9a9a9",
  darkkhaki: "bdb76b",
  darkmagenta: "8b008b",
  darkolivegreen: "556b2f",
  darkorange: "ff8c00",
  darkorchid: "9932cc",
  darkred: "8b0000",
  darksalmon: "e9967a",
  darkseagreen: "8fbc8f",
  darkslateblue: "483d8b",
  darkslategray: "2f4f4f",
  darkslategrey: "2f4f4f",
  darkturquoise: "00ced1",
  darkviolet: "9400d3",
  deeppink: "ff1493",
  deepskyblue: "00bfff",
  dimgray: "696969",
  dimgrey: "696969",
  dodgerblue: "1e90ff",
  firebrick: "b22222",
  floralwhite: "fffaf0",
  forestgreen: "228b22",
  fuchsia: "f0f",
  gainsboro: "dcdcdc",
  ghostwhite: "f8f8ff",
  gold: "ffd700",
  goldenrod: "daa520",
  gray: "808080",
  green: "008000",
  greenyellow: "adff2f",
  grey: "808080",
  honeydew: "f0fff0",
  hotpink: "ff69b4",
  indianred: "cd5c5c",
  indigo: "4b0082",
  ivory: "fffff0",
  khaki: "f0e68c",
  lavender: "e6e6fa",
  lavenderblush: "fff0f5",
  lawngreen: "7cfc00",
  lemonchiffon: "fffacd",
  lightblue: "add8e6",
  lightcoral: "f08080",
  lightcyan: "e0ffff",
  lightgoldenrodyellow: "fafad2",
  lightgray: "d3d3d3",
  lightgreen: "90ee90",
  lightgrey: "d3d3d3",
  lightpink: "ffb6c1",
  lightsalmon: "ffa07a",
  lightseagreen: "20b2aa",
  lightskyblue: "87cefa",
  lightslategray: "789",
  lightslategrey: "789",
  lightsteelblue: "b0c4de",
  lightyellow: "ffffe0",
  lime: "0f0",
  limegreen: "32cd32",
  linen: "faf0e6",
  magenta: "f0f",
  maroon: "800000",
  mediumaquamarine: "66cdaa",
  mediumblue: "0000cd",
  mediumorchid: "ba55d3",
  mediumpurple: "9370db",
  mediumseagreen: "3cb371",
  mediumslateblue: "7b68ee",
  mediumspringgreen: "00fa9a",
  mediumturquoise: "48d1cc",
  mediumvioletred: "c71585",
  midnightblue: "191970",
  mintcream: "f5fffa",
  mistyrose: "ffe4e1",
  moccasin: "ffe4b5",
  navajowhite: "ffdead",
  navy: "000080",
  oldlace: "fdf5e6",
  olive: "808000",
  olivedrab: "6b8e23",
  orange: "ffa500",
  orangered: "ff4500",
  orchid: "da70d6",
  palegoldenrod: "eee8aa",
  palegreen: "98fb98",
  paleturquoise: "afeeee",
  palevioletred: "db7093",
  papayawhip: "ffefd5",
  peachpuff: "ffdab9",
  peru: "cd853f",
  pink: "ffc0cb",
  plum: "dda0dd",
  powderblue: "b0e0e6",
  purple: "800080",
  rebeccapurple: "663399",
  red: "f00",
  rosybrown: "bc8f8f",
  royalblue: "4169e1",
  saddlebrown: "8b4513",
  salmon: "fa8072",
  sandybrown: "f4a460",
  seagreen: "2e8b57",
  seashell: "fff5ee",
  sienna: "a0522d",
  silver: "c0c0c0",
  skyblue: "87ceeb",
  slateblue: "6a5acd",
  slategray: "708090",
  slategrey: "708090",
  snow: "fffafa",
  springgreen: "00ff7f",
  steelblue: "4682b4",
  tan: "d2b48c",
  teal: "008080",
  thistle: "d8bfd8",
  tomato: "ff6347",
  turquoise: "40e0d0",
  violet: "ee82ee",
  wheat: "f5deb3",
  white: "fff",
  whitesmoke: "f5f5f5",
  yellow: "ff0",
  yellowgreen: "9acd32"
}, hX = Zt.hexNames = dX(wb);
function dX(i) {
  var e = {};
  for (var t in i)
    i.hasOwnProperty(t) && (e[i[t]] = t);
  return e;
}
function CP(i) {
  return i = parseFloat(i), (isNaN(i) || i < 0 || i > 1) && (i = 1), i;
}
function ki(i, e) {
  fX(i) && (i = "100%");
  var t = AX(i);
  return i = Math.min(e, Math.max(0, parseFloat(i))), t && (i = parseInt(i * e, 10) / 100), Math.abs(i - e) < 1e-6 ? 1 : i % e / parseFloat(e);
}
function T2(i) {
  return Math.min(1, Math.max(0, i));
}
function mo(i) {
  return parseInt(i, 16);
}
function fX(i) {
  return typeof i == "string" && i.indexOf(".") != -1 && parseFloat(i) === 1;
}
function AX(i) {
  return typeof i == "string" && i.indexOf("%") != -1;
}
function _a(i) {
  return i.length == 1 ? "0" + i : "" + i;
}
function mp(i) {
  return i <= 1 && (i = i * 100 + "%"), i;
}
function PP(i) {
  return Math.round(parseFloat(i) * 255).toString(16);
}
function K4(i) {
  return mo(i) / 255;
}
var ua = (function() {
  var i = "[-\\+]?\\d+%?", e = "[-\\+]?\\d*\\.\\d+%?", t = "(?:" + e + ")|(?:" + i + ")", n = "[\\s|\\(]+(" + t + ")[,|\\s]+(" + t + ")[,|\\s]+(" + t + ")\\s*\\)?", r = "[\\s|\\(]+(" + t + ")[,|\\s]+(" + t + ")[,|\\s]+(" + t + ")[,|\\s]+(" + t + ")\\s*\\)?";
  return {
    CSS_UNIT: new RegExp(t),
    rgb: new RegExp("rgb" + n),
    rgba: new RegExp("rgba" + r),
    hsl: new RegExp("hsl" + n),
    hsla: new RegExp("hsla" + r),
    hsv: new RegExp("hsv" + n),
    hsva: new RegExp("hsva" + r),
    hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
    hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
  };
})();
function yl(i) {
  return !!ua.CSS_UNIT.exec(i);
}
function pX(i) {
  i = i.replace(jj, "").replace(Xj, "").toLowerCase();
  var e = !1;
  if (wb[i])
    i = wb[i], e = !0;
  else if (i == "transparent")
    return {
      r: 0,
      g: 0,
      b: 0,
      a: 0,
      format: "name"
    };
  var t;
  return (t = ua.rgb.exec(i)) ? {
    r: t[1],
    g: t[2],
    b: t[3]
  } : (t = ua.rgba.exec(i)) ? {
    r: t[1],
    g: t[2],
    b: t[3],
    a: t[4]
  } : (t = ua.hsl.exec(i)) ? {
    h: t[1],
    s: t[2],
    l: t[3]
  } : (t = ua.hsla.exec(i)) ? {
    h: t[1],
    s: t[2],
    l: t[3],
    a: t[4]
  } : (t = ua.hsv.exec(i)) ? {
    h: t[1],
    s: t[2],
    v: t[3]
  } : (t = ua.hsva.exec(i)) ? {
    h: t[1],
    s: t[2],
    v: t[3],
    a: t[4]
  } : (t = ua.hex8.exec(i)) ? {
    r: mo(t[1]),
    g: mo(t[2]),
    b: mo(t[3]),
    a: K4(t[4]),
    format: e ? "name" : "hex8"
  } : (t = ua.hex6.exec(i)) ? {
    r: mo(t[1]),
    g: mo(t[2]),
    b: mo(t[3]),
    format: e ? "name" : "hex"
  } : (t = ua.hex4.exec(i)) ? {
    r: mo(t[1] + "" + t[1]),
    g: mo(t[2] + "" + t[2]),
    b: mo(t[3] + "" + t[3]),
    a: K4(t[4] + "" + t[4]),
    format: e ? "name" : "hex8"
  } : (t = ua.hex3.exec(i)) ? {
    r: mo(t[1] + "" + t[1]),
    g: mo(t[2] + "" + t[2]),
    b: mo(t[3] + "" + t[3]),
    format: e ? "name" : "hex"
  } : !1;
}
function mX(i) {
  var e, t;
  return i = i || {
    level: "AA",
    size: "small"
  }, e = (i.level || "AA").toUpperCase(), t = (i.size || "small").toLowerCase(), e !== "AA" && e !== "AAA" && (e = "AA"), t !== "small" && t !== "large" && (t = "small"), {
    level: e,
    size: t
  };
}
function Mb(i, e) {
  (e == null || e > i.length) && (e = i.length);
  for (var t = 0, n = Array(e); t < e; t++) n[t] = i[t];
  return n;
}
function gX(i) {
  if (Array.isArray(i)) return i;
}
function _X(i) {
  if (Array.isArray(i)) return Mb(i);
}
function NP(i, e, t) {
  if (typeof i == "function" ? i === e : i.has(e)) return arguments.length < 3 ? e : t;
  throw new TypeError("Private element is not present on this object");
}
function xX(i, e) {
  if (e.has(i)) throw new TypeError("Cannot initialize the same private elements twice on an object");
}
function yX(i, e) {
  if (!(i instanceof e)) throw new TypeError("Cannot call a class as a function");
}
function ls(i, e) {
  return i.get(NP(i, e));
}
function Vd(i, e, t) {
  xX(i, e), e.set(i, t);
}
function og(i, e, t) {
  return i.set(NP(i, e), t), t;
}
function vX(i, e) {
  for (var t = 0; t < e.length; t++) {
    var n = e[t];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(i, PX(n.key), n);
  }
}
function bX(i, e, t) {
  return e && vX(i.prototype, e), Object.defineProperty(i, "prototype", {
    writable: !1
  }), i;
}
function SX(i) {
  if (typeof Symbol < "u" && i[Symbol.iterator] != null || i["@@iterator"] != null) return Array.from(i);
}
function TX(i, e) {
  var t = i == null ? null : typeof Symbol < "u" && i[Symbol.iterator] || i["@@iterator"];
  if (t != null) {
    var n, r, s, o, a = [], l = !0, u = !1;
    try {
      if (s = (t = t.call(i)).next, e !== 0) for (; !(l = (n = s.call(t)).done) && (a.push(n.value), a.length !== e); l = !0) ;
    } catch (c) {
      u = !0, r = c;
    } finally {
      try {
        if (!l && t.return != null && (o = t.return(), Object(o) !== o)) return;
      } finally {
        if (u) throw r;
      }
    }
    return a;
  }
}
function wX() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function MX() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function EX(i, e) {
  return gX(i) || TX(i, e) || DP(i, e) || wX();
}
function RX(i) {
  return _X(i) || SX(i) || DP(i) || MX();
}
function CX(i, e) {
  if (typeof i != "object" || !i) return i;
  var t = i[Symbol.toPrimitive];
  if (t !== void 0) {
    var n = t.call(i, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(i);
}
function PX(i) {
  var e = CX(i, "string");
  return typeof e == "symbol" ? e : e + "";
}
function DP(i, e) {
  if (i) {
    if (typeof i == "string") return Mb(i, e);
    var t = {}.toString.call(i).slice(8, -1);
    return t === "Object" && i.constructor && (t = i.constructor.name), t === "Map" || t === "Set" ? Array.from(i) : t === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? Mb(i, e) : void 0;
  }
}
var Gd = /* @__PURE__ */ new WeakMap(), GA = /* @__PURE__ */ new WeakMap(), zd = /* @__PURE__ */ new WeakMap(), Uy = /* @__PURE__ */ new WeakMap(), Oy = /* @__PURE__ */ new WeakMap(), ky = /* @__PURE__ */ new WeakMap(), NX = /* @__PURE__ */ (function() {
  function i() {
    yX(this, i), Vd(this, Gd, /* @__PURE__ */ new Map()), Vd(this, GA, /* @__PURE__ */ new Map()), Vd(this, zd, function(e) {
      return e;
    }), Vd(this, Uy, function() {
      return {};
    }), Vd(this, Oy, function() {
    }), Vd(this, ky, function() {
    });
  }
  return bX(i, [{
    key: "getObj",
    value: function(t) {
      return ls(Gd, this).get(ls(zd, this).call(this, t));
    }
  }, {
    key: "getData",
    value: function(t) {
      return ls(GA, this).get(t);
    }
  }, {
    key: "entries",
    value: function() {
      return RX(ls(GA, this).entries()).map(function(t) {
        var n = EX(t, 2), r = n[0], s = n[1];
        return [s, r];
      });
    }
  }, {
    key: "id",
    value: function(t) {
      return og(zd, this, je(t)), this;
    }
  }, {
    key: "onCreateObj",
    value: function(t) {
      return og(Uy, this, t), this;
    }
  }, {
    key: "onUpdateObj",
    value: function(t) {
      return og(Oy, this, t), this;
    }
  }, {
    key: "onRemoveObj",
    value: function(t) {
      return og(ky, this, t), this;
    }
  }, {
    key: "digest",
    value: function(t) {
      var n = this;
      t.filter(function(s) {
        return !ls(Gd, n).has(ls(zd, n).call(n, s));
      }).forEach(function(s) {
        var o = ls(Uy, n).call(n, s);
        ls(Gd, n).set(ls(zd, n).call(n, s), o), ls(GA, n).set(o, s);
      });
      var r = new Map(t.map(function(s) {
        return [ls(zd, n).call(n, s), s];
      }));
      return ls(Gd, this).forEach(function(s, o) {
        r.has(o) ? ls(Oy, n).call(n, s, r.get(o)) : (ls(ky, n).call(n, s, o), ls(Gd, n).delete(o), ls(GA, n).delete(s));
      }), this;
    }
  }, {
    key: "clear",
    value: function() {
      return this.digest([]), this;
    }
  }]);
})();
function DX(i) {
  return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i;
}
var Jg = { exports: {} }, LX = Jg.exports, Z4;
function IX() {
  return Z4 || (Z4 = 1, (function(i, e) {
    (function(t, n) {
      i.exports = n();
    })(LX, function() {
      return (function(t) {
        function n(s) {
          if (r[s]) return r[s].exports;
          var o = r[s] = { exports: {}, id: s, loaded: !1 };
          return t[s].call(o.exports, o, o.exports, n), o.loaded = !0, o.exports;
        }
        var r = {};
        return n.m = t, n.c = r, n.p = "", n(0);
      })([function(t, n, r) {
        var s = r(1), o = (function() {
          function a(l, u, c) {
            l === void 0 && (l = NaN), u === void 0 && (u = NaN), c === void 0 && (c = !1), this._minFPS = u, this._maxFPS = l, this._timeScale = 1, this._currentTick = 0, this._currentTime = 0, this._tickDeltaTime = 0, this._isRunning = !1, this._maxInterval = isNaN(this._minFPS) ? NaN : 1e3 / this._minFPS, this._minInterval = isNaN(this._maxFPS) ? NaN : 1e3 / this._maxFPS, this._onResume = new s.default(), this._onPause = new s.default(), this._onTick = new s.default(), this._onTickOncePerFrame = new s.default(), c || this.resume();
          }
          return a.prototype.updateOnce = function(l) {
            l(this.currentTimeSeconds, this.tickDeltaTimeSeconds, this.currentTick);
          }, a.prototype.resume = function() {
            this._isRunning || (this._isRunning = !0, this._lastTimeUpdated = this.getTimer(), this._onResume.dispatch(), this.animateOnce());
          }, a.prototype.pause = function() {
            this._isRunning && (this._isRunning = !1, this._onPause.dispatch(), window.cancelAnimationFrame(this._animationFrameHandle));
          }, a.prototype.dispose = function() {
            this.pause(), this._onResume.removeAll(), this._onPause.removeAll(), this._onTick.removeAll();
          }, Object.defineProperty(a.prototype, "currentTick", { get: function() {
            return this._currentTick;
          }, enumerable: !0, configurable: !0 }), Object.defineProperty(a.prototype, "currentTimeSeconds", { get: function() {
            return this._currentTime / 1e3;
          }, enumerable: !0, configurable: !0 }), Object.defineProperty(a.prototype, "tickDeltaTimeSeconds", { get: function() {
            return this._tickDeltaTime / 1e3;
          }, enumerable: !0, configurable: !0 }), Object.defineProperty(a.prototype, "timeScale", { get: function() {
            return this._timeScale;
          }, set: function(l) {
            this._timeScale !== l && (this._timeScale = l);
          }, enumerable: !0, configurable: !0 }), Object.defineProperty(a.prototype, "onResume", { get: function() {
            return this._onResume;
          }, enumerable: !0, configurable: !0 }), Object.defineProperty(a.prototype, "onPause", { get: function() {
            return this._onPause;
          }, enumerable: !0, configurable: !0 }), Object.defineProperty(a.prototype, "onTick", { get: function() {
            return this._onTick;
          }, enumerable: !0, configurable: !0 }), Object.defineProperty(a.prototype, "onTickOncePerFrame", { get: function() {
            return this._onTickOncePerFrame;
          }, enumerable: !0, configurable: !0 }), Object.defineProperty(a.prototype, "isRunning", { get: function() {
            return this._isRunning;
          }, enumerable: !0, configurable: !0 }), a.prototype.animateOnce = function() {
            var l = this;
            this._animationFrameHandle = window.requestAnimationFrame(function() {
              return l.onFrame();
            });
          }, a.prototype.onFrame = function() {
            if (this._now = this.getTimer(), this._frameDeltaTime = this._now - this._lastTimeUpdated, isNaN(this._minInterval) || this._frameDeltaTime >= this._minInterval) if (isNaN(this._maxInterval)) this.update(this._frameDeltaTime * this._timeScale, !0), this._lastTimeUpdated = this._now;
            else for (this._interval = Math.min(this._frameDeltaTime, this._maxInterval); this._now >= this._lastTimeUpdated + this._interval; ) this.update(this._interval * this._timeScale, this._now <= this._lastTimeUpdated + 2 * this._maxInterval), this._lastTimeUpdated += this._interval;
            this._isRunning && this.animateOnce();
          }, a.prototype.update = function(l, u) {
            u === void 0 && (u = !0), this._currentTick++, this._currentTime += l, this._tickDeltaTime = l, this._onTick.dispatch(this.currentTimeSeconds, this.tickDeltaTimeSeconds, this.currentTick), u && this._onTickOncePerFrame.dispatch(this.currentTimeSeconds, this.tickDeltaTimeSeconds, this.currentTick);
          }, a.prototype.getTimer = function() {
            return Date.now();
          }, a;
        })();
        Object.defineProperty(n, "__esModule", { value: !0 }), n.default = o;
      }, function(t, n, r) {
        (function(s, o) {
          t.exports = o();
        })(this, function() {
          return (function(s) {
            function o(l) {
              if (a[l]) return a[l].exports;
              var u = a[l] = { exports: {}, id: l, loaded: !1 };
              return s[l].call(u.exports, u, u.exports, o), u.loaded = !0, u.exports;
            }
            var a = {};
            return o.m = s, o.c = a, o.p = "", o(0);
          })([function(s, o) {
            var a = (function() {
              function l() {
                this.functions = [];
              }
              return l.prototype.add = function(u) {
                return this.functions.indexOf(u) === -1 && (this.functions.push(u), !0);
              }, l.prototype.remove = function(u) {
                var c = this.functions.indexOf(u);
                return c > -1 && (this.functions.splice(c, 1), !0);
              }, l.prototype.removeAll = function() {
                return this.functions.length > 0 && (this.functions.length = 0, !0);
              }, l.prototype.dispatch = function() {
                for (var u = [], c = 0; c < arguments.length; c++) u[c] = arguments[c];
                var A = this.functions.concat();
                A.forEach(function(m) {
                  m.apply(void 0, u);
                });
              }, Object.defineProperty(l.prototype, "numItems", { get: function() {
                return this.functions.length;
              }, enumerable: !0, configurable: !0 }), l;
            })();
            Object.defineProperty(o, "__esModule", { value: !0 }), o.default = a;
          }]);
        });
      }]);
    });
  })(Jg)), Jg.exports;
}
var BX = IX();
const $f = /* @__PURE__ */ DX(BX), Il = 11102230246251565e-32, us = 134217729, FX = (3 + 8 * Il) * Il;
function Vy(i, e, t, n, r) {
  let s, o, a, l, u = e[0], c = n[0], A = 0, m = 0;
  c > u == c > -u ? (s = u, u = e[++A]) : (s = c, c = n[++m]);
  let _ = 0;
  if (A < i && m < t)
    for (c > u == c > -u ? (o = u + s, a = s - (o - u), u = e[++A]) : (o = c + s, a = s - (o - c), c = n[++m]), s = o, a !== 0 && (r[_++] = a); A < i && m < t; )
      c > u == c > -u ? (o = s + u, l = o - s, a = s - (o - l) + (u - l), u = e[++A]) : (o = s + c, l = o - s, a = s - (o - l) + (c - l), c = n[++m]), s = o, a !== 0 && (r[_++] = a);
  for (; A < i; )
    o = s + u, l = o - s, a = s - (o - l) + (u - l), u = e[++A], s = o, a !== 0 && (r[_++] = a);
  for (; m < t; )
    o = s + c, l = o - s, a = s - (o - l) + (c - l), c = n[++m], s = o, a !== 0 && (r[_++] = a);
  return (s !== 0 || _ === 0) && (r[_++] = s), _;
}
function UX(i, e) {
  let t = e[0];
  for (let n = 1; n < i; n++) t += e[n];
  return t;
}
function B0(i) {
  return new Float64Array(i);
}
const OX = (3 + 16 * Il) * Il, kX = (2 + 12 * Il) * Il, VX = (9 + 64 * Il) * Il * Il, qd = B0(4), J4 = B0(8), eR = B0(12), tR = B0(16), Ts = B0(4);
function GX(i, e, t, n, r, s, o) {
  let a, l, u, c, A, m, _, y, T, b, S, E, R, C, L, D, B, U;
  const N = i - r, O = t - r, G = e - s, H = n - s;
  C = N * H, m = us * N, _ = m - (m - N), y = N - _, m = us * H, T = m - (m - H), b = H - T, L = y * b - (C - _ * T - y * T - _ * b), D = G * O, m = us * G, _ = m - (m - G), y = G - _, m = us * O, T = m - (m - O), b = O - T, B = y * b - (D - _ * T - y * T - _ * b), S = L - B, A = L - S, qd[0] = L - (S + A) + (A - B), E = C + S, A = E - C, R = C - (E - A) + (S - A), S = R - D, A = R - S, qd[1] = R - (S + A) + (A - D), U = E + S, A = U - E, qd[2] = E - (U - A) + (S - A), qd[3] = U;
  let Y = UX(4, qd), K = kX * o;
  if (Y >= K || -Y >= K || (A = i - N, a = i - (N + A) + (A - r), A = t - O, u = t - (O + A) + (A - r), A = e - G, l = e - (G + A) + (A - s), A = n - H, c = n - (H + A) + (A - s), a === 0 && l === 0 && u === 0 && c === 0) || (K = VX * o + FX * Math.abs(Y), Y += N * c + H * a - (G * u + O * l), Y >= K || -Y >= K)) return Y;
  C = a * H, m = us * a, _ = m - (m - a), y = a - _, m = us * H, T = m - (m - H), b = H - T, L = y * b - (C - _ * T - y * T - _ * b), D = l * O, m = us * l, _ = m - (m - l), y = l - _, m = us * O, T = m - (m - O), b = O - T, B = y * b - (D - _ * T - y * T - _ * b), S = L - B, A = L - S, Ts[0] = L - (S + A) + (A - B), E = C + S, A = E - C, R = C - (E - A) + (S - A), S = R - D, A = R - S, Ts[1] = R - (S + A) + (A - D), U = E + S, A = U - E, Ts[2] = E - (U - A) + (S - A), Ts[3] = U;
  const X = Vy(4, qd, 4, Ts, J4);
  C = N * c, m = us * N, _ = m - (m - N), y = N - _, m = us * c, T = m - (m - c), b = c - T, L = y * b - (C - _ * T - y * T - _ * b), D = G * u, m = us * G, _ = m - (m - G), y = G - _, m = us * u, T = m - (m - u), b = u - T, B = y * b - (D - _ * T - y * T - _ * b), S = L - B, A = L - S, Ts[0] = L - (S + A) + (A - B), E = C + S, A = E - C, R = C - (E - A) + (S - A), S = R - D, A = R - S, Ts[1] = R - (S + A) + (A - D), U = E + S, A = U - E, Ts[2] = E - (U - A) + (S - A), Ts[3] = U;
  const ee = Vy(X, J4, 4, Ts, eR);
  C = a * c, m = us * a, _ = m - (m - a), y = a - _, m = us * c, T = m - (m - c), b = c - T, L = y * b - (C - _ * T - y * T - _ * b), D = l * u, m = us * l, _ = m - (m - l), y = l - _, m = us * u, T = m - (m - u), b = u - T, B = y * b - (D - _ * T - y * T - _ * b), S = L - B, A = L - S, Ts[0] = L - (S + A) + (A - B), E = C + S, A = E - C, R = C - (E - A) + (S - A), S = R - D, A = R - S, Ts[1] = R - (S + A) + (A - D), U = E + S, A = U - E, Ts[2] = E - (U - A) + (S - A), Ts[3] = U;
  const oe = Vy(ee, eR, 4, Ts, tR);
  return tR[oe - 1];
}
function gp(i, e, t, n, r, s) {
  const o = (e - s) * (t - r), a = (i - r) * (n - s), l = o - a, u = Math.abs(o + a);
  return Math.abs(l) >= OX * u ? l : -GX(i, e, t, n, r, s, u);
}
const nR = Math.pow(2, -52), ag = new Uint32Array(512);
class t0 {
  static from(e, t = $X, n = jX) {
    const r = e.length, s = new Float64Array(r * 2);
    for (let o = 0; o < r; o++) {
      const a = e[o];
      s[2 * o] = t(a), s[2 * o + 1] = n(a);
    }
    return new t0(s);
  }
  constructor(e) {
    const t = e.length >> 1;
    if (t > 0 && typeof e[0] != "number") throw new Error("Expected coords to contain numbers.");
    this.coords = e;
    const n = Math.max(2 * t - 5, 0);
    this._triangles = new Uint32Array(n * 3), this._halfedges = new Int32Array(n * 3), this._hashSize = Math.ceil(Math.sqrt(t)), this._hullPrev = new Uint32Array(t), this._hullNext = new Uint32Array(t), this._hullTri = new Uint32Array(t), this._hullHash = new Int32Array(this._hashSize), this._ids = new Uint32Array(t), this._dists = new Float64Array(t), this.update();
  }
  update() {
    const { coords: e, _hullPrev: t, _hullNext: n, _hullTri: r, _hullHash: s } = this, o = e.length >> 1;
    let a = 1 / 0, l = 1 / 0, u = -1 / 0, c = -1 / 0;
    for (let N = 0; N < o; N++) {
      const O = e[2 * N], G = e[2 * N + 1];
      O < a && (a = O), G < l && (l = G), O > u && (u = O), G > c && (c = G), this._ids[N] = N;
    }
    const A = (a + u) / 2, m = (l + c) / 2;
    let _, y, T;
    for (let N = 0, O = 1 / 0; N < o; N++) {
      const G = Gy(A, m, e[2 * N], e[2 * N + 1]);
      G < O && (_ = N, O = G);
    }
    const b = e[2 * _], S = e[2 * _ + 1];
    for (let N = 0, O = 1 / 0; N < o; N++) {
      if (N === _) continue;
      const G = Gy(b, S, e[2 * N], e[2 * N + 1]);
      G < O && G > 0 && (y = N, O = G);
    }
    let E = e[2 * y], R = e[2 * y + 1], C = 1 / 0;
    for (let N = 0; N < o; N++) {
      if (N === _ || N === y) continue;
      const O = HX(b, S, E, R, e[2 * N], e[2 * N + 1]);
      O < C && (T = N, C = O);
    }
    let L = e[2 * T], D = e[2 * T + 1];
    if (C === 1 / 0) {
      for (let G = 0; G < o; G++)
        this._dists[G] = e[2 * G] - e[0] || e[2 * G + 1] - e[1];
      cf(this._ids, this._dists, 0, o - 1);
      const N = new Uint32Array(o);
      let O = 0;
      for (let G = 0, H = -1 / 0; G < o; G++) {
        const Y = this._ids[G], K = this._dists[Y];
        K > H && (N[O++] = Y, H = K);
      }
      this.hull = N.subarray(0, O), this.triangles = new Uint32Array(0), this.halfedges = new Uint32Array(0);
      return;
    }
    if (gp(b, S, E, R, L, D) < 0) {
      const N = y, O = E, G = R;
      y = T, E = L, R = D, T = N, L = O, D = G;
    }
    const B = WX(b, S, E, R, L, D);
    this._cx = B.x, this._cy = B.y;
    for (let N = 0; N < o; N++)
      this._dists[N] = Gy(e[2 * N], e[2 * N + 1], B.x, B.y);
    cf(this._ids, this._dists, 0, o - 1), this._hullStart = _;
    let U = 3;
    n[_] = t[T] = y, n[y] = t[_] = T, n[T] = t[y] = _, r[_] = 0, r[y] = 1, r[T] = 2, s.fill(-1), s[this._hashKey(b, S)] = _, s[this._hashKey(E, R)] = y, s[this._hashKey(L, D)] = T, this.trianglesLen = 0, this._addTriangle(_, y, T, -1, -1, -1);
    for (let N = 0, O, G; N < this._ids.length; N++) {
      const H = this._ids[N], Y = e[2 * H], K = e[2 * H + 1];
      if (N > 0 && Math.abs(Y - O) <= nR && Math.abs(K - G) <= nR || (O = Y, G = K, H === _ || H === y || H === T)) continue;
      let X = 0;
      for (let Te = 0, Ce = this._hashKey(Y, K); Te < this._hashSize && (X = s[(Ce + Te) % this._hashSize], !(X !== -1 && X !== n[X])); Te++)
        ;
      X = t[X];
      let ee = X, oe;
      for (; oe = n[ee], gp(Y, K, e[2 * ee], e[2 * ee + 1], e[2 * oe], e[2 * oe + 1]) >= 0; )
        if (ee = oe, ee === X) {
          ee = -1;
          break;
        }
      if (ee === -1) continue;
      let fe = this._addTriangle(ee, H, n[ee], -1, -1, r[ee]);
      r[H] = this._legalize(fe + 2), r[ee] = fe, U++;
      let _e = n[ee];
      for (; oe = n[_e], gp(Y, K, e[2 * _e], e[2 * _e + 1], e[2 * oe], e[2 * oe + 1]) < 0; )
        fe = this._addTriangle(_e, H, oe, r[H], -1, r[_e]), r[H] = this._legalize(fe + 2), n[_e] = _e, U--, _e = oe;
      if (ee === X)
        for (; oe = t[ee], gp(Y, K, e[2 * oe], e[2 * oe + 1], e[2 * ee], e[2 * ee + 1]) < 0; )
          fe = this._addTriangle(oe, H, ee, -1, r[ee], r[oe]), this._legalize(fe + 2), r[oe] = fe, n[ee] = ee, U--, ee = oe;
      this._hullStart = t[H] = ee, n[ee] = t[_e] = H, n[H] = _e, s[this._hashKey(Y, K)] = H, s[this._hashKey(e[2 * ee], e[2 * ee + 1])] = ee;
    }
    this.hull = new Uint32Array(U);
    for (let N = 0, O = this._hullStart; N < U; N++)
      this.hull[N] = O, O = n[O];
    this.triangles = this._triangles.subarray(0, this.trianglesLen), this.halfedges = this._halfedges.subarray(0, this.trianglesLen);
  }
  _hashKey(e, t) {
    return Math.floor(zX(e - this._cx, t - this._cy) * this._hashSize) % this._hashSize;
  }
  _legalize(e) {
    const { _triangles: t, _halfedges: n, coords: r } = this;
    let s = 0, o = 0;
    for (; ; ) {
      const a = n[e], l = e - e % 3;
      if (o = l + (e + 2) % 3, a === -1) {
        if (s === 0) break;
        e = ag[--s];
        continue;
      }
      const u = a - a % 3, c = l + (e + 1) % 3, A = u + (a + 2) % 3, m = t[o], _ = t[e], y = t[c], T = t[A];
      if (qX(
        r[2 * m],
        r[2 * m + 1],
        r[2 * _],
        r[2 * _ + 1],
        r[2 * y],
        r[2 * y + 1],
        r[2 * T],
        r[2 * T + 1]
      )) {
        t[e] = T, t[a] = m;
        const S = n[A];
        if (S === -1) {
          let R = this._hullStart;
          do {
            if (this._hullTri[R] === A) {
              this._hullTri[R] = e;
              break;
            }
            R = this._hullPrev[R];
          } while (R !== this._hullStart);
        }
        this._link(e, S), this._link(a, n[o]), this._link(o, A);
        const E = u + (a + 1) % 3;
        s < ag.length && (ag[s++] = E);
      } else {
        if (s === 0) break;
        e = ag[--s];
      }
    }
    return o;
  }
  _link(e, t) {
    this._halfedges[e] = t, t !== -1 && (this._halfedges[t] = e);
  }
  // add a new triangle given vertex indices and adjacent half-edge ids
  _addTriangle(e, t, n, r, s, o) {
    const a = this.trianglesLen;
    return this._triangles[a] = e, this._triangles[a + 1] = t, this._triangles[a + 2] = n, this._link(a, r), this._link(a + 1, s), this._link(a + 2, o), this.trianglesLen += 3, a;
  }
}
function zX(i, e) {
  const t = i / (Math.abs(i) + Math.abs(e));
  return (e > 0 ? 3 - t : 1 + t) / 4;
}
function Gy(i, e, t, n) {
  const r = i - t, s = e - n;
  return r * r + s * s;
}
function qX(i, e, t, n, r, s, o, a) {
  const l = i - o, u = e - a, c = t - o, A = n - a, m = r - o, _ = s - a, y = l * l + u * u, T = c * c + A * A, b = m * m + _ * _;
  return l * (A * b - T * _) - u * (c * b - T * m) + y * (c * _ - A * m) < 0;
}
function HX(i, e, t, n, r, s) {
  const o = t - i, a = n - e, l = r - i, u = s - e, c = o * o + a * a, A = l * l + u * u, m = 0.5 / (o * u - a * l), _ = (u * c - a * A) * m, y = (o * A - l * c) * m;
  return _ * _ + y * y;
}
function WX(i, e, t, n, r, s) {
  const o = t - i, a = n - e, l = r - i, u = s - e, c = o * o + a * a, A = l * l + u * u, m = 0.5 / (o * u - a * l), _ = i + (u * c - a * A) * m, y = e + (o * A - l * c) * m;
  return { x: _, y };
}
function cf(i, e, t, n) {
  if (n - t <= 20)
    for (let r = t + 1; r <= n; r++) {
      const s = i[r], o = e[s];
      let a = r - 1;
      for (; a >= t && e[i[a]] > o; ) i[a + 1] = i[a--];
      i[a + 1] = s;
    }
  else {
    const r = t + n >> 1;
    let s = t + 1, o = n;
    zA(i, r, s), e[i[t]] > e[i[n]] && zA(i, t, n), e[i[s]] > e[i[n]] && zA(i, s, n), e[i[t]] > e[i[s]] && zA(i, t, s);
    const a = i[s], l = e[a];
    for (; ; ) {
      do
        s++;
      while (e[i[s]] < l);
      do
        o--;
      while (e[i[o]] > l);
      if (o < s) break;
      zA(i, s, o);
    }
    i[t + 1] = i[o], i[o] = a, n - s + 1 >= o - t ? (cf(i, e, s, n), cf(i, e, t, o - 1)) : (cf(i, e, t, o - 1), cf(i, e, s, n));
  }
}
function zA(i, e, t) {
  const n = i[e];
  i[e] = i[t], i[t] = n;
}
function $X(i) {
  return i[0];
}
function jX(i) {
  return i[1];
}
function XX(i, e) {
  var t, n, r = 0, s, o, a, l, u, c, A, m = i[0], _ = i[1], y = e.length;
  for (t = 0; t < y; t++) {
    n = 0;
    var T = e[t], b = T.length - 1;
    if (c = T[0], c[0] !== T[b][0] && c[1] !== T[b][1])
      throw new Error("First and last coordinates in a ring must be the same");
    for (o = c[0] - m, a = c[1] - _, n; n < b; n++) {
      if (A = T[n + 1], l = A[0] - m, u = A[1] - _, a === 0 && u === 0) {
        if (l <= 0 && o >= 0 || o <= 0 && l >= 0)
          return 0;
      } else if (u >= 0 && a <= 0 || u <= 0 && a >= 0) {
        if (s = gp(o, l, a, u, 0, 0), s === 0)
          return 0;
        (s > 0 && u > 0 && a <= 0 || s < 0 && u <= 0 && a > 0) && r++;
      }
      c = A, a = u, o = l;
    }
  }
  return r % 2 !== 0;
}
function YX(i) {
  if (!i)
    throw new Error("coord is required");
  if (!Array.isArray(i)) {
    if (i.type === "Feature" && i.geometry !== null && i.geometry.type === "Point")
      return [...i.geometry.coordinates];
    if (i.type === "Point")
      return [...i.coordinates];
  }
  if (Array.isArray(i) && i.length >= 2 && !Array.isArray(i[0]) && !Array.isArray(i[1]))
    return [...i];
  throw new Error("coord must be GeoJSON Point or an Array of numbers");
}
function QX(i) {
  return i.type === "Feature" ? i.geometry : i;
}
function KX(i, e, t = {}) {
  if (!i)
    throw new Error("point is required");
  if (!e)
    throw new Error("polygon is required");
  const n = YX(i), r = QX(e), s = r.type, o = e.bbox;
  let a = r.coordinates;
  if (o && ZX(n, o) === !1)
    return !1;
  s === "Polygon" && (a = [a]);
  let l = !1;
  for (var u = 0; u < a.length; ++u) {
    const c = XX(n, a[u]);
    if (c === 0) return !t.ignoreBoundary;
    c && (l = !0);
  }
  return l;
}
function ZX(i, e) {
  return e[0] <= i[0] && e[1] <= i[1] && e[2] >= i[0] && e[3] >= i[1];
}
var JX = KX;
const iR = 1e-6;
class th {
  constructor() {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null, this._ = "";
  }
  moveTo(e, t) {
    this._ += `M${this._x0 = this._x1 = +e},${this._y0 = this._y1 = +t}`;
  }
  closePath() {
    this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._ += "Z");
  }
  lineTo(e, t) {
    this._ += `L${this._x1 = +e},${this._y1 = +t}`;
  }
  arc(e, t, n) {
    e = +e, t = +t, n = +n;
    const r = e + n, s = t;
    if (n < 0) throw new Error("negative radius");
    this._x1 === null ? this._ += `M${r},${s}` : (Math.abs(this._x1 - r) > iR || Math.abs(this._y1 - s) > iR) && (this._ += "L" + r + "," + s), n && (this._ += `A${n},${n},0,1,1,${e - n},${t}A${n},${n},0,1,1,${this._x1 = r},${this._y1 = s}`);
  }
  rect(e, t, n, r) {
    this._ += `M${this._x0 = this._x1 = +e},${this._y0 = this._y1 = +t}h${+n}v${+r}h${-n}Z`;
  }
  value() {
    return this._ || null;
  }
}
class Eb {
  constructor() {
    this._ = [];
  }
  moveTo(e, t) {
    this._.push([e, t]);
  }
  closePath() {
    this._.push(this._[0].slice());
  }
  lineTo(e, t) {
    this._.push([e, t]);
  }
  value() {
    return this._.length ? this._ : null;
  }
}
class eY {
  constructor(e, [t, n, r, s] = [0, 0, 960, 500]) {
    if (!((r = +r) >= (t = +t)) || !((s = +s) >= (n = +n))) throw new Error("invalid bounds");
    this.delaunay = e, this._circumcenters = new Float64Array(e.points.length * 2), this.vectors = new Float64Array(e.points.length * 2), this.xmax = r, this.xmin = t, this.ymax = s, this.ymin = n, this._init();
  }
  update() {
    return this.delaunay.update(), this._init(), this;
  }
  _init() {
    const { delaunay: { points: e, hull: t, triangles: n }, vectors: r } = this;
    let s, o;
    const a = this.circumcenters = this._circumcenters.subarray(0, n.length / 3 * 2);
    for (let T = 0, b = 0, S = n.length, E, R; T < S; T += 3, b += 2) {
      const C = n[T] * 2, L = n[T + 1] * 2, D = n[T + 2] * 2, B = e[C], U = e[C + 1], N = e[L], O = e[L + 1], G = e[D], H = e[D + 1], Y = N - B, K = O - U, X = G - B, ee = H - U, oe = (Y * ee - K * X) * 2;
      if (Math.abs(oe) < 1e-9) {
        if (s === void 0) {
          s = o = 0;
          for (const _e of t) s += e[_e * 2], o += e[_e * 2 + 1];
          s /= t.length, o /= t.length;
        }
        const fe = 1e9 * Math.sign((s - B) * ee - (o - U) * X);
        E = (B + G) / 2 - fe * ee, R = (U + H) / 2 + fe * X;
      } else {
        const fe = 1 / oe, _e = Y * Y + K * K, Te = X * X + ee * ee;
        E = B + (ee * _e - K * Te) * fe, R = U + (Y * Te - X * _e) * fe;
      }
      a[b] = E, a[b + 1] = R;
    }
    let l = t[t.length - 1], u, c = l * 4, A, m = e[2 * l], _, y = e[2 * l + 1];
    r.fill(0);
    for (let T = 0; T < t.length; ++T)
      l = t[T], u = c, A = m, _ = y, c = l * 4, m = e[2 * l], y = e[2 * l + 1], r[u + 2] = r[c] = _ - y, r[u + 3] = r[c + 1] = m - A;
  }
  render(e) {
    const t = e == null ? e = new th() : void 0, { delaunay: { halfedges: n, inedges: r, hull: s }, circumcenters: o, vectors: a } = this;
    if (s.length <= 1) return null;
    for (let c = 0, A = n.length; c < A; ++c) {
      const m = n[c];
      if (m < c) continue;
      const _ = Math.floor(c / 3) * 2, y = Math.floor(m / 3) * 2, T = o[_], b = o[_ + 1], S = o[y], E = o[y + 1];
      this._renderSegment(T, b, S, E, e);
    }
    let l, u = s[s.length - 1];
    for (let c = 0; c < s.length; ++c) {
      l = u, u = s[c];
      const A = Math.floor(r[u] / 3) * 2, m = o[A], _ = o[A + 1], y = l * 4, T = this._project(m, _, a[y + 2], a[y + 3]);
      T && this._renderSegment(m, _, T[0], T[1], e);
    }
    return t && t.value();
  }
  renderBounds(e) {
    const t = e == null ? e = new th() : void 0;
    return e.rect(this.xmin, this.ymin, this.xmax - this.xmin, this.ymax - this.ymin), t && t.value();
  }
  renderCell(e, t) {
    const n = t == null ? t = new th() : void 0, r = this._clip(e);
    if (r === null || !r.length) return;
    t.moveTo(r[0], r[1]);
    let s = r.length;
    for (; r[0] === r[s - 2] && r[1] === r[s - 1] && s > 1; ) s -= 2;
    for (let o = 2; o < s; o += 2)
      (r[o] !== r[o - 2] || r[o + 1] !== r[o - 1]) && t.lineTo(r[o], r[o + 1]);
    return t.closePath(), n && n.value();
  }
  *cellPolygons() {
    const { delaunay: { points: e } } = this;
    for (let t = 0, n = e.length / 2; t < n; ++t) {
      const r = this.cellPolygon(t);
      r && (r.index = t, yield r);
    }
  }
  cellPolygon(e) {
    const t = new Eb();
    return this.renderCell(e, t), t.value();
  }
  _renderSegment(e, t, n, r, s) {
    let o;
    const a = this._regioncode(e, t), l = this._regioncode(n, r);
    a === 0 && l === 0 ? (s.moveTo(e, t), s.lineTo(n, r)) : (o = this._clipSegment(e, t, n, r, a, l)) && (s.moveTo(o[0], o[1]), s.lineTo(o[2], o[3]));
  }
  contains(e, t, n) {
    return t = +t, t !== t || (n = +n, n !== n) ? !1 : this.delaunay._step(e, t, n) === e;
  }
  *neighbors(e) {
    const t = this._clip(e);
    if (t) for (const n of this.delaunay.neighbors(e)) {
      const r = this._clip(n);
      if (r) {
        e: for (let s = 0, o = t.length; s < o; s += 2)
          for (let a = 0, l = r.length; a < l; a += 2)
            if (t[s] === r[a] && t[s + 1] === r[a + 1] && t[(s + 2) % o] === r[(a + l - 2) % l] && t[(s + 3) % o] === r[(a + l - 1) % l]) {
              yield n;
              break e;
            }
      }
    }
  }
  _cell(e) {
    const { circumcenters: t, delaunay: { inedges: n, halfedges: r, triangles: s } } = this, o = n[e];
    if (o === -1) return null;
    const a = [];
    let l = o;
    do {
      const u = Math.floor(l / 3);
      if (a.push(t[u * 2], t[u * 2 + 1]), l = l % 3 === 2 ? l - 2 : l + 1, s[l] !== e) break;
      l = r[l];
    } while (l !== o && l !== -1);
    return a;
  }
  _clip(e) {
    if (e === 0 && this.delaunay.hull.length === 1)
      return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
    const t = this._cell(e);
    if (t === null) return null;
    const { vectors: n } = this, r = e * 4;
    return this._simplify(n[r] || n[r + 1] ? this._clipInfinite(e, t, n[r], n[r + 1], n[r + 2], n[r + 3]) : this._clipFinite(e, t));
  }
  _clipFinite(e, t) {
    const n = t.length;
    let r = null, s, o, a = t[n - 2], l = t[n - 1], u, c = this._regioncode(a, l), A, m = 0;
    for (let _ = 0; _ < n; _ += 2)
      if (s = a, o = l, a = t[_], l = t[_ + 1], u = c, c = this._regioncode(a, l), u === 0 && c === 0)
        A = m, m = 0, r ? r.push(a, l) : r = [a, l];
      else {
        let y, T, b, S, E;
        if (u === 0) {
          if ((y = this._clipSegment(s, o, a, l, u, c)) === null) continue;
          [T, b, S, E] = y;
        } else {
          if ((y = this._clipSegment(a, l, s, o, c, u)) === null) continue;
          [S, E, T, b] = y, A = m, m = this._edgecode(T, b), A && m && this._edge(e, A, m, r, r.length), r ? r.push(T, b) : r = [T, b];
        }
        A = m, m = this._edgecode(S, E), A && m && this._edge(e, A, m, r, r.length), r ? r.push(S, E) : r = [S, E];
      }
    if (r)
      A = m, m = this._edgecode(r[0], r[1]), A && m && this._edge(e, A, m, r, r.length);
    else if (this.contains(e, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2))
      return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
    return r;
  }
  _clipSegment(e, t, n, r, s, o) {
    const a = s < o;
    for (a && ([e, t, n, r, s, o] = [n, r, e, t, o, s]); ; ) {
      if (s === 0 && o === 0) return a ? [n, r, e, t] : [e, t, n, r];
      if (s & o) return null;
      let l, u, c = s || o;
      c & 8 ? (l = e + (n - e) * (this.ymax - t) / (r - t), u = this.ymax) : c & 4 ? (l = e + (n - e) * (this.ymin - t) / (r - t), u = this.ymin) : c & 2 ? (u = t + (r - t) * (this.xmax - e) / (n - e), l = this.xmax) : (u = t + (r - t) * (this.xmin - e) / (n - e), l = this.xmin), s ? (e = l, t = u, s = this._regioncode(e, t)) : (n = l, r = u, o = this._regioncode(n, r));
    }
  }
  _clipInfinite(e, t, n, r, s, o) {
    let a = Array.from(t), l;
    if ((l = this._project(a[0], a[1], n, r)) && a.unshift(l[0], l[1]), (l = this._project(a[a.length - 2], a[a.length - 1], s, o)) && a.push(l[0], l[1]), a = this._clipFinite(e, a))
      for (let u = 0, c = a.length, A, m = this._edgecode(a[c - 2], a[c - 1]); u < c; u += 2)
        A = m, m = this._edgecode(a[u], a[u + 1]), A && m && (u = this._edge(e, A, m, a, u), c = a.length);
    else this.contains(e, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2) && (a = [this.xmin, this.ymin, this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax]);
    return a;
  }
  _edge(e, t, n, r, s) {
    for (; t !== n; ) {
      let o, a;
      switch (t) {
        case 5:
          t = 4;
          continue;
        // top-left
        case 4:
          t = 6, o = this.xmax, a = this.ymin;
          break;
        // top
        case 6:
          t = 2;
          continue;
        // top-right
        case 2:
          t = 10, o = this.xmax, a = this.ymax;
          break;
        // right
        case 10:
          t = 8;
          continue;
        // bottom-right
        case 8:
          t = 9, o = this.xmin, a = this.ymax;
          break;
        // bottom
        case 9:
          t = 1;
          continue;
        // bottom-left
        case 1:
          t = 5, o = this.xmin, a = this.ymin;
          break;
      }
      (r[s] !== o || r[s + 1] !== a) && this.contains(e, o, a) && (r.splice(s, 0, o, a), s += 2);
    }
    return s;
  }
  _project(e, t, n, r) {
    let s = 1 / 0, o, a, l;
    if (r < 0) {
      if (t <= this.ymin) return null;
      (o = (this.ymin - t) / r) < s && (l = this.ymin, a = e + (s = o) * n);
    } else if (r > 0) {
      if (t >= this.ymax) return null;
      (o = (this.ymax - t) / r) < s && (l = this.ymax, a = e + (s = o) * n);
    }
    if (n > 0) {
      if (e >= this.xmax) return null;
      (o = (this.xmax - e) / n) < s && (a = this.xmax, l = t + (s = o) * r);
    } else if (n < 0) {
      if (e <= this.xmin) return null;
      (o = (this.xmin - e) / n) < s && (a = this.xmin, l = t + (s = o) * r);
    }
    return [a, l];
  }
  _edgecode(e, t) {
    return (e === this.xmin ? 1 : e === this.xmax ? 2 : 0) | (t === this.ymin ? 4 : t === this.ymax ? 8 : 0);
  }
  _regioncode(e, t) {
    return (e < this.xmin ? 1 : e > this.xmax ? 2 : 0) | (t < this.ymin ? 4 : t > this.ymax ? 8 : 0);
  }
  _simplify(e) {
    if (e && e.length > 4) {
      for (let t = 0; t < e.length; t += 2) {
        const n = (t + 2) % e.length, r = (t + 4) % e.length;
        (e[t] === e[n] && e[n] === e[r] || e[t + 1] === e[n + 1] && e[n + 1] === e[r + 1]) && (e.splice(n, 2), t -= 2);
      }
      e.length || (e = null);
    }
    return e;
  }
}
const tY = 2 * Math.PI, Hd = Math.pow;
function nY(i) {
  return i[0];
}
function iY(i) {
  return i[1];
}
function rY(i) {
  const { triangles: e, coords: t } = i;
  for (let n = 0; n < e.length; n += 3) {
    const r = 2 * e[n], s = 2 * e[n + 1], o = 2 * e[n + 2];
    if ((t[o] - t[r]) * (t[s + 1] - t[r + 1]) - (t[s] - t[r]) * (t[o + 1] - t[r + 1]) > 1e-10) return !1;
  }
  return !0;
}
function sY(i, e, t) {
  return [i + Math.sin(i + e) * t, e + Math.cos(i - e) * t];
}
class RS {
  static from(e, t = nY, n = iY, r) {
    return new RS("length" in e ? oY(e, t, n, r) : Float64Array.from(aY(e, t, n, r)));
  }
  constructor(e) {
    this._delaunator = new t0(e), this.inedges = new Int32Array(e.length / 2), this._hullIndex = new Int32Array(e.length / 2), this.points = this._delaunator.coords, this._init();
  }
  update() {
    return this._delaunator.update(), this._init(), this;
  }
  _init() {
    const e = this._delaunator, t = this.points;
    if (e.hull && e.hull.length > 2 && rY(e)) {
      this.collinear = Int32Array.from({ length: t.length / 2 }, (m, _) => _).sort((m, _) => t[2 * m] - t[2 * _] || t[2 * m + 1] - t[2 * _ + 1]);
      const l = this.collinear[0], u = this.collinear[this.collinear.length - 1], c = [t[2 * l], t[2 * l + 1], t[2 * u], t[2 * u + 1]], A = 1e-8 * Math.hypot(c[3] - c[1], c[2] - c[0]);
      for (let m = 0, _ = t.length / 2; m < _; ++m) {
        const y = sY(t[2 * m], t[2 * m + 1], A);
        t[2 * m] = y[0], t[2 * m + 1] = y[1];
      }
      this._delaunator = new t0(t);
    } else
      delete this.collinear;
    const n = this.halfedges = this._delaunator.halfedges, r = this.hull = this._delaunator.hull, s = this.triangles = this._delaunator.triangles, o = this.inedges.fill(-1), a = this._hullIndex.fill(-1);
    for (let l = 0, u = n.length; l < u; ++l) {
      const c = s[l % 3 === 2 ? l - 2 : l + 1];
      (n[l] === -1 || o[c] === -1) && (o[c] = l);
    }
    for (let l = 0, u = r.length; l < u; ++l)
      a[r[l]] = l;
    r.length <= 2 && r.length > 0 && (this.triangles = new Int32Array(3).fill(-1), this.halfedges = new Int32Array(3).fill(-1), this.triangles[0] = r[0], o[r[0]] = 1, r.length === 2 && (o[r[1]] = 0, this.triangles[1] = r[1], this.triangles[2] = r[1]));
  }
  voronoi(e) {
    return new eY(this, e);
  }
  *neighbors(e) {
    const { inedges: t, hull: n, _hullIndex: r, halfedges: s, triangles: o, collinear: a } = this;
    if (a) {
      const A = a.indexOf(e);
      A > 0 && (yield a[A - 1]), A < a.length - 1 && (yield a[A + 1]);
      return;
    }
    const l = t[e];
    if (l === -1) return;
    let u = l, c = -1;
    do {
      if (yield c = o[u], u = u % 3 === 2 ? u - 2 : u + 1, o[u] !== e) return;
      if (u = s[u], u === -1) {
        const A = n[(r[e] + 1) % n.length];
        A !== c && (yield A);
        return;
      }
    } while (u !== l);
  }
  find(e, t, n = 0) {
    if (e = +e, e !== e || (t = +t, t !== t)) return -1;
    const r = n;
    let s;
    for (; (s = this._step(n, e, t)) >= 0 && s !== n && s !== r; ) n = s;
    return s;
  }
  _step(e, t, n) {
    const { inedges: r, hull: s, _hullIndex: o, halfedges: a, triangles: l, points: u } = this;
    if (r[e] === -1 || !u.length) return (e + 1) % (u.length >> 1);
    let c = e, A = Hd(t - u[e * 2], 2) + Hd(n - u[e * 2 + 1], 2);
    const m = r[e];
    let _ = m;
    do {
      let y = l[_];
      const T = Hd(t - u[y * 2], 2) + Hd(n - u[y * 2 + 1], 2);
      if (T < A && (A = T, c = y), _ = _ % 3 === 2 ? _ - 2 : _ + 1, l[_] !== e) break;
      if (_ = a[_], _ === -1) {
        if (_ = s[(o[e] + 1) % s.length], _ !== y && Hd(t - u[_ * 2], 2) + Hd(n - u[_ * 2 + 1], 2) < A)
          return _;
        break;
      }
    } while (_ !== m);
    return c;
  }
  render(e) {
    const t = e == null ? e = new th() : void 0, { points: n, halfedges: r, triangles: s } = this;
    for (let o = 0, a = r.length; o < a; ++o) {
      const l = r[o];
      if (l < o) continue;
      const u = s[o] * 2, c = s[l] * 2;
      e.moveTo(n[u], n[u + 1]), e.lineTo(n[c], n[c + 1]);
    }
    return this.renderHull(e), t && t.value();
  }
  renderPoints(e, t) {
    t === void 0 && (!e || typeof e.moveTo != "function") && (t = e, e = null), t = t == null ? 2 : +t;
    const n = e == null ? e = new th() : void 0, { points: r } = this;
    for (let s = 0, o = r.length; s < o; s += 2) {
      const a = r[s], l = r[s + 1];
      e.moveTo(a + t, l), e.arc(a, l, t, 0, tY);
    }
    return n && n.value();
  }
  renderHull(e) {
    const t = e == null ? e = new th() : void 0, { hull: n, points: r } = this, s = n[0] * 2, o = n.length;
    e.moveTo(r[s], r[s + 1]);
    for (let a = 1; a < o; ++a) {
      const l = 2 * n[a];
      e.lineTo(r[l], r[l + 1]);
    }
    return e.closePath(), t && t.value();
  }
  hullPolygon() {
    const e = new Eb();
    return this.renderHull(e), e.value();
  }
  renderTriangle(e, t) {
    const n = t == null ? t = new th() : void 0, { points: r, triangles: s } = this, o = s[e *= 3] * 2, a = s[e + 1] * 2, l = s[e + 2] * 2;
    return t.moveTo(r[o], r[o + 1]), t.lineTo(r[a], r[a + 1]), t.lineTo(r[l], r[l + 1]), t.closePath(), n && n.value();
  }
  *trianglePolygons() {
    const { triangles: e } = this;
    for (let t = 0, n = e.length / 3; t < n; ++t)
      yield this.trianglePolygon(t);
  }
  trianglePolygon(e) {
    const t = new Eb();
    return this.renderTriangle(e, t), t.value();
  }
}
function oY(i, e, t, n) {
  const r = i.length, s = new Float64Array(r * 2);
  for (let o = 0; o < r; ++o) {
    const a = i[o];
    s[o * 2] = e.call(n, a, o, i), s[o * 2 + 1] = t.call(n, a, o, i);
  }
  return s;
}
function* aY(i, e, t, n) {
  let r = 0;
  for (const s of i)
    yield e.call(n, s, r, i), yield t.call(n, s, r, i), ++r;
}
const CS = Math.PI, rR = CS / 2, sR = 180 / CS, oR = CS / 180, lY = Math.atan2, aR = Math.cos, uY = Math.max, cY = Math.min, lR = Math.sin, hY = Math.sign || function(i) {
  return i > 0 ? 1 : i < 0 ? -1 : 0;
}, LP = Math.sqrt;
function dY(i) {
  return i > 1 ? rR : i < -1 ? -rR : Math.asin(i);
}
function IP(i, e) {
  return i[0] * e[0] + i[1] * e[1] + i[2] * e[2];
}
function yo(i, e) {
  return [
    i[1] * e[2] - i[2] * e[1],
    i[2] * e[0] - i[0] * e[2],
    i[0] * e[1] - i[1] * e[0]
  ];
}
function K1(i, e) {
  return [i[0] + e[0], i[1] + e[1], i[2] + e[2]];
}
function Z1(i) {
  var e = LP(i[0] * i[0] + i[1] * i[1] + i[2] * i[2]);
  return [i[0] / e, i[1] / e, i[2] / e];
}
function PS(i) {
  return [
    lY(i[1], i[0]) * sR,
    dY(uY(-1, cY(1, i[2]))) * sR
  ];
}
function Ka(i) {
  const e = i[0] * oR, t = i[1] * oR, n = aR(t);
  return [n * aR(e), n * lR(e), lR(t)];
}
function NS(i) {
  return i = i.map((e) => Ka(e)), IP(i[0], yo(i[2], i[1]));
}
function fY(i) {
  const e = pY(i), t = gY(e), n = mY(t, i), r = xY(t, i.length), s = AY(r, i), o = _Y(t, i), { polygons: a, centers: l } = yY(o, t, i), u = vY(a), c = SY(t, i), A = bY(n, t);
  return {
    delaunay: e,
    edges: n,
    triangles: t,
    centers: l,
    neighbors: r,
    polygons: a,
    mesh: u,
    hull: c,
    urquhart: A,
    find: s
  };
}
function AY(i, e) {
  function t(n, r) {
    let s = n[0] - r[0], o = n[1] - r[1], a = n[2] - r[2];
    return s * s + o * o + a * a;
  }
  return function(r, s, o) {
    o === void 0 && (o = 0);
    let a, l, u = o;
    const c = Ka([r, s]);
    do
      a = o, o = null, l = t(c, Ka(e[a])), i[a].forEach((A) => {
        let m = t(c, Ka(e[A]));
        if (m < l) {
          l = m, o = A, u = A;
          return;
        }
      });
    while (o !== null);
    return u;
  };
}
function pY(i) {
  if (i.length < 2) return {};
  let e = 0;
  for (; isNaN(i[e][0] + i[e][1]) && e++ < i.length; ) ;
  const t = t$(i[e]), n = I$().translate([0, 0]).scale(1).rotate(t.invert([180, 0]));
  i = i.map(n);
  const r = [];
  let s = 1;
  for (let A = 0, m = i.length; A < m; A++) {
    let _ = i[A][0] ** 2 + i[A][1] ** 2;
    !isFinite(_) || _ > 1e32 ? r.push(A) : _ > s && (s = _);
  }
  const o = 1e6 * LP(s);
  r.forEach((A) => i[A] = [o, 0]), i.push([0, o]), i.push([-o, 0]), i.push([0, -o]);
  const a = RS.from(i);
  a.projection = n;
  const { triangles: l, halfedges: u, inedges: c } = a;
  for (let A = 0, m = u.length; A < m; A++)
    if (u[A] < 0) {
      const _ = A % 3 == 2 ? A - 2 : A + 1, y = A % 3 == 0 ? A + 2 : A - 1, T = u[_], b = u[y];
      u[T] = b, u[b] = T, u[_] = u[y] = -1, l[A] = l[_] = l[y] = e, c[l[T]] = T % 3 == 0 ? T + 2 : T - 1, c[l[b]] = b % 3 == 0 ? b + 2 : b - 1, A += 2 - A % 3;
    } else l[A] > i.length - 3 - 1 && (l[A] = e);
  return a;
}
function mY(i, e) {
  const t = /* @__PURE__ */ new Set();
  return e.length === 2 ? [[0, 1]] : (i.forEach((n) => {
    if (n[0] !== n[1] && !(NS(n.map((r) => e[r])) < 0))
      for (let r = 0, s; r < 3; r++)
        s = (r + 1) % 3, t.add(b1([n[r], n[s]]).join("-"));
  }), Array.from(t, (n) => n.split("-").map(Number)));
}
function gY(i) {
  const { triangles: e } = i;
  if (!e) return [];
  const t = [];
  for (let n = 0, r = e.length / 3; n < r; n++) {
    const s = e[3 * n], o = e[3 * n + 1], a = e[3 * n + 2];
    s !== o && o !== a && t.push([s, a, o]);
  }
  return t;
}
function _Y(i, e) {
  return i.map((t) => {
    const n = t.map((s) => e[s]).map(Ka), r = K1(
      K1(yo(n[1], n[0]), yo(n[2], n[1])),
      yo(n[0], n[2])
    );
    return PS(Z1(r));
  });
}
function xY(i, e) {
  const t = [];
  return i.forEach((n) => {
    for (let r = 0; r < 3; r++) {
      const s = n[r], o = n[(r + 1) % 3];
      t[s] = t[s] || [], t[s].push(o);
    }
  }), i.length === 0 && (e === 2 ? (t[0] = [1], t[1] = [0]) : e === 1 && (t[0] = [])), t;
}
function yY(i, e, t) {
  const n = [], r = i.slice();
  if (e.length === 0) {
    if (t.length < 2) return { polygons: n, centers: r };
    if (t.length === 2) {
      const a = Ka(t[0]), l = Ka(t[1]), u = Z1(K1(a, l)), c = Z1(yo(a, l)), A = yo(u, c), m = [
        u,
        yo(u, A),
        yo(yo(u, A), A),
        yo(yo(yo(u, A), A), A)
      ].map(PS).map(o);
      return n.push(m), n.push(m.slice().reverse()), { polygons: n, centers: r };
    }
  }
  e.forEach((a, l) => {
    for (let u = 0; u < 3; u++) {
      const c = a[u], A = a[(u + 1) % 3], m = a[(u + 2) % 3];
      n[c] = n[c] || [], n[c].push([A, m, l, [c, A, m]]);
    }
  });
  const s = n.map((a) => {
    const l = [a[0][2]];
    let u = a[0][1];
    for (let c = 1; c < a.length; c++)
      for (let A = 0; A < a.length; A++)
        if (a[A][0] == u) {
          u = a[A][1], l.push(a[A][2]);
          break;
        }
    if (l.length > 2)
      return l;
    if (l.length == 2) {
      const c = uR(
        t[a[0][3][0]],
        t[a[0][3][1]],
        r[l[0]]
      ), A = uR(
        t[a[0][3][2]],
        t[a[0][3][0]],
        r[l[0]]
      ), m = o(c), _ = o(A);
      return [l[0], _, l[1], m];
    }
  });
  function o(a) {
    let l = -1;
    return r.slice(e.length, 1 / 0).forEach((u, c) => {
      u[0] === a[0] && u[1] === a[1] && (l = c + e.length);
    }), l < 0 && (l = r.length, r.push(a)), l;
  }
  return { polygons: s, centers: r };
}
function uR(i, e, t) {
  i = Ka(i), e = Ka(e), t = Ka(t);
  const n = hY(IP(yo(e, i), t));
  return PS(Z1(K1(i, e)).map((r) => n * r));
}
function vY(i) {
  const e = [];
  return i.forEach((t) => {
    if (!t) return;
    let n = t[t.length - 1];
    for (let r of t)
      r > n && e.push([n, r]), n = r;
  }), e;
}
function bY(i, e) {
  return function(t) {
    const n = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Map();
    return i.forEach((s, o) => {
      const a = s.join("-");
      n.set(a, t[o]), r.set(a, !0);
    }), e.forEach((s) => {
      let o = 0, a = -1;
      for (let l = 0; l < 3; l++) {
        let u = b1([s[l], s[(l + 1) % 3]]).join("-");
        n.get(u) > o && (o = n.get(u), a = u);
      }
      r.set(a, !1);
    }), i.map((s) => r.get(s.join("-")));
  };
}
function SY(i, e) {
  const t = /* @__PURE__ */ new Set(), n = [];
  i.map((a) => {
    if (!(NS(a.map((l) => e[l > e.length ? 0 : l])) > 1e-12))
      for (let l = 0; l < 3; l++) {
        let u = [a[l], a[(l + 1) % 3]], c = `${u[0]}-${u[1]}`;
        t.has(c) ? t.delete(c) : t.add(`${u[1]}-${u[0]}`);
      }
  });
  const r = /* @__PURE__ */ new Map();
  let s;
  if (t.forEach((a) => {
    a = a.split("-").map(Number), r.set(a[0], a[1]), s = a[0];
  }), s === void 0) return n;
  let o = s;
  do {
    n.push(o);
    let a = r.get(o);
    r.set(o, -1), o = a;
  } while (o > -1 && o !== s);
  return n;
}
function TY(i) {
  const e = function(t) {
    if (e.delaunay = null, e._data = t, typeof e._data == "object" && e._data.type === "FeatureCollection" && (e._data = e._data.features), typeof e._data == "object") {
      const n = e._data.map((r) => [e._vx(r), e._vy(r), r]).filter((r) => isFinite(r[0] + r[1]));
      e.points = n.map((r) => [r[0], r[1]]), e.valid = n.map((r) => r[2]), e.delaunay = fY(e.points);
    }
    return e;
  };
  return e._vx = function(t) {
    if (typeof t == "object" && "type" in t)
      return y4(t)[0];
    if (0 in t) return t[0];
  }, e._vy = function(t) {
    if (typeof t == "object" && "type" in t)
      return y4(t)[1];
    if (1 in t) return t[1];
  }, e.x = function(t) {
    return t ? (e._vx = t, e) : e._vx;
  }, e.y = function(t) {
    return t ? (e._vy = t, e) : e._vy;
  }, e.polygons = function(t) {
    if (t !== void 0 && e(t), !e.delaunay) return !1;
    const n = {
      type: "FeatureCollection",
      features: []
    };
    return e.valid.length === 0 || (e.delaunay.polygons.forEach(
      (r, s) => n.features.push({
        type: "Feature",
        geometry: r ? {
          type: "Polygon",
          coordinates: [
            [...r, r[0]].map((o) => e.delaunay.centers[o])
          ]
        } : null,
        properties: {
          site: e.valid[s],
          sitecoordinates: e.points[s],
          neighbours: e.delaunay.neighbors[s]
          // not part of the public API
        }
      })
    ), e.valid.length === 1 && n.features.push({
      type: "Feature",
      geometry: { type: "Sphere" },
      properties: {
        site: e.valid[0],
        sitecoordinates: e.points[0],
        neighbours: []
      }
    })), n;
  }, e.triangles = function(t) {
    return t !== void 0 && e(t), e.delaunay ? {
      type: "FeatureCollection",
      features: e.delaunay.triangles.map((n, r) => (n = n.map((s) => e.points[s]), n.center = e.delaunay.centers[r], n)).filter((n) => NS(n) > 0).map((n) => ({
        type: "Feature",
        properties: {
          circumcenter: n.center
        },
        geometry: {
          type: "Polygon",
          coordinates: [[...n, n[0]]]
        }
      }))
    } : !1;
  }, e.links = function(t) {
    if (t !== void 0 && e(t), !e.delaunay) return !1;
    const n = e.delaunay.edges.map(
      (s) => ju(e.points[s[0]], e.points[s[1]])
    ), r = e.delaunay.urquhart(n);
    return {
      type: "FeatureCollection",
      features: e.delaunay.edges.map((s, o) => ({
        type: "Feature",
        properties: {
          source: e.valid[s[0]],
          target: e.valid[s[1]],
          length: n[o],
          urquhart: !!r[o]
        },
        geometry: {
          type: "LineString",
          coordinates: [e.points[s[0]], e.points[s[1]]]
        }
      }))
    };
  }, e.mesh = function(t) {
    return t !== void 0 && e(t), e.delaunay ? {
      type: "MultiLineString",
      coordinates: e.delaunay.edges.map((n) => [
        e.points[n[0]],
        e.points[n[1]]
      ])
    } : !1;
  }, e.cellMesh = function(t) {
    if (t !== void 0 && e(t), !e.delaunay) return !1;
    const { centers: n, polygons: r } = e.delaunay, s = [];
    for (const o of r)
      if (o)
        for (let a = o.length, l = o[a - 1], u = o[0], c = 0; c < a; l = u, u = o[++c])
          u > l && s.push([n[l], n[u]]);
    return {
      type: "MultiLineString",
      coordinates: s
    };
  }, e._found = void 0, e.find = function(t, n, r) {
    if (e._found = e.delaunay.find(t, n, e._found), !r || ju([t, n], e.points[e._found]) < r)
      return e._found;
  }, e.hull = function(t) {
    t !== void 0 && e(t);
    const n = e.delaunay.hull, r = e.points;
    return n.length === 0 ? null : {
      type: "Polygon",
      coordinates: [[...n.map((s) => r[s]), r[n[0]]]]
    };
  }, i ? e(i) : e;
}
function Rb(i, e) {
  (e == null || e > i.length) && (e = i.length);
  for (var t = 0, n = Array(e); t < e; t++) n[t] = i[t];
  return n;
}
function wY(i) {
  if (Array.isArray(i)) return i;
}
function MY(i) {
  if (Array.isArray(i)) return Rb(i);
}
function EY(i) {
  if (i === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return i;
}
function RY(i, e, t) {
  return e = J1(e), FY(i, BP() ? Reflect.construct(e, [], J1(i).constructor) : e.apply(i, t));
}
function CY(i, e) {
  if (!(i instanceof e)) throw new TypeError("Cannot call a class as a function");
}
function PY(i, e, t) {
  return Object.defineProperty(i, "prototype", {
    writable: !1
  }), i;
}
function J1(i) {
  return J1 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e) {
    return e.__proto__ || Object.getPrototypeOf(e);
  }, J1(i);
}
function NY(i, e) {
  if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function");
  i.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: i,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(i, "prototype", {
    writable: !1
  }), e && Cb(i, e);
}
function BP() {
  try {
    var i = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (BP = function() {
    return !!i;
  })();
}
function DY(i) {
  if (typeof Symbol < "u" && i[Symbol.iterator] != null || i["@@iterator"] != null) return Array.from(i);
}
function LY(i, e) {
  var t = i == null ? null : typeof Symbol < "u" && i[Symbol.iterator] || i["@@iterator"];
  if (t != null) {
    var n, r, s, o, a = [], l = !0, u = !1;
    try {
      if (s = (t = t.call(i)).next, e !== 0) for (; !(l = (n = s.call(t)).done) && (a.push(n.value), a.length !== e); l = !0) ;
    } catch (c) {
      u = !0, r = c;
    } finally {
      try {
        if (!l && t.return != null && (o = t.return(), Object(o) !== o)) return;
      } finally {
        if (u) throw r;
      }
    }
    return a;
  }
}
function IY() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function BY() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function FY(i, e) {
  if (e && (typeof e == "object" || typeof e == "function")) return e;
  if (e !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
  return EY(i);
}
function Cb(i, e) {
  return Cb = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, n) {
    return t.__proto__ = n, t;
  }, Cb(i, e);
}
function qa(i, e) {
  return wY(i) || LY(i, e) || FP(i, e) || IY();
}
function zy(i) {
  return MY(i) || DY(i) || FP(i) || BY();
}
function FP(i, e) {
  if (i) {
    if (typeof i == "string") return Rb(i, e);
    var t = {}.toString.call(i).slice(8, -1);
    return t === "Object" && i.constructor && (t = i.constructor.name), t === "Map" || t === "Set" ? Array.from(i) : t === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? Rb(i, e) : void 0;
  }
}
function UY(i) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, t = e.resolution, n = t === void 0 ? 1 / 0 : t, r = OY(i, n), s = jp(r), o = kY(i, n), a = [].concat(zy(s), zy(o)), l = {
    type: "Polygon",
    coordinates: i
  }, u = nP(l), c = qa(u, 2), A = qa(c[0], 2), m = A[0], _ = A[1], y = qa(c[1], 2), T = y[0], b = y[1], S = m > T || b >= 89 || _ <= -89, E = [];
  if (S) {
    var R = TY(a).triangles(), C = new Map(a.map(function(oe, fe) {
      var _e = qa(oe, 2), Te = _e[0], Ce = _e[1];
      return ["".concat(Te, "-").concat(Ce), fe];
    }));
    R.features.forEach(function(oe) {
      var fe, _e = oe.geometry.coordinates[0].slice(0, 3).reverse(), Te = [];
      if (_e.forEach(function(Je) {
        var Qe = qa(Je, 2), zt = Qe[0], Tt = Qe[1], Pe = "".concat(zt, "-").concat(Tt);
        C.has(Pe) && Te.push(C.get(Pe));
      }), Te.length === 3) {
        if (Te.some(function(Je) {
          return Je < s.length;
        })) {
          var Ce = oe.properties.circumcenter;
          if (!Pb(Ce, l, S)) return;
        }
        (fe = E).push.apply(fe, Te);
      }
    });
  } else if (o.length)
    for (var N = t0.from(a), O = function(fe) {
      var _e, Te = [2, 1, 0].map(function(Qe) {
        return N.triangles[fe + Qe];
      }), Ce = Te.map(function(Qe) {
        return a[Qe];
      });
      if (Te.some(function(Qe) {
        return Qe < s.length;
      })) {
        var Je = [0, 1].map(function(Qe) {
          return XH(Ce, function(zt) {
            return zt[Qe];
          });
        });
        if (!Pb(Je, l, S)) return 1;
      }
      (_e = E).push.apply(_e, zy(Te));
    }, G = 0, H = N.triangles.length; G < H; G += 3)
      O(G);
  else {
    var L = j1(r), D = L.vertices, B = L.holes, U = B === void 0 ? [] : B;
    E = rj(D, U, 2);
  }
  var Y = $l(b1(a, function(oe) {
    return oe[0];
  }), [0, 1]), K = $l(b1(a, function(oe) {
    return oe[1];
  }), [0, 1]), X = a.map(function(oe) {
    var fe = qa(oe, 2), _e = fe[0], Te = fe[1];
    return [Y(_e), K(Te)];
  }), ee = {
    points: a,
    indices: E,
    uvs: X
  };
  return {
    contour: r,
    triangles: ee
  };
}
function OY(i, e) {
  return i.map(function(t) {
    var n = [], r;
    return t.forEach(function(s) {
      if (r) {
        var o = ju(s, r) * 180 / Math.PI;
        if (o > e)
          for (var a = bS(r, s), l = 1 / Math.ceil(o / e), u = l; u < 1; )
            n.push(a(u)), u += l;
      }
      n.push(r = s);
    }), n;
  });
}
function kY(i, e) {
  var t = {
    type: "Polygon",
    coordinates: i
  }, n = nP(t), r = qa(n, 2), s = qa(r[0], 2), o = s[0], a = s[1], l = qa(r[1], 2), u = l[0], c = l[1];
  if (Math.min(Math.abs(u - o), Math.abs(c - a)) < e) return [];
  var A = o > u || c >= 89 || a <= -89;
  return VY(e, {
    minLng: o,
    maxLng: u,
    minLat: a,
    maxLat: c
  }).filter(function(m) {
    return Pb(m, t, A);
  });
}
function VY(i) {
  for (var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, t = e.minLng, n = e.maxLng, r = e.minLat, s = e.maxLat, o = Math.round(Math.pow(360 / i, 2) / Math.PI), a = (1 + Math.sqrt(5)) / 2, l = function(S) {
    return S / a * 360 % 360 - 180;
  }, u = function(S) {
    return Math.acos(2 * S / o - 1) / Math.PI * 180 - 90;
  }, c = function(S) {
    return o * (Math.cos((S + 90) * Math.PI / 180) + 1) / 2;
  }, A = [s !== void 0 ? Math.ceil(c(s)) : 0, r !== void 0 ? Math.floor(c(r)) : o - 1], m = t === void 0 && n === void 0 ? function() {
    return !0;
  } : t === void 0 ? function(b) {
    return b <= n;
  } : n === void 0 ? function(b) {
    return b >= t;
  } : n >= t ? function(b) {
    return b >= t && b <= n;
  } : function(b) {
    return b >= t || b <= n;
  }, _ = [], y = A[0]; y <= A[1]; y++) {
    var T = l(y);
    m(T) && _.push([T, u(y)]);
  }
  return _;
}
function Pb(i, e) {
  var t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
  return t ? _$(e, i) : JX(i, e);
}
var e1 = window.THREE ? window.THREE : {
  BufferGeometry: Yt,
  Float32BufferAttribute: xt
}, cR = new e1.BufferGeometry().setAttribute ? "setAttribute" : "addAttribute", DS = /* @__PURE__ */ (function(i) {
  function e(t, n, r, s, o, a, l) {
    var u;
    CY(this, e), u = RY(this, e), u.type = "ConicPolygonGeometry", u.parameters = {
      polygonGeoJson: t,
      bottomHeight: n,
      topHeight: r,
      closedBottom: s,
      closedTop: o,
      includeSides: a,
      curvatureResolution: l
    }, n = n || 0, r = r || 1, s = s !== void 0 ? s : !0, o = o !== void 0 ? o : !0, a = a !== void 0 ? a : !0, l = l || 5;
    var c = UY(t, {
      resolution: l
    }), A = c.contour, m = c.triangles, _ = jp(m.uvs), y = [], T = [], b = [], S = 0, E = function(B) {
      var U = Math.round(y.length / 3), N = b.length;
      y = y.concat(B.vertices), T = T.concat(B.uvs), b = b.concat(U ? B.indices.map(function(O) {
        return O + U;
      }) : B.indices), u.addGroup(N, b.length - N, S++);
    };
    a && E(C()), s && E(L(n, !1)), o && E(L(r, !0)), u.setIndex(b), u[cR]("position", new e1.Float32BufferAttribute(y, 3)), u[cR]("uv", new e1.Float32BufferAttribute(T, 2)), u.computeVertexNormals();
    function R(D, B) {
      var U = typeof B == "function" ? B : function() {
        return B;
      }, N = D.map(function(O) {
        return O.map(function(G) {
          var H = qa(G, 2), Y = H[0], K = H[1];
          return GY(K, Y, U(Y, K));
        });
      });
      return j1(N);
    }
    function C() {
      for (var D = R(A, n), B = D.vertices, U = D.holes, N = R(A, r), O = N.vertices, G = jp([O, B]), H = Math.round(O.length / 3), Y = new Set(U), K = 0, X = [], ee = 0; ee < H; ee++) {
        var oe = ee + 1;
        if (oe === H)
          oe = K;
        else if (Y.has(oe)) {
          var fe = oe;
          oe = K, K = fe;
        }
        X.push(ee, ee + H, oe + H), X.push(oe + H, oe, ee);
      }
      for (var _e = [], Te = 1; Te >= 0; Te--) for (var Ce = 0; Ce < H; Ce += 1) _e.push(Ce / (H - 1), Te);
      return {
        indices: X,
        vertices: G,
        uvs: _e
      };
    }
    function L(D) {
      var B = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
      return {
        // need to reverse-wind the bottom triangles to make them face outwards
        indices: B ? m.indices : m.indices.slice().reverse(),
        vertices: R([m.points], D).vertices,
        uvs: _
      };
    }
    return u;
  }
  return NY(e, i), PY(e);
})(e1.BufferGeometry);
function GY(i, e) {
  var t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, n = (90 - i) * Math.PI / 180, r = (90 - e) * Math.PI / 180;
  return [
    t * Math.sin(n) * Math.cos(r),
    // x
    t * Math.cos(n),
    // y
    t * Math.sin(n) * Math.sin(r)
    // z
  ];
}
function Nb(i, e) {
  (e == null || e > i.length) && (e = i.length);
  for (var t = 0, n = Array(e); t < e; t++) n[t] = i[t];
  return n;
}
function zY(i) {
  if (Array.isArray(i)) return i;
}
function qY(i) {
  if (Array.isArray(i)) return Nb(i);
}
function HY(i) {
  if (typeof Symbol < "u" && i[Symbol.iterator] != null || i["@@iterator"] != null) return Array.from(i);
}
function WY(i, e) {
  var t = i == null ? null : typeof Symbol < "u" && i[Symbol.iterator] || i["@@iterator"];
  if (t != null) {
    var n, r, s, o, a = [], l = !0, u = !1;
    try {
      if (s = (t = t.call(i)).next, e !== 0) for (; !(l = (n = s.call(t)).done) && (a.push(n.value), a.length !== e); l = !0) ;
    } catch (c) {
      u = !0, r = c;
    } finally {
      try {
        if (!l && t.return != null && (o = t.return(), Object(o) !== o)) return;
      } finally {
        if (u) throw r;
      }
    }
    return a;
  }
}
function $Y() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function jY() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function XY(i, e) {
  if (i == null) return {};
  var t, n, r = YY(i, e);
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(i);
    for (n = 0; n < s.length; n++) t = s[n], e.includes(t) || {}.propertyIsEnumerable.call(i, t) && (r[t] = i[t]);
  }
  return r;
}
function YY(i, e) {
  if (i == null) return {};
  var t = {};
  for (var n in i) if ({}.hasOwnProperty.call(i, n)) {
    if (e.includes(n)) continue;
    t[n] = i[n];
  }
  return t;
}
function QY(i, e) {
  return zY(i) || WY(i, e) || UP(i, e) || $Y();
}
function KY(i) {
  return qY(i) || HY(i) || UP(i) || jY();
}
function ZY(i, e) {
  if (typeof i != "object" || !i) return i;
  var t = i[Symbol.toPrimitive];
  if (t !== void 0) {
    var n = t.call(i, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(i);
}
function JY(i) {
  var e = ZY(i, "string");
  return typeof e == "symbol" ? e : e + "";
}
function UP(i, e) {
  if (i) {
    if (typeof i == "string") return Nb(i, e);
    var t = {}.toString.call(i).slice(8, -1);
    return t === "Object" && i.constructor && (t = i.constructor.name), t === "Map" || t === "Set" ? Array.from(i) : t === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? Nb(i, e) : void 0;
  }
}
var eQ = (function() {
  var i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0, n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1, r = (e instanceof Array ? e.length ? e : [void 0] : [e]).map(function(a) {
    return {
      keyAccessor: a,
      isProp: !(a instanceof Function)
    };
  }), s = i.reduce(function(a, l) {
    var u = a, c = l;
    return r.forEach(function(A, m) {
      var _ = A.keyAccessor, y = A.isProp, T;
      if (y) {
        var b = c, S = b[_], E = XY(b, [_].map(JY));
        T = S, c = E;
      } else
        T = _(c, m);
      m + 1 < r.length ? (u.hasOwnProperty(T) || (u[T] = {}), u = u[T]) : t ? (u.hasOwnProperty(T) || (u[T] = []), u[T].push(c)) : u[T] = c;
    }), a;
  }, {});
  t instanceof Function && (function a(l) {
    var u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
    u === r.length ? Object.keys(l).forEach(function(c) {
      return l[c] = t(l[c]);
    }) : Object.values(l).forEach(function(c) {
      return a(c, u + 1);
    });
  })(s);
  var o = s;
  return n && (o = [], (function a(l) {
    var u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    u.length === r.length ? o.push({
      keys: u,
      vals: l
    }) : Object.entries(l).forEach(function(c) {
      var A = QY(c, 2), m = A[0], _ = A[1];
      return a(_, [].concat(KY(u), [m]));
    });
  })(s), e instanceof Array && e.length === 0 && o.length === 1 && (o[0].keys = [])), o;
}), zn = (function(i) {
  i = i || {};
  var e = typeof i < "u" ? i : {}, t = {}, n;
  for (n in e)
    e.hasOwnProperty(n) && (t[n] = e[n]);
  var r = "";
  function s(De) {
    return e.locateFile ? e.locateFile(De, r) : r + De;
  }
  var o;
  typeof document < "u" && document.currentScript && (r = document.currentScript.src), r.indexOf("blob:") !== 0 ? r = r.substr(0, r.lastIndexOf("/") + 1) : r = "", o = function(ze, mt, $e) {
    var f = new XMLHttpRequest();
    f.open("GET", ze, !0), f.responseType = "arraybuffer", f.onload = function() {
      if (f.status == 200 || f.status == 0 && f.response) {
        mt(f.response);
        return;
      }
      var Mn = Vt(ze);
      if (Mn) {
        mt(Mn.buffer);
        return;
      }
      $e();
    }, f.onerror = $e, f.send(null);
  };
  var a = e.print || console.log.bind(console), l = e.printErr || console.warn.bind(console);
  for (n in t)
    t.hasOwnProperty(n) && (e[n] = t[n]);
  t = null, e.arguments && e.arguments;
  var u = 0, c = function(De) {
    u = De;
  }, A = function() {
    return u;
  }, m = 8;
  function _(De, ze, mt, $e) {
    switch (mt = mt || "i8", mt.charAt(mt.length - 1) === "*" && (mt = "i32"), mt) {
      case "i1":
        H[De >> 0] = ze;
        break;
      case "i8":
        H[De >> 0] = ze;
        break;
      case "i16":
        K[De >> 1] = ze;
        break;
      case "i32":
        X[De >> 2] = ze;
        break;
      case "i64":
        ge = [ze >>> 0, (W = ze, +z(W) >= 1 ? W > 0 ? (Ee(+he(W / 4294967296), 4294967295) | 0) >>> 0 : ~~+ue((W - +(~~W >>> 0)) / 4294967296) >>> 0 : 0)], X[De >> 2] = ge[0], X[De + 4 >> 2] = ge[1];
        break;
      case "float":
        ee[De >> 2] = ze;
        break;
      case "double":
        oe[De >> 3] = ze;
        break;
      default:
        es("invalid type for setValue: " + mt);
    }
  }
  function y(De, ze, mt) {
    switch (ze = ze || "i8", ze.charAt(ze.length - 1) === "*" && (ze = "i32"), ze) {
      case "i1":
        return H[De >> 0];
      case "i8":
        return H[De >> 0];
      case "i16":
        return K[De >> 1];
      case "i32":
        return X[De >> 2];
      case "i64":
        return X[De >> 2];
      case "float":
        return ee[De >> 2];
      case "double":
        return oe[De >> 3];
      default:
        es("invalid type for getValue: " + ze);
    }
    return null;
  }
  var T = !1;
  function b(De, ze) {
    De || es("Assertion failed: " + ze);
  }
  function S(De) {
    var ze = e["_" + De];
    return b(ze, "Cannot call unknown function " + De + ", make sure it is exported"), ze;
  }
  function E(De, ze, mt, $e, f) {
    var $ = {
      string: function(vn) {
        var ys = 0;
        if (vn != null && vn !== 0) {
          var ud = (vn.length << 2) + 1;
          ys = lt(ud), U(vn, ys, ud);
        }
        return ys;
      },
      array: function(vn) {
        var ys = lt(vn.length);
        return N(vn, ys), ys;
      }
    };
    function Mn(vn) {
      return ze === "string" ? D(vn) : ze === "boolean" ? !!vn : vn;
    }
    var jn = S(De), nr = [], yn = 0;
    if ($e)
      for (var Nn = 0; Nn < $e.length; Nn++) {
        var ta = $[mt[Nn]];
        ta ? (yn === 0 && (yn = it()), nr[Nn] = ta($e[Nn])) : nr[Nn] = $e[Nn];
      }
    var On = jn.apply(null, nr);
    return On = Mn(On), yn !== 0 && Ct(yn), On;
  }
  function R(De, ze, mt, $e) {
    mt = mt || [];
    var f = mt.every(function(Mn) {
      return Mn === "number";
    }), $ = ze !== "string";
    return $ && f && !$e ? S(De) : function() {
      return E(De, ze, mt, arguments);
    };
  }
  var C = typeof TextDecoder < "u" ? new TextDecoder("utf8") : void 0;
  function L(De, ze, mt) {
    for (var $e = ze + mt, f = ze; De[f] && !(f >= $e); )
      ++f;
    if (f - ze > 16 && De.subarray && C)
      return C.decode(De.subarray(ze, f));
    for (var $ = ""; ze < f; ) {
      var Mn = De[ze++];
      if (!(Mn & 128)) {
        $ += String.fromCharCode(Mn);
        continue;
      }
      var jn = De[ze++] & 63;
      if ((Mn & 224) == 192) {
        $ += String.fromCharCode((Mn & 31) << 6 | jn);
        continue;
      }
      var nr = De[ze++] & 63;
      if ((Mn & 240) == 224 ? Mn = (Mn & 15) << 12 | jn << 6 | nr : Mn = (Mn & 7) << 18 | jn << 12 | nr << 6 | De[ze++] & 63, Mn < 65536)
        $ += String.fromCharCode(Mn);
      else {
        var yn = Mn - 65536;
        $ += String.fromCharCode(55296 | yn >> 10, 56320 | yn & 1023);
      }
    }
    return $;
  }
  function D(De, ze) {
    return De ? L(Y, De, ze) : "";
  }
  function B(De, ze, mt, $e) {
    if (!($e > 0))
      return 0;
    for (var f = mt, $ = mt + $e - 1, Mn = 0; Mn < De.length; ++Mn) {
      var jn = De.charCodeAt(Mn);
      if (jn >= 55296 && jn <= 57343) {
        var nr = De.charCodeAt(++Mn);
        jn = 65536 + ((jn & 1023) << 10) | nr & 1023;
      }
      if (jn <= 127) {
        if (mt >= $)
          break;
        ze[mt++] = jn;
      } else if (jn <= 2047) {
        if (mt + 1 >= $)
          break;
        ze[mt++] = 192 | jn >> 6, ze[mt++] = 128 | jn & 63;
      } else if (jn <= 65535) {
        if (mt + 2 >= $)
          break;
        ze[mt++] = 224 | jn >> 12, ze[mt++] = 128 | jn >> 6 & 63, ze[mt++] = 128 | jn & 63;
      } else {
        if (mt + 3 >= $)
          break;
        ze[mt++] = 240 | jn >> 18, ze[mt++] = 128 | jn >> 12 & 63, ze[mt++] = 128 | jn >> 6 & 63, ze[mt++] = 128 | jn & 63;
      }
    }
    return ze[mt] = 0, mt - f;
  }
  function U(De, ze, mt) {
    return B(De, Y, ze, mt);
  }
  typeof TextDecoder < "u" && new TextDecoder("utf-16le");
  function N(De, ze) {
    H.set(De, ze);
  }
  function O(De, ze) {
    return De % ze > 0 && (De += ze - De % ze), De;
  }
  var G, H, Y, K, X, ee, oe;
  function fe(De) {
    G = De, e.HEAP8 = H = new Int8Array(De), e.HEAP16 = K = new Int16Array(De), e.HEAP32 = X = new Int32Array(De), e.HEAPU8 = Y = new Uint8Array(De), e.HEAPU16 = new Uint16Array(De), e.HEAPU32 = new Uint32Array(De), e.HEAPF32 = ee = new Float32Array(De), e.HEAPF64 = oe = new Float64Array(De);
  }
  var _e = 5271536, Te = 28624, Ce = e.TOTAL_MEMORY || 33554432;
  e.buffer ? G = e.buffer : G = new ArrayBuffer(Ce), Ce = G.byteLength, fe(G), X[Te >> 2] = _e;
  function Je(De) {
    for (; De.length > 0; ) {
      var ze = De.shift();
      if (typeof ze == "function") {
        ze();
        continue;
      }
      var mt = ze.func;
      typeof mt == "number" ? ze.arg === void 0 ? e.dynCall_v(mt) : e.dynCall_vi(mt, ze.arg) : mt(ze.arg === void 0 ? null : ze.arg);
    }
  }
  var Qe = [], zt = [], Tt = [], Pe = [];
  function ke() {
    if (e.preRun)
      for (typeof e.preRun == "function" && (e.preRun = [e.preRun]); e.preRun.length; )
        Wt(e.preRun.shift());
    Je(Qe);
  }
  function at() {
    Je(zt);
  }
  function wt() {
    Je(Tt);
  }
  function ot() {
    if (e.postRun)
      for (typeof e.postRun == "function" && (e.postRun = [e.postRun]); e.postRun.length; )
        en(e.postRun.shift());
    Je(Pe);
  }
  function Wt(De) {
    Qe.unshift(De);
  }
  function en(De) {
    Pe.unshift(De);
  }
  var z = Math.abs, ue = Math.ceil, he = Math.floor, Ee = Math.min, Ye = 0, te = null;
  function Et(De) {
    Ye++, e.monitorRunDependencies && e.monitorRunDependencies(Ye);
  }
  function dt(De) {
    if (Ye--, e.monitorRunDependencies && e.monitorRunDependencies(Ye), Ye == 0 && te) {
      var ze = te;
      te = null, ze();
    }
  }
  e.preloadedImages = {}, e.preloadedAudios = {};
  var Nt = null, rt = "data:application/octet-stream;base64,";
  function ne(De) {
    return String.prototype.startsWith ? De.startsWith(rt) : De.indexOf(rt) === 0;
  }
  var W, ge;
  Nt = "data:application/octet-stream;base64,AAAAAAAAAAAAAAAAAQAAAAIAAAADAAAABAAAAAUAAAAGAAAAAQAAAAQAAAADAAAABgAAAAUAAAACAAAAAAAAAAIAAAADAAAAAQAAAAQAAAAGAAAAAAAAAAUAAAADAAAABgAAAAQAAAAFAAAAAAAAAAEAAAACAAAABAAAAAUAAAAGAAAAAAAAAAIAAAADAAAAAQAAAAUAAAACAAAAAAAAAAEAAAADAAAABgAAAAQAAAAGAAAAAAAAAAUAAAACAAAAAQAAAAQAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAEAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAIAAAADAAAAAAAAAAAAAAACAAAAAAAAAAEAAAADAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAABAAAAAYAAAAAAAAABQAAAAAAAAAAAAAABAAAAAUAAAAAAAAAAAAAAAAAAAACAAAAAAAAAAYAAAAAAAAABgAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAgAAAAMAAAAEAAAABQAAAAYAAAABAAAAAgAAAAMAAAAEAAAABQAAAAYAAAAAAAAAAgAAAAMAAAAEAAAABQAAAAYAAAAAAAAAAQAAAAMAAAAEAAAABQAAAAYAAAAAAAAAAQAAAAIAAAAEAAAABQAAAAYAAAAAAAAAAQAAAAIAAAADAAAABQAAAAYAAAAAAAAAAQAAAAIAAAADAAAABAAAAAYAAAAAAAAAAQAAAAIAAAADAAAABAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAgAAAAIAAAAAAAAAAAAAAAYAAAAAAAAAAwAAAAIAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAFAAAABAAAAAAAAAABAAAAAAAAAAAAAAAFAAAABQAAAAAAAAAAAAAAAAAAAAYAAAAAAAAABAAAAAAAAAAGAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAFAAAAAgAAAAQAAAADAAAACAAAAAEAAAAHAAAABgAAAAkAAAAAAAAAAwAAAAIAAAACAAAABgAAAAoAAAALAAAAAAAAAAEAAAAFAAAAAwAAAA0AAAABAAAABwAAAAQAAAAMAAAAAAAAAAQAAAB/AAAADwAAAAgAAAADAAAAAAAAAAwAAAAFAAAAAgAAABIAAAAKAAAACAAAAAAAAAAQAAAABgAAAA4AAAALAAAAEQAAAAEAAAAJAAAAAgAAAAcAAAAVAAAACQAAABMAAAADAAAADQAAAAEAAAAIAAAABQAAABYAAAAQAAAABAAAAAAAAAAPAAAACQAAABMAAAAOAAAAFAAAAAEAAAAHAAAABgAAAAoAAAALAAAAGAAAABcAAAAFAAAAAgAAABIAAAALAAAAEQAAABcAAAAZAAAAAgAAAAYAAAAKAAAADAAAABwAAAANAAAAGgAAAAQAAAAPAAAAAwAAAA0AAAAaAAAAFQAAAB0AAAADAAAADAAAAAcAAAAOAAAAfwAAABEAAAAbAAAACQAAABQAAAAGAAAADwAAABYAAAAcAAAAHwAAAAQAAAAIAAAADAAAABAAAAASAAAAIQAAAB4AAAAIAAAABQAAABYAAAARAAAACwAAAA4AAAAGAAAAIwAAABkAAAAbAAAAEgAAABgAAAAeAAAAIAAAAAUAAAAKAAAAEAAAABMAAAAiAAAAFAAAACQAAAAHAAAAFQAAAAkAAAAUAAAADgAAABMAAAAJAAAAKAAAABsAAAAkAAAAFQAAACYAAAATAAAAIgAAAA0AAAAdAAAABwAAABYAAAAQAAAAKQAAACEAAAAPAAAACAAAAB8AAAAXAAAAGAAAAAsAAAAKAAAAJwAAACUAAAAZAAAAGAAAAH8AAAAgAAAAJQAAAAoAAAAXAAAAEgAAABkAAAAXAAAAEQAAAAsAAAAtAAAAJwAAACMAAAAaAAAAKgAAAB0AAAArAAAADAAAABwAAAANAAAAGwAAACgAAAAjAAAALgAAAA4AAAAUAAAAEQAAABwAAAAfAAAAKgAAACwAAAAMAAAADwAAABoAAAAdAAAAKwAAACYAAAAvAAAADQAAABoAAAAVAAAAHgAAACAAAAAwAAAAMgAAABAAAAASAAAAIQAAAB8AAAApAAAALAAAADUAAAAPAAAAFgAAABwAAAAgAAAAHgAAABgAAAASAAAANAAAADIAAAAlAAAAIQAAAB4AAAAxAAAAMAAAABYAAAAQAAAAKQAAACIAAAATAAAAJgAAABUAAAA2AAAAJAAAADMAAAAjAAAALgAAAC0AAAA4AAAAEQAAABsAAAAZAAAAJAAAABQAAAAiAAAAEwAAADcAAAAoAAAANgAAACUAAAAnAAAANAAAADkAAAAYAAAAFwAAACAAAAAmAAAAfwAAACIAAAAzAAAAHQAAAC8AAAAVAAAAJwAAACUAAAAZAAAAFwAAADsAAAA5AAAALQAAACgAAAAbAAAAJAAAABQAAAA8AAAALgAAADcAAAApAAAAMQAAADUAAAA9AAAAFgAAACEAAAAfAAAAKgAAADoAAAArAAAAPgAAABwAAAAsAAAAGgAAACsAAAA+AAAALwAAAEAAAAAaAAAAKgAAAB0AAAAsAAAANQAAADoAAABBAAAAHAAAAB8AAAAqAAAALQAAACcAAAAjAAAAGQAAAD8AAAA7AAAAOAAAAC4AAAA8AAAAOAAAAEQAAAAbAAAAKAAAACMAAAAvAAAAJgAAACsAAAAdAAAARQAAADMAAABAAAAAMAAAADEAAAAeAAAAIQAAAEMAAABCAAAAMgAAADEAAAB/AAAAPQAAAEIAAAAhAAAAMAAAACkAAAAyAAAAMAAAACAAAAAeAAAARgAAAEMAAAA0AAAAMwAAAEUAAAA2AAAARwAAACYAAAAvAAAAIgAAADQAAAA5AAAARgAAAEoAAAAgAAAAJQAAADIAAAA1AAAAPQAAAEEAAABLAAAAHwAAACkAAAAsAAAANgAAAEcAAAA3AAAASQAAACIAAAAzAAAAJAAAADcAAAAoAAAANgAAACQAAABIAAAAPAAAAEkAAAA4AAAARAAAAD8AAABNAAAAIwAAAC4AAAAtAAAAOQAAADsAAABKAAAATgAAACUAAAAnAAAANAAAADoAAAB/AAAAPgAAAEwAAAAsAAAAQQAAACoAAAA7AAAAPwAAAE4AAABPAAAAJwAAAC0AAAA5AAAAPAAAAEgAAABEAAAAUAAAACgAAAA3AAAALgAAAD0AAAA1AAAAMQAAACkAAABRAAAASwAAAEIAAAA+AAAAKwAAADoAAAAqAAAAUgAAAEAAAABMAAAAPwAAAH8AAAA4AAAALQAAAE8AAAA7AAAATQAAAEAAAAAvAAAAPgAAACsAAABUAAAARQAAAFIAAABBAAAAOgAAADUAAAAsAAAAVgAAAEwAAABLAAAAQgAAAEMAAABRAAAAVQAAADEAAAAwAAAAPQAAAEMAAABCAAAAMgAAADAAAABXAAAAVQAAAEYAAABEAAAAOAAAADwAAAAuAAAAWgAAAE0AAABQAAAARQAAADMAAABAAAAALwAAAFkAAABHAAAAVAAAAEYAAABDAAAANAAAADIAAABTAAAAVwAAAEoAAABHAAAAWQAAAEkAAABbAAAAMwAAAEUAAAA2AAAASAAAAH8AAABJAAAANwAAAFAAAAA8AAAAWAAAAEkAAABbAAAASAAAAFgAAAA2AAAARwAAADcAAABKAAAATgAAAFMAAABcAAAANAAAADkAAABGAAAASwAAAEEAAAA9AAAANQAAAF4AAABWAAAAUQAAAEwAAABWAAAAUgAAAGAAAAA6AAAAQQAAAD4AAABNAAAAPwAAAEQAAAA4AAAAXQAAAE8AAABaAAAATgAAAEoAAAA7AAAAOQAAAF8AAABcAAAATwAAAE8AAABOAAAAPwAAADsAAABdAAAAXwAAAE0AAABQAAAARAAAAEgAAAA8AAAAYwAAAFoAAABYAAAAUQAAAFUAAABeAAAAZQAAAD0AAABCAAAASwAAAFIAAABgAAAAVAAAAGIAAAA+AAAATAAAAEAAAABTAAAAfwAAAEoAAABGAAAAZAAAAFcAAABcAAAAVAAAAEUAAABSAAAAQAAAAGEAAABZAAAAYgAAAFUAAABXAAAAZQAAAGYAAABCAAAAQwAAAFEAAABWAAAATAAAAEsAAABBAAAAaAAAAGAAAABeAAAAVwAAAFMAAABmAAAAZAAAAEMAAABGAAAAVQAAAFgAAABIAAAAWwAAAEkAAABjAAAAUAAAAGkAAABZAAAAYQAAAFsAAABnAAAARQAAAFQAAABHAAAAWgAAAE0AAABQAAAARAAAAGoAAABdAAAAYwAAAFsAAABJAAAAWQAAAEcAAABpAAAAWAAAAGcAAABcAAAAUwAAAE4AAABKAAAAbAAAAGQAAABfAAAAXQAAAE8AAABaAAAATQAAAG0AAABfAAAAagAAAF4AAABWAAAAUQAAAEsAAABrAAAAaAAAAGUAAABfAAAAXAAAAE8AAABOAAAAbQAAAGwAAABdAAAAYAAAAGgAAABiAAAAbgAAAEwAAABWAAAAUgAAAGEAAAB/AAAAYgAAAFQAAABnAAAAWQAAAG8AAABiAAAAbgAAAGEAAABvAAAAUgAAAGAAAABUAAAAYwAAAFAAAABpAAAAWAAAAGoAAABaAAAAcQAAAGQAAABmAAAAUwAAAFcAAABsAAAAcgAAAFwAAABlAAAAZgAAAGsAAABwAAAAUQAAAFUAAABeAAAAZgAAAGUAAABXAAAAVQAAAHIAAABwAAAAZAAAAGcAAABbAAAAYQAAAFkAAAB0AAAAaQAAAG8AAABoAAAAawAAAG4AAABzAAAAVgAAAF4AAABgAAAAaQAAAFgAAABnAAAAWwAAAHEAAABjAAAAdAAAAGoAAABdAAAAYwAAAFoAAAB1AAAAbQAAAHEAAABrAAAAfwAAAGUAAABeAAAAcwAAAGgAAABwAAAAbAAAAGQAAABfAAAAXAAAAHYAAAByAAAAbQAAAG0AAABsAAAAXQAAAF8AAAB1AAAAdgAAAGoAAABuAAAAYgAAAGgAAABgAAAAdwAAAG8AAABzAAAAbwAAAGEAAABuAAAAYgAAAHQAAABnAAAAdwAAAHAAAABrAAAAZgAAAGUAAAB4AAAAcwAAAHIAAABxAAAAYwAAAHQAAABpAAAAdQAAAGoAAAB5AAAAcgAAAHAAAABkAAAAZgAAAHYAAAB4AAAAbAAAAHMAAABuAAAAawAAAGgAAAB4AAAAdwAAAHAAAAB0AAAAZwAAAHcAAABvAAAAcQAAAGkAAAB5AAAAdQAAAH8AAABtAAAAdgAAAHEAAAB5AAAAagAAAHYAAAB4AAAAbAAAAHIAAAB1AAAAeQAAAG0AAAB3AAAAbwAAAHMAAABuAAAAeQAAAHQAAAB4AAAAeAAAAHMAAAByAAAAcAAAAHkAAAB3AAAAdgAAAHkAAAB0AAAAeAAAAHcAAAB1AAAAcQAAAHYAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAABAAAABQAAAAEAAAAAAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAACAAAABQAAAAEAAAAAAAAA/////wEAAAAAAAAAAwAAAAQAAAACAAAAAAAAAAAAAAABAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAMAAAAFAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAFAAAAAQAAAAAAAAAAAAAAAQAAAAMAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAEAAAADAAAAAAAAAAAAAAABAAAAAAAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAADAAAABQAAAAEAAAAAAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABAAAAAAAAAP////8DAAAAAAAAAAUAAAACAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAEAAAABQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAMAAAADAAAAAwAAAAMAAAAAAAAAAwAAAAAAAAAAAAAAAAAAAAMAAAAFAAAABQAAAAAAAAAAAAAAAwAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAADAAAAAwAAAAAAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAFAAAABQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAMAAAADAAAAAwAAAAAAAAADAAAAAAAAAAAAAAD/////AwAAAAAAAAAFAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAAAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAADAAAAAAAAAAAAAAAAAAAAAwAAAAMAAAAAAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAAAAAABAAAAAwAAAAAAAAAAAAAAAQAAAAAAAAADAAAAAwAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAMAAAADAAAAAwAAAAMAAAAAAAAAAwAAAAAAAAAAAAAAAQAAAAMAAAAAAAAAAAAAAAEAAAAAAAAAAwAAAAMAAAADAAAAAwAAAAAAAAADAAAAAAAAAAAAAAADAAAAAAAAAAMAAAAAAAAAAwAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAAAAAAAAwAAAAAAAAAAAAAAAAAAAAMAAAADAAAAAAAAAP////8DAAAAAAAAAAUAAAACAAAAAAAAAAAAAAADAAAAAAAAAAAAAAADAAAAAwAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAwAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAUAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAFAAAABQAAAAAAAAAAAAAAAwAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAwAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAwAAAAMAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAADAAAAAwAAAAAAAAADAAAAAAAAAAAAAAADAAAAAwAAAAMAAAAAAAAAAwAAAAAAAAAAAAAA/////wMAAAAAAAAABQAAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAwAAAAAAAAADAAAAAAAAAAAAAAAAAAAAAwAAAAMAAAAAAAAAAAAAAAMAAAAAAAAAAwAAAAAAAAADAAAAAAAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAADAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAADAAAAAAAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAwAAAAAAAAAAAAAA/////wMAAAAAAAAABQAAAAIAAAAAAAAAAAAAAAMAAAADAAAAAwAAAAMAAAADAAAAAAAAAAAAAAADAAAAAwAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAwAAAAMAAAADAAAAAwAAAAAAAAADAAAAAAAAAAMAAAADAAAAAwAAAAMAAAAAAAAAAwAAAAAAAAD/////AwAAAAAAAAAFAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAAAAAADAAAAAAAAAAMAAAADAAAAAwAAAAAAAAADAAAAAAAAAAAAAAADAAAAAAAAAAAAAAAAAAAAAwAAAAMAAAAAAAAAAwAAAAAAAAAAAAAAAwAAAAMAAAAAAAAAAAAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAAAAAADAAAAAwAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAADAAAAAAAAAAAAAAD/////AwAAAAAAAAAFAAAAAgAAAAAAAAAAAAAAAwAAAAMAAAADAAAAAAAAAAAAAAADAAAAAAAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAAAAAAAAwAAAAAAAAAAAAAAAAAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAFAAAAAAAAAAAAAAADAAAAAwAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAADAAAAAQAAAAAAAAABAAAAAAAAAAAAAAABAAAAAwAAAAEAAAAAAAAAAQAAAAAAAAAAAAAAAwAAAAAAAAADAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAAAAAAAAwAAAAAAAAADAAAAAAAAAP////8DAAAAAAAAAAUAAAACAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAwAAAAMAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAADAAAAAAAAAAAAAAADAAAAAwAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAUAAAAAAAAAAAAAAAMAAAADAAAAAwAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAwAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAFAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAFAAAABQAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAwAAAAAAAAAAAAAA/////wMAAAAAAAAABQAAAAIAAAAAAAAAAAAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAwAAAAAAAAAFAAAAAAAAAAAAAAAFAAAABQAAAAAAAAAAAAAAAAAAAAEAAAADAAAAAQAAAAAAAAABAAAAAAAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAwAAAAAAAAADAAAAAwAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAADAAAAAQAAAAAAAAABAAAAAAAAAAMAAAADAAAAAwAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAEAAAAAAAAAAwAAAAUAAAABAAAAAAAAAP////8DAAAAAAAAAAUAAAACAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAFAAAABQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAABAAAAAUAAAABAAAAAAAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAIAAAAFAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAEAAAADAAAAAQAAAAAAAAABAAAAAAAAAAUAAAAAAAAAAAAAAAUAAAAFAAAAAAAAAAAAAAD/////AQAAAAAAAAADAAAABAAAAAIAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAUAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAFAAAAAAAAAAAAAAAFAAAABQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAQAAAAUAAAABAAAAAAAAAAAAAAABAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAAAAAAAAAEAAAD//////////wEAAAABAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAADAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAsAAAACAAAAAAAAAAAAAAABAAAAAgAAAAYAAAAEAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAABAAAAAQAAAAAAAAAAAAAAAAAAAAcAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAACAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAYAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAKAAAAAgAAAAAAAAAAAAAAAQAAAAEAAAAFAAAABgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAABAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAABwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAsAAAABAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAACAAAAAAAAAAAAAAABAAAAAwAAAAcAAAAGAAAAAQAAAAAAAAABAAAAAAAAAAAAAAAAAAAABwAAAAEAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAABAAAAAQAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAGAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAADgAAAAIAAAAAAAAAAAAAAAEAAAAAAAAACQAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACgAAAAEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAMAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAABwAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAsAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADQAAAAIAAAAAAAAAAAAAAAEAAAAEAAAACAAAAAoAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAALAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAACQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAGAAAAAgAAAAAAAAAAAAAAAQAAAAsAAAAPAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAOAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAEAAAAAAAAAAQAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAIAAAAAQAAAAAAAAABAAAAAAAAAAAAAAAAAAAABQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAAAAgAAAAAAAAAAAAAAAQAAAAwAAAAQAAAADAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAoAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAJAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAPAAAAAAAAAAEAAAABAAAAAAAAAAAAAAAAAAAADwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAADQAAAAEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAACAAAAAAAAAAAAAAABAAAACgAAABMAAAAIAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkAAAABAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAEQAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEQAAAAAAAAABAAAAAQAAAAAAAAAAAAAAAAAAAA8AAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAQAAAAAQAAAAAAAAABAAAAAAAAAAAAAAAAAAAACQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAIAAAAAAAAAAAAAAAEAAAANAAAAEQAAAA0AAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAARAAAAAQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAEwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAATAAAAAAAAAAEAAAABAAAAAAAAAAAAAAAAAAAAEQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAA0AAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAARAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkAAAACAAAAAAAAAAAAAAABAAAADgAAABIAAAAPAAAAAQAAAAAAAAABAAAAAAAAAAAAAAAAAAAADwAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABIAAAAAAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAASAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAEwAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAABEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAABIAAAABAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAATAAAAAgAAAAAAAAAAAAAAAQAAAP//////////EwAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATAAAAAQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAEgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAASAAAAAAAAABgAAAAAAAAAIQAAAAAAAAAeAAAAAAAAACAAAAADAAAAMQAAAAEAAAAwAAAAAwAAADIAAAADAAAACAAAAAAAAAAFAAAABQAAAAoAAAAFAAAAFgAAAAAAAAAQAAAAAAAAABIAAAAAAAAAKQAAAAEAAAAhAAAAAAAAAB4AAAAAAAAABAAAAAAAAAAAAAAABQAAAAIAAAAFAAAADwAAAAEAAAAIAAAAAAAAAAUAAAAFAAAAHwAAAAEAAAAWAAAAAAAAABAAAAAAAAAAAgAAAAAAAAAGAAAAAAAAAA4AAAAAAAAACgAAAAAAAAALAAAAAAAAABEAAAADAAAAGAAAAAEAAAAXAAAAAwAAABkAAAADAAAAAAAAAAAAAAABAAAABQAAAAkAAAAFAAAABQAAAAAAAAACAAAAAAAAAAYAAAAAAAAAEgAAAAEAAAAKAAAAAAAAAAsAAAAAAAAABAAAAAEAAAADAAAABQAAAAcAAAAFAAAACAAAAAEAAAAAAAAAAAAAAAEAAAAFAAAAEAAAAAEAAAAFAAAAAAAAAAIAAAAAAAAABwAAAAAAAAAVAAAAAAAAACYAAAAAAAAACQAAAAAAAAATAAAAAAAAACIAAAADAAAADgAAAAEAAAAUAAAAAwAAACQAAAADAAAAAwAAAAAAAAANAAAABQAAAB0AAAAFAAAAAQAAAAAAAAAHAAAAAAAAABUAAAAAAAAABgAAAAEAAAAJAAAAAAAAABMAAAAAAAAABAAAAAIAAAAMAAAABQAAABoAAAAFAAAAAAAAAAEAAAADAAAAAAAAAA0AAAAFAAAAAgAAAAEAAAABAAAAAAAAAAcAAAAAAAAAGgAAAAAAAAAqAAAAAAAAADoAAAAAAAAAHQAAAAAAAAArAAAAAAAAAD4AAAADAAAAJgAAAAEAAAAvAAAAAwAAAEAAAAADAAAADAAAAAAAAAAcAAAABQAAACwAAAAFAAAADQAAAAAAAAAaAAAAAAAAACoAAAAAAAAAFQAAAAEAAAAdAAAAAAAAACsAAAAAAAAABAAAAAMAAAAPAAAABQAAAB8AAAAFAAAAAwAAAAEAAAAMAAAAAAAAABwAAAAFAAAABwAAAAEAAAANAAAAAAAAABoAAAAAAAAAHwAAAAAAAAApAAAAAAAAADEAAAAAAAAALAAAAAAAAAA1AAAAAAAAAD0AAAADAAAAOgAAAAEAAABBAAAAAwAAAEsAAAADAAAADwAAAAAAAAAWAAAABQAAACEAAAAFAAAAHAAAAAAAAAAfAAAAAAAAACkAAAAAAAAAKgAAAAEAAAAsAAAAAAAAADUAAAAAAAAABAAAAAQAAAAIAAAABQAAABAAAAAFAAAADAAAAAEAAAAPAAAAAAAAABYAAAAFAAAAGgAAAAEAAAAcAAAAAAAAAB8AAAAAAAAAMgAAAAAAAAAwAAAAAAAAADEAAAADAAAAIAAAAAAAAAAeAAAAAwAAACEAAAADAAAAGAAAAAMAAAASAAAAAwAAABAAAAADAAAARgAAAAAAAABDAAAAAAAAAEIAAAADAAAANAAAAAMAAAAyAAAAAAAAADAAAAAAAAAAJQAAAAMAAAAgAAAAAAAAAB4AAAADAAAAUwAAAAAAAABXAAAAAwAAAFUAAAADAAAASgAAAAMAAABGAAAAAAAAAEMAAAAAAAAAOQAAAAEAAAA0AAAAAwAAADIAAAAAAAAAGQAAAAAAAAAXAAAAAAAAABgAAAADAAAAEQAAAAAAAAALAAAAAwAAAAoAAAADAAAADgAAAAMAAAAGAAAAAwAAAAIAAAADAAAALQAAAAAAAAAnAAAAAAAAACUAAAADAAAAIwAAAAMAAAAZAAAAAAAAABcAAAAAAAAAGwAAAAMAAAARAAAAAAAAAAsAAAADAAAAPwAAAAAAAAA7AAAAAwAAADkAAAADAAAAOAAAAAMAAAAtAAAAAAAAACcAAAAAAAAALgAAAAMAAAAjAAAAAwAAABkAAAAAAAAAJAAAAAAAAAAUAAAAAAAAAA4AAAADAAAAIgAAAAAAAAATAAAAAwAAAAkAAAADAAAAJgAAAAMAAAAVAAAAAwAAAAcAAAADAAAANwAAAAAAAAAoAAAAAAAAABsAAAADAAAANgAAAAMAAAAkAAAAAAAAABQAAAAAAAAAMwAAAAMAAAAiAAAAAAAAABMAAAADAAAASAAAAAAAAAA8AAAAAwAAAC4AAAADAAAASQAAAAMAAAA3AAAAAAAAACgAAAAAAAAARwAAAAMAAAA2AAAAAwAAACQAAAAAAAAAQAAAAAAAAAAvAAAAAAAAACYAAAADAAAAPgAAAAAAAAArAAAAAwAAAB0AAAADAAAAOgAAAAMAAAAqAAAAAwAAABoAAAADAAAAVAAAAAAAAABFAAAAAAAAADMAAAADAAAAUgAAAAMAAABAAAAAAAAAAC8AAAAAAAAATAAAAAMAAAA+AAAAAAAAACsAAAADAAAAYQAAAAAAAABZAAAAAwAAAEcAAAADAAAAYgAAAAMAAABUAAAAAAAAAEUAAAAAAAAAYAAAAAMAAABSAAAAAwAAAEAAAAAAAAAASwAAAAAAAABBAAAAAAAAADoAAAADAAAAPQAAAAAAAAA1AAAAAwAAACwAAAADAAAAMQAAAAMAAAApAAAAAwAAAB8AAAADAAAAXgAAAAAAAABWAAAAAAAAAEwAAAADAAAAUQAAAAMAAABLAAAAAAAAAEEAAAAAAAAAQgAAAAMAAAA9AAAAAAAAADUAAAADAAAAawAAAAAAAABoAAAAAwAAAGAAAAADAAAAZQAAAAMAAABeAAAAAAAAAFYAAAAAAAAAVQAAAAMAAABRAAAAAwAAAEsAAAAAAAAAOQAAAAAAAAA7AAAAAAAAAD8AAAADAAAASgAAAAAAAABOAAAAAwAAAE8AAAADAAAAUwAAAAMAAABcAAAAAwAAAF8AAAADAAAAJQAAAAAAAAAnAAAAAwAAAC0AAAADAAAANAAAAAAAAAA5AAAAAAAAADsAAAAAAAAARgAAAAMAAABKAAAAAAAAAE4AAAADAAAAGAAAAAAAAAAXAAAAAwAAABkAAAADAAAAIAAAAAMAAAAlAAAAAAAAACcAAAADAAAAMgAAAAMAAAA0AAAAAAAAADkAAAAAAAAALgAAAAAAAAA8AAAAAAAAAEgAAAADAAAAOAAAAAAAAABEAAAAAwAAAFAAAAADAAAAPwAAAAMAAABNAAAAAwAAAFoAAAADAAAAGwAAAAAAAAAoAAAAAwAAADcAAAADAAAAIwAAAAAAAAAuAAAAAAAAADwAAAAAAAAALQAAAAMAAAA4AAAAAAAAAEQAAAADAAAADgAAAAAAAAAUAAAAAwAAACQAAAADAAAAEQAAAAMAAAAbAAAAAAAAACgAAAADAAAAGQAAAAMAAAAjAAAAAAAAAC4AAAAAAAAARwAAAAAAAABZAAAAAAAAAGEAAAADAAAASQAAAAAAAABbAAAAAwAAAGcAAAADAAAASAAAAAMAAABYAAAAAwAAAGkAAAADAAAAMwAAAAAAAABFAAAAAwAAAFQAAAADAAAANgAAAAAAAABHAAAAAAAAAFkAAAAAAAAANwAAAAMAAABJAAAAAAAAAFsAAAADAAAAJgAAAAAAAAAvAAAAAwAAAEAAAAADAAAAIgAAAAMAAAAzAAAAAAAAAEUAAAADAAAAJAAAAAMAAAA2AAAAAAAAAEcAAAAAAAAAYAAAAAAAAABoAAAAAAAAAGsAAAADAAAAYgAAAAAAAABuAAAAAwAAAHMAAAADAAAAYQAAAAMAAABvAAAAAwAAAHcAAAADAAAATAAAAAAAAABWAAAAAwAAAF4AAAADAAAAUgAAAAAAAABgAAAAAAAAAGgAAAAAAAAAVAAAAAMAAABiAAAAAAAAAG4AAAADAAAAOgAAAAAAAABBAAAAAwAAAEsAAAADAAAAPgAAAAMAAABMAAAAAAAAAFYAAAADAAAAQAAAAAMAAABSAAAAAAAAAGAAAAAAAAAAVQAAAAAAAABXAAAAAAAAAFMAAAADAAAAZQAAAAAAAABmAAAAAwAAAGQAAAADAAAAawAAAAMAAABwAAAAAwAAAHIAAAADAAAAQgAAAAAAAABDAAAAAwAAAEYAAAADAAAAUQAAAAAAAABVAAAAAAAAAFcAAAAAAAAAXgAAAAMAAABlAAAAAAAAAGYAAAADAAAAMQAAAAAAAAAwAAAAAwAAADIAAAADAAAAPQAAAAMAAABCAAAAAAAAAEMAAAADAAAASwAAAAMAAABRAAAAAAAAAFUAAAAAAAAAXwAAAAAAAABcAAAAAAAAAFMAAAAAAAAATwAAAAAAAABOAAAAAAAAAEoAAAADAAAAPwAAAAEAAAA7AAAAAwAAADkAAAADAAAAbQAAAAAAAABsAAAAAAAAAGQAAAAFAAAAXQAAAAEAAABfAAAAAAAAAFwAAAAAAAAATQAAAAEAAABPAAAAAAAAAE4AAAAAAAAAdQAAAAQAAAB2AAAABQAAAHIAAAAFAAAAagAAAAEAAABtAAAAAAAAAGwAAAAAAAAAWgAAAAEAAABdAAAAAQAAAF8AAAAAAAAAWgAAAAAAAABNAAAAAAAAAD8AAAAAAAAAUAAAAAAAAABEAAAAAAAAADgAAAADAAAASAAAAAEAAAA8AAAAAwAAAC4AAAADAAAAagAAAAAAAABdAAAAAAAAAE8AAAAFAAAAYwAAAAEAAABaAAAAAAAAAE0AAAAAAAAAWAAAAAEAAABQAAAAAAAAAEQAAAAAAAAAdQAAAAMAAABtAAAABQAAAF8AAAAFAAAAcQAAAAEAAABqAAAAAAAAAF0AAAAAAAAAaQAAAAEAAABjAAAAAQAAAFoAAAAAAAAAaQAAAAAAAABYAAAAAAAAAEgAAAAAAAAAZwAAAAAAAABbAAAAAAAAAEkAAAADAAAAYQAAAAEAAABZAAAAAwAAAEcAAAADAAAAcQAAAAAAAABjAAAAAAAAAFAAAAAFAAAAdAAAAAEAAABpAAAAAAAAAFgAAAAAAAAAbwAAAAEAAABnAAAAAAAAAFsAAAAAAAAAdQAAAAIAAABqAAAABQAAAFoAAAAFAAAAeQAAAAEAAABxAAAAAAAAAGMAAAAAAAAAdwAAAAEAAAB0AAAAAQAAAGkAAAAAAAAAdwAAAAAAAABvAAAAAAAAAGEAAAAAAAAAcwAAAAAAAABuAAAAAAAAAGIAAAADAAAAawAAAAEAAABoAAAAAwAAAGAAAAADAAAAeQAAAAAAAAB0AAAAAAAAAGcAAAAFAAAAeAAAAAEAAAB3AAAAAAAAAG8AAAAAAAAAcAAAAAEAAABzAAAAAAAAAG4AAAAAAAAAdQAAAAEAAABxAAAABQAAAGkAAAAFAAAAdgAAAAEAAAB5AAAAAAAAAHQAAAAAAAAAcgAAAAEAAAB4AAAAAQAAAHcAAAAAAAAAcgAAAAAAAABwAAAAAAAAAGsAAAAAAAAAZAAAAAAAAABmAAAAAAAAAGUAAAADAAAAUwAAAAEAAABXAAAAAwAAAFUAAAADAAAAdgAAAAAAAAB4AAAAAAAAAHMAAAAFAAAAbAAAAAEAAAByAAAAAAAAAHAAAAAAAAAAXAAAAAEAAABkAAAAAAAAAGYAAAAAAAAAdQAAAAAAAAB5AAAABQAAAHcAAAAFAAAAbQAAAAEAAAB2AAAAAAAAAHgAAAAAAAAAXwAAAAEAAABsAAAAAQAAAHIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAEAAAAAAAAAAAAAAAEAAAABAAAAAQAAAAAAAAAAAAAAAQAAAAAAAAABAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAGAAAAAgAAAAUAAAABAAAABAAAAAAAAAAAAAAABQAAAAMAAAABAAAABgAAAAQAAAACAAAAAAAAAH6iBfbytuk/Gq6akm/58z/Xrm0Liez0P5doSdOpSwRAWs602ULg8D/dT7Rcbo/1v1N1RQHFNOM/g9Snx7HW3L8HWsP8Q3jfP6VwOLosutk/9rjk1YQcxj+gnmKMsNn6P/HDeuPFY+M/YHwDjqKhB0Ci19/fCVrbP4UxKkDWOP6/pvljWa09tL9wi7wrQXjnv/Z6yLImkM2/3yTlOzY14D+m+WNZrT20PzwKVQnrQwNA9nrIsiaQzT/g40rFrRQFwPa45NWEHMa/kbslHEZq97/xw3rjxWPjv4cLC2SMBci/otff3wla27+rKF5oIAv0P1N1RQHFNOO/iDJPGyWHBUAHWsP8Q3jfvwQf/by16gXAfqIF9vK26b8XrO0Vh0r+v9eubQuJ7PS/BxLrA0ZZ479azrTZQuDwv1MK1EuItPw/yscgV9Z6FkAwHBR2WjQMQJNRzXsQ5vY/GlUHVJYKF0DONuFv2lMNQNCGZ28QJfk/0WUwoIL36D8ggDOMQuATQNqMOeAy/wZAWFYOYM+M2z/LWC4uH3oSQDE+LyTsMgRAkJzhRGWFGEDd4soovCQQQKqk0DJMEP8/rGmNdwOLBUAW2X/9xCbjP4hu3dcqJhNAzuYItRvdB0CgzW3zJW/sPxotm/Y2TxRAQAk9XmdDDEC1Kx9MKgT3P1M+NctcghZAFVqcLlb0C0Bgzd3sB2b2P77mZDPUWhZAFROHJpUGCEDAfma5CxXtPz1DWq/zYxRAmhYY5824F0DOuQKWSbAOQNCMqrvu3fs/L6DR22K2wT9nAAxPBU8RQGiN6mW43AFAZhu25b633D8c1YgmzowSQNM25BRKWARArGS08/lNxD+LFssHwmMRQLC5aNcxBgJABL9HT0WRF0CjCmJmOGEOQHsuaVzMP/s/TWJCaGGwBUCeu1PAPLzjP9nqN9DZOBNAKE4JcydbCkCGtbd1qjPzP8dgm9U8jhVAtPeKTkVwDkCeCLss5l37P401XMPLmBdAFd29VMVQDUBg0yA55h75Pz6odcYLCRdApBM4rBrkAkDyAVWgQxbRP4XDMnK20hFAymLlF7EmzD8GUgo9XBHlP3lbK7T9COc/k+OhPthhy7+YGEpnrOvCPzBFhLs15u4/epbqB6H4uz9IuuLF5svev6lzLKY31es/CaQ0envF5z8ZY0xlUADXv7zaz7HYEuI/CfbK1sn16T8uAQfWwxLWPzKn/YuFN94/5KdbC1AFu793fyCSnlfvPzK2y4doAMY/NRg5t1/X6b/shq4QJaHDP5yNIAKPOeI/vpn7BSE30r/X4YQrO6nrv78Ziv/Thto/DqJ1Y6+y5z9l51NaxFrlv8QlA65HOLS/86dxiEc96z+Hj0+LFjneP6LzBZ8LTc2/DaJ1Y6+y579l51NaxFrlP8QlA65HOLQ/8qdxiEc967+Jj0+LFjnev6LzBZ8LTc0/1qdbC1AFuz93fyCSnlfvvzK2y4doAMa/NRg5t1/X6T/vhq4QJaHDv5yNIAKPOeK/wJn7BSE30j/W4YQrO6nrP78Ziv/Thtq/CaQ0envF578XY0xlUADXP7zaz7HYEuK/CvbK1sn16b8rAQfWwxLWvzKn/YuFN96/zWLlF7EmzL8GUgo9XBHlv3lbK7T9COe/kOOhPthhyz+cGEpnrOvCvzBFhLs15u6/c5bqB6H4u79IuuLF5sveP6lzLKY31eu/AQAAAP////8HAAAA/////zEAAAD/////VwEAAP////9hCQAA/////6dBAAD/////kcsBAP/////3kAwA/////8H2VwAAAAAAAAAAAAAAAAACAAAA/////w4AAAD/////YgAAAP////+uAgAA/////8ISAAD/////ToMAAP////8ilwMA/////+4hGQD/////gu2vAAAAAAAAAAAAAAAAAAAAAAACAAAA//////////8BAAAAAwAAAP//////////////////////////////////////////////////////////////////////////AQAAAAAAAAACAAAA////////////////AwAAAP//////////////////////////////////////////////////////////////////////////AQAAAAAAAAACAAAA////////////////AwAAAP//////////////////////////////////////////////////////////////////////////AQAAAAAAAAACAAAA////////////////AwAAAP//////////////////////////////////////////////////////////AgAAAP//////////AQAAAAAAAAD/////////////////////AwAAAP////////////////////////////////////////////////////8DAAAA/////////////////////wAAAAD/////////////////////AQAAAP///////////////wIAAAD///////////////////////////////8DAAAA/////////////////////wAAAAD///////////////8CAAAAAQAAAP////////////////////////////////////////////////////8DAAAA/////////////////////wAAAAD///////////////8CAAAAAQAAAP////////////////////////////////////////////////////8DAAAA/////////////////////wAAAAD///////////////8CAAAAAQAAAP////////////////////////////////////////////////////8DAAAA/////////////////////wAAAAD///////////////8CAAAAAQAAAP////////////////////////////////////////////////////8BAAAAAgAAAP///////////////wAAAAD/////////////////////AwAAAP////////////////////////////////////////////////////8BAAAAAgAAAP///////////////wAAAAD/////////////////////AwAAAP////////////////////////////////////////////////////8BAAAAAgAAAP///////////////wAAAAD/////////////////////AwAAAP////////////////////////////////////////////////////8BAAAAAgAAAP///////////////wAAAAD/////////////////////AwAAAP///////////////////////////////wIAAAD///////////////8BAAAA/////////////////////wAAAAD/////////////////////AwAAAP////////////////////////////////////////////////////8DAAAA/////////////////////wAAAAABAAAA//////////8CAAAA//////////////////////////////////////////////////////////8DAAAA////////////////AgAAAAAAAAABAAAA//////////////////////////////////////////////////////////////////////////8DAAAA////////////////AgAAAAAAAAABAAAA//////////////////////////////////////////////////////////////////////////8DAAAA////////////////AgAAAAAAAAABAAAA//////////////////////////////////////////////////////////////////////////8DAAAAAQAAAP//////////AgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAACAAAAAAAAAAIAAAABAAAAAQAAAAIAAAACAAAAAAAAAAUAAAAFAAAAAAAAAAIAAAACAAAAAwAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAAAAgAAAAEAAAACAAAAAgAAAAIAAAAAAAAABQAAAAYAAAAAAAAAAgAAAAIAAAADAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAgAAAAAAAAACAAAAAQAAAAMAAAACAAAAAgAAAAAAAAAFAAAABwAAAAAAAAACAAAAAgAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAACAAAAAAAAAAIAAAABAAAABAAAAAIAAAACAAAAAAAAAAUAAAAIAAAAAAAAAAIAAAACAAAAAwAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAIAAAAAAAAAAgAAAAEAAAAAAAAAAgAAAAIAAAAAAAAABQAAAAkAAAAAAAAAAgAAAAIAAAADAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAKAAAAAgAAAAIAAAAAAAAAAwAAAA4AAAACAAAAAAAAAAIAAAADAAAAAAAAAAAAAAACAAAAAgAAAAMAAAAGAAAAAAAAAAAAAAAAAAAAAAAAAAsAAAACAAAAAgAAAAAAAAADAAAACgAAAAIAAAAAAAAAAgAAAAMAAAABAAAAAAAAAAIAAAACAAAAAwAAAAcAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAIAAAACAAAAAAAAAAMAAAALAAAAAgAAAAAAAAACAAAAAwAAAAIAAAAAAAAAAgAAAAIAAAADAAAACAAAAAAAAAAAAAAAAAAAAAAAAAANAAAAAgAAAAIAAAAAAAAAAwAAAAwAAAACAAAAAAAAAAIAAAADAAAAAwAAAAAAAAACAAAAAgAAAAMAAAAJAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAACAAAAAgAAAAAAAAADAAAADQAAAAIAAAAAAAAAAgAAAAMAAAAEAAAAAAAAAAIAAAACAAAAAwAAAAoAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAIAAAACAAAAAAAAAAMAAAAGAAAAAgAAAAAAAAACAAAAAwAAAA8AAAAAAAAAAgAAAAIAAAADAAAACwAAAAAAAAAAAAAAAAAAAAAAAAAGAAAAAgAAAAIAAAAAAAAAAwAAAAcAAAACAAAAAAAAAAIAAAADAAAAEAAAAAAAAAACAAAAAgAAAAMAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAcAAAACAAAAAgAAAAAAAAADAAAACAAAAAIAAAAAAAAAAgAAAAMAAAARAAAAAAAAAAIAAAACAAAAAwAAAA0AAAAAAAAAAAAAAAAAAAAAAAAACAAAAAIAAAACAAAAAAAAAAMAAAAJAAAAAgAAAAAAAAACAAAAAwAAABIAAAAAAAAAAgAAAAIAAAADAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAJAAAAAgAAAAIAAAAAAAAAAwAAAAUAAAACAAAAAAAAAAIAAAADAAAAEwAAAAAAAAACAAAAAgAAAAMAAAAPAAAAAAAAAAAAAAAAAAAAAAAAABAAAAACAAAAAAAAAAIAAAABAAAAEwAAAAIAAAACAAAAAAAAAAUAAAAKAAAAAAAAAAIAAAACAAAAAwAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEQAAAAIAAAAAAAAAAgAAAAEAAAAPAAAAAgAAAAIAAAAAAAAABQAAAAsAAAAAAAAAAgAAAAIAAAADAAAAEQAAAAAAAAAAAAAAAAAAAAAAAAASAAAAAgAAAAAAAAACAAAAAQAAABAAAAACAAAAAgAAAAAAAAAFAAAADAAAAAAAAAACAAAAAgAAAAMAAAASAAAAAAAAAAAAAAAAAAAAAAAAABMAAAACAAAAAAAAAAIAAAABAAAAEQAAAAIAAAACAAAAAAAAAAUAAAANAAAAAAAAAAIAAAACAAAAAwAAABMAAAAAAAAAAAAAAAAAAAAAAAAADwAAAAIAAAAAAAAAAgAAAAEAAAASAAAAAgAAAAIAAAAAAAAABQAAAA4AAAAAAAAAAgAAAAIAAAADAAAAAgAAAAEAAAAAAAAAAQAAAAIAAAAAAAAAAAAAAAIAAAABAAAAAAAAAAEAAAACAAAAAQAAAAAAAAACAAAAAAAAAAUAAAAEAAAAAAAAAAEAAAAFAAAAAAAAAAAAAAAFAAAABAAAAAAAAAABAAAABQAAAAQAAAAAAAAABQAAAAAAAAACAAAAAQAAAAAAAAABAAAAAgAAAAAAAAAAAAAAAgAAAAEAAAAAAAAAAQAAAAIAAAABAAAAAAAAAAIAAAACAAAAAAAAAAEAAAAAAAAAAAAAAAUAAAAEAAAAAAAAAAEAAAAFAAAAAAAAAAAAAAAFAAAABAAAAAAAAAABAAAABQAAAAQAAAAAAAAABQAAAAUAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAABAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAEAAAAAAAAAAAEAAAAAAQAAAAAAAAAAAQAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAABAAAAAAAAAAAAAQAAAAAAAAAAAAA6B6FaUp9QQTPXMuL4myJBraiDfBwx9UBYJseitzTIQOL5if9jqZtAnXX+Z+ycb0C3pucbhRBCQG8wJBYqpRRAlWbDCzCY5z/eFWBUEve6P/+qo4Q50Y4/D9YM3iCcYT8fcA2QJSA0P4ADxu0qAAc/BNcGolVJ2j5d9FACqwquPh9z7MthtI9CSUSYJke/YUJQ/64OyjU0Qpi0+HCmFQdCm3GfIVdh2kHsJ11kAyauQYC3UDFJOoFBSJsFV1OwU0FK5fcxX4AmQWhy/zZIt/lACqaCPsBjzUDbdUNIScugQMYQlVJ4MXNANiuq8GTvRUDxTXnulxEZQFZ8QX5kpuw/qmG/JwYFlEAluh3Q6DB+QKn4vyNq0GZAKOXekas+UUB8xabXXhI6QG63C2pLtSNAdDBtyNfLDUDyOcu67ID2P0rCMvRXAeE/Ki2TSVyzyT9Dk+8Sz2uzP5J+w5ARWp0/NQAoOiMuhj9YnP+RyMJwPxgW7TvQVFk/KgsLYF0kQz9g5dAC6IwzQcgHPVvDex1B1XjppodHBkHJq3OMM9fwQNvcmJ7wddlAInGPpQs/w0BRobq5EBmtQJZ2ai7n+ZVAtv2G5E+bgECG+gIfKBlpQK5f8jdI91JAL39sL/WpPEB8rGxhDqklQK6yUf43XhBAxL9y/tK8+D86XyZpgrHiPwAAAAD/////AAAAAAAAAAAAAAAAAAAAAAAAAAD/////////////////////////////////////AAAAAP////8AAAAAAAAAAAAAAAABAAAAAAAAAAAAAAD/////AAAAAAAAAAABAAAAAQAAAAAAAAAAAAAA/////wAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAP////8FAAAABQAAAAAAAAAAAAAAAAAAAAAAAAD/////AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/////////////////////////////////////wAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP////////////////////////////////////8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAFAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/////////////////////////////////////AAAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAQAAAAEAAAABAAAAAAAAAAEAAAAAAAAABQAAAAEAAAABAAAAAAAAAAAAAAABAAAAAQAAAAAAAAABAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQAAAAAAAQABAAABAQAAAAAAAQAAAAEAAAABAAEAAAAAAAAAAAAAAAAAAAAAquJYWJZl+D9jaeZNtj/zPwwdI9KqaeO/qGefXwdHdz+q4lhYlmX4P+OrlPMN3PI/DB0j0qpp47+7SQLV4VIEQKriWFiWZfg/r2kma3tz8T82eQmLqNIGwMRIWXMqSvo/fcCszPux9j+jara6ozTwP6hnn18HR3c/MSoKLequ8r+SabgA2nj0P7jBLbDOHO8/1Ym/ICfH4T+6lxjvlFXHv73m373LRPU/0vXyDVxo7T+ToKRHJXMAQF/33578aPE/pAyy64tD9T8+U/hCvyruPwxv8Y7YYwLAuXYr8NAiCEB4+LDK0Sn0P1Qeuy4j+eo/OMx50n7K7L+TrGB/nyf8v5ehC2fbYPM/aXMKexiT6z8mFRIMjg/zP7yUVwGGBNw/E6opHERf8z/z0wR2g9DqPw4pBpcOhvu/NbA29uWAA8DMaTExyXzyP02biiQ+Ruk/S8jz2/FKBEB1pzZnpbb9P7pQU4wLfPI//7ZcQXeG6D9CqEQvAYoIwDB2VB6sSgRAVyv8H5We8T+EHWF8XNPmPzB2wT8Nrrg/SEi+cX+w4L8of+GtdSDxP1sjk5AdouU/6ZjOVru13r8K0obqI6bxvwVbdNXyhfA/w5GG024n5z+rwmtMzP8BwLw9pSX49QXABe/2uQxP8D+b6wCzCvXkP7uGT87fK+Q/pz/JWw4coj+qoBf2J0nwP/yE3PUo0+I/vFJeHcaC+D96luSIqvntP/bf8sHUYu8/gZNN41mL4z9bhOqVOF4FwO6lmAh1hQhAbCVxbdhk7z+1C8NdDcfiPwG36x/0OQBAx0WJ76c2+D9nlSHXANfuP2HlfZ3gqOE/EwnVlVPg9r96+oHzEH//v5bXzdT1Auw/DM3GwLsA4D9p/8uoKcr+v+U9x5DQVAPAehjSdghb7D9sc1IetODgP8MVwwB1pu6/azPk6OGe978W8t/TUc3rP+0QMvYfP+A/RsG/QpSE8D+l3uwScxzgPwQaifgujuw/k1Vti1I43z8MAwLnSh0GQH5nYnwwZgJAiGUzWC5s6j8WyyI/BbLgPw4iUapGeQJAB3W+imnp/j9BLWR4ssrpP2t+gG5Pstk/cpBsfm6DCMCOpU9dOZsFQEv8nFypHeo/ehJ6i+6S2D9jqlGEmarLv7STC5TRiOa/bC+x8WZD6D9H3yUkWpDZP8gZvmCMuQLAreY19/eRBsCoPOc8UzzpP6KI/QV+y9g/t/MoboyWzT+Hv5q3Zu3Mvy2xROCT4uY/9gQitMMg1T9abAqhWMDkv1oLTavoUfG/PMUJP9CD5j+fHRX3t6fSPz7W2gk6bvs/WRnuHwqN9D8YFturGCTmP1EZczv0b9I/5t4exabB5D/1ESLh5fTEP9X2z6SYweQ/6lv3I2zT0D9zkRGNUNMAQKoSvc4EIfs/Xggt8wQI5T+mJHHg/w/SP4lhT/9t8vQ/DrZ/DbwH7D+XlhbYZrjkP34LIpFt6c4/lwfp8fLX9L+j96CTTf76v3WdNhEv9uM/d8c3o4lV0D/vFdCHVcsFwAHeDq0F1QhApbYqcZiN5D9KoilqByXLPwX0/diA0vq/0fo0GxnxAMBbaTkvlCzjP/RrFrWXrMs/UYTrky7jA0DB9f4FiZYAQEGAk/3QzeE/r/TeqE8t0D/OqjlsnPbvvz8RKU8JOfW/smSEbK/O4T8MzuyPm3DDP/rFtctq9gZAfb1EVEaSA0Dts5dVInnhP18SFMc79MM/7y34cw6LAMDFrRJsZO0DwC2KLvLSYuA/hx5wcUHewz+49SnK/4ruPyeS0PX9a+E/ZxaaLvvZ3z8WPu5T2QS8Pygo4RIvMqa/BJ0Kqsd0279cKW4ay8jdP3b05bmZ364/10/qtdxk2r+Bcz6CDMvpv54qOw+Amdw/qLV71pW7sT/YKc80nIPUP8OfIaBJ77G/LyTuD1un2z+diYu8efWzP1wU7ACkfwjAZroyPL1yBkAmv3lKJJbbPysKSE4W+p0/dIgqY79TA8ATLTOQ3tsGwJ2zweD/Xdg/XO/jXeFUaL8VW2qLFKfov1cA9Aa6XfK/tIa7YGgI2T+f3hu/sxqPv2nXdPpf3Pc/jkw8Jbda8j+tT/z8tGPVP1yBHpJd35k/KYvYOy1s8j/yz+kCQjPrP9+agH7x59g/PZfJ9aBhpr/rDKzvYBb+PwtkiaGCt/c/vb1mVr+f1T/JIHwHc8Govw7aeF6+9vG/Xv7kD6fp979isYioQYHVP7AIQZuSFrG/3z1AdUTnAUDN3XY9O7f9P0AdQ9ljYNQ/dJANJPTOrb8kLECUiiPlP4yF7UgmStA/9xGmXxCG1T9qZzix4W2zv2SGJRJVrPe/Fh9a2M/B/b8IexzFCoPSP9y1QFD2bLe/Q86cWLJe/b+mOOfYm78BwOTjkPAGE9E/8aPCUKu/ub9pPZyLCiUGwBA7Mev/BQlALOmrlRi+0j+AMJ/dKULBv7iLtL6a6QRAEMDV/yajAUDa62dE3crJP1P70RgBUbq/38hVnR6esT/s1tG10Z/Ov/zLwalHPss/dTS9NKTXx78nMcRzCIEHQAabxDsAmQRA0tyLK3gSyT+Aui7nOhDGv5Gs58z3WgHATN3forJuBMCAui7nOhDGP9Lciyt4Esm/WAJyHQ4c7z8UP5HFIs3iP3U0vTSk18c//MvBqUc+y7+cvv8HLg/Kvy1I/mHsI+K/U/vRGAFRuj/a62dE3crJv8p+WV8KlQjAuQ/nOP43B0CAMJ/dKULBPyzpq5UYvtK/ZoU+VoLh4L9etLlRUfvtv/GjwlCrv7k/5OOQ8AYT0b9DfT9FhufXPwUX8hJp+4u/3LVAUPZstz8IexzFCoPSv9+L609E5fQ/q9Fz7X2J7T9qZzix4W2zP/cRpl8QhtW/vtNilqGX+j8MOy7QJoL0P3SQDST0zq0/QB1D2WNg1L8IIjSvGNkDwGB8Jou2GAfAsAhBm5IWsT9isYioQYHVvyS9D3zb6uy/gnwRa7uM9L/JIHwHc8GoP729Zla/n9W/CsAHJZwmAEDEW6OYT1r6Pz2XyfWgYaY/35qAfvHn2L83Tdy4lS30vxf2/gZ0jPq/XIEekl3fmb+tT/z8tGPVvybPr2zJ1/+/K7mJ0ypVAsCf3hu/sxqPPwCGu2BoCNm/5oITrpZn+r+UDUyDP+n/v1zv413hVGg/nbPB4P9d2L9MlmkxNvgCQMtZlKE85v8/KwpIThb6nb8mv3lKJJbbv8+SZsTvOOc/pQCIIOYw0j+diYu8efWzvy8k7g9bp9u/kxYDa+pKtD9XlYvA8HnVv6i1e9aVu7G/nio7D4CZ3L/WR6rNh5EGwCkgQweBkghAdvTluZnfrr9cKW4ay8jdvxbjhr1f1QVAR5C0MzivAkAWPu5T2QS8v2cWmi772d+/cKj4lzLJCEBx2QJfYrMFQIcecHFB3sO/LYou8tJi4L+jr7lhO38BwIcI0Nb7xgTAXxIUxzv0w7/ts5dVInnhv0T+l8DZLfE/MP3FoFvS5D8MzuyPm3DDv7JkhGyvzuG/tzhzRIRc0b9Ovv3/0z7mv6/03qhPLdC/m4CT/dDN4b9dwjU5VCQBQBBJX1ntCv0/9GsWtZesy79baTkvlCzjv1mjYgEz++S/oW6KnOQW8b9KoilqByXLv6W2KnGYjeS/SmaKz3Vx9z+BZB5yxGHwP3fHN6OJVdC/dZ02ES/2478PuaBjLrXaP4/JU81pPaO/fgsikW3pzr+XlhbYZrjkv4tSn7YDbP0/f2LnFKlF9z+mJHHg/w/Sv14ILfMECOW/mfg4qYhR/b+OP+RQDCACwOpb9yNs09C/1fbPpJjB5L9pN2WOVZ3wv3hHy9nxIve/URlzO/Rv0r8YFturGCTmv1d1/KKR8QPA8gsy9qzSB8CfHRX3t6fSvzzFCT/Qg+a/EYStnrzV9r/2QJqI7Lb9v/YEIrTDINW/LbFE4JPi5r/7kQEs5fEDQHunnf4GeQBAooj9BX7L2L+oPOc8Uzzpv+ydYY2SSAfAL4HK6CRTB0BH3yUkWpDZv2wvsfFmQ+i/Ik0Yzruh6T8fM3LoGoDUP3oSeovukti/S/ycXKkd6r9rEv+7UWcHQCRIQe/GfwNAa36Abk+y2b9BLWR4ssrpv9KT87qa0bM/FTyktw823L8WyyI/BbLgv4hlM1gubOq/DizMp9Ki6r8b5ckdjVrzv5NVbYtSON+/BBqJ+C6O7L/dUBFqgyXYv00Wh18r7+q/7RAy9h8/4L8W8t/TUc3rv4RM5DKx3wDAfvWIj94aBcBsc1IetODgv3oY0nYIW+y/oGcTFF54AUDkJqS/FKX6PwzNxsC7AOC/ltfN1PUC7L+5Wrz/zHnzP6688w2rNOc/YeV9neCo4b9nlSHXANfuvw9RsxKjY/s/1V8GteXE8j+1C8NdDcfiv2wlcW3YZO+/IOywaA7Q8b9bFP+4Tg36v4GTTeNZi+O/9t/ywdRi77+tRc3yFR7eP2bkcHXJkLO//ITc9SjT4r+qoBf2J0nwv2YHKoswwfm/iQcLspCjAcCb6wCzCvXkvwXv9rkMT/C/YkuwYAMXBMApCNUai9kIwMORhtNuJ+e/BVt01fKF8L+ZqWEfvIjsP6h693QZYNk/WyOTkB2i5b8of+GtdSDxvwpaaulDSwVADMQAX+lOAECEHWF8XNPmv1cr/B+VnvG/XyFG6opcCMD/mtR32/UEQP+2XEF3hui/ulBTjAt88r/imfCfRP+yP9zbvtc8XeO/TZuKJD5G6b/MaTExyXzyvxiTQeElXOO/rbJRQVGN9L/z0wR2g9DqvxOqKRxEX/O/FDGCEei99j9x8zV4VYTmP2lzCnsYk+u/l6ELZ9tg878pRXacaDT/v3k6GZRqoQXAVB67LiP56r94+LDK0Sn0vwO6pZ9b7wFAvK0nKVcc9j8+U/hCvyruv6QMsuuLQ/W/FPhKFYv46j8MyxaDTOW/v9L18g1caO2/vebfvctE9b/7GD8ZrF3xv3gx1AR9bQDAuMEtsM4c77+SabgA2nj0v5xKFIwxsATArKNSBaKsB0Cjara6ozTwv33ArMz7sfa/dF2U0FcWCcDxL357DJX/P69pJmt7c/G/quJYWJZl+L/YntVJlnrSP4sRLzXM+fe/46uU8w3c8r+q4lhYlmX4v85lu5+QRwRAsI0H/WU8479jaeZNtj/zv6riWFiWZfi/sI0H/WU847/OZbufkEcEQHAoPUBrnss/9exKzDtFtT88wM8kax+gP9OqeKeAYog/MW0ItiZvcj+ph+smvt5bP2lCaV5dEUU/StaUmQDaLz+kK9y22BMYP0O3whZuMwI/IIbgZGWE6z7UkjYaEM3UPuezxwa9cr8+LybxRMnFpz6E1N8DbPiRPsYjySMvK3s+//////8fAAj//////zMQCP////9/MiAI/////28yMAj/////YzJACP///z9iMlAI////N2IyYAj///8zYjJwCP//vzNiMoAI//+rM2IykAj/f6szYjKgCP8PqzNiMrAI/wOrM2IywAi/A6szYjLQCJ8DqzNiMuAImQOrM2Iy8Aj//////z8PCP//////Kx8I/////38pLwj/////Pyk/CP////85KU8I////PzgpXwj///8POClvCP///w44KX8I//8fDjgpjwj//w8OOCmfCP9/DQ44Ka8I/w8NDjgpvwj/DQ0OOCnPCP8MDQ44Kd8IxwwNDjgp7wjEDA0OOCn/CAcAAAAHAAAAAQAAAAIAAAAEAAAAAwAAAAAAAAAAAAAABwAAAAMAAAABAAAAAgAAAAUAAAAEAAAAAAAAAAAAAAAEAAAABAAAAAAAAAACAAAAAQAAAAMAAAAOAAAABgAAAAsAAAACAAAABwAAAAEAAAAYAAAABQAAAAoAAAABAAAABgAAAAAAAAAmAAAABwAAAAwAAAADAAAACAAAAAIAAAAxAAAACQAAAA4AAAAAAAAABQAAAAQAAAA6AAAACAAAAA0AAAAEAAAACQAAAAMAAAA/AAAACwAAAAYAAAAPAAAACgAAABAAAABIAAAADAAAAAcAAAAQAAAACwAAABEAAABTAAAACgAAAAUAAAATAAAADgAAAA8AAABhAAAADQAAAAgAAAARAAAADAAAABIAAABrAAAADgAAAAkAAAASAAAADQAAABMAAAB1AAAADwAAABMAAAARAAAAEgAAABAAAAAGAAAAAgAAAAMAAAAFAAAABAAAAAAAAAAAAAAAAAAAAAYAAAACAAAAAwAAAAEAAAAFAAAABAAAAAAAAAAAAAAABwAAAAUAAAADAAAABAAAAAEAAAAAAAAAAgAAAAAAAAACAAAAAwAAAAEAAAAFAAAABAAAAAYAAAAAAAAAAAAAABgtRFT7Ifk/GC1EVPsh+b8YLURU+yEJQBgtRFT7IQnAYWxnb3MuYwBoM05laWdoYm9yUm90YXRpb25zAGNvb3JkaWprLmMAX3VwQXA3Q2hlY2tlZABfdXBBcDdyQ2hlY2tlZABkaXJlY3RlZEVkZ2UuYwBkaXJlY3RlZEVkZ2VUb0JvdW5kYXJ5AGFkamFjZW50RmFjZURpclt0bXBGaWprLmZhY2VdW2ZpamsuZmFjZV0gPT0gS0kAZmFjZWlqay5jAF9mYWNlSWprUGVudFRvQ2VsbEJvdW5kYXJ5AGFkamFjZW50RmFjZURpcltjZW50ZXJJSksuZmFjZV1bZmFjZTJdID09IEtJAF9mYWNlSWprVG9DZWxsQm91bmRhcnkAaDNJbmRleC5jAGNvbXBhY3RDZWxscwBsYXRMbmdUb0NlbGwAY2VsbFRvQ2hpbGRQb3MAdmFsaWRhdGVDaGlsZFBvcwBsYXRMbmcuYwBjZWxsQXJlYVJhZHMyAHBvbHlnb24tPm5leHQgPT0gTlVMTABsaW5rZWRHZW8uYwBhZGROZXdMaW5rZWRQb2x5Z29uAG5leHQgIT0gTlVMTABsb29wICE9IE5VTEwAYWRkTmV3TGlua2VkTG9vcABwb2x5Z29uLT5maXJzdCA9PSBOVUxMAGFkZExpbmtlZExvb3AAY29vcmQgIT0gTlVMTABhZGRMaW5rZWRDb29yZABsb29wLT5maXJzdCA9PSBOVUxMAGlubmVyTG9vcHMgIT0gTlVMTABub3JtYWxpemVNdWx0aVBvbHlnb24AYmJveGVzICE9IE5VTEwAY2FuZGlkYXRlcyAhPSBOVUxMAGZpbmRQb2x5Z29uRm9ySG9sZQBjYW5kaWRhdGVCQm94ZXMgIT0gTlVMTAByZXZEaXIgIT0gSU5WQUxJRF9ESUdJVABsb2NhbGlqLmMAY2VsbFRvTG9jYWxJamsAYmFzZUNlbGwgIT0gb3JpZ2luQmFzZUNlbGwAIShvcmlnaW5PblBlbnQgJiYgaW5kZXhPblBlbnQpAGJhc2VDZWxsID09IG9yaWdpbkJhc2VDZWxsAGJhc2VDZWxsICE9IElOVkFMSURfQkFTRV9DRUxMAGxvY2FsSWprVG9DZWxsACFfaXNCYXNlQ2VsbFBlbnRhZ29uKGJhc2VDZWxsKQBiYXNlQ2VsbFJvdGF0aW9ucyA+PSAwAGdyaWRQYXRoQ2VsbHMAcG9seWZpbGwuYwBpdGVyU3RlcFBvbHlnb25Db21wYWN0ADAAdmVydGV4LmMAdmVydGV4Um90YXRpb25zAGNlbGxUb1ZlcnRleABncmFwaC0+YnVja2V0cyAhPSBOVUxMAHZlcnRleEdyYXBoLmMAaW5pdFZlcnRleEdyYXBoAG5vZGUgIT0gTlVMTABhZGRWZXJ0ZXhOb2Rl";
  var Fe = 28640;
  function We(De, ze, mt, $e) {
    es("Assertion failed: " + D(De) + ", at: " + [ze ? D(ze) : "unknown filename", mt, $e ? D($e) : "unknown function"]);
  }
  function Oe() {
    return H.length;
  }
  function kt(De, ze, mt) {
    Y.set(Y.subarray(ze, ze + mt), De);
  }
  function ft(De) {
    return e.___errno_location && (X[e.___errno_location() >> 2] = De), De;
  }
  function Ft(De) {
    es("OOM");
  }
  function nn(De) {
    try {
      var ze = new ArrayBuffer(De);
      return ze.byteLength != De ? void 0 : (new Int8Array(ze).set(H), bt(ze), fe(ze), 1);
    } catch {
    }
  }
  function tt(De) {
    var ze = Oe(), mt = 16777216, $e = 2147483648 - mt;
    if (De > $e)
      return !1;
    for (var f = 16777216, $ = Math.max(ze, f); $ < De; )
      $ <= 536870912 ? $ = O(2 * $, mt) : $ = Math.min(O((3 * $ + 2147483648) / 4, mt), $e);
    var Mn = nn($);
    return !!Mn;
  }
  var _t = typeof atob == "function" ? atob : function(De) {
    var ze = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", mt = "", $e, f, $, Mn, jn, nr, yn, Nn = 0;
    De = De.replace(/[^A-Za-z0-9\+\/\=]/g, "");
    do
      Mn = ze.indexOf(De.charAt(Nn++)), jn = ze.indexOf(De.charAt(Nn++)), nr = ze.indexOf(De.charAt(Nn++)), yn = ze.indexOf(De.charAt(Nn++)), $e = Mn << 2 | jn >> 4, f = (jn & 15) << 4 | nr >> 2, $ = (nr & 3) << 6 | yn, mt = mt + String.fromCharCode($e), nr !== 64 && (mt = mt + String.fromCharCode(f)), yn !== 64 && (mt = mt + String.fromCharCode($));
    while (Nn < De.length);
    return mt;
  };
  function Ut(De) {
    try {
      for (var ze = _t(De), mt = new Uint8Array(ze.length), $e = 0; $e < ze.length; ++$e)
        mt[$e] = ze.charCodeAt($e);
      return mt;
    } catch {
      throw new Error("Converting base64 string to bytes failed.");
    }
  }
  function Vt(De) {
    if (ne(De))
      return Ut(De.slice(rt.length));
  }
  var pt = {
    Math,
    Int8Array,
    Int32Array,
    Uint8Array,
    Float32Array,
    Float64Array
  }, Rn = {
    b: c,
    c: A,
    d: We,
    e: ft,
    f: Oe,
    g: kt,
    h: tt,
    i: Ft,
    o: Fe,
    p: Te
  }, ie = (
    /** @suppress {uselessCode} */
    (function(De, ze, mt) {
      "almost asm";
      var $e = new De.Int8Array(mt), f = new De.Int32Array(mt);
      new De.Uint8Array(mt), new De.Float32Array(mt);
      var $ = new De.Float64Array(mt), Mn = ze.o | 0, jn = ze.p | 0, nr = De.Math.floor, yn = De.Math.abs, Nn = De.Math.sqrt, ta = De.Math.pow, On = De.Math.cos, vn = De.Math.sin, ys = De.Math.tan, ud = De.Math.acos, Ax = De.Math.asin, mA = De.Math.atan, ks = De.Math.atan2, nu = De.Math.ceil, No = De.Math.imul, Z = De.Math.min, ve = De.Math.max, Ne = De.Math.clz32, xe = ze.b, V = ze.c, Ve = ze.d, Dt = ze.e, yt = ze.f, Bt = ze.g, $t = ze.h, ln = ze.i, q = 28656;
      function Cn(d) {
        return $e = new Int8Array(d), f = new Int32Array(d), $ = new Float64Array(d), mt = d, !0;
      }
      function oi(d) {
        d = d | 0;
        var h = 0;
        return h = q, q = q + d | 0, q = q + 15 & -16, h | 0;
      }
      function Fi() {
        return q | 0;
      }
      function Ui(d) {
        d = d | 0, q = d;
      }
      function fi(d, h) {
        d = d | 0, q = d;
      }
      function Jt(d, h) {
        d = d | 0, h = h | 0;
        var p = 0, g = 0, x = 0;
        return (d | 0) < 0 ? (h = 2, h | 0) : (d | 0) > 13780509 ? (h = J0(15, h) | 0, h | 0) : (p = ((d | 0) < 0) << 31 >> 31, x = Mr(d | 0, p | 0, 3, 0) | 0, g = V() | 0, p = jt(d | 0, p | 0, 1, 0) | 0, p = Mr(x | 0, g | 0, p | 0, V() | 0) | 0, p = jt(p | 0, V() | 0, 1, 0) | 0, d = V() | 0, f[h >> 2] = p, f[h + 4 >> 2] = d, h = 0, h | 0);
      }
      function Kn(d, h, p, g) {
        return d = d | 0, h = h | 0, p = p | 0, g = g | 0, Hn(d, h, p, g, 0) | 0;
      }
      function Hn(d, h, p, g, x) {
        d = d | 0, h = h | 0, p = p | 0, g = g | 0, x = x | 0;
        var v = 0, w = 0, M = 0, P = 0, I = 0;
        if (P = q, q = q + 16 | 0, w = P, !(ts(d, h, p, g, x) | 0))
          return g = 0, q = P, g | 0;
        do
          if ((p | 0) >= 0) {
            if ((p | 0) > 13780509) {
              if (v = J0(15, w) | 0, v | 0)
                break;
              M = w, w = f[M >> 2] | 0, M = f[M + 4 >> 2] | 0;
            } else
              v = ((p | 0) < 0) << 31 >> 31, I = Mr(p | 0, v | 0, 3, 0) | 0, M = V() | 0, v = jt(p | 0, v | 0, 1, 0) | 0, v = Mr(I | 0, M | 0, v | 0, V() | 0) | 0, v = jt(v | 0, V() | 0, 1, 0) | 0, M = V() | 0, f[w >> 2] = v, f[w + 4 >> 2] = M, w = v;
            if (au(g | 0, 0, w << 3 | 0) | 0, x | 0) {
              au(x | 0, 0, w << 2 | 0) | 0, v = Or(d, h, p, g, x, w, M, 0) | 0;
              break;
            }
            v = Gs(w, 4) | 0, v ? (I = Or(d, h, p, g, v, w, M, 0) | 0, Qt(v), v = I) : v = 13;
          } else
            v = 2;
        while (!1);
        return I = v, q = P, I | 0;
      }
      function ts(d, h, p, g, x) {
        d = d | 0, h = h | 0, p = p | 0, g = g | 0, x = x | 0;
        var v = 0, w = 0, M = 0, P = 0, I = 0, k = 0, Q = 0, re = 0, se = 0, ae = 0, Ae = 0;
        if (Ae = q, q = q + 16 | 0, se = Ae, ae = Ae + 8 | 0, re = se, f[re >> 2] = d, f[re + 4 >> 2] = h, (p | 0) < 0)
          return ae = 2, q = Ae, ae | 0;
        if (v = g, f[v >> 2] = d, f[v + 4 >> 2] = h, v = (x | 0) != 0, v && (f[x >> 2] = 0), xi(d, h) | 0)
          return ae = 9, q = Ae, ae | 0;
        f[ae >> 2] = 0;
        e: do
          if ((p | 0) >= 1)
            if (v)
              for (k = 1, I = 0, Q = 0, re = 1, v = d; ; ) {
                if (!(I | Q)) {
                  if (v = Zn(v, h, 4, ae, se) | 0, v | 0)
                    break e;
                  if (h = se, v = f[h >> 2] | 0, h = f[h + 4 >> 2] | 0, xi(v, h) | 0) {
                    v = 9;
                    break e;
                  }
                }
                if (v = Zn(v, h, f[26800 + (Q << 2) >> 2] | 0, ae, se) | 0, v | 0)
                  break e;
                if (h = se, v = f[h >> 2] | 0, h = f[h + 4 >> 2] | 0, d = g + (k << 3) | 0, f[d >> 2] = v, f[d + 4 >> 2] = h, f[x + (k << 2) >> 2] = re, d = I + 1 | 0, w = (d | 0) == (re | 0), M = Q + 1 | 0, P = (M | 0) == 6, xi(v, h) | 0) {
                  v = 9;
                  break e;
                }
                if (re = re + (P & w & 1) | 0, (re | 0) > (p | 0)) {
                  v = 0;
                  break;
                } else
                  k = k + 1 | 0, I = w ? 0 : d, Q = w ? P ? 0 : M : Q;
              }
            else
              for (k = 1, I = 0, Q = 0, re = 1, v = d; ; ) {
                if (!(I | Q)) {
                  if (v = Zn(v, h, 4, ae, se) | 0, v | 0)
                    break e;
                  if (h = se, v = f[h >> 2] | 0, h = f[h + 4 >> 2] | 0, xi(v, h) | 0) {
                    v = 9;
                    break e;
                  }
                }
                if (v = Zn(v, h, f[26800 + (Q << 2) >> 2] | 0, ae, se) | 0, v | 0)
                  break e;
                if (h = se, v = f[h >> 2] | 0, h = f[h + 4 >> 2] | 0, d = g + (k << 3) | 0, f[d >> 2] = v, f[d + 4 >> 2] = h, d = I + 1 | 0, w = (d | 0) == (re | 0), M = Q + 1 | 0, P = (M | 0) == 6, xi(v, h) | 0) {
                  v = 9;
                  break e;
                }
                if (re = re + (P & w & 1) | 0, (re | 0) > (p | 0)) {
                  v = 0;
                  break;
                } else
                  k = k + 1 | 0, I = w ? 0 : d, Q = w ? P ? 0 : M : Q;
              }
          else
            v = 0;
        while (!1);
        return ae = v, q = Ae, ae | 0;
      }
      function Or(d, h, p, g, x, v, w, M) {
        d = d | 0, h = h | 0, p = p | 0, g = g | 0, x = x | 0, v = v | 0, w = w | 0, M = M | 0;
        var P = 0, I = 0, k = 0, Q = 0, re = 0, se = 0, ae = 0, Ae = 0, ye = 0, Re = 0;
        if (Ae = q, q = q + 16 | 0, se = Ae + 8 | 0, ae = Ae, P = pd(d | 0, h | 0, v | 0, w | 0) | 0, k = V() | 0, Q = g + (P << 3) | 0, ye = Q, Re = f[ye >> 2] | 0, ye = f[ye + 4 >> 2] | 0, I = (Re | 0) == (d | 0) & (ye | 0) == (h | 0), !((Re | 0) == 0 & (ye | 0) == 0 | I))
          do
            P = jt(P | 0, k | 0, 1, 0) | 0, P = Ad(P | 0, V() | 0, v | 0, w | 0) | 0, k = V() | 0, Q = g + (P << 3) | 0, Re = Q, ye = f[Re >> 2] | 0, Re = f[Re + 4 >> 2] | 0, I = (ye | 0) == (d | 0) & (Re | 0) == (h | 0);
          while (!((ye | 0) == 0 & (Re | 0) == 0 | I));
        if (P = x + (P << 2) | 0, I && (f[P >> 2] | 0) <= (M | 0) || (Re = Q, f[Re >> 2] = d, f[Re + 4 >> 2] = h, f[P >> 2] = M, (M | 0) >= (p | 0)))
          return Re = 0, q = Ae, Re | 0;
        switch (I = M + 1 | 0, f[se >> 2] = 0, P = Zn(d, h, 2, se, ae) | 0, P | 0) {
          case 9: {
            re = 9;
            break;
          }
          case 0: {
            P = ae, P = Or(f[P >> 2] | 0, f[P + 4 >> 2] | 0, p, g, x, v, w, I) | 0, P || (re = 9);
            break;
          }
        }
        e: do
          if ((re | 0) == 9) {
            switch (f[se >> 2] = 0, P = Zn(d, h, 3, se, ae) | 0, P | 0) {
              case 9:
                break;
              case 0: {
                if (P = ae, P = Or(f[P >> 2] | 0, f[P + 4 >> 2] | 0, p, g, x, v, w, I) | 0, P | 0)
                  break e;
                break;
              }
              default:
                break e;
            }
            switch (f[se >> 2] = 0, P = Zn(d, h, 1, se, ae) | 0, P | 0) {
              case 9:
                break;
              case 0: {
                if (P = ae, P = Or(f[P >> 2] | 0, f[P + 4 >> 2] | 0, p, g, x, v, w, I) | 0, P | 0)
                  break e;
                break;
              }
              default:
                break e;
            }
            switch (f[se >> 2] = 0, P = Zn(d, h, 5, se, ae) | 0, P | 0) {
              case 9:
                break;
              case 0: {
                if (P = ae, P = Or(f[P >> 2] | 0, f[P + 4 >> 2] | 0, p, g, x, v, w, I) | 0, P | 0)
                  break e;
                break;
              }
              default:
                break e;
            }
            switch (f[se >> 2] = 0, P = Zn(d, h, 4, se, ae) | 0, P | 0) {
              case 9:
                break;
              case 0: {
                if (P = ae, P = Or(f[P >> 2] | 0, f[P + 4 >> 2] | 0, p, g, x, v, w, I) | 0, P | 0)
                  break e;
                break;
              }
              default:
                break e;
            }
            switch (f[se >> 2] = 0, P = Zn(d, h, 6, se, ae) | 0, P | 0) {
              case 9:
                break;
              case 0: {
                if (P = ae, P = Or(f[P >> 2] | 0, f[P + 4 >> 2] | 0, p, g, x, v, w, I) | 0, P | 0)
                  break e;
                break;
              }
              default:
                break e;
            }
            return Re = 0, q = Ae, Re | 0;
          }
        while (!1);
        return Re = P, q = Ae, Re | 0;
      }
      function Zn(d, h, p, g, x) {
        d = d | 0, h = h | 0, p = p | 0, g = g | 0, x = x | 0;
        var v = 0, w = 0, M = 0, P = 0, I = 0, k = 0, Q = 0, re = 0, se = 0, ae = 0;
        if (p >>> 0 > 6)
          return x = 1, x | 0;
        if (Q = (f[g >> 2] | 0) % 6 | 0, f[g >> 2] = Q, (Q | 0) > 0) {
          v = 0;
          do
            p = Ac(p) | 0, v = v + 1 | 0;
          while ((v | 0) < (f[g >> 2] | 0));
        }
        if (Q = qe(d | 0, h | 0, 45) | 0, V() | 0, k = Q & 127, k >>> 0 > 121)
          return x = 5, x | 0;
        P = Vs(d, h) | 0, v = qe(d | 0, h | 0, 52) | 0, V() | 0, v = v & 15;
        e: do
          if (!v)
            I = 8;
          else {
            for (; ; ) {
              if (w = (15 - v | 0) * 3 | 0, M = qe(d | 0, h | 0, w | 0) | 0, V() | 0, M = M & 7, (M | 0) == 7) {
                h = 5;
                break;
              }
              if (ae = (Do(v) | 0) == 0, v = v + -1 | 0, re = Ze(7, 0, w | 0) | 0, h = h & ~(V() | 0), se = Ze(f[(ae ? 432 : 16) + (M * 28 | 0) + (p << 2) >> 2] | 0, 0, w | 0) | 0, w = V() | 0, p = f[(ae ? 640 : 224) + (M * 28 | 0) + (p << 2) >> 2] | 0, d = se | d & ~re, h = w | h, !p) {
                p = 0;
                break e;
              }
              if (!v) {
                I = 8;
                break e;
              }
            }
            return h | 0;
          }
        while (!1);
        (I | 0) == 8 && (ae = f[848 + (k * 28 | 0) + (p << 2) >> 2] | 0, se = Ze(ae | 0, 0, 45) | 0, d = se | d, h = V() | 0 | h & -1040385, p = f[4272 + (k * 28 | 0) + (p << 2) >> 2] | 0, (ae & 127 | 0) == 127 && (ae = Ze(f[848 + (k * 28 | 0) + 20 >> 2] | 0, 0, 45) | 0, h = V() | 0 | h & -1040385, p = f[4272 + (k * 28 | 0) + 20 >> 2] | 0, d = pc(ae | d, h) | 0, h = V() | 0, f[g >> 2] = (f[g >> 2] | 0) + 1)), M = qe(d | 0, h | 0, 45) | 0, V() | 0, M = M & 127;
        e: do
          if (Ni(M) | 0) {
            t: do
              if ((Vs(d, h) | 0) == 1) {
                if ((k | 0) != (M | 0))
                  if (Tw(M, f[7696 + (k * 28 | 0) >> 2] | 0) | 0) {
                    d = Rx(d, h) | 0, w = 1, h = V() | 0;
                    break;
                  } else
                    Ve(27795, 26864, 533, 26872);
                switch (P | 0) {
                  case 3: {
                    d = pc(d, h) | 0, h = V() | 0, f[g >> 2] = (f[g >> 2] | 0) + 1, w = 0;
                    break t;
                  }
                  case 5: {
                    d = Rx(d, h) | 0, h = V() | 0, f[g >> 2] = (f[g >> 2] | 0) + 5, w = 0;
                    break t;
                  }
                  case 0:
                    return ae = 9, ae | 0;
                  default:
                    return ae = 1, ae | 0;
                }
              } else
                w = 0;
            while (!1);
            if ((p | 0) > 0) {
              v = 0;
              do
                d = Ex(d, h) | 0, h = V() | 0, v = v + 1 | 0;
              while ((v | 0) != (p | 0));
            }
            if ((k | 0) != (M | 0)) {
              if (!(px(M) | 0)) {
                if ((w | 0) != 0 | (Vs(d, h) | 0) != 5)
                  break;
                f[g >> 2] = (f[g >> 2] | 0) + 1;
                break;
              }
              switch (Q & 127) {
                case 8:
                case 118:
                  break e;
              }
              (Vs(d, h) | 0) != 3 && (f[g >> 2] = (f[g >> 2] | 0) + 1);
            }
          } else if ((p | 0) > 0) {
            v = 0;
            do
              d = pc(d, h) | 0, h = V() | 0, v = v + 1 | 0;
            while ((v | 0) != (p | 0));
          }
        while (!1);
        return f[g >> 2] = ((f[g >> 2] | 0) + p | 0) % 6 | 0, ae = x, f[ae >> 2] = d, f[ae + 4 >> 2] = h, ae = 0, ae | 0;
      }
      function hc(d, h, p, g) {
        return d = d | 0, h = h | 0, p = p | 0, g = g | 0, Ai(d, h, p, g) | 0 ? (au(g | 0, 0, p * 48 | 0) | 0, g = ns(d, h, p, g) | 0, g | 0) : (g = 0, g | 0);
      }
      function Ai(d, h, p, g) {
        d = d | 0, h = h | 0, p = p | 0, g = g | 0;
        var x = 0, v = 0, w = 0, M = 0, P = 0, I = 0, k = 0, Q = 0, re = 0, se = 0, ae = 0;
        if (ae = q, q = q + 16 | 0, re = ae, se = ae + 8 | 0, Q = re, f[Q >> 2] = d, f[Q + 4 >> 2] = h, (p | 0) < 0)
          return se = 2, q = ae, se | 0;
        if (!p)
          return se = g, f[se >> 2] = d, f[se + 4 >> 2] = h, se = 0, q = ae, se | 0;
        f[se >> 2] = 0;
        e: do
          if (xi(d, h) | 0)
            d = 9;
          else {
            x = 0, Q = d;
            do {
              if (d = Zn(Q, h, 4, se, re) | 0, d | 0)
                break e;
              if (h = re, Q = f[h >> 2] | 0, h = f[h + 4 >> 2] | 0, x = x + 1 | 0, xi(Q, h) | 0) {
                d = 9;
                break e;
              }
            } while ((x | 0) < (p | 0));
            k = g, f[k >> 2] = Q, f[k + 4 >> 2] = h, k = p + -1 | 0, I = 0, d = 1;
            do {
              if (x = 26800 + (I << 2) | 0, (I | 0) == 5)
                for (w = f[x >> 2] | 0, v = 0, x = d; ; ) {
                  if (d = re, d = Zn(f[d >> 2] | 0, f[d + 4 >> 2] | 0, w, se, re) | 0, d | 0)
                    break e;
                  if ((v | 0) != (k | 0))
                    if (P = re, M = f[P >> 2] | 0, P = f[P + 4 >> 2] | 0, d = g + (x << 3) | 0, f[d >> 2] = M, f[d + 4 >> 2] = P, !(xi(M, P) | 0))
                      d = x + 1 | 0;
                    else {
                      d = 9;
                      break e;
                    }
                  else
                    d = x;
                  if (v = v + 1 | 0, (v | 0) >= (p | 0))
                    break;
                  x = d;
                }
              else
                for (w = re, P = f[x >> 2] | 0, M = 0, x = d, v = f[w >> 2] | 0, w = f[w + 4 >> 2] | 0; ; ) {
                  if (d = Zn(v, w, P, se, re) | 0, d | 0)
                    break e;
                  if (w = re, v = f[w >> 2] | 0, w = f[w + 4 >> 2] | 0, d = g + (x << 3) | 0, f[d >> 2] = v, f[d + 4 >> 2] = w, d = x + 1 | 0, xi(v, w) | 0) {
                    d = 9;
                    break e;
                  }
                  if (M = M + 1 | 0, (M | 0) >= (p | 0))
                    break;
                  x = d;
                }
              I = I + 1 | 0;
            } while (I >>> 0 < 6);
            d = re, d = (Q | 0) == (f[d >> 2] | 0) && (h | 0) == (f[d + 4 >> 2] | 0) ? 0 : 9;
          }
        while (!1);
        return se = d, q = ae, se | 0;
      }
      function ns(d, h, p, g) {
        d = d | 0, h = h | 0, p = p | 0, g = g | 0;
        var x = 0, v = 0, w = 0, M = 0, P = 0, I = 0, k = 0, Q = 0, re = 0;
        if (Q = q, q = q + 16 | 0, w = Q, !p)
          return f[g >> 2] = d, f[g + 4 >> 2] = h, g = 0, q = Q, g | 0;
        do
          if ((p | 0) >= 0) {
            if ((p | 0) > 13780509) {
              if (x = J0(15, w) | 0, x | 0)
                break;
              v = w, x = f[v >> 2] | 0, v = f[v + 4 >> 2] | 0;
            } else
              x = ((p | 0) < 0) << 31 >> 31, k = Mr(p | 0, x | 0, 3, 0) | 0, v = V() | 0, x = jt(p | 0, x | 0, 1, 0) | 0, x = Mr(k | 0, v | 0, x | 0, V() | 0) | 0, x = jt(x | 0, V() | 0, 1, 0) | 0, v = V() | 0, k = w, f[k >> 2] = x, f[k + 4 >> 2] = v;
            if (I = Gs(x, 8) | 0, !I)
              x = 13;
            else {
              if (k = Gs(x, 4) | 0, !k) {
                Qt(I), x = 13;
                break;
              }
              if (x = Or(d, h, p, I, k, x, v, 0) | 0, x | 0) {
                Qt(I), Qt(k);
                break;
              }
              if (h = f[w >> 2] | 0, w = f[w + 4 >> 2] | 0, (w | 0) > 0 | (w | 0) == 0 & h >>> 0 > 0) {
                x = 0, M = 0, P = 0;
                do
                  d = I + (M << 3) | 0, v = f[d >> 2] | 0, d = f[d + 4 >> 2] | 0, !((v | 0) == 0 & (d | 0) == 0) && (f[k + (M << 2) >> 2] | 0) == (p | 0) && (re = g + (x << 3) | 0, f[re >> 2] = v, f[re + 4 >> 2] = d, x = x + 1 | 0), M = jt(M | 0, P | 0, 1, 0) | 0, P = V() | 0;
                while ((P | 0) < (w | 0) | (P | 0) == (w | 0) & M >>> 0 < h >>> 0);
              }
              Qt(I), Qt(k), x = 0;
            }
          } else
            x = 2;
        while (!1);
        return re = x, q = Q, re | 0;
      }
      function is(d, h, p, g) {
        d = d | 0, h = h | 0, p = p | 0, g = g | 0;
        var x = 0, v = 0, w = 0, M = 0, P = 0, I = 0;
        for (M = q, q = q + 16 | 0, v = M, w = M + 8 | 0, x = (xi(d, h) | 0) == 0, x = x ? 1 : 2; ; ) {
          if (f[w >> 2] = 0, I = (Zn(d, h, x, w, v) | 0) == 0, P = v, I & ((f[P >> 2] | 0) == (p | 0) ? (f[P + 4 >> 2] | 0) == (g | 0) : 0)) {
            d = 4;
            break;
          }
          if (x = x + 1 | 0, x >>> 0 >= 7) {
            x = 7, d = 4;
            break;
          }
        }
        return (d | 0) == 4 ? (q = M, x | 0) : 0;
      }
      function kr(d, h, p, g) {
        d = d | 0, h = h | 0, p = p | 0, g = g | 0;
        var x = 0, v = 0, w = 0, M = 0, P = 0, I = 0;
        if (M = q, q = q + 48 | 0, x = M + 16 | 0, v = M + 8 | 0, w = M, p = SA(p) | 0, p | 0)
          return w = p, q = M, w | 0;
        if (I = d, P = f[I + 4 >> 2] | 0, p = v, f[p >> 2] = f[I >> 2], f[p + 4 >> 2] = P, Qw(v, x), p = Rw(x, h, w) | 0, !p) {
          if (h = f[v >> 2] | 0, v = f[d + 8 >> 2] | 0, (v | 0) > 0) {
            x = f[d + 12 >> 2] | 0, p = 0;
            do
              h = (f[x + (p << 3) >> 2] | 0) + h | 0, p = p + 1 | 0;
            while ((p | 0) < (v | 0));
          }
          p = w, x = f[p >> 2] | 0, p = f[p + 4 >> 2] | 0, v = ((h | 0) < 0) << 31 >> 31, (p | 0) < (v | 0) | (p | 0) == (v | 0) & x >>> 0 < h >>> 0 ? (p = w, f[p >> 2] = h, f[p + 4 >> 2] = v, p = v) : h = x, P = jt(h | 0, p | 0, 12, 0) | 0, I = V() | 0, p = w, f[p >> 2] = P, f[p + 4 >> 2] = I, p = g, f[p >> 2] = P, f[p + 4 >> 2] = I, p = 0;
        }
        return I = p, q = M, I | 0;
      }
      function Vr(d, h, p, g, x, v, w) {
        d = d | 0, h = h | 0, p = p | 0, g = g | 0, x = x | 0, v = v | 0, w = w | 0;
        var M = 0, P = 0, I = 0, k = 0, Q = 0, re = 0, se = 0, ae = 0, Ae = 0, ye = 0, Re = 0, we = 0, be = 0, me = 0, nt = 0, qt = 0, Pt = 0, mn = 0, gn = 0, Pn = 0, an = 0, Ht = 0, et = 0, wn = 0, pi = 0, bn = 0, mi = 0, bs = 0, cM = 0;
        if (pi = q, q = q + 64 | 0, an = pi + 48 | 0, Ht = pi + 32 | 0, et = pi + 24 | 0, nt = pi + 8 | 0, qt = pi, P = f[d >> 2] | 0, (P | 0) <= 0)
          return wn = 0, q = pi, wn | 0;
        for (Pt = d + 4 | 0, mn = an + 8 | 0, gn = Ht + 8 | 0, Pn = nt + 8 | 0, M = 0, be = 0; ; ) {
          I = f[Pt >> 2] | 0, we = I + (be << 4) | 0, f[an >> 2] = f[we >> 2], f[an + 4 >> 2] = f[we + 4 >> 2], f[an + 8 >> 2] = f[we + 8 >> 2], f[an + 12 >> 2] = f[we + 12 >> 2], (be | 0) == (P + -1 | 0) ? (f[Ht >> 2] = f[I >> 2], f[Ht + 4 >> 2] = f[I + 4 >> 2], f[Ht + 8 >> 2] = f[I + 8 >> 2], f[Ht + 12 >> 2] = f[I + 12 >> 2]) : (we = I + (be + 1 << 4) | 0, f[Ht >> 2] = f[we >> 2], f[Ht + 4 >> 2] = f[we + 4 >> 2], f[Ht + 8 >> 2] = f[we + 8 >> 2], f[Ht + 12 >> 2] = f[we + 12 >> 2]), P = J7(an, Ht, g, et) | 0;
          e: do
            if (P)
              I = 0, M = P;
            else if (P = et, I = f[P >> 2] | 0, P = f[P + 4 >> 2] | 0, (P | 0) > 0 | (P | 0) == 0 & I >>> 0 > 0) {
              Re = 0, we = 0;
              t: for (; ; ) {
                if (mi = 1 / (+(I >>> 0) + 4294967296 * +(P | 0)), cM = +$[an >> 3], P = wr(I | 0, P | 0, Re | 0, we | 0) | 0, bs = +(P >>> 0) + 4294967296 * +(V() | 0), bn = +(Re >>> 0) + 4294967296 * +(we | 0), $[nt >> 3] = mi * (cM * bs) + mi * (+$[Ht >> 3] * bn), $[Pn >> 3] = mi * (+$[mn >> 3] * bs) + mi * (+$[gn >> 3] * bn), P = Cx(nt, g, qt) | 0, P | 0) {
                  M = P;
                  break;
                }
                ye = qt, Ae = f[ye >> 2] | 0, ye = f[ye + 4 >> 2] | 0, re = pd(Ae | 0, ye | 0, h | 0, p | 0) | 0, k = V() | 0, P = w + (re << 3) | 0, Q = P, I = f[Q >> 2] | 0, Q = f[Q + 4 >> 2] | 0;
                n: do
                  if ((I | 0) == 0 & (Q | 0) == 0)
                    me = P, wn = 16;
                  else
                    for (se = 0, ae = 0; ; ) {
                      if ((se | 0) > (p | 0) | (se | 0) == (p | 0) & ae >>> 0 > h >>> 0) {
                        M = 1;
                        break t;
                      }
                      if ((I | 0) == (Ae | 0) & (Q | 0) == (ye | 0))
                        break n;
                      if (P = jt(re | 0, k | 0, 1, 0) | 0, re = Ad(P | 0, V() | 0, h | 0, p | 0) | 0, k = V() | 0, ae = jt(ae | 0, se | 0, 1, 0) | 0, se = V() | 0, P = w + (re << 3) | 0, Q = P, I = f[Q >> 2] | 0, Q = f[Q + 4 >> 2] | 0, (I | 0) == 0 & (Q | 0) == 0) {
                        me = P, wn = 16;
                        break;
                      }
                    }
                while (!1);
                if ((wn | 0) == 16 && (wn = 0, !((Ae | 0) == 0 & (ye | 0) == 0)) && (ae = me, f[ae >> 2] = Ae, f[ae + 4 >> 2] = ye, ae = v + (f[x >> 2] << 3) | 0, f[ae >> 2] = Ae, f[ae + 4 >> 2] = ye, ae = x, ae = jt(f[ae >> 2] | 0, f[ae + 4 >> 2] | 0, 1, 0) | 0, Ae = V() | 0, ye = x, f[ye >> 2] = ae, f[ye + 4 >> 2] = Ae), Re = jt(Re | 0, we | 0, 1, 0) | 0, we = V() | 0, P = et, I = f[P >> 2] | 0, P = f[P + 4 >> 2] | 0, !((P | 0) > (we | 0) | (P | 0) == (we | 0) & I >>> 0 > Re >>> 0)) {
                  I = 1;
                  break e;
                }
              }
              I = 0;
            } else
              I = 1;
          while (!1);
          if (be = be + 1 | 0, !I) {
            wn = 21;
            break;
          }
          if (P = f[d >> 2] | 0, (be | 0) >= (P | 0)) {
            M = 0, wn = 21;
            break;
          }
        }
        return (wn | 0) == 21 ? (q = pi, M | 0) : 0;
      }
      function gA(d, h, p, g) {
        d = d | 0, h = h | 0, p = p | 0, g = g | 0;
        var x = 0, v = 0, w = 0, M = 0, P = 0, I = 0, k = 0, Q = 0, re = 0, se = 0, ae = 0, Ae = 0, ye = 0, Re = 0, we = 0, be = 0, me = 0, nt = 0, qt = 0, Pt = 0, mn = 0, gn = 0, Pn = 0, an = 0, Ht = 0, et = 0, wn = 0, pi = 0, bn = 0, mi = 0, bs = 0;
        if (bs = q, q = q + 112 | 0, wn = bs + 80 | 0, P = bs + 72 | 0, pi = bs, bn = bs + 56 | 0, x = SA(p) | 0, x | 0)
          return mi = x, q = bs, mi | 0;
        if (I = d + 8 | 0, mi = Ra((f[I >> 2] << 5) + 32 | 0) | 0, !mi)
          return mi = 13, q = bs, mi | 0;
        if (Fx(d, mi), x = SA(p) | 0, !x) {
          if (Ht = d, et = f[Ht + 4 >> 2] | 0, x = P, f[x >> 2] = f[Ht >> 2], f[x + 4 >> 2] = et, Qw(P, wn), x = Rw(wn, h, pi) | 0, x)
            Ht = 0, et = 0;
          else {
            if (x = f[P >> 2] | 0, v = f[I >> 2] | 0, (v | 0) > 0) {
              w = f[d + 12 >> 2] | 0, p = 0;
              do
                x = (f[w + (p << 3) >> 2] | 0) + x | 0, p = p + 1 | 0;
              while ((p | 0) != (v | 0));
              p = x;
            } else
              p = x;
            x = pi, v = f[x >> 2] | 0, x = f[x + 4 >> 2] | 0, w = ((p | 0) < 0) << 31 >> 31, (x | 0) < (w | 0) | (x | 0) == (w | 0) & v >>> 0 < p >>> 0 ? (x = pi, f[x >> 2] = p, f[x + 4 >> 2] = w, x = w) : p = v, Ht = jt(p | 0, x | 0, 12, 0) | 0, et = V() | 0, x = pi, f[x >> 2] = Ht, f[x + 4 >> 2] = et, x = 0;
          }
          if (!x) {
            if (p = Gs(Ht, 8) | 0, !p)
              return Qt(mi), mi = 13, q = bs, mi | 0;
            if (M = Gs(Ht, 8) | 0, !M)
              return Qt(mi), Qt(p), mi = 13, q = bs, mi | 0;
            Pn = wn, f[Pn >> 2] = 0, f[Pn + 4 >> 2] = 0, Pn = d, an = f[Pn + 4 >> 2] | 0, x = P, f[x >> 2] = f[Pn >> 2], f[x + 4 >> 2] = an, x = Vr(P, Ht, et, h, wn, p, M) | 0;
            e: do
              if (x)
                Qt(p), Qt(M), Qt(mi);
              else {
                t: do
                  if ((f[I >> 2] | 0) > 0) {
                    for (w = d + 12 | 0, v = 0; x = Vr((f[w >> 2] | 0) + (v << 3) | 0, Ht, et, h, wn, p, M) | 0, v = v + 1 | 0, !(x | 0); )
                      if ((v | 0) >= (f[I >> 2] | 0))
                        break t;
                    Qt(p), Qt(M), Qt(mi);
                    break e;
                  }
                while (!1);
                (et | 0) > 0 | (et | 0) == 0 & Ht >>> 0 > 0 && au(M | 0, 0, Ht << 3 | 0) | 0, an = wn, Pn = f[an + 4 >> 2] | 0;
                t: do
                  if ((Pn | 0) > 0 | (Pn | 0) == 0 & (f[an >> 2] | 0) >>> 0 > 0) {
                    Pt = p, mn = M, gn = p, Pn = M, an = p, x = p, me = p, nt = M, qt = M, p = M;
                    n: for (; ; ) {
                      for (ye = 0, Re = 0, we = 0, be = 0, v = 0, w = 0; ; ) {
                        M = pi, P = M + 56 | 0;
                        do
                          f[M >> 2] = 0, M = M + 4 | 0;
                        while ((M | 0) < (P | 0));
                        if (h = Pt + (ye << 3) | 0, I = f[h >> 2] | 0, h = f[h + 4 >> 2] | 0, ts(I, h, 1, pi, 0) | 0) {
                          M = pi, P = M + 56 | 0;
                          do
                            f[M >> 2] = 0, M = M + 4 | 0;
                          while ((M | 0) < (P | 0));
                          M = Gs(7, 4) | 0, M | 0 && (Or(I, h, 1, pi, M, 7, 0, 0) | 0, Qt(M));
                        }
                        for (Ae = 0; ; ) {
                          ae = pi + (Ae << 3) | 0, se = f[ae >> 2] | 0, ae = f[ae + 4 >> 2] | 0;
                          i: do
                            if ((se | 0) == 0 & (ae | 0) == 0)
                              M = v, P = w;
                            else {
                              if (k = pd(se | 0, ae | 0, Ht | 0, et | 0) | 0, I = V() | 0, M = g + (k << 3) | 0, h = M, P = f[h >> 2] | 0, h = f[h + 4 >> 2] | 0, !((P | 0) == 0 & (h | 0) == 0)) {
                                Q = 0, re = 0;
                                do {
                                  if ((Q | 0) > (et | 0) | (Q | 0) == (et | 0) & re >>> 0 > Ht >>> 0)
                                    break n;
                                  if ((P | 0) == (se | 0) & (h | 0) == (ae | 0)) {
                                    M = v, P = w;
                                    break i;
                                  }
                                  M = jt(k | 0, I | 0, 1, 0) | 0, k = Ad(M | 0, V() | 0, Ht | 0, et | 0) | 0, I = V() | 0, re = jt(re | 0, Q | 0, 1, 0) | 0, Q = V() | 0, M = g + (k << 3) | 0, h = M, P = f[h >> 2] | 0, h = f[h + 4 >> 2] | 0;
                                } while (!((P | 0) == 0 & (h | 0) == 0));
                              }
                              if ((se | 0) == 0 & (ae | 0) == 0) {
                                M = v, P = w;
                                break;
                              }
                              mc(se, ae, bn) | 0, Ux(d, mi, bn) | 0 && (re = jt(v | 0, w | 0, 1, 0) | 0, w = V() | 0, Q = M, f[Q >> 2] = se, f[Q + 4 >> 2] = ae, v = mn + (v << 3) | 0, f[v >> 2] = se, f[v + 4 >> 2] = ae, v = re), M = v, P = w;
                            }
                          while (!1);
                          if (Ae = Ae + 1 | 0, Ae >>> 0 >= 7)
                            break;
                          v = M, w = P;
                        }
                        if (ye = jt(ye | 0, Re | 0, 1, 0) | 0, Re = V() | 0, we = jt(we | 0, be | 0, 1, 0) | 0, be = V() | 0, w = wn, v = f[w >> 2] | 0, w = f[w + 4 >> 2] | 0, (be | 0) < (w | 0) | (be | 0) == (w | 0) & we >>> 0 < v >>> 0)
                          v = M, w = P;
                        else
                          break;
                      }
                      if ((w | 0) > 0 | (w | 0) == 0 & v >>> 0 > 0) {
                        v = 0, w = 0;
                        do
                          be = Pt + (v << 3) | 0, f[be >> 2] = 0, f[be + 4 >> 2] = 0, v = jt(v | 0, w | 0, 1, 0) | 0, w = V() | 0, be = wn, we = f[be + 4 >> 2] | 0;
                        while ((w | 0) < (we | 0) | ((w | 0) == (we | 0) ? v >>> 0 < (f[be >> 2] | 0) >>> 0 : 0));
                      }
                      if (be = wn, f[be >> 2] = M, f[be + 4 >> 2] = P, (P | 0) > 0 | (P | 0) == 0 & M >>> 0 > 0)
                        Ae = p, ye = qt, Re = an, we = nt, be = mn, p = me, qt = x, nt = gn, me = Ae, x = ye, an = Pn, Pn = Re, gn = we, mn = Pt, Pt = be;
                      else
                        break t;
                    }
                    Qt(gn), Qt(Pn), Qt(mi), x = 1;
                    break e;
                  } else
                    x = M;
                while (!1);
                Qt(mi), Qt(p), Qt(x), x = 0;
              }
            while (!1);
            return mi = x, q = bs, mi | 0;
          }
        }
        return Qt(mi), mi = x, q = bs, mi | 0;
      }
      function dl(d, h, p) {
        d = d | 0, h = h | 0, p = p | 0;
        var g = 0, x = 0, v = 0, w = 0, M = 0, P = 0, I = 0, k = 0;
        if (k = q, q = q + 176 | 0, P = k, (h | 0) < 1)
          return nM(p, 0, 0), I = 0, q = k, I | 0;
        for (M = d, M = qe(f[M >> 2] | 0, f[M + 4 >> 2] | 0, 52) | 0, V() | 0, nM(p, (h | 0) > 6 ? h : 6, M & 15), M = 0; g = d + (M << 3) | 0, g = dd(f[g >> 2] | 0, f[g + 4 >> 2] | 0, P) | 0, !(g | 0); ) {
          if (g = f[P >> 2] | 0, (g | 0) > 0) {
            w = 0;
            do
              v = P + 8 + (w << 4) | 0, w = w + 1 | 0, g = P + 8 + (((w | 0) % (g | 0) | 0) << 4) | 0, x = _F(p, g, v) | 0, x ? sM(p, x) | 0 : gF(p, v, g) | 0, g = f[P >> 2] | 0;
            while ((w | 0) < (g | 0));
          }
          if (M = M + 1 | 0, (M | 0) >= (h | 0)) {
            g = 0, I = 13;
            break;
          }
        }
        return (I | 0) == 13 ? (q = k, g | 0) : (iM(p), I = g, q = k, I | 0);
      }
      function H7(d, h, p) {
        d = d | 0, h = h | 0, p = p | 0;
        var g = 0, x = 0, v = 0, w = 0;
        if (v = q, q = q + 32 | 0, g = v, x = v + 16 | 0, d = dl(d, h, x) | 0, d | 0)
          return p = d, q = v, p | 0;
        if (f[p >> 2] = 0, f[p + 4 >> 2] = 0, f[p + 8 >> 2] = 0, d = rM(x) | 0, d | 0)
          do {
            h = jB(p) | 0;
            do
              XB(h, d) | 0, w = d + 16 | 0, f[g >> 2] = f[w >> 2], f[g + 4 >> 2] = f[w + 4 >> 2], f[g + 8 >> 2] = f[w + 8 >> 2], f[g + 12 >> 2] = f[w + 12 >> 2], sM(x, d) | 0, d = xF(x, g) | 0;
            while ((d | 0) != 0);
            d = rM(x) | 0;
          } while ((d | 0) != 0);
        return iM(x), d = YB(p) | 0, d ? ($w(p), w = d, q = v, w | 0) : (w = 0, q = v, w | 0);
      }
      function Ni(d) {
        return d = d | 0, d >>> 0 > 121 ? (d = 0, d | 0) : (d = f[7696 + (d * 28 | 0) + 16 >> 2] | 0, d | 0);
      }
      function px(d) {
        return d = d | 0, (d | 0) == 4 | (d | 0) == 117 | 0;
      }
      function Sw(d) {
        return d = d | 0, f[11120 + ((f[d >> 2] | 0) * 216 | 0) + ((f[d + 4 >> 2] | 0) * 72 | 0) + ((f[d + 8 >> 2] | 0) * 24 | 0) + (f[d + 12 >> 2] << 3) >> 2] | 0;
      }
      function W7(d) {
        return d = d | 0, f[11120 + ((f[d >> 2] | 0) * 216 | 0) + ((f[d + 4 >> 2] | 0) * 72 | 0) + ((f[d + 8 >> 2] | 0) * 24 | 0) + (f[d + 12 >> 2] << 3) + 4 >> 2] | 0;
      }
      function $7(d, h) {
        d = d | 0, h = h | 0, d = 7696 + (d * 28 | 0) | 0, f[h >> 2] = f[d >> 2], f[h + 4 >> 2] = f[d + 4 >> 2], f[h + 8 >> 2] = f[d + 8 >> 2], f[h + 12 >> 2] = f[d + 12 >> 2];
      }
      function j7(d, h) {
        d = d | 0, h = h | 0;
        var p = 0, g = 0;
        if (h >>> 0 > 20)
          return h = -1, h | 0;
        do
          if ((f[11120 + (h * 216 | 0) >> 2] | 0) != (d | 0))
            if ((f[11120 + (h * 216 | 0) + 8 >> 2] | 0) != (d | 0))
              if ((f[11120 + (h * 216 | 0) + 16 >> 2] | 0) != (d | 0))
                if ((f[11120 + (h * 216 | 0) + 24 >> 2] | 0) != (d | 0))
                  if ((f[11120 + (h * 216 | 0) + 32 >> 2] | 0) != (d | 0))
                    if ((f[11120 + (h * 216 | 0) + 40 >> 2] | 0) != (d | 0))
                      if ((f[11120 + (h * 216 | 0) + 48 >> 2] | 0) != (d | 0))
                        if ((f[11120 + (h * 216 | 0) + 56 >> 2] | 0) != (d | 0))
                          if ((f[11120 + (h * 216 | 0) + 64 >> 2] | 0) != (d | 0))
                            if ((f[11120 + (h * 216 | 0) + 72 >> 2] | 0) != (d | 0))
                              if ((f[11120 + (h * 216 | 0) + 80 >> 2] | 0) != (d | 0))
                                if ((f[11120 + (h * 216 | 0) + 88 >> 2] | 0) != (d | 0))
                                  if ((f[11120 + (h * 216 | 0) + 96 >> 2] | 0) != (d | 0))
                                    if ((f[11120 + (h * 216 | 0) + 104 >> 2] | 0) != (d | 0))
                                      if ((f[11120 + (h * 216 | 0) + 112 >> 2] | 0) != (d | 0))
                                        if ((f[11120 + (h * 216 | 0) + 120 >> 2] | 0) != (d | 0))
                                          if ((f[11120 + (h * 216 | 0) + 128 >> 2] | 0) != (d | 0))
                                            if ((f[11120 + (h * 216 | 0) + 136 >> 2] | 0) == (d | 0))
                                              d = 2, p = 1, g = 2;
                                            else {
                                              if ((f[11120 + (h * 216 | 0) + 144 >> 2] | 0) == (d | 0)) {
                                                d = 0, p = 2, g = 0;
                                                break;
                                              }
                                              if ((f[11120 + (h * 216 | 0) + 152 >> 2] | 0) == (d | 0)) {
                                                d = 0, p = 2, g = 1;
                                                break;
                                              }
                                              if ((f[11120 + (h * 216 | 0) + 160 >> 2] | 0) == (d | 0)) {
                                                d = 0, p = 2, g = 2;
                                                break;
                                              }
                                              if ((f[11120 + (h * 216 | 0) + 168 >> 2] | 0) == (d | 0)) {
                                                d = 1, p = 2, g = 0;
                                                break;
                                              }
                                              if ((f[11120 + (h * 216 | 0) + 176 >> 2] | 0) == (d | 0)) {
                                                d = 1, p = 2, g = 1;
                                                break;
                                              }
                                              if ((f[11120 + (h * 216 | 0) + 184 >> 2] | 0) == (d | 0)) {
                                                d = 1, p = 2, g = 2;
                                                break;
                                              }
                                              if ((f[11120 + (h * 216 | 0) + 192 >> 2] | 0) == (d | 0)) {
                                                d = 2, p = 2, g = 0;
                                                break;
                                              }
                                              if ((f[11120 + (h * 216 | 0) + 200 >> 2] | 0) == (d | 0)) {
                                                d = 2, p = 2, g = 1;
                                                break;
                                              }
                                              if ((f[11120 + (h * 216 | 0) + 208 >> 2] | 0) == (d | 0)) {
                                                d = 2, p = 2, g = 2;
                                                break;
                                              } else
                                                d = -1;
                                              return d | 0;
                                            }
                                          else
                                            d = 2, p = 1, g = 1;
                                        else
                                          d = 2, p = 1, g = 0;
                                      else
                                        d = 1, p = 1, g = 2;
                                    else
                                      d = 1, p = 1, g = 1;
                                  else
                                    d = 1, p = 1, g = 0;
                                else
                                  d = 0, p = 1, g = 2;
                              else
                                d = 0, p = 1, g = 1;
                            else
                              d = 0, p = 1, g = 0;
                          else
                            d = 2, p = 0, g = 2;
                        else
                          d = 2, p = 0, g = 1;
                      else
                        d = 2, p = 0, g = 0;
                    else
                      d = 1, p = 0, g = 2;
                  else
                    d = 1, p = 0, g = 1;
                else
                  d = 1, p = 0, g = 0;
              else
                d = 0, p = 0, g = 2;
            else
              d = 0, p = 0, g = 1;
          else
            d = 0, p = 0, g = 0;
        while (!1);
        return h = f[11120 + (h * 216 | 0) + (p * 72 | 0) + (d * 24 | 0) + (g << 3) + 4 >> 2] | 0, h | 0;
      }
      function Tw(d, h) {
        return d = d | 0, h = h | 0, (f[7696 + (d * 28 | 0) + 20 >> 2] | 0) == (h | 0) ? (h = 1, h | 0) : (h = (f[7696 + (d * 28 | 0) + 24 >> 2] | 0) == (h | 0), h | 0);
      }
      function mx(d, h) {
        return d = d | 0, h = h | 0, f[848 + (d * 28 | 0) + (h << 2) >> 2] | 0;
      }
      function gx(d, h) {
        return d = d | 0, h = h | 0, (f[848 + (d * 28 | 0) >> 2] | 0) == (h | 0) ? (h = 0, h | 0) : (f[848 + (d * 28 | 0) + 4 >> 2] | 0) == (h | 0) ? (h = 1, h | 0) : (f[848 + (d * 28 | 0) + 8 >> 2] | 0) == (h | 0) ? (h = 2, h | 0) : (f[848 + (d * 28 | 0) + 12 >> 2] | 0) == (h | 0) ? (h = 3, h | 0) : (f[848 + (d * 28 | 0) + 16 >> 2] | 0) == (h | 0) ? (h = 4, h | 0) : (f[848 + (d * 28 | 0) + 20 >> 2] | 0) == (h | 0) ? (h = 5, h | 0) : ((f[848 + (d * 28 | 0) + 24 >> 2] | 0) == (h | 0) ? 6 : 7) | 0;
      }
      function X7() {
        return 122;
      }
      function Y7(d) {
        d = d | 0;
        var h = 0, p = 0, g = 0;
        h = 0;
        do
          Ze(h | 0, 0, 45) | 0, g = V() | 0 | 134225919, p = d + (h << 3) | 0, f[p >> 2] = -1, f[p + 4 >> 2] = g, h = h + 1 | 0;
        while ((h | 0) != 122);
        return 0;
      }
      function Q7(d) {
        d = d | 0;
        var h = 0, p = 0, g = 0;
        return g = +$[d + 16 >> 3], p = +$[d + 24 >> 3], h = g - p, +(g < p ? h + 6.283185307179586 : h);
      }
      function ww(d) {
        return d = d | 0, +$[d + 16 >> 3] < +$[d + 24 >> 3] | 0;
      }
      function K7(d) {
        return d = d | 0, +(+$[d >> 3] - +$[d + 8 >> 3]);
      }
      function _x(d, h) {
        d = d | 0, h = h | 0;
        var p = 0, g = 0, x = 0;
        return p = +$[h >> 3], !(p >= +$[d + 8 >> 3]) || !(p <= +$[d >> 3]) ? (h = 0, h | 0) : (g = +$[d + 16 >> 3], p = +$[d + 24 >> 3], x = +$[h + 8 >> 3], h = x >= p, d = x <= g & 1, g < p ? h && (d = 1) : h || (d = 0), h = (d | 0) != 0, h | 0);
      }
      function xx(d, h) {
        d = d | 0, h = h | 0;
        var p = 0, g = 0, x = 0, v = 0, w = 0, M = 0, P = 0, I = 0, k = 0;
        return +$[d >> 3] < +$[h + 8 >> 3] || +$[d + 8 >> 3] > +$[h >> 3] ? (g = 0, g | 0) : (v = +$[d + 16 >> 3], p = d + 24 | 0, k = +$[p >> 3], w = v < k, g = h + 16 | 0, I = +$[g >> 3], x = h + 24 | 0, P = +$[x >> 3], M = I < P, h = k - I < P - v, d = w ? M | h ? 1 : 2 : 0, h = M ? w ? 1 : h ? 2 : 1 : 0, v = +ho(v, d), v < +ho(+$[x >> 3], h) || (k = +ho(+$[p >> 3], d), k > +ho(+$[g >> 3], h)) ? (M = 0, M | 0) : (M = 1, M | 0));
      }
      function Z7(d, h, p, g) {
        d = d | 0, h = h | 0, p = p | 0, g = g | 0;
        var x = 0, v = 0, w = 0, M = 0, P = 0;
        v = +$[d + 16 >> 3], P = +$[d + 24 >> 3], d = v < P, M = +$[h + 16 >> 3], w = +$[h + 24 >> 3], x = M < w, h = P - M < w - v, f[p >> 2] = d ? x | h ? 1 : 2 : 0, f[g >> 2] = x ? d ? 1 : h ? 2 : 1 : 0;
      }
      function Mw(d, h) {
        d = d | 0, h = h | 0;
        var p = 0, g = 0, x = 0, v = 0, w = 0, M = 0, P = 0, I = 0, k = 0;
        return +$[d >> 3] < +$[h >> 3] || +$[d + 8 >> 3] > +$[h + 8 >> 3] ? (g = 0, g | 0) : (g = d + 16 | 0, P = +$[g >> 3], v = +$[d + 24 >> 3], w = P < v, p = h + 16 | 0, k = +$[p >> 3], x = h + 24 | 0, I = +$[x >> 3], M = k < I, h = v - k < I - P, d = w ? M | h ? 1 : 2 : 0, h = M ? w ? 1 : h ? 2 : 1 : 0, v = +ho(v, d), v <= +ho(+$[x >> 3], h) ? (k = +ho(+$[g >> 3], d), M = k >= +ho(+$[p >> 3], h), M | 0) : (M = 0, M | 0));
      }
      function Ew(d, h) {
        d = d | 0, h = h | 0;
        var p = 0, g = 0, x = 0, v = 0, w = 0, M = 0;
        x = q, q = q + 176 | 0, g = x, f[g >> 2] = 4, M = +$[h >> 3], $[g + 8 >> 3] = M, v = +$[h + 16 >> 3], $[g + 16 >> 3] = v, $[g + 24 >> 3] = M, M = +$[h + 24 >> 3], $[g + 32 >> 3] = M, w = +$[h + 8 >> 3], $[g + 40 >> 3] = w, $[g + 48 >> 3] = M, $[g + 56 >> 3] = w, $[g + 64 >> 3] = v, h = g + 72 | 0, p = h + 96 | 0;
        do
          f[h >> 2] = 0, h = h + 4 | 0;
        while ((h | 0) < (p | 0));
        md(d | 0, g | 0, 168) | 0, q = x;
      }
      function Rw(d, h, p) {
        d = d | 0, h = h | 0, p = p | 0;
        var g = 0, x = 0, v = 0, w = 0, M = 0, P = 0, I = 0, k = 0, Q = 0, re = 0, se = 0, ae = 0, Ae = 0, ye = 0;
        ae = q, q = q + 288 | 0, k = ae + 264 | 0, Q = ae + 96 | 0, I = ae, M = I, P = M + 96 | 0;
        do
          f[M >> 2] = 0, M = M + 4 | 0;
        while ((M | 0) < (P | 0));
        return h = Nx(h, I) | 0, h | 0 ? (se = h, q = ae, se | 0) : (P = I, I = f[P >> 2] | 0, P = f[P + 4 >> 2] | 0, mc(I, P, k) | 0, dd(I, P, Q) | 0, w = +vA(k, Q + 8 | 0), $[k >> 3] = +$[d >> 3], P = k + 8 | 0, $[P >> 3] = +$[d + 16 >> 3], $[Q >> 3] = +$[d + 8 >> 3], I = Q + 8 | 0, $[I >> 3] = +$[d + 24 >> 3], x = +vA(k, Q), ye = +$[P >> 3] - +$[I >> 3], v = +yn(+ye), Ae = +$[k >> 3] - +$[Q >> 3], g = +yn(+Ae), !(ye == 0 | Ae == 0) && (ye = +lM(+v, +g), ye = +nu(+(x * x / +nm(+(ye / +nm(+v, +g)), 3) / (w * (w * 2.59807621135) * 0.8))), $[Mn >> 3] = ye, re = ~~ye >>> 0, se = +yn(ye) >= 1 ? ye > 0 ? ~~+Z(+nr(ye / 4294967296), 4294967295) >>> 0 : ~~+nu((ye - +(~~ye >>> 0)) / 4294967296) >>> 0 : 0, (f[Mn + 4 >> 2] & 2146435072 | 0) != 2146435072) ? (Q = (re | 0) == 0 & (se | 0) == 0, h = p, f[h >> 2] = Q ? 1 : re, f[h + 4 >> 2] = Q ? 0 : se, h = 0) : h = 1, se = h, q = ae, se | 0);
      }
      function J7(d, h, p, g) {
        d = d | 0, h = h | 0, p = p | 0, g = g | 0;
        var x = 0, v = 0, w = 0, M = 0, P = 0, I = 0, k = 0;
        I = q, q = q + 288 | 0, w = I + 264 | 0, M = I + 96 | 0, P = I, x = P, v = x + 96 | 0;
        do
          f[x >> 2] = 0, x = x + 4 | 0;
        while ((x | 0) < (v | 0));
        return p = Nx(p, P) | 0, p | 0 ? (g = p, q = I, g | 0) : (p = P, x = f[p >> 2] | 0, p = f[p + 4 >> 2] | 0, mc(x, p, w) | 0, dd(x, p, M) | 0, k = +vA(w, M + 8 | 0), k = +nu(+(+vA(d, h) / (k * 2))), $[Mn >> 3] = k, p = ~~k >>> 0, x = +yn(k) >= 1 ? k > 0 ? ~~+Z(+nr(k / 4294967296), 4294967295) >>> 0 : ~~+nu((k - +(~~k >>> 0)) / 4294967296) >>> 0 : 0, (f[Mn + 4 >> 2] & 2146435072 | 0) == 2146435072 ? (g = 1, q = I, g | 0) : (P = (p | 0) == 0 & (x | 0) == 0, f[g >> 2] = P ? 1 : p, f[g + 4 >> 2] = P ? 0 : x, g = 0, q = I, g | 0));
      }
      function eB(d, h) {
        d = d | 0, h = +h;
        var p = 0, g = 0, x = 0, v = 0, w = 0, M = 0, P = 0, I = 0, k = 0;
        v = d + 16 | 0, w = +$[v >> 3], p = d + 24 | 0, x = +$[p >> 3], g = w - x, g = w < x ? g + 6.283185307179586 : g, I = +$[d >> 3], M = d + 8 | 0, P = +$[M >> 3], k = I - P, g = (g * h - g) * 0.5, h = (k * h - k) * 0.5, I = I + h, $[d >> 3] = I > 1.5707963267948966 ? 1.5707963267948966 : I, h = P - h, $[M >> 3] = h < -1.5707963267948966 ? -1.5707963267948966 : h, h = w + g, h = h > 3.141592653589793 ? h + -6.283185307179586 : h, $[v >> 3] = h < -3.141592653589793 ? h + 6.283185307179586 : h, h = x - g, h = h > 3.141592653589793 ? h + -6.283185307179586 : h, $[p >> 3] = h < -3.141592653589793 ? h + 6.283185307179586 : h;
      }
      function tB(d, h, p, g) {
        d = d | 0, h = h | 0, p = p | 0, g = g | 0, f[d >> 2] = h, f[d + 4 >> 2] = p, f[d + 8 >> 2] = g;
      }
      function nB(d, h) {
        d = d | 0, h = h | 0;
        var p = 0, g = 0, x = 0, v = 0, w = 0, M = 0, P = 0, I = 0, k = 0, Q = 0, re = 0;
        Q = h + 8 | 0, f[Q >> 2] = 0, P = +$[d >> 3], w = +yn(+P), I = +$[d + 8 >> 3], M = +yn(+I) * 1.1547005383792515, w = w + M * 0.5, p = ~~w, d = ~~M, w = w - +(p | 0), M = M - +(d | 0);
        do
          if (w < 0.5)
            if (w < 0.3333333333333333)
              if (f[h >> 2] = p, M < (w + 1) * 0.5) {
                f[h + 4 >> 2] = d;
                break;
              } else {
                d = d + 1 | 0, f[h + 4 >> 2] = d;
                break;
              }
            else if (re = 1 - w, d = (!(M < re) & 1) + d | 0, f[h + 4 >> 2] = d, re <= M & M < w * 2) {
              p = p + 1 | 0, f[h >> 2] = p;
              break;
            } else {
              f[h >> 2] = p;
              break;
            }
          else {
            if (!(w < 0.6666666666666666))
              if (p = p + 1 | 0, f[h >> 2] = p, M < w * 0.5) {
                f[h + 4 >> 2] = d;
                break;
              } else {
                d = d + 1 | 0, f[h + 4 >> 2] = d;
                break;
              }
            if (M < 1 - w) {
              if (f[h + 4 >> 2] = d, w * 2 + -1 < M) {
                f[h >> 2] = p;
                break;
              }
            } else
              d = d + 1 | 0, f[h + 4 >> 2] = d;
            p = p + 1 | 0, f[h >> 2] = p;
          }
        while (!1);
        do
          if (P < 0)
            if (d & 1) {
              k = (d + 1 | 0) / 2 | 0, k = wr(p | 0, ((p | 0) < 0) << 31 >> 31 | 0, k | 0, ((k | 0) < 0) << 31 >> 31 | 0) | 0, p = ~~(+(p | 0) - ((+(k >>> 0) + 4294967296 * +(V() | 0)) * 2 + 1)), f[h >> 2] = p;
              break;
            } else {
              k = (d | 0) / 2 | 0, k = wr(p | 0, ((p | 0) < 0) << 31 >> 31 | 0, k | 0, ((k | 0) < 0) << 31 >> 31 | 0) | 0, p = ~~(+(p | 0) - (+(k >>> 0) + 4294967296 * +(V() | 0)) * 2), f[h >> 2] = p;
              break;
            }
        while (!1);
        k = h + 4 | 0, I < 0 && (p = p - ((d << 1 | 1 | 0) / 2 | 0) | 0, f[h >> 2] = p, d = 0 - d | 0, f[k >> 2] = d), g = d - p | 0, (p | 0) < 0 ? (x = 0 - p | 0, f[k >> 2] = g, f[Q >> 2] = x, f[h >> 2] = 0, d = g, p = 0) : x = 0, (d | 0) < 0 && (p = p - d | 0, f[h >> 2] = p, x = x - d | 0, f[Q >> 2] = x, f[k >> 2] = 0, d = 0), v = p - x | 0, g = d - x | 0, (x | 0) < 0 && (f[h >> 2] = v, f[k >> 2] = g, f[Q >> 2] = 0, d = g, p = v, x = 0), g = (d | 0) < (p | 0) ? d : p, g = (x | 0) < (g | 0) ? x : g, !((g | 0) <= 0) && (f[h >> 2] = p - g, f[k >> 2] = d - g, f[Q >> 2] = x - g);
      }
      function rs(d) {
        d = d | 0;
        var h = 0, p = 0, g = 0, x = 0, v = 0, w = 0;
        h = f[d >> 2] | 0, w = d + 4 | 0, p = f[w >> 2] | 0, (h | 0) < 0 && (p = p - h | 0, f[w >> 2] = p, v = d + 8 | 0, f[v >> 2] = (f[v >> 2] | 0) - h, f[d >> 2] = 0, h = 0), (p | 0) < 0 ? (h = h - p | 0, f[d >> 2] = h, v = d + 8 | 0, x = (f[v >> 2] | 0) - p | 0, f[v >> 2] = x, f[w >> 2] = 0, p = 0) : (x = d + 8 | 0, v = x, x = f[x >> 2] | 0), (x | 0) < 0 && (h = h - x | 0, f[d >> 2] = h, p = p - x | 0, f[w >> 2] = p, f[v >> 2] = 0, x = 0), g = (p | 0) < (h | 0) ? p : h, g = (x | 0) < (g | 0) ? x : g, !((g | 0) <= 0) && (f[d >> 2] = h - g, f[w >> 2] = p - g, f[v >> 2] = x - g);
      }
      function dc(d, h) {
        d = d | 0, h = h | 0;
        var p = 0, g = 0;
        g = f[d + 8 >> 2] | 0, p = +((f[d + 4 >> 2] | 0) - g | 0), $[h >> 3] = +((f[d >> 2] | 0) - g | 0) - p * 0.5, $[h + 8 >> 3] = p * 0.8660254037844386;
      }
      function vs(d, h, p) {
        d = d | 0, h = h | 0, p = p | 0, f[p >> 2] = (f[h >> 2] | 0) + (f[d >> 2] | 0), f[p + 4 >> 2] = (f[h + 4 >> 2] | 0) + (f[d + 4 >> 2] | 0), f[p + 8 >> 2] = (f[h + 8 >> 2] | 0) + (f[d + 8 >> 2] | 0);
      }
      function yx(d, h, p) {
        d = d | 0, h = h | 0, p = p | 0, f[p >> 2] = (f[d >> 2] | 0) - (f[h >> 2] | 0), f[p + 4 >> 2] = (f[d + 4 >> 2] | 0) - (f[h + 4 >> 2] | 0), f[p + 8 >> 2] = (f[d + 8 >> 2] | 0) - (f[h + 8 >> 2] | 0);
      }
      function Cw(d, h) {
        d = d | 0, h = h | 0;
        var p = 0, g = 0;
        p = No(f[d >> 2] | 0, h) | 0, f[d >> 2] = p, p = d + 4 | 0, g = No(f[p >> 2] | 0, h) | 0, f[p >> 2] = g, d = d + 8 | 0, h = No(f[d >> 2] | 0, h) | 0, f[d >> 2] = h;
      }
      function Y0(d) {
        d = d | 0;
        var h = 0, p = 0, g = 0, x = 0, v = 0, w = 0, M = 0;
        w = f[d >> 2] | 0, M = (w | 0) < 0, g = (f[d + 4 >> 2] | 0) - (M ? w : 0) | 0, v = (g | 0) < 0, x = (v ? 0 - g | 0 : 0) + ((f[d + 8 >> 2] | 0) - (M ? w : 0)) | 0, p = (x | 0) < 0, d = p ? 0 : x, h = (v ? 0 : g) - (p ? x : 0) | 0, x = (M ? 0 : w) - (v ? g : 0) - (p ? x : 0) | 0, p = (h | 0) < (x | 0) ? h : x, p = (d | 0) < (p | 0) ? d : p, g = (p | 0) > 0, d = d - (g ? p : 0) | 0, h = h - (g ? p : 0) | 0;
        e: do
          switch (x - (g ? p : 0) | 0) {
            case 0:
              switch (h | 0) {
                case 0:
                  return M = (d | 0) == 0 ? 0 : (d | 0) == 1 ? 1 : 7, M | 0;
                case 1:
                  return M = (d | 0) == 0 ? 2 : (d | 0) == 1 ? 3 : 7, M | 0;
                default:
                  break e;
              }
            case 1:
              switch (h | 0) {
                case 0:
                  return M = (d | 0) == 0 ? 4 : (d | 0) == 1 ? 5 : 7, M | 0;
                case 1: {
                  if (!d)
                    d = 6;
                  else
                    break e;
                  return d | 0;
                }
                default:
                  break e;
              }
          }
        while (!1);
        return M = 7, M | 0;
      }
      function iB(d) {
        d = d | 0;
        var h = 0, p = 0, g = 0, x = 0, v = 0, w = 0, M = 0, P = 0, I = 0;
        if (P = d + 8 | 0, w = f[P >> 2] | 0, M = (f[d >> 2] | 0) - w | 0, I = d + 4 | 0, w = (f[I >> 2] | 0) - w | 0, M >>> 0 > 715827881 | w >>> 0 > 715827881) {
          if (g = (M | 0) > 0, x = 2147483647 - M | 0, v = -2147483648 - M | 0, (g ? (x | 0) < (M | 0) : (v | 0) > (M | 0)) || (p = M << 1, g ? (2147483647 - p | 0) < (M | 0) : (-2147483648 - p | 0) > (M | 0)) || ((w | 0) > 0 ? (2147483647 - w | 0) < (w | 0) : (-2147483648 - w | 0) > (w | 0)) || (h = M * 3 | 0, p = w << 1, (g ? (x | 0) < (p | 0) : (v | 0) > (p | 0)) || ((M | 0) > -1 ? (h | -2147483648 | 0) >= (w | 0) : (h ^ -2147483648 | 0) < (w | 0))))
            return I = 1, I | 0;
        } else
          p = w << 1, h = M * 3 | 0;
        return g = su(+(h - w | 0) * 0.14285714285714285) | 0, f[d >> 2] = g, x = su(+(p + M | 0) * 0.14285714285714285) | 0, f[I >> 2] = x, f[P >> 2] = 0, p = (x | 0) < (g | 0), h = p ? g : x, p = p ? x : g, (p | 0) < 0 && (((p | 0) == -2147483648 || ((h | 0) > 0 ? (2147483647 - h | 0) < (p | 0) : (-2147483648 - h | 0) > (p | 0))) && Ve(27795, 26892, 354, 26903), ((h | 0) > -1 ? (h | -2147483648 | 0) >= (p | 0) : (h ^ -2147483648 | 0) < (p | 0)) && Ve(27795, 26892, 354, 26903)), h = x - g | 0, (g | 0) < 0 ? (p = 0 - g | 0, f[I >> 2] = h, f[P >> 2] = p, f[d >> 2] = 0, g = 0) : (h = x, p = 0), (h | 0) < 0 && (g = g - h | 0, f[d >> 2] = g, p = p - h | 0, f[P >> 2] = p, f[I >> 2] = 0, h = 0), v = g - p | 0, x = h - p | 0, (p | 0) < 0 ? (f[d >> 2] = v, f[I >> 2] = x, f[P >> 2] = 0, h = x, x = v, p = 0) : x = g, g = (h | 0) < (x | 0) ? h : x, g = (p | 0) < (g | 0) ? p : g, (g | 0) <= 0 ? (I = 0, I | 0) : (f[d >> 2] = x - g, f[I >> 2] = h - g, f[P >> 2] = p - g, I = 0, I | 0);
      }
      function rB(d) {
        d = d | 0;
        var h = 0, p = 0, g = 0, x = 0, v = 0, w = 0, M = 0, P = 0;
        if (w = d + 8 | 0, x = f[w >> 2] | 0, v = (f[d >> 2] | 0) - x | 0, M = d + 4 | 0, x = (f[M >> 2] | 0) - x | 0, v >>> 0 > 715827881 | x >>> 0 > 715827881) {
          if (p = (v | 0) > 0, (p ? (2147483647 - v | 0) < (v | 0) : (-2147483648 - v | 0) > (v | 0)) || (h = v << 1, g = (x | 0) > 0, g ? (2147483647 - x | 0) < (x | 0) : (-2147483648 - x | 0) > (x | 0)))
            return M = 1, M | 0;
          if (P = x << 1, (g ? (2147483647 - P | 0) < (x | 0) : (-2147483648 - P | 0) > (x | 0)) || (p ? (2147483647 - h | 0) < (x | 0) : (-2147483648 - h | 0) > (x | 0)) || (p = x * 3 | 0, (x | 0) > -1 ? (p | -2147483648 | 0) >= (v | 0) : (p ^ -2147483648 | 0) < (v | 0)))
            return P = 1, P | 0;
        } else
          p = x * 3 | 0, h = v << 1;
        return g = su(+(h + x | 0) * 0.14285714285714285) | 0, f[d >> 2] = g, x = su(+(p - v | 0) * 0.14285714285714285) | 0, f[M >> 2] = x, f[w >> 2] = 0, p = (x | 0) < (g | 0), h = p ? g : x, p = p ? x : g, (p | 0) < 0 && (((p | 0) == -2147483648 || ((h | 0) > 0 ? (2147483647 - h | 0) < (p | 0) : (-2147483648 - h | 0) > (p | 0))) && Ve(27795, 26892, 402, 26917), ((h | 0) > -1 ? (h | -2147483648 | 0) >= (p | 0) : (h ^ -2147483648 | 0) < (p | 0)) && Ve(27795, 26892, 402, 26917)), h = x - g | 0, (g | 0) < 0 ? (p = 0 - g | 0, f[M >> 2] = h, f[w >> 2] = p, f[d >> 2] = 0, g = 0) : (h = x, p = 0), (h | 0) < 0 && (g = g - h | 0, f[d >> 2] = g, p = p - h | 0, f[w >> 2] = p, f[M >> 2] = 0, h = 0), v = g - p | 0, x = h - p | 0, (p | 0) < 0 ? (f[d >> 2] = v, f[M >> 2] = x, f[w >> 2] = 0, h = x, x = v, p = 0) : x = g, g = (h | 0) < (x | 0) ? h : x, g = (p | 0) < (g | 0) ? p : g, (g | 0) <= 0 ? (P = 0, P | 0) : (f[d >> 2] = x - g, f[M >> 2] = h - g, f[w >> 2] = p - g, P = 0, P | 0);
      }
      function sB(d) {
        d = d | 0;
        var h = 0, p = 0, g = 0, x = 0, v = 0, w = 0, M = 0;
        w = d + 8 | 0, p = f[w >> 2] | 0, h = (f[d >> 2] | 0) - p | 0, M = d + 4 | 0, p = (f[M >> 2] | 0) - p | 0, g = su(+((h * 3 | 0) - p | 0) * 0.14285714285714285) | 0, f[d >> 2] = g, h = su(+((p << 1) + h | 0) * 0.14285714285714285) | 0, f[M >> 2] = h, f[w >> 2] = 0, p = h - g | 0, (g | 0) < 0 ? (v = 0 - g | 0, f[M >> 2] = p, f[w >> 2] = v, f[d >> 2] = 0, h = p, g = 0, p = v) : p = 0, (h | 0) < 0 && (g = g - h | 0, f[d >> 2] = g, p = p - h | 0, f[w >> 2] = p, f[M >> 2] = 0, h = 0), v = g - p | 0, x = h - p | 0, (p | 0) < 0 ? (f[d >> 2] = v, f[M >> 2] = x, f[w >> 2] = 0, h = x, x = v, p = 0) : x = g, g = (h | 0) < (x | 0) ? h : x, g = (p | 0) < (g | 0) ? p : g, !((g | 0) <= 0) && (f[d >> 2] = x - g, f[M >> 2] = h - g, f[w >> 2] = p - g);
      }
      function Pw(d) {
        d = d | 0;
        var h = 0, p = 0, g = 0, x = 0, v = 0, w = 0, M = 0;
        w = d + 8 | 0, p = f[w >> 2] | 0, h = (f[d >> 2] | 0) - p | 0, M = d + 4 | 0, p = (f[M >> 2] | 0) - p | 0, g = su(+((h << 1) + p | 0) * 0.14285714285714285) | 0, f[d >> 2] = g, h = su(+((p * 3 | 0) - h | 0) * 0.14285714285714285) | 0, f[M >> 2] = h, f[w >> 2] = 0, p = h - g | 0, (g | 0) < 0 ? (v = 0 - g | 0, f[M >> 2] = p, f[w >> 2] = v, f[d >> 2] = 0, h = p, g = 0, p = v) : p = 0, (h | 0) < 0 && (g = g - h | 0, f[d >> 2] = g, p = p - h | 0, f[w >> 2] = p, f[M >> 2] = 0, h = 0), v = g - p | 0, x = h - p | 0, (p | 0) < 0 ? (f[d >> 2] = v, f[M >> 2] = x, f[w >> 2] = 0, h = x, x = v, p = 0) : x = g, g = (h | 0) < (x | 0) ? h : x, g = (p | 0) < (g | 0) ? p : g, !((g | 0) <= 0) && (f[d >> 2] = x - g, f[M >> 2] = h - g, f[w >> 2] = p - g);
      }
      function Q0(d) {
        d = d | 0;
        var h = 0, p = 0, g = 0, x = 0, v = 0, w = 0, M = 0;
        h = f[d >> 2] | 0, w = d + 4 | 0, p = f[w >> 2] | 0, M = d + 8 | 0, g = f[M >> 2] | 0, x = p + (h * 3 | 0) | 0, f[d >> 2] = x, p = g + (p * 3 | 0) | 0, f[w >> 2] = p, h = (g * 3 | 0) + h | 0, f[M >> 2] = h, g = p - x | 0, (x | 0) < 0 ? (h = h - x | 0, f[w >> 2] = g, f[M >> 2] = h, f[d >> 2] = 0, p = g, g = 0) : g = x, (p | 0) < 0 && (g = g - p | 0, f[d >> 2] = g, h = h - p | 0, f[M >> 2] = h, f[w >> 2] = 0, p = 0), v = g - h | 0, x = p - h | 0, (h | 0) < 0 ? (f[d >> 2] = v, f[w >> 2] = x, f[M >> 2] = 0, g = v, h = 0) : x = p, p = (x | 0) < (g | 0) ? x : g, p = (h | 0) < (p | 0) ? h : p, !((p | 0) <= 0) && (f[d >> 2] = g - p, f[w >> 2] = x - p, f[M >> 2] = h - p);
      }
      function fc(d) {
        d = d | 0;
        var h = 0, p = 0, g = 0, x = 0, v = 0, w = 0, M = 0;
        x = f[d >> 2] | 0, w = d + 4 | 0, h = f[w >> 2] | 0, M = d + 8 | 0, p = f[M >> 2] | 0, g = (h * 3 | 0) + x | 0, x = p + (x * 3 | 0) | 0, f[d >> 2] = x, f[w >> 2] = g, h = (p * 3 | 0) + h | 0, f[M >> 2] = h, p = g - x | 0, (x | 0) < 0 ? (h = h - x | 0, f[w >> 2] = p, f[M >> 2] = h, f[d >> 2] = 0, x = 0) : p = g, (p | 0) < 0 && (x = x - p | 0, f[d >> 2] = x, h = h - p | 0, f[M >> 2] = h, f[w >> 2] = 0, p = 0), v = x - h | 0, g = p - h | 0, (h | 0) < 0 ? (f[d >> 2] = v, f[w >> 2] = g, f[M >> 2] = 0, x = v, h = 0) : g = p, p = (g | 0) < (x | 0) ? g : x, p = (h | 0) < (p | 0) ? h : p, !((p | 0) <= 0) && (f[d >> 2] = x - p, f[w >> 2] = g - p, f[M >> 2] = h - p);
      }
      function Nw(d, h) {
        d = d | 0, h = h | 0;
        var p = 0, g = 0, x = 0, v = 0, w = 0, M = 0;
        (h + -1 | 0) >>> 0 >= 6 || (x = (f[15440 + (h * 12 | 0) >> 2] | 0) + (f[d >> 2] | 0) | 0, f[d >> 2] = x, M = d + 4 | 0, g = (f[15440 + (h * 12 | 0) + 4 >> 2] | 0) + (f[M >> 2] | 0) | 0, f[M >> 2] = g, w = d + 8 | 0, h = (f[15440 + (h * 12 | 0) + 8 >> 2] | 0) + (f[w >> 2] | 0) | 0, f[w >> 2] = h, p = g - x | 0, (x | 0) < 0 ? (h = h - x | 0, f[M >> 2] = p, f[w >> 2] = h, f[d >> 2] = 0, g = 0) : (p = g, g = x), (p | 0) < 0 && (g = g - p | 0, f[d >> 2] = g, h = h - p | 0, f[w >> 2] = h, f[M >> 2] = 0, p = 0), v = g - h | 0, x = p - h | 0, (h | 0) < 0 ? (f[d >> 2] = v, f[M >> 2] = x, f[w >> 2] = 0, g = v, h = 0) : x = p, p = (x | 0) < (g | 0) ? x : g, p = (h | 0) < (p | 0) ? h : p, !((p | 0) <= 0) && (f[d >> 2] = g - p, f[M >> 2] = x - p, f[w >> 2] = h - p));
      }
      function Dw(d) {
        d = d | 0;
        var h = 0, p = 0, g = 0, x = 0, v = 0, w = 0, M = 0;
        x = f[d >> 2] | 0, w = d + 4 | 0, h = f[w >> 2] | 0, M = d + 8 | 0, p = f[M >> 2] | 0, g = h + x | 0, x = p + x | 0, f[d >> 2] = x, f[w >> 2] = g, h = p + h | 0, f[M >> 2] = h, p = g - x | 0, (x | 0) < 0 ? (h = h - x | 0, f[w >> 2] = p, f[M >> 2] = h, f[d >> 2] = 0, g = 0) : (p = g, g = x), (p | 0) < 0 && (g = g - p | 0, f[d >> 2] = g, h = h - p | 0, f[M >> 2] = h, f[w >> 2] = 0, p = 0), v = g - h | 0, x = p - h | 0, (h | 0) < 0 ? (f[d >> 2] = v, f[w >> 2] = x, f[M >> 2] = 0, g = v, h = 0) : x = p, p = (x | 0) < (g | 0) ? x : g, p = (h | 0) < (p | 0) ? h : p, !((p | 0) <= 0) && (f[d >> 2] = g - p, f[w >> 2] = x - p, f[M >> 2] = h - p);
      }
      function K0(d) {
        d = d | 0;
        var h = 0, p = 0, g = 0, x = 0, v = 0, w = 0, M = 0;
        h = f[d >> 2] | 0, w = d + 4 | 0, g = f[w >> 2] | 0, M = d + 8 | 0, p = f[M >> 2] | 0, x = g + h | 0, f[d >> 2] = x, g = p + g | 0, f[w >> 2] = g, h = p + h | 0, f[M >> 2] = h, p = g - x | 0, (x | 0) < 0 ? (h = h - x | 0, f[w >> 2] = p, f[M >> 2] = h, f[d >> 2] = 0, g = 0) : (p = g, g = x), (p | 0) < 0 && (g = g - p | 0, f[d >> 2] = g, h = h - p | 0, f[M >> 2] = h, f[w >> 2] = 0, p = 0), v = g - h | 0, x = p - h | 0, (h | 0) < 0 ? (f[d >> 2] = v, f[w >> 2] = x, f[M >> 2] = 0, g = v, h = 0) : x = p, p = (x | 0) < (g | 0) ? x : g, p = (h | 0) < (p | 0) ? h : p, !((p | 0) <= 0) && (f[d >> 2] = g - p, f[w >> 2] = x - p, f[M >> 2] = h - p);
      }
      function Ac(d) {
        switch (d = d | 0, d | 0) {
          case 1: {
            d = 5;
            break;
          }
          case 5: {
            d = 4;
            break;
          }
          case 4: {
            d = 6;
            break;
          }
          case 6: {
            d = 2;
            break;
          }
          case 2: {
            d = 3;
            break;
          }
          case 3: {
            d = 1;
            break;
          }
        }
        return d | 0;
      }
      function iu(d) {
        switch (d = d | 0, d | 0) {
          case 1: {
            d = 3;
            break;
          }
          case 3: {
            d = 2;
            break;
          }
          case 2: {
            d = 6;
            break;
          }
          case 6: {
            d = 4;
            break;
          }
          case 4: {
            d = 5;
            break;
          }
          case 5: {
            d = 1;
            break;
          }
        }
        return d | 0;
      }
      function Lw(d) {
        d = d | 0;
        var h = 0, p = 0, g = 0, x = 0, v = 0, w = 0, M = 0;
        h = f[d >> 2] | 0, w = d + 4 | 0, p = f[w >> 2] | 0, M = d + 8 | 0, g = f[M >> 2] | 0, x = p + (h << 1) | 0, f[d >> 2] = x, p = g + (p << 1) | 0, f[w >> 2] = p, h = (g << 1) + h | 0, f[M >> 2] = h, g = p - x | 0, (x | 0) < 0 ? (h = h - x | 0, f[w >> 2] = g, f[M >> 2] = h, f[d >> 2] = 0, p = g, g = 0) : g = x, (p | 0) < 0 && (g = g - p | 0, f[d >> 2] = g, h = h - p | 0, f[M >> 2] = h, f[w >> 2] = 0, p = 0), v = g - h | 0, x = p - h | 0, (h | 0) < 0 ? (f[d >> 2] = v, f[w >> 2] = x, f[M >> 2] = 0, g = v, h = 0) : x = p, p = (x | 0) < (g | 0) ? x : g, p = (h | 0) < (p | 0) ? h : p, !((p | 0) <= 0) && (f[d >> 2] = g - p, f[w >> 2] = x - p, f[M >> 2] = h - p);
      }
      function Iw(d) {
        d = d | 0;
        var h = 0, p = 0, g = 0, x = 0, v = 0, w = 0, M = 0;
        x = f[d >> 2] | 0, w = d + 4 | 0, h = f[w >> 2] | 0, M = d + 8 | 0, p = f[M >> 2] | 0, g = (h << 1) + x | 0, x = p + (x << 1) | 0, f[d >> 2] = x, f[w >> 2] = g, h = (p << 1) + h | 0, f[M >> 2] = h, p = g - x | 0, (x | 0) < 0 ? (h = h - x | 0, f[w >> 2] = p, f[M >> 2] = h, f[d >> 2] = 0, x = 0) : p = g, (p | 0) < 0 && (x = x - p | 0, f[d >> 2] = x, h = h - p | 0, f[M >> 2] = h, f[w >> 2] = 0, p = 0), v = x - h | 0, g = p - h | 0, (h | 0) < 0 ? (f[d >> 2] = v, f[w >> 2] = g, f[M >> 2] = 0, x = v, h = 0) : g = p, p = (g | 0) < (x | 0) ? g : x, p = (h | 0) < (p | 0) ? h : p, !((p | 0) <= 0) && (f[d >> 2] = x - p, f[w >> 2] = g - p, f[M >> 2] = h - p);
      }
      function vx(d, h) {
        d = d | 0, h = h | 0;
        var p = 0, g = 0, x = 0, v = 0, w = 0, M = 0;
        return w = (f[d >> 2] | 0) - (f[h >> 2] | 0) | 0, M = (w | 0) < 0, g = (f[d + 4 >> 2] | 0) - (f[h + 4 >> 2] | 0) - (M ? w : 0) | 0, v = (g | 0) < 0, x = (M ? 0 - w | 0 : 0) + (f[d + 8 >> 2] | 0) - (f[h + 8 >> 2] | 0) + (v ? 0 - g | 0 : 0) | 0, d = (x | 0) < 0, h = d ? 0 : x, p = (v ? 0 : g) - (d ? x : 0) | 0, x = (M ? 0 : w) - (v ? g : 0) - (d ? x : 0) | 0, d = (p | 0) < (x | 0) ? p : x, d = (h | 0) < (d | 0) ? h : d, g = (d | 0) > 0, h = h - (g ? d : 0) | 0, p = p - (g ? d : 0) | 0, d = x - (g ? d : 0) | 0, d = (d | 0) > -1 ? d : 0 - d | 0, p = (p | 0) > -1 ? p : 0 - p | 0, h = (h | 0) > -1 ? h : 0 - h | 0, h = (p | 0) > (h | 0) ? p : h, ((d | 0) > (h | 0) ? d : h) | 0;
      }
      function oB(d, h) {
        d = d | 0, h = h | 0;
        var p = 0;
        p = f[d + 8 >> 2] | 0, f[h >> 2] = (f[d >> 2] | 0) - p, f[h + 4 >> 2] = (f[d + 4 >> 2] | 0) - p;
      }
      function aB(d, h) {
        d = d | 0, h = h | 0;
        var p = 0, g = 0, x = 0, v = 0, w = 0, M = 0;
        return g = f[d >> 2] | 0, f[h >> 2] = g, x = f[d + 4 >> 2] | 0, w = h + 4 | 0, f[w >> 2] = x, M = h + 8 | 0, f[M >> 2] = 0, p = (x | 0) < (g | 0), d = p ? g : x, p = p ? x : g, (p | 0) < 0 && ((p | 0) == -2147483648 || ((d | 0) > 0 ? (2147483647 - d | 0) < (p | 0) : (-2147483648 - d | 0) > (p | 0)) || ((d | 0) > -1 ? (d | -2147483648 | 0) >= (p | 0) : (d ^ -2147483648 | 0) < (p | 0))) ? (h = 1, h | 0) : (d = x - g | 0, (g | 0) < 0 ? (p = 0 - g | 0, f[w >> 2] = d, f[M >> 2] = p, f[h >> 2] = 0, g = 0) : (d = x, p = 0), (d | 0) < 0 && (g = g - d | 0, f[h >> 2] = g, p = p - d | 0, f[M >> 2] = p, f[w >> 2] = 0, d = 0), v = g - p | 0, x = d - p | 0, (p | 0) < 0 ? (f[h >> 2] = v, f[w >> 2] = x, f[M >> 2] = 0, d = x, x = v, p = 0) : x = g, g = (d | 0) < (x | 0) ? d : x, g = (p | 0) < (g | 0) ? p : g, (g | 0) <= 0 ? (h = 0, h | 0) : (f[h >> 2] = x - g, f[w >> 2] = d - g, f[M >> 2] = p - g, h = 0, h | 0));
      }
      function Bw(d) {
        d = d | 0;
        var h = 0, p = 0, g = 0, x = 0;
        h = d + 8 | 0, x = f[h >> 2] | 0, p = x - (f[d >> 2] | 0) | 0, f[d >> 2] = p, g = d + 4 | 0, d = (f[g >> 2] | 0) - x | 0, f[g >> 2] = d, f[h >> 2] = 0 - (d + p);
      }
      function lB(d) {
        d = d | 0;
        var h = 0, p = 0, g = 0, x = 0, v = 0, w = 0, M = 0;
        p = f[d >> 2] | 0, h = 0 - p | 0, f[d >> 2] = h, w = d + 8 | 0, f[w >> 2] = 0, M = d + 4 | 0, g = f[M >> 2] | 0, x = g + p | 0, (p | 0) > 0 ? (f[M >> 2] = x, f[w >> 2] = p, f[d >> 2] = 0, h = 0, g = x) : p = 0, (g | 0) < 0 ? (v = h - g | 0, f[d >> 2] = v, p = p - g | 0, f[w >> 2] = p, f[M >> 2] = 0, x = v - p | 0, h = 0 - p | 0, (p | 0) < 0 ? (f[d >> 2] = x, f[M >> 2] = h, f[w >> 2] = 0, g = h, p = 0) : (g = 0, x = v)) : x = h, h = (g | 0) < (x | 0) ? g : x, h = (p | 0) < (h | 0) ? p : h, !((h | 0) <= 0) && (f[d >> 2] = x - h, f[M >> 2] = g - h, f[w >> 2] = p - h);
      }
      function uB(d, h, p, g, x) {
        d = d | 0, h = h | 0, p = p | 0, g = g | 0, x = x | 0;
        var v = 0, w = 0, M = 0, P = 0, I = 0, k = 0, Q = 0;
        if (Q = q, q = q + 64 | 0, k = Q, M = Q + 56 | 0, !(!0 & (h & 2013265920 | 0) == 134217728 & (!0 & (g & 2013265920 | 0) == 134217728)))
          return x = 5, q = Q, x | 0;
        if ((d | 0) == (p | 0) & (h | 0) == (g | 0))
          return f[x >> 2] = 0, x = 0, q = Q, x | 0;
        if (w = qe(d | 0, h | 0, 52) | 0, V() | 0, w = w & 15, I = qe(p | 0, g | 0, 52) | 0, V() | 0, (w | 0) != (I & 15 | 0))
          return x = 12, q = Q, x | 0;
        if (v = w + -1 | 0, w >>> 0 > 1) {
          Mx(d, h, v, k) | 0, Mx(p, g, v, M) | 0, I = k, P = f[I >> 2] | 0, I = f[I + 4 >> 2] | 0;
          e: do
            if ((P | 0) == (f[M >> 2] | 0) && (I | 0) == (f[M + 4 >> 2] | 0)) {
              w = (w ^ 15) * 3 | 0, v = qe(d | 0, h | 0, w | 0) | 0, V() | 0, v = v & 7, w = qe(p | 0, g | 0, w | 0) | 0, V() | 0, w = w & 7;
              do
                if ((v | 0) == 0 | (w | 0) == 0)
                  f[x >> 2] = 1, v = 0;
                else if ((v | 0) == 7)
                  v = 5;
                else {
                  if ((v | 0) == 1 | (w | 0) == 1 && xi(P, I) | 0) {
                    v = 5;
                    break;
                  }
                  if ((f[15536 + (v << 2) >> 2] | 0) != (w | 0) && (f[15568 + (v << 2) >> 2] | 0) != (w | 0))
                    break e;
                  f[x >> 2] = 1, v = 0;
                }
              while (!1);
              return x = v, q = Q, x | 0;
            }
          while (!1);
        }
        v = k, w = v + 56 | 0;
        do
          f[v >> 2] = 0, v = v + 4 | 0;
        while ((v | 0) < (w | 0));
        return Kn(d, h, 1, k) | 0, h = k, !((f[h >> 2] | 0) == (p | 0) && (f[h + 4 >> 2] | 0) == (g | 0)) && (h = k + 8 | 0, !((f[h >> 2] | 0) == (p | 0) && (f[h + 4 >> 2] | 0) == (g | 0))) && (h = k + 16 | 0, !((f[h >> 2] | 0) == (p | 0) && (f[h + 4 >> 2] | 0) == (g | 0))) && (h = k + 24 | 0, !((f[h >> 2] | 0) == (p | 0) && (f[h + 4 >> 2] | 0) == (g | 0))) && (h = k + 32 | 0, !((f[h >> 2] | 0) == (p | 0) && (f[h + 4 >> 2] | 0) == (g | 0))) && (h = k + 40 | 0, !((f[h >> 2] | 0) == (p | 0) && (f[h + 4 >> 2] | 0) == (g | 0))) ? (v = k + 48 | 0, v = ((f[v >> 2] | 0) == (p | 0) ? (f[v + 4 >> 2] | 0) == (g | 0) : 0) & 1) : v = 1, f[x >> 2] = v, x = 0, q = Q, x | 0;
      }
      function cB(d, h, p, g, x) {
        return d = d | 0, h = h | 0, p = p | 0, g = g | 0, x = x | 0, p = is(d, h, p, g) | 0, (p | 0) == 7 ? (x = 11, x | 0) : (g = Ze(p | 0, 0, 56) | 0, h = h & -2130706433 | (V() | 0) | 268435456, f[x >> 2] = d | g, f[x + 4 >> 2] = h, x = 0, x | 0);
      }
      function hB(d, h, p) {
        return d = d | 0, h = h | 0, p = p | 0, !0 & (h & 2013265920 | 0) == 268435456 ? (f[p >> 2] = d, f[p + 4 >> 2] = h & -2130706433 | 134217728, p = 0, p | 0) : (p = 6, p | 0);
      }
      function dB(d, h, p) {
        d = d | 0, h = h | 0, p = p | 0;
        var g = 0, x = 0, v = 0;
        return x = q, q = q + 16 | 0, g = x, f[g >> 2] = 0, !0 & (h & 2013265920 | 0) == 268435456 ? (v = qe(d | 0, h | 0, 56) | 0, V() | 0, g = Zn(d, h & -2130706433 | 134217728, v & 7, g, p) | 0, q = x, g | 0) : (g = 6, q = x, g | 0);
      }
      function Fw(d, h) {
        d = d | 0, h = h | 0;
        var p = 0;
        switch (p = qe(d | 0, h | 0, 56) | 0, V() | 0, p & 7) {
          case 0:
          case 7:
            return p = 0, p | 0;
        }
        return p = h & -2130706433 | 134217728, !(!0 & (h & 2013265920 | 0) == 268435456) || !0 & (h & 117440512 | 0) == 16777216 & (xi(d, p) | 0) != 0 ? (p = 0, p | 0) : (p = Tx(d, p) | 0, p | 0);
      }
      function fB(d, h, p) {
        d = d | 0, h = h | 0, p = p | 0;
        var g = 0, x = 0, v = 0, w = 0;
        return x = q, q = q + 16 | 0, g = x, !0 & (h & 2013265920 | 0) == 268435456 ? (v = h & -2130706433 | 134217728, w = p, f[w >> 2] = d, f[w + 4 >> 2] = v, f[g >> 2] = 0, h = qe(d | 0, h | 0, 56) | 0, V() | 0, g = Zn(d, v, h & 7, g, p + 8 | 0) | 0, q = x, g | 0) : (g = 6, q = x, g | 0);
      }
      function AB(d, h, p) {
        d = d | 0, h = h | 0, p = p | 0;
        var g = 0, x = 0;
        return x = (xi(d, h) | 0) == 0, h = h & -2130706433, g = p, f[g >> 2] = x ? d : 0, f[g + 4 >> 2] = x ? h | 285212672 : 0, g = p + 8 | 0, f[g >> 2] = d, f[g + 4 >> 2] = h | 301989888, g = p + 16 | 0, f[g >> 2] = d, f[g + 4 >> 2] = h | 318767104, g = p + 24 | 0, f[g >> 2] = d, f[g + 4 >> 2] = h | 335544320, g = p + 32 | 0, f[g >> 2] = d, f[g + 4 >> 2] = h | 352321536, p = p + 40 | 0, f[p >> 2] = d, f[p + 4 >> 2] = h | 369098752, 0;
      }
      function Z0(d, h, p) {
        d = d | 0, h = h | 0, p = p | 0;
        var g = 0, x = 0, v = 0, w = 0;
        return w = q, q = q + 16 | 0, x = w, v = h & -2130706433 | 134217728, !0 & (h & 2013265920 | 0) == 268435456 ? (g = qe(d | 0, h | 0, 56) | 0, V() | 0, g = AF(d, v, g & 7) | 0, (g | 0) == -1 ? (f[p >> 2] = 0, v = 6, q = w, v | 0) : (hd(d, v, x) | 0 && Ve(27795, 26932, 282, 26947), h = qe(d | 0, h | 0, 52) | 0, V() | 0, h = h & 15, xi(d, v) | 0 ? bx(x, h, g, 2, p) : Sx(x, h, g, 2, p), v = 0, q = w, v | 0)) : (v = 6, q = w, v | 0);
      }
      function pB(d, h, p) {
        d = d | 0, h = h | 0, p = p | 0;
        var g = 0, x = 0;
        g = q, q = q + 16 | 0, x = g, mB(d, h, p, x), nB(x, p + 4 | 0), q = g;
      }
      function mB(d, h, p, g) {
        d = d | 0, h = h | 0, p = p | 0, g = g | 0;
        var x = 0, v = 0, w = 0, M = 0, P = 0;
        if (M = q, q = q + 16 | 0, P = M, gB(d, p, P), v = +ud(+(1 - +$[P >> 3] * 0.5)), v < 1e-16) {
          f[g >> 2] = 0, f[g + 4 >> 2] = 0, f[g + 8 >> 2] = 0, f[g + 12 >> 2] = 0, q = M;
          return;
        }
        if (P = f[p >> 2] | 0, x = +$[15920 + (P * 24 | 0) >> 3], x = +yA(x - +yA(+UB(15600 + (P << 4) | 0, d))), Do(h) | 0 ? w = +yA(x + -0.3334731722518321) : w = x, x = +ys(+v) * 2.618033988749896, (h | 0) > 0) {
          d = 0;
          do
            x = x * 2.6457513110645907, d = d + 1 | 0;
          while ((d | 0) != (h | 0));
        }
        v = +On(+w) * x, $[g >> 3] = v, w = +vn(+w) * x, $[g + 8 >> 3] = w, q = M;
      }
      function gB(d, h, p) {
        d = d | 0, h = h | 0, p = p | 0;
        var g = 0, x = 0, v = 0;
        if (v = q, q = q + 32 | 0, x = v, fF(d, x), f[h >> 2] = 0, $[p >> 3] = 5, g = +ar(16400, x), g < +$[p >> 3] && (f[h >> 2] = 0, $[p >> 3] = g), g = +ar(16424, x), g < +$[p >> 3] && (f[h >> 2] = 1, $[p >> 3] = g), g = +ar(16448, x), g < +$[p >> 3] && (f[h >> 2] = 2, $[p >> 3] = g), g = +ar(16472, x), g < +$[p >> 3] && (f[h >> 2] = 3, $[p >> 3] = g), g = +ar(16496, x), g < +$[p >> 3] && (f[h >> 2] = 4, $[p >> 3] = g), g = +ar(16520, x), g < +$[p >> 3] && (f[h >> 2] = 5, $[p >> 3] = g), g = +ar(16544, x), g < +$[p >> 3] && (f[h >> 2] = 6, $[p >> 3] = g), g = +ar(16568, x), g < +$[p >> 3] && (f[h >> 2] = 7, $[p >> 3] = g), g = +ar(16592, x), g < +$[p >> 3] && (f[h >> 2] = 8, $[p >> 3] = g), g = +ar(16616, x), g < +$[p >> 3] && (f[h >> 2] = 9, $[p >> 3] = g), g = +ar(16640, x), g < +$[p >> 3] && (f[h >> 2] = 10, $[p >> 3] = g), g = +ar(16664, x), g < +$[p >> 3] && (f[h >> 2] = 11, $[p >> 3] = g), g = +ar(16688, x), g < +$[p >> 3] && (f[h >> 2] = 12, $[p >> 3] = g), g = +ar(16712, x), g < +$[p >> 3] && (f[h >> 2] = 13, $[p >> 3] = g), g = +ar(16736, x), g < +$[p >> 3] && (f[h >> 2] = 14, $[p >> 3] = g), g = +ar(16760, x), g < +$[p >> 3] && (f[h >> 2] = 15, $[p >> 3] = g), g = +ar(16784, x), g < +$[p >> 3] && (f[h >> 2] = 16, $[p >> 3] = g), g = +ar(16808, x), g < +$[p >> 3] && (f[h >> 2] = 17, $[p >> 3] = g), g = +ar(16832, x), g < +$[p >> 3] && (f[h >> 2] = 18, $[p >> 3] = g), g = +ar(16856, x), !(g < +$[p >> 3])) {
          q = v;
          return;
        }
        f[h >> 2] = 19, $[p >> 3] = g, q = v;
      }
      function _A(d, h, p, g, x) {
        d = d | 0, h = h | 0, p = p | 0, g = g | 0, x = x | 0;
        var v = 0, w = 0, M = 0;
        if (v = +dF(d), v < 1e-16) {
          h = 15600 + (h << 4) | 0, f[x >> 2] = f[h >> 2], f[x + 4 >> 2] = f[h + 4 >> 2], f[x + 8 >> 2] = f[h + 8 >> 2], f[x + 12 >> 2] = f[h + 12 >> 2];
          return;
        }
        if (w = +ks(+ +$[d + 8 >> 3], + +$[d >> 3]), (p | 0) > 0) {
          d = 0;
          do
            v = v * 0.37796447300922725, d = d + 1 | 0;
          while ((d | 0) != (p | 0));
        }
        M = v * 0.3333333333333333, g ? (p = (Do(p) | 0) == 0, v = +mA(+((p ? M : M * 0.37796447300922725) * 0.381966011250105))) : (v = +mA(+(v * 0.381966011250105)), Do(p) | 0 && (w = +yA(w + 0.3334731722518321))), OB(15600 + (h << 4) | 0, +yA(+$[15920 + (h * 24 | 0) >> 3] - w), v, x);
      }
      function _B(d, h, p) {
        d = d | 0, h = h | 0, p = p | 0;
        var g = 0, x = 0;
        g = q, q = q + 16 | 0, x = g, dc(d + 4 | 0, x), _A(x, f[d >> 2] | 0, h, 0, p), q = g;
      }
      function bx(d, h, p, g, x) {
        d = d | 0, h = h | 0, p = p | 0, g = g | 0, x = x | 0;
        var v = 0, w = 0, M = 0, P = 0, I = 0, k = 0, Q = 0, re = 0, se = 0, ae = 0, Ae = 0, ye = 0, Re = 0, we = 0, be = 0, me = 0, nt = 0, qt = 0, Pt = 0, mn = 0, gn = 0, Pn = 0, an = 0, Ht = 0, et = 0, wn = 0, pi = 0, bn = 0;
        if (wn = q, q = q + 272 | 0, v = wn + 256 | 0, we = wn + 240 | 0, an = wn, Ht = wn + 224 | 0, et = wn + 208 | 0, be = wn + 176 | 0, me = wn + 160 | 0, nt = wn + 192 | 0, qt = wn + 144 | 0, Pt = wn + 128 | 0, mn = wn + 112 | 0, gn = wn + 96 | 0, Pn = wn + 80 | 0, f[v >> 2] = h, f[we >> 2] = f[d >> 2], f[we + 4 >> 2] = f[d + 4 >> 2], f[we + 8 >> 2] = f[d + 8 >> 2], f[we + 12 >> 2] = f[d + 12 >> 2], Uw(we, v, an), f[x >> 2] = 0, we = g + p + ((g | 0) == 5 & 1) | 0, (we | 0) <= (p | 0)) {
          q = wn;
          return;
        }
        P = f[v >> 2] | 0, I = Ht + 4 | 0, k = be + 4 | 0, Q = p + 5 | 0, re = 16880 + (P << 2) | 0, se = 16960 + (P << 2) | 0, ae = Pt + 8 | 0, Ae = mn + 8 | 0, ye = gn + 8 | 0, Re = et + 4 | 0, M = p;
        e: for (; ; ) {
          w = an + (((M | 0) % 5 | 0) << 4) | 0, f[et >> 2] = f[w >> 2], f[et + 4 >> 2] = f[w + 4 >> 2], f[et + 8 >> 2] = f[w + 8 >> 2], f[et + 12 >> 2] = f[w + 12 >> 2];
          do
            ;
          while ((cd(et, P, 0, 1) | 0) == 2);
          if ((M | 0) > (p | 0) & (Do(h) | 0) != 0) {
            if (f[be >> 2] = f[et >> 2], f[be + 4 >> 2] = f[et + 4 >> 2], f[be + 8 >> 2] = f[et + 8 >> 2], f[be + 12 >> 2] = f[et + 12 >> 2], dc(I, me), g = f[be >> 2] | 0, v = f[17040 + (g * 80 | 0) + (f[Ht >> 2] << 2) >> 2] | 0, f[be >> 2] = f[18640 + (g * 80 | 0) + (v * 20 | 0) >> 2], w = f[18640 + (g * 80 | 0) + (v * 20 | 0) + 16 >> 2] | 0, (w | 0) > 0) {
              d = 0;
              do
                Dw(k), d = d + 1 | 0;
              while ((d | 0) < (w | 0));
            }
            switch (w = 18640 + (g * 80 | 0) + (v * 20 | 0) + 4 | 0, f[nt >> 2] = f[w >> 2], f[nt + 4 >> 2] = f[w + 4 >> 2], f[nt + 8 >> 2] = f[w + 8 >> 2], Cw(nt, (f[re >> 2] | 0) * 3 | 0), vs(k, nt, k), rs(k), dc(k, qt), pi = +(f[se >> 2] | 0), $[Pt >> 3] = pi * 3, $[ae >> 3] = 0, bn = pi * -1.5, $[mn >> 3] = bn, $[Ae >> 3] = pi * 2.598076211353316, $[gn >> 3] = bn, $[ye >> 3] = pi * -2.598076211353316, f[17040 + ((f[be >> 2] | 0) * 80 | 0) + (f[et >> 2] << 2) >> 2] | 0) {
              case 1: {
                d = mn, g = Pt;
                break;
              }
              case 3: {
                d = gn, g = mn;
                break;
              }
              case 2: {
                d = Pt, g = gn;
                break;
              }
              default: {
                d = 12;
                break e;
              }
            }
            Jw(me, qt, g, d, Pn), _A(Pn, f[be >> 2] | 0, P, 1, x + 8 + (f[x >> 2] << 4) | 0), f[x >> 2] = (f[x >> 2] | 0) + 1;
          }
          if ((M | 0) < (Q | 0) && (dc(Re, be), _A(be, f[et >> 2] | 0, P, 1, x + 8 + (f[x >> 2] << 4) | 0), f[x >> 2] = (f[x >> 2] | 0) + 1), f[Ht >> 2] = f[et >> 2], f[Ht + 4 >> 2] = f[et + 4 >> 2], f[Ht + 8 >> 2] = f[et + 8 >> 2], f[Ht + 12 >> 2] = f[et + 12 >> 2], M = M + 1 | 0, (M | 0) >= (we | 0)) {
            d = 3;
            break;
          }
        }
        if ((d | 0) == 3) {
          q = wn;
          return;
        } else (d | 0) == 12 && Ve(26970, 27017, 572, 27027);
      }
      function Uw(d, h, p) {
        d = d | 0, h = h | 0, p = p | 0;
        var g = 0, x = 0, v = 0, w = 0, M = 0, P = 0;
        P = q, q = q + 128 | 0, g = P + 64 | 0, x = P, v = g, w = 20240, M = v + 60 | 0;
        do
          f[v >> 2] = f[w >> 2], v = v + 4 | 0, w = w + 4 | 0;
        while ((v | 0) < (M | 0));
        v = x, w = 20304, M = v + 60 | 0;
        do
          f[v >> 2] = f[w >> 2], v = v + 4 | 0, w = w + 4 | 0;
        while ((v | 0) < (M | 0));
        M = (Do(f[h >> 2] | 0) | 0) == 0, g = M ? g : x, x = d + 4 | 0, Lw(x), Iw(x), Do(f[h >> 2] | 0) | 0 && (fc(x), f[h >> 2] = (f[h >> 2] | 0) + 1), f[p >> 2] = f[d >> 2], h = p + 4 | 0, vs(x, g, h), rs(h), f[p + 16 >> 2] = f[d >> 2], h = p + 20 | 0, vs(x, g + 12 | 0, h), rs(h), f[p + 32 >> 2] = f[d >> 2], h = p + 36 | 0, vs(x, g + 24 | 0, h), rs(h), f[p + 48 >> 2] = f[d >> 2], h = p + 52 | 0, vs(x, g + 36 | 0, h), rs(h), f[p + 64 >> 2] = f[d >> 2], p = p + 68 | 0, vs(x, g + 48 | 0, p), rs(p), q = P;
      }
      function cd(d, h, p, g) {
        d = d | 0, h = h | 0, p = p | 0, g = g | 0;
        var x = 0, v = 0, w = 0, M = 0, P = 0, I = 0, k = 0, Q = 0, re = 0, se = 0, ae = 0;
        if (ae = q, q = q + 32 | 0, re = ae + 12 | 0, M = ae, se = d + 4 | 0, Q = f[16960 + (h << 2) >> 2] | 0, k = (g | 0) != 0, Q = k ? Q * 3 | 0 : Q, x = f[se >> 2] | 0, I = d + 8 | 0, w = f[I >> 2] | 0, k) {
          if (v = d + 12 | 0, g = f[v >> 2] | 0, x = w + x + g | 0, (x | 0) == (Q | 0))
            return se = 1, q = ae, se | 0;
          P = v;
        } else
          P = d + 12 | 0, g = f[P >> 2] | 0, x = w + x + g | 0;
        if ((x | 0) <= (Q | 0))
          return se = 0, q = ae, se | 0;
        do
          if ((g | 0) > 0) {
            if (g = f[d >> 2] | 0, (w | 0) > 0) {
              v = 18640 + (g * 80 | 0) + 60 | 0, g = d;
              break;
            }
            g = 18640 + (g * 80 | 0) + 40 | 0, p ? (tB(re, Q, 0, 0), yx(se, re, M), K0(M), vs(M, re, se), v = g, g = d) : (v = g, g = d);
          } else
            v = 18640 + ((f[d >> 2] | 0) * 80 | 0) + 20 | 0, g = d;
        while (!1);
        if (f[g >> 2] = f[v >> 2], x = v + 16 | 0, (f[x >> 2] | 0) > 0) {
          g = 0;
          do
            Dw(se), g = g + 1 | 0;
          while ((g | 0) < (f[x >> 2] | 0));
        }
        return d = v + 4 | 0, f[re >> 2] = f[d >> 2], f[re + 4 >> 2] = f[d + 4 >> 2], f[re + 8 >> 2] = f[d + 8 >> 2], h = f[16880 + (h << 2) >> 2] | 0, Cw(re, k ? h * 3 | 0 : h), vs(se, re, se), rs(se), k ? g = ((f[I >> 2] | 0) + (f[se >> 2] | 0) + (f[P >> 2] | 0) | 0) == (Q | 0) ? 1 : 2 : g = 2, se = g, q = ae, se | 0;
      }
      function xB(d, h) {
        d = d | 0, h = h | 0;
        var p = 0;
        do
          p = cd(d, h, 0, 1) | 0;
        while ((p | 0) == 2);
        return p | 0;
      }
      function Sx(d, h, p, g, x) {
        d = d | 0, h = h | 0, p = p | 0, g = g | 0, x = x | 0;
        var v = 0, w = 0, M = 0, P = 0, I = 0, k = 0, Q = 0, re = 0, se = 0, ae = 0, Ae = 0, ye = 0, Re = 0, we = 0, be = 0, me = 0, nt = 0, qt = 0, Pt = 0, mn = 0, gn = 0, Pn = 0, an = 0;
        if (gn = q, q = q + 240 | 0, v = gn + 224 | 0, nt = gn + 208 | 0, qt = gn, Pt = gn + 192 | 0, mn = gn + 176 | 0, ye = gn + 160 | 0, Re = gn + 144 | 0, we = gn + 128 | 0, be = gn + 112 | 0, me = gn + 96 | 0, f[v >> 2] = h, f[nt >> 2] = f[d >> 2], f[nt + 4 >> 2] = f[d + 4 >> 2], f[nt + 8 >> 2] = f[d + 8 >> 2], f[nt + 12 >> 2] = f[d + 12 >> 2], Ow(nt, v, qt), f[x >> 2] = 0, Ae = g + p + ((g | 0) == 6 & 1) | 0, (Ae | 0) <= (p | 0)) {
          q = gn;
          return;
        }
        P = f[v >> 2] | 0, I = p + 6 | 0, k = 16960 + (P << 2) | 0, Q = Re + 8 | 0, re = we + 8 | 0, se = be + 8 | 0, ae = Pt + 4 | 0, w = 0, M = p, g = -1;
        e: for (; ; ) {
          if (v = (M | 0) % 6 | 0, d = qt + (v << 4) | 0, f[Pt >> 2] = f[d >> 2], f[Pt + 4 >> 2] = f[d + 4 >> 2], f[Pt + 8 >> 2] = f[d + 8 >> 2], f[Pt + 12 >> 2] = f[d + 12 >> 2], d = w, w = cd(Pt, P, 0, 1) | 0, (M | 0) > (p | 0) & (Do(h) | 0) != 0 && (d | 0) != 1 && (f[Pt >> 2] | 0) != (g | 0)) {
            switch (dc(qt + (((v + 5 | 0) % 6 | 0) << 4) + 4 | 0, mn), dc(qt + (v << 4) + 4 | 0, ye), Pn = +(f[k >> 2] | 0), $[Re >> 3] = Pn * 3, $[Q >> 3] = 0, an = Pn * -1.5, $[we >> 3] = an, $[re >> 3] = Pn * 2.598076211353316, $[be >> 3] = an, $[se >> 3] = Pn * -2.598076211353316, v = f[nt >> 2] | 0, f[17040 + (v * 80 | 0) + (((g | 0) == (v | 0) ? f[Pt >> 2] | 0 : g) << 2) >> 2] | 0) {
              case 1: {
                d = we, g = Re;
                break;
              }
              case 3: {
                d = be, g = we;
                break;
              }
              case 2: {
                d = Re, g = be;
                break;
              }
              default: {
                d = 8;
                break e;
              }
            }
            Jw(mn, ye, g, d, me), !(eM(mn, me) | 0) && !(eM(ye, me) | 0) && (_A(me, f[nt >> 2] | 0, P, 1, x + 8 + (f[x >> 2] << 4) | 0), f[x >> 2] = (f[x >> 2] | 0) + 1);
          }
          if ((M | 0) < (I | 0) && (dc(ae, mn), _A(mn, f[Pt >> 2] | 0, P, 1, x + 8 + (f[x >> 2] << 4) | 0), f[x >> 2] = (f[x >> 2] | 0) + 1), M = M + 1 | 0, (M | 0) >= (Ae | 0)) {
            d = 3;
            break;
          } else
            g = f[Pt >> 2] | 0;
        }
        if ((d | 0) == 3) {
          q = gn;
          return;
        } else (d | 0) == 8 && Ve(27054, 27017, 737, 27099);
      }
      function Ow(d, h, p) {
        d = d | 0, h = h | 0, p = p | 0;
        var g = 0, x = 0, v = 0, w = 0, M = 0, P = 0;
        P = q, q = q + 160 | 0, g = P + 80 | 0, x = P, v = g, w = 20368, M = v + 72 | 0;
        do
          f[v >> 2] = f[w >> 2], v = v + 4 | 0, w = w + 4 | 0;
        while ((v | 0) < (M | 0));
        v = x, w = 20448, M = v + 72 | 0;
        do
          f[v >> 2] = f[w >> 2], v = v + 4 | 0, w = w + 4 | 0;
        while ((v | 0) < (M | 0));
        M = (Do(f[h >> 2] | 0) | 0) == 0, g = M ? g : x, x = d + 4 | 0, Lw(x), Iw(x), Do(f[h >> 2] | 0) | 0 && (fc(x), f[h >> 2] = (f[h >> 2] | 0) + 1), f[p >> 2] = f[d >> 2], h = p + 4 | 0, vs(x, g, h), rs(h), f[p + 16 >> 2] = f[d >> 2], h = p + 20 | 0, vs(x, g + 12 | 0, h), rs(h), f[p + 32 >> 2] = f[d >> 2], h = p + 36 | 0, vs(x, g + 24 | 0, h), rs(h), f[p + 48 >> 2] = f[d >> 2], h = p + 52 | 0, vs(x, g + 36 | 0, h), rs(h), f[p + 64 >> 2] = f[d >> 2], h = p + 68 | 0, vs(x, g + 48 | 0, h), rs(h), f[p + 80 >> 2] = f[d >> 2], p = p + 84 | 0, vs(x, g + 60 | 0, p), rs(p), q = P;
      }
      function yB(d, h) {
        return d = d | 0, h = h | 0, h = qe(d | 0, h | 0, 52) | 0, V() | 0, h & 15 | 0;
      }
      function kw(d, h) {
        return d = d | 0, h = h | 0, h = qe(d | 0, h | 0, 45) | 0, V() | 0, h & 127 | 0;
      }
      function vB(d, h, p, g) {
        return d = d | 0, h = h | 0, p = p | 0, g = g | 0, (p + -1 | 0) >>> 0 > 14 ? (g = 4, g | 0) : (p = qe(d | 0, h | 0, (15 - p | 0) * 3 | 0) | 0, V() | 0, f[g >> 2] = p & 7, g = 0, g | 0);
      }
      function bB(d, h, p, g) {
        d = d | 0, h = h | 0, p = p | 0, g = g | 0;
        var x = 0, v = 0, w = 0, M = 0, P = 0, I = 0;
        if (d >>> 0 > 15)
          return g = 4, g | 0;
        if (h >>> 0 > 121)
          return g = 17, g | 0;
        w = Ze(d | 0, 0, 52) | 0, x = V() | 0, M = Ze(h | 0, 0, 45) | 0, x = x | (V() | 0) | 134225919;
        e: do
          if ((d | 0) >= 1) {
            for (M = 1, w = ($e[20528 + h >> 0] | 0) != 0, v = -1; ; ) {
              if (h = f[p + (M + -1 << 2) >> 2] | 0, h >>> 0 > 6) {
                x = 18, h = 10;
                break;
              }
              if (!((h | 0) == 0 | w ^ 1))
                if ((h | 0) == 1) {
                  x = 19, h = 10;
                  break;
                } else
                  w = 0;
              if (I = (15 - M | 0) * 3 | 0, P = Ze(7, 0, I | 0) | 0, x = x & ~(V() | 0), h = Ze(h | 0, ((h | 0) < 0) << 31 >> 31 | 0, I | 0) | 0, v = h | v & ~P, x = V() | 0 | x, (M | 0) < (d | 0))
                M = M + 1 | 0;
              else
                break e;
            }
            if ((h | 0) == 10)
              return x | 0;
          } else
            v = -1;
        while (!1);
        return I = g, f[I >> 2] = v, f[I + 4 >> 2] = x, I = 0, I | 0;
      }
      function Tx(d, h) {
        d = d | 0, h = h | 0;
        var p = 0, g = 0, x = 0, v = 0, w = 0;
        return !(!0 & (h & -16777216 | 0) == 134217728) || (g = qe(d | 0, h | 0, 52) | 0, V() | 0, g = g & 15, p = qe(d | 0, h | 0, 45) | 0, V() | 0, p = p & 127, p >>> 0 > 121) ? (d = 0, d | 0) : (w = (g ^ 15) * 3 | 0, x = qe(d | 0, h | 0, w | 0) | 0, w = Ze(x | 0, V() | 0, w | 0) | 0, x = V() | 0, v = wr(-1227133514, -1171, w | 0, x | 0) | 0, !((w & 613566756 & v | 0) == 0 & (x & 4681 & (V() | 0) | 0) == 0) || (w = (g * 3 | 0) + 19 | 0, v = Ze(~d | 0, ~h | 0, w | 0) | 0, w = qe(v | 0, V() | 0, w | 0) | 0, !((g | 0) == 15 | (w | 0) == 0 & (V() | 0) == 0)) ? (w = 0, w | 0) : !($e[20528 + p >> 0] | 0) || (h = h & 8191, (d | 0) == 0 & (h | 0) == 0) ? (w = 1, w | 0) : (w = kx(d | 0, h | 0) | 0, V() | 0, ((63 - w | 0) % 3 | 0 | 0) != 0 | 0));
      }
      function SB(d, h) {
        d = d | 0, h = h | 0;
        var p = 0, g = 0, x = 0, v = 0, w = 0;
        return !0 & (h & -16777216 | 0) == 134217728 && (g = qe(d | 0, h | 0, 52) | 0, V() | 0, g = g & 15, p = qe(d | 0, h | 0, 45) | 0, V() | 0, p = p & 127, p >>> 0 <= 121) && (w = (g ^ 15) * 3 | 0, x = qe(d | 0, h | 0, w | 0) | 0, w = Ze(x | 0, V() | 0, w | 0) | 0, x = V() | 0, v = wr(-1227133514, -1171, w | 0, x | 0) | 0, (w & 613566756 & v | 0) == 0 & (x & 4681 & (V() | 0) | 0) == 0) && (w = (g * 3 | 0) + 19 | 0, v = Ze(~d | 0, ~h | 0, w | 0) | 0, w = qe(v | 0, V() | 0, w | 0) | 0, (g | 0) == 15 | (w | 0) == 0 & (V() | 0) == 0) && (!($e[20528 + p >> 0] | 0) || (p = h & 8191, (d | 0) == 0 & (p | 0) == 0) || (w = kx(d | 0, p | 0) | 0, V() | 0, (63 - w | 0) % 3 | 0 | 0)) || Fw(d, h) | 0 ? (w = 1, w | 0) : (w = (tM(d, h) | 0) != 0 & 1, w | 0);
      }
      function wx(d, h, p, g) {
        d = d | 0, h = h | 0, p = p | 0, g = g | 0;
        var x = 0, v = 0, w = 0, M = 0;
        if (x = Ze(h | 0, 0, 52) | 0, v = V() | 0, p = Ze(p | 0, 0, 45) | 0, p = v | (V() | 0) | 134225919, (h | 0) < 1) {
          v = -1, g = p, h = d, f[h >> 2] = v, d = d + 4 | 0, f[d >> 2] = g;
          return;
        }
        for (v = 1, x = -1; w = (15 - v | 0) * 3 | 0, M = Ze(7, 0, w | 0) | 0, p = p & ~(V() | 0), w = Ze(g | 0, 0, w | 0) | 0, x = x & ~M | w, p = p | (V() | 0), (v | 0) != (h | 0); )
          v = v + 1 | 0;
        M = d, w = M, f[w >> 2] = x, M = M + 4 | 0, f[M >> 2] = p;
      }
      function Mx(d, h, p, g) {
        d = d | 0, h = h | 0, p = p | 0, g = g | 0;
        var x = 0, v = 0;
        if (v = qe(d | 0, h | 0, 52) | 0, V() | 0, v = v & 15, p >>> 0 > 15)
          return g = 4, g | 0;
        if ((v | 0) < (p | 0))
          return g = 12, g | 0;
        if ((v | 0) == (p | 0))
          return f[g >> 2] = d, f[g + 4 >> 2] = h, g = 0, g | 0;
        if (x = Ze(p | 0, 0, 52) | 0, x = x | d, d = V() | 0 | h & -15728641, (v | 0) > (p | 0))
          do
            h = Ze(7, 0, (14 - p | 0) * 3 | 0) | 0, p = p + 1 | 0, x = h | x, d = V() | 0 | d;
          while ((p | 0) < (v | 0));
        return f[g >> 2] = x, f[g + 4 >> 2] = d, g = 0, g | 0;
      }
      function xA(d, h, p, g) {
        d = d | 0, h = h | 0, p = p | 0, g = g | 0;
        var x = 0, v = 0, w = 0;
        if (v = qe(d | 0, h | 0, 52) | 0, V() | 0, v = v & 15, !((p | 0) < 16 & (v | 0) <= (p | 0)))
          return g = 4, g | 0;
        x = p - v | 0, p = qe(d | 0, h | 0, 45) | 0, V() | 0;
        e: do
          if (!(Ni(p & 127) | 0))
            p = ru(7, 0, x, ((x | 0) < 0) << 31 >> 31) | 0, x = V() | 0;
          else {
            t: do
              if (v | 0) {
                for (p = 1; w = Ze(7, 0, (15 - p | 0) * 3 | 0) | 0, !!((w & d | 0) == 0 & ((V() | 0) & h | 0) == 0); )
                  if (p >>> 0 < v >>> 0)
                    p = p + 1 | 0;
                  else
                    break t;
                p = ru(7, 0, x, ((x | 0) < 0) << 31 >> 31) | 0, x = V() | 0;
                break e;
              }
            while (!1);
            p = ru(7, 0, x, ((x | 0) < 0) << 31 >> 31) | 0, p = Mr(p | 0, V() | 0, 5, 0) | 0, p = jt(p | 0, V() | 0, -5, -1) | 0, p = ou(p | 0, V() | 0, 6, 0) | 0, p = jt(p | 0, V() | 0, 1, 0) | 0, x = V() | 0;
          }
        while (!1);
        return w = g, f[w >> 2] = p, f[w + 4 >> 2] = x, w = 0, w | 0;
      }
      function xi(d, h) {
        d = d | 0, h = h | 0;
        var p = 0, g = 0, x = 0;
        if (x = qe(d | 0, h | 0, 45) | 0, V() | 0, !(Ni(x & 127) | 0))
          return x = 0, x | 0;
        x = qe(d | 0, h | 0, 52) | 0, V() | 0, x = x & 15;
        e: do
          if (!x)
            p = 0;
          else
            for (g = 1; ; ) {
              if (p = qe(d | 0, h | 0, (15 - g | 0) * 3 | 0) | 0, V() | 0, p = p & 7, p | 0)
                break e;
              if (g >>> 0 < x >>> 0)
                g = g + 1 | 0;
              else {
                p = 0;
                break;
              }
            }
        while (!1);
        return x = (p | 0) == 0 & 1, x | 0;
      }
      function TB(d, h, p, g) {
        d = d | 0, h = h | 0, p = p | 0, g = g | 0;
        var x = 0, v = 0, w = 0, M = 0;
        if (w = q, q = q + 16 | 0, v = w, Dx(v, d, h, p), h = v, d = f[h >> 2] | 0, h = f[h + 4 >> 2] | 0, (d | 0) == 0 & (h | 0) == 0)
          return q = w, 0;
        x = 0, p = 0;
        do
          M = g + (x << 3) | 0, f[M >> 2] = d, f[M + 4 >> 2] = h, x = jt(x | 0, p | 0, 1, 0) | 0, p = V() | 0, Lx(v), M = v, d = f[M >> 2] | 0, h = f[M + 4 >> 2] | 0;
        while (!((d | 0) == 0 & (h | 0) == 0));
        return q = w, 0;
      }
      function Vw(d, h, p, g) {
        return d = d | 0, h = h | 0, p = p | 0, g = g | 0, (g | 0) < (p | 0) ? (p = h, g = d, xe(p | 0), g | 0) : (p = Ze(-1, -1, ((g - p | 0) * 3 | 0) + 3 | 0) | 0, g = Ze(~p | 0, ~(V() | 0) | 0, (15 - g | 0) * 3 | 0) | 0, p = ~(V() | 0) & h, g = ~g & d, xe(p | 0), g | 0);
      }
      function Gw(d, h, p, g) {
        d = d | 0, h = h | 0, p = p | 0, g = g | 0;
        var x = 0;
        return x = qe(d | 0, h | 0, 52) | 0, V() | 0, x = x & 15, (p | 0) < 16 & (x | 0) <= (p | 0) ? ((x | 0) < (p | 0) && (x = Ze(-1, -1, ((p + -1 - x | 0) * 3 | 0) + 3 | 0) | 0, x = Ze(~x | 0, ~(V() | 0) | 0, (15 - p | 0) * 3 | 0) | 0, h = ~(V() | 0) & h, d = ~x & d), x = Ze(p | 0, 0, 52) | 0, p = h & -15728641 | (V() | 0), f[g >> 2] = d | x, f[g + 4 >> 2] = p, g = 0, g | 0) : (g = 4, g | 0);
      }
      function wB(d, h, p, g) {
        d = d | 0, h = h | 0, p = p | 0, g = g | 0;
        var x = 0, v = 0, w = 0, M = 0, P = 0, I = 0, k = 0, Q = 0, re = 0, se = 0, ae = 0, Ae = 0, ye = 0, Re = 0, we = 0, be = 0, me = 0, nt = 0, qt = 0, Pt = 0, mn = 0, gn = 0, Pn = 0, an = 0, Ht = 0, et = 0;
        if ((p | 0) == 0 & (g | 0) == 0)
          return et = 0, et | 0;
        if (x = d, v = f[x >> 2] | 0, x = f[x + 4 >> 2] | 0, !0 & (x & 15728640 | 0) == 0) {
          if (!((g | 0) > 0 | (g | 0) == 0 & p >>> 0 > 0) || (et = h, f[et >> 2] = v, f[et + 4 >> 2] = x, (p | 0) == 1 & (g | 0) == 0))
            return et = 0, et | 0;
          x = 1, v = 0;
          do
            an = d + (x << 3) | 0, Ht = f[an + 4 >> 2] | 0, et = h + (x << 3) | 0, f[et >> 2] = f[an >> 2], f[et + 4 >> 2] = Ht, x = jt(x | 0, v | 0, 1, 0) | 0, v = V() | 0;
          while ((v | 0) < (g | 0) | (v | 0) == (g | 0) & x >>> 0 < p >>> 0);
          return x = 0, x | 0;
        }
        if (Pn = p << 3, Ht = Ra(Pn) | 0, !Ht)
          return et = 13, et | 0;
        if (md(Ht | 0, d | 0, Pn | 0) | 0, an = Gs(p, 8) | 0, !an)
          return Qt(Ht), et = 13, et | 0;
        e: for (; ; ) {
          x = Ht, I = f[x >> 2] | 0, x = f[x + 4 >> 2] | 0, mn = qe(I | 0, x | 0, 52) | 0, V() | 0, mn = mn & 15, gn = mn + -1 | 0, Pt = (mn | 0) != 0, qt = (g | 0) > 0 | (g | 0) == 0 & p >>> 0 > 0;
          t: do
            if (Pt & qt) {
              if (we = Ze(gn | 0, 0, 52) | 0, be = V() | 0, gn >>> 0 > 15) {
                if (!((I | 0) == 0 & (x | 0) == 0)) {
                  et = 16;
                  break e;
                }
                for (v = 0, d = 0; ; ) {
                  if (v = jt(v | 0, d | 0, 1, 0) | 0, d = V() | 0, !((d | 0) < (g | 0) | (d | 0) == (g | 0) & v >>> 0 < p >>> 0))
                    break t;
                  if (w = Ht + (v << 3) | 0, nt = f[w >> 2] | 0, w = f[w + 4 >> 2] | 0, !((nt | 0) == 0 & (w | 0) == 0)) {
                    x = w, et = 16;
                    break e;
                  }
                }
              }
              for (M = I, d = x, v = 0, w = 0; ; ) {
                if (!((M | 0) == 0 & (d | 0) == 0)) {
                  if (!(!0 & (d & 117440512 | 0) == 0)) {
                    et = 21;
                    break e;
                  }
                  if (k = qe(M | 0, d | 0, 52) | 0, V() | 0, k = k & 15, (k | 0) < (gn | 0)) {
                    x = 12, et = 27;
                    break e;
                  }
                  if ((k | 0) != (gn | 0) && (M = M | we, d = d & -15728641 | be, k >>> 0 >= mn >>> 0)) {
                    P = gn;
                    do
                      nt = Ze(7, 0, (14 - P | 0) * 3 | 0) | 0, P = P + 1 | 0, M = nt | M, d = V() | 0 | d;
                    while (P >>> 0 < k >>> 0);
                  }
                  if (re = pd(M | 0, d | 0, p | 0, g | 0) | 0, se = V() | 0, P = an + (re << 3) | 0, k = P, Q = f[k >> 2] | 0, k = f[k + 4 >> 2] | 0, !((Q | 0) == 0 & (k | 0) == 0)) {
                    ye = 0, Re = 0;
                    do {
                      if ((ye | 0) > (g | 0) | (ye | 0) == (g | 0) & Re >>> 0 > p >>> 0) {
                        et = 31;
                        break e;
                      }
                      if ((Q | 0) == (M | 0) & (k & -117440513 | 0) == (d | 0)) {
                        ae = qe(Q | 0, k | 0, 56) | 0, V() | 0, ae = ae & 7, Ae = ae + 1 | 0, nt = qe(Q | 0, k | 0, 45) | 0, V() | 0;
                        n: do
                          if (!(Ni(nt & 127) | 0))
                            k = 7;
                          else {
                            if (Q = qe(Q | 0, k | 0, 52) | 0, V() | 0, Q = Q & 15, !Q) {
                              k = 6;
                              break;
                            }
                            for (k = 1; ; ) {
                              if (nt = Ze(7, 0, (15 - k | 0) * 3 | 0) | 0, !((nt & M | 0) == 0 & ((V() | 0) & d | 0) == 0)) {
                                k = 7;
                                break n;
                              }
                              if (k >>> 0 < Q >>> 0)
                                k = k + 1 | 0;
                              else {
                                k = 6;
                                break;
                              }
                            }
                          }
                        while (!1);
                        if ((ae + 2 | 0) >>> 0 > k >>> 0) {
                          et = 41;
                          break e;
                        }
                        nt = Ze(Ae | 0, 0, 56) | 0, d = V() | 0 | d & -117440513, me = P, f[me >> 2] = 0, f[me + 4 >> 2] = 0, M = nt | M;
                      } else
                        re = jt(re | 0, se | 0, 1, 0) | 0, re = Ad(re | 0, V() | 0, p | 0, g | 0) | 0, se = V() | 0;
                      Re = jt(Re | 0, ye | 0, 1, 0) | 0, ye = V() | 0, P = an + (re << 3) | 0, k = P, Q = f[k >> 2] | 0, k = f[k + 4 >> 2] | 0;
                    } while (!((Q | 0) == 0 & (k | 0) == 0));
                  }
                  nt = P, f[nt >> 2] = M, f[nt + 4 >> 2] = d;
                }
                if (v = jt(v | 0, w | 0, 1, 0) | 0, w = V() | 0, !((w | 0) < (g | 0) | (w | 0) == (g | 0) & v >>> 0 < p >>> 0))
                  break t;
                d = Ht + (v << 3) | 0, M = f[d >> 2] | 0, d = f[d + 4 >> 2] | 0;
              }
            }
          while (!1);
          if (nt = jt(p | 0, g | 0, 5, 0) | 0, me = V() | 0, me >>> 0 < 0 | (me | 0) == 0 & nt >>> 0 < 11) {
            et = 85;
            break;
          }
          if (nt = ou(p | 0, g | 0, 6, 0) | 0, V() | 0, nt = Gs(nt, 8) | 0, !nt) {
            et = 48;
            break;
          }
          do
            if (qt) {
              for (Ae = 0, d = 0, ae = 0, ye = 0; ; ) {
                if (k = an + (Ae << 3) | 0, w = k, v = f[w >> 2] | 0, w = f[w + 4 >> 2] | 0, (v | 0) == 0 & (w | 0) == 0)
                  me = ae;
                else {
                  Q = qe(v | 0, w | 0, 56) | 0, V() | 0, Q = Q & 7, M = Q + 1 | 0, re = w & -117440513, me = qe(v | 0, w | 0, 45) | 0, V() | 0;
                  t: do
                    if (Ni(me & 127) | 0) {
                      if (se = qe(v | 0, w | 0, 52) | 0, V() | 0, se = se & 15, se | 0)
                        for (P = 1; ; ) {
                          if (me = Ze(7, 0, (15 - P | 0) * 3 | 0) | 0, !((v & me | 0) == 0 & (re & (V() | 0) | 0) == 0))
                            break t;
                          if (P >>> 0 < se >>> 0)
                            P = P + 1 | 0;
                          else
                            break;
                        }
                      w = Ze(M | 0, 0, 56) | 0, v = w | v, w = V() | 0 | re, M = k, f[M >> 2] = v, f[M + 4 >> 2] = w, M = Q + 2 | 0;
                    }
                  while (!1);
                  (M | 0) == 7 ? (me = nt + (d << 3) | 0, f[me >> 2] = v, f[me + 4 >> 2] = w & -117440513, d = jt(d | 0, ae | 0, 1, 0) | 0, me = V() | 0) : me = ae;
                }
                if (Ae = jt(Ae | 0, ye | 0, 1, 0) | 0, ye = V() | 0, (ye | 0) < (g | 0) | (ye | 0) == (g | 0) & Ae >>> 0 < p >>> 0)
                  ae = me;
                else
                  break;
              }
              if (qt) {
                if (Re = gn >>> 0 > 15, we = Ze(gn | 0, 0, 52) | 0, be = V() | 0, !Pt) {
                  for (v = 0, P = 0, M = 0, w = 0; (I | 0) == 0 & (x | 0) == 0 || (gn = h + (v << 3) | 0, f[gn >> 2] = I, f[gn + 4 >> 2] = x, v = jt(v | 0, P | 0, 1, 0) | 0, P = V() | 0), M = jt(M | 0, w | 0, 1, 0) | 0, w = V() | 0, !!((w | 0) < (g | 0) | (w | 0) == (g | 0) & M >>> 0 < p >>> 0); )
                    x = Ht + (M << 3) | 0, I = f[x >> 2] | 0, x = f[x + 4 >> 2] | 0;
                  x = me;
                  break;
                }
                for (v = 0, P = 0, w = 0, M = 0; ; ) {
                  do
                    if (!((I | 0) == 0 & (x | 0) == 0)) {
                      if (se = qe(I | 0, x | 0, 52) | 0, V() | 0, se = se & 15, Re | (se | 0) < (gn | 0)) {
                        et = 80;
                        break e;
                      }
                      if ((se | 0) != (gn | 0)) {
                        if (k = I | we, Q = x & -15728641 | be, se >>> 0 >= mn >>> 0) {
                          re = gn;
                          do
                            Pt = Ze(7, 0, (14 - re | 0) * 3 | 0) | 0, re = re + 1 | 0, k = Pt | k, Q = V() | 0 | Q;
                          while (re >>> 0 < se >>> 0);
                        }
                      } else
                        k = I, Q = x;
                      ae = pd(k | 0, Q | 0, p | 0, g | 0) | 0, re = 0, se = 0, ye = V() | 0;
                      do {
                        if ((re | 0) > (g | 0) | (re | 0) == (g | 0) & se >>> 0 > p >>> 0) {
                          et = 81;
                          break e;
                        }
                        if (Pt = an + (ae << 3) | 0, Ae = f[Pt + 4 >> 2] | 0, (Ae & -117440513 | 0) == (Q | 0) && (f[Pt >> 2] | 0) == (k | 0)) {
                          et = 65;
                          break;
                        }
                        Pt = jt(ae | 0, ye | 0, 1, 0) | 0, ae = Ad(Pt | 0, V() | 0, p | 0, g | 0) | 0, ye = V() | 0, se = jt(se | 0, re | 0, 1, 0) | 0, re = V() | 0, Pt = an + (ae << 3) | 0;
                      } while (!((f[Pt >> 2] | 0) == (k | 0) && (f[Pt + 4 >> 2] | 0) == (Q | 0)));
                      if ((et | 0) == 65 && (et = 0, !0 & (Ae & 117440512 | 0) == 100663296))
                        break;
                      Pt = h + (v << 3) | 0, f[Pt >> 2] = I, f[Pt + 4 >> 2] = x, v = jt(v | 0, P | 0, 1, 0) | 0, P = V() | 0;
                    }
                  while (!1);
                  if (w = jt(w | 0, M | 0, 1, 0) | 0, M = V() | 0, !((M | 0) < (g | 0) | (M | 0) == (g | 0) & w >>> 0 < p >>> 0))
                    break;
                  x = Ht + (w << 3) | 0, I = f[x >> 2] | 0, x = f[x + 4 >> 2] | 0;
                }
                x = me;
              } else
                v = 0, x = me;
            } else
              v = 0, d = 0, x = 0;
          while (!1);
          if (au(an | 0, 0, Pn | 0) | 0, md(Ht | 0, nt | 0, d << 3 | 0) | 0, Qt(nt), (d | 0) == 0 & (x | 0) == 0) {
            et = 89;
            break;
          } else
            h = h + (v << 3) | 0, g = x, p = d;
        }
        if ((et | 0) == 16)
          !0 & (x & 117440512 | 0) == 0 ? (x = 4, et = 27) : et = 21;
        else if ((et | 0) == 31)
          Ve(27795, 27122, 620, 27132);
        else {
          if ((et | 0) == 41)
            return Qt(Ht), Qt(an), et = 10, et | 0;
          if ((et | 0) == 48)
            return Qt(Ht), Qt(an), et = 13, et | 0;
          (et | 0) == 80 ? Ve(27795, 27122, 711, 27132) : (et | 0) == 81 ? Ve(27795, 27122, 723, 27132) : (et | 0) == 85 && (md(h | 0, Ht | 0, p << 3 | 0) | 0, et = 89);
        }
        return (et | 0) == 21 ? (Qt(Ht), Qt(an), et = 5, et | 0) : (et | 0) == 27 ? (Qt(Ht), Qt(an), et = x, et | 0) : (et | 0) == 89 ? (Qt(Ht), Qt(an), et = 0, et | 0) : 0;
      }
      function MB(d, h, p, g, x, v, w) {
        d = d | 0, h = h | 0, p = p | 0, g = g | 0, x = x | 0, v = v | 0, w = w | 0;
        var M = 0, P = 0, I = 0, k = 0, Q = 0, re = 0, se = 0, ae = 0, Ae = 0;
        if (Ae = q, q = q + 16 | 0, ae = Ae, !((p | 0) > 0 | (p | 0) == 0 & h >>> 0 > 0))
          return ae = 0, q = Ae, ae | 0;
        if ((w | 0) >= 16)
          return ae = 12, q = Ae, ae | 0;
        re = 0, se = 0, Q = 0, M = 0;
        e: for (; ; ) {
          if (I = d + (re << 3) | 0, P = f[I >> 2] | 0, I = f[I + 4 >> 2] | 0, k = qe(P | 0, I | 0, 52) | 0, V() | 0, (k & 15 | 0) > (w | 0)) {
            M = 12, P = 11;
            break;
          }
          if (Dx(ae, P, I, w), k = ae, I = f[k >> 2] | 0, k = f[k + 4 >> 2] | 0, (I | 0) == 0 & (k | 0) == 0)
            P = Q;
          else {
            P = Q;
            do {
              if (!((M | 0) < (v | 0) | (M | 0) == (v | 0) & P >>> 0 < x >>> 0)) {
                P = 10;
                break e;
              }
              Q = g + (P << 3) | 0, f[Q >> 2] = I, f[Q + 4 >> 2] = k, P = jt(P | 0, M | 0, 1, 0) | 0, M = V() | 0, Lx(ae), Q = ae, I = f[Q >> 2] | 0, k = f[Q + 4 >> 2] | 0;
            } while (!((I | 0) == 0 & (k | 0) == 0));
          }
          if (re = jt(re | 0, se | 0, 1, 0) | 0, se = V() | 0, (se | 0) < (p | 0) | (se | 0) == (p | 0) & re >>> 0 < h >>> 0)
            Q = P;
          else {
            M = 0, P = 11;
            break;
          }
        }
        return (P | 0) == 10 ? (ae = 14, q = Ae, ae | 0) : (P | 0) == 11 ? (q = Ae, M | 0) : 0;
      }
      function EB(d, h, p, g, x) {
        d = d | 0, h = h | 0, p = p | 0, g = g | 0, x = x | 0;
        var v = 0, w = 0, M = 0, P = 0, I = 0, k = 0, Q = 0, re = 0;
        re = q, q = q + 16 | 0, Q = re;
        e: do
          if ((p | 0) > 0 | (p | 0) == 0 & h >>> 0 > 0) {
            for (I = 0, w = 0, v = 0, k = 0; ; ) {
              if (P = d + (I << 3) | 0, M = f[P >> 2] | 0, P = f[P + 4 >> 2] | 0, !((M | 0) == 0 & (P | 0) == 0) && (P = (xA(M, P, g, Q) | 0) == 0, M = Q, w = jt(f[M >> 2] | 0, f[M + 4 >> 2] | 0, w | 0, v | 0) | 0, v = V() | 0, !P)) {
                v = 12;
                break;
              }
              if (I = jt(I | 0, k | 0, 1, 0) | 0, k = V() | 0, !((k | 0) < (p | 0) | (k | 0) == (p | 0) & I >>> 0 < h >>> 0))
                break e;
            }
            return q = re, v | 0;
          } else
            w = 0, v = 0;
        while (!1);
        return f[x >> 2] = w, f[x + 4 >> 2] = v, x = 0, q = re, x | 0;
      }
      function RB(d, h) {
        return d = d | 0, h = h | 0, h = qe(d | 0, h | 0, 52) | 0, V() | 0, h & 1 | 0;
      }
      function Vs(d, h) {
        d = d | 0, h = h | 0;
        var p = 0, g = 0, x = 0;
        if (x = qe(d | 0, h | 0, 52) | 0, V() | 0, x = x & 15, !x)
          return x = 0, x | 0;
        for (g = 1; ; ) {
          if (p = qe(d | 0, h | 0, (15 - g | 0) * 3 | 0) | 0, V() | 0, p = p & 7, p | 0) {
            g = 5;
            break;
          }
          if (g >>> 0 < x >>> 0)
            g = g + 1 | 0;
          else {
            p = 0, g = 5;
            break;
          }
        }
        return (g | 0) == 5 ? p | 0 : 0;
      }
      function Ex(d, h) {
        d = d | 0, h = h | 0;
        var p = 0, g = 0, x = 0, v = 0, w = 0, M = 0, P = 0;
        if (P = qe(d | 0, h | 0, 52) | 0, V() | 0, P = P & 15, !P)
          return M = h, P = d, xe(M | 0), P | 0;
        for (M = 1, p = 0; ; ) {
          v = (15 - M | 0) * 3 | 0, g = Ze(7, 0, v | 0) | 0, x = V() | 0, w = qe(d | 0, h | 0, v | 0) | 0, V() | 0, v = Ze(Ac(w & 7) | 0, 0, v | 0) | 0, w = V() | 0, d = v | d & ~g, h = w | h & ~x;
          e: do
            if (!p)
              if ((v & g | 0) == 0 & (w & x | 0) == 0)
                p = 0;
              else if (g = qe(d | 0, h | 0, 52) | 0, V() | 0, g = g & 15, !g)
                p = 1;
              else {
                p = 1;
                t: for (; ; ) {
                  switch (w = qe(d | 0, h | 0, (15 - p | 0) * 3 | 0) | 0, V() | 0, w & 7) {
                    case 1:
                      break t;
                    case 0:
                      break;
                    default: {
                      p = 1;
                      break e;
                    }
                  }
                  if (p >>> 0 < g >>> 0)
                    p = p + 1 | 0;
                  else {
                    p = 1;
                    break e;
                  }
                }
                for (p = 1; ; )
                  if (w = (15 - p | 0) * 3 | 0, x = qe(d | 0, h | 0, w | 0) | 0, V() | 0, v = Ze(7, 0, w | 0) | 0, h = h & ~(V() | 0), w = Ze(Ac(x & 7) | 0, 0, w | 0) | 0, d = d & ~v | w, h = h | (V() | 0), p >>> 0 < g >>> 0)
                    p = p + 1 | 0;
                  else {
                    p = 1;
                    break;
                  }
              }
          while (!1);
          if (M >>> 0 < P >>> 0)
            M = M + 1 | 0;
          else
            break;
        }
        return xe(h | 0), d | 0;
      }
      function pc(d, h) {
        d = d | 0, h = h | 0;
        var p = 0, g = 0, x = 0, v = 0, w = 0;
        if (g = qe(d | 0, h | 0, 52) | 0, V() | 0, g = g & 15, !g)
          return p = h, g = d, xe(p | 0), g | 0;
        for (p = 1; v = (15 - p | 0) * 3 | 0, w = qe(d | 0, h | 0, v | 0) | 0, V() | 0, x = Ze(7, 0, v | 0) | 0, h = h & ~(V() | 0), v = Ze(Ac(w & 7) | 0, 0, v | 0) | 0, d = v | d & ~x, h = V() | 0 | h, p >>> 0 < g >>> 0; )
          p = p + 1 | 0;
        return xe(h | 0), d | 0;
      }
      function CB(d, h) {
        d = d | 0, h = h | 0;
        var p = 0, g = 0, x = 0, v = 0, w = 0, M = 0, P = 0;
        if (P = qe(d | 0, h | 0, 52) | 0, V() | 0, P = P & 15, !P)
          return M = h, P = d, xe(M | 0), P | 0;
        for (M = 1, p = 0; ; ) {
          v = (15 - M | 0) * 3 | 0, g = Ze(7, 0, v | 0) | 0, x = V() | 0, w = qe(d | 0, h | 0, v | 0) | 0, V() | 0, v = Ze(iu(w & 7) | 0, 0, v | 0) | 0, w = V() | 0, d = v | d & ~g, h = w | h & ~x;
          e: do
            if (!p)
              if ((v & g | 0) == 0 & (w & x | 0) == 0)
                p = 0;
              else if (g = qe(d | 0, h | 0, 52) | 0, V() | 0, g = g & 15, !g)
                p = 1;
              else {
                p = 1;
                t: for (; ; ) {
                  switch (w = qe(d | 0, h | 0, (15 - p | 0) * 3 | 0) | 0, V() | 0, w & 7) {
                    case 1:
                      break t;
                    case 0:
                      break;
                    default: {
                      p = 1;
                      break e;
                    }
                  }
                  if (p >>> 0 < g >>> 0)
                    p = p + 1 | 0;
                  else {
                    p = 1;
                    break e;
                  }
                }
                for (p = 1; ; )
                  if (x = (15 - p | 0) * 3 | 0, v = Ze(7, 0, x | 0) | 0, w = h & ~(V() | 0), h = qe(d | 0, h | 0, x | 0) | 0, V() | 0, h = Ze(iu(h & 7) | 0, 0, x | 0) | 0, d = d & ~v | h, h = w | (V() | 0), p >>> 0 < g >>> 0)
                    p = p + 1 | 0;
                  else {
                    p = 1;
                    break;
                  }
              }
          while (!1);
          if (M >>> 0 < P >>> 0)
            M = M + 1 | 0;
          else
            break;
        }
        return xe(h | 0), d | 0;
      }
      function Rx(d, h) {
        d = d | 0, h = h | 0;
        var p = 0, g = 0, x = 0, v = 0, w = 0;
        if (g = qe(d | 0, h | 0, 52) | 0, V() | 0, g = g & 15, !g)
          return p = h, g = d, xe(p | 0), g | 0;
        for (p = 1; w = (15 - p | 0) * 3 | 0, v = Ze(7, 0, w | 0) | 0, x = h & ~(V() | 0), h = qe(d | 0, h | 0, w | 0) | 0, V() | 0, h = Ze(iu(h & 7) | 0, 0, w | 0) | 0, d = h | d & ~v, h = V() | 0 | x, p >>> 0 < g >>> 0; )
          p = p + 1 | 0;
        return xe(h | 0), d | 0;
      }
      function PB(d, h) {
        d = d | 0, h = h | 0;
        var p = 0, g = 0, x = 0, v = 0, w = 0, M = 0, P = 0, I = 0, k = 0;
        if (P = q, q = q + 64 | 0, M = P + 40 | 0, g = P + 24 | 0, x = P + 12 | 0, v = P, Ze(h | 0, 0, 52) | 0, p = V() | 0 | 134225919, !h)
          return (f[d + 4 >> 2] | 0) > 2 || (f[d + 8 >> 2] | 0) > 2 || (f[d + 12 >> 2] | 0) > 2 ? (w = 0, M = 0, xe(w | 0), q = P, M | 0) : (Ze(Sw(d) | 0, 0, 45) | 0, w = V() | 0 | p, M = -1, xe(w | 0), q = P, M | 0);
        if (f[M >> 2] = f[d >> 2], f[M + 4 >> 2] = f[d + 4 >> 2], f[M + 8 >> 2] = f[d + 8 >> 2], f[M + 12 >> 2] = f[d + 12 >> 2], w = M + 4 | 0, (h | 0) > 0)
          for (d = -1; f[g >> 2] = f[w >> 2], f[g + 4 >> 2] = f[w + 4 >> 2], f[g + 8 >> 2] = f[w + 8 >> 2], h & 1 ? (sB(w), f[x >> 2] = f[w >> 2], f[x + 4 >> 2] = f[w + 4 >> 2], f[x + 8 >> 2] = f[w + 8 >> 2], Q0(x)) : (Pw(w), f[x >> 2] = f[w >> 2], f[x + 4 >> 2] = f[w + 4 >> 2], f[x + 8 >> 2] = f[w + 8 >> 2], fc(x)), yx(g, x, v), rs(v), k = (15 - h | 0) * 3 | 0, I = Ze(7, 0, k | 0) | 0, p = p & ~(V() | 0), k = Ze(Y0(v) | 0, 0, k | 0) | 0, d = k | d & ~I, p = V() | 0 | p, (h | 0) > 1; )
            h = h + -1 | 0;
        else
          d = -1;
        e: do
          if ((f[w >> 2] | 0) <= 2 && (f[M + 8 >> 2] | 0) <= 2 && (f[M + 12 >> 2] | 0) <= 2) {
            if (g = Sw(M) | 0, h = Ze(g | 0, 0, 45) | 0, h = h | d, d = V() | 0 | p & -1040385, v = W7(M) | 0, !(Ni(g) | 0)) {
              if ((v | 0) <= 0)
                break;
              for (x = 0; ; ) {
                if (g = qe(h | 0, d | 0, 52) | 0, V() | 0, g = g & 15, g)
                  for (p = 1; k = (15 - p | 0) * 3 | 0, M = qe(h | 0, d | 0, k | 0) | 0, V() | 0, I = Ze(7, 0, k | 0) | 0, d = d & ~(V() | 0), k = Ze(Ac(M & 7) | 0, 0, k | 0) | 0, h = h & ~I | k, d = d | (V() | 0), p >>> 0 < g >>> 0; )
                    p = p + 1 | 0;
                if (x = x + 1 | 0, (x | 0) == (v | 0))
                  break e;
              }
            }
            x = qe(h | 0, d | 0, 52) | 0, V() | 0, x = x & 15;
            t: do
              if (x) {
                p = 1;
                n: for (; ; ) {
                  switch (k = qe(h | 0, d | 0, (15 - p | 0) * 3 | 0) | 0, V() | 0, k & 7) {
                    case 1:
                      break n;
                    case 0:
                      break;
                    default:
                      break t;
                  }
                  if (p >>> 0 < x >>> 0)
                    p = p + 1 | 0;
                  else
                    break t;
                }
                if (Tw(g, f[M >> 2] | 0) | 0)
                  for (p = 1; M = (15 - p | 0) * 3 | 0, I = Ze(7, 0, M | 0) | 0, k = d & ~(V() | 0), d = qe(h | 0, d | 0, M | 0) | 0, V() | 0, d = Ze(iu(d & 7) | 0, 0, M | 0) | 0, h = h & ~I | d, d = k | (V() | 0), p >>> 0 < x >>> 0; )
                    p = p + 1 | 0;
                else
                  for (p = 1; k = (15 - p | 0) * 3 | 0, M = qe(h | 0, d | 0, k | 0) | 0, V() | 0, I = Ze(7, 0, k | 0) | 0, d = d & ~(V() | 0), k = Ze(Ac(M & 7) | 0, 0, k | 0) | 0, h = h & ~I | k, d = d | (V() | 0), p >>> 0 < x >>> 0; )
                    p = p + 1 | 0;
              }
            while (!1);
            if ((v | 0) > 0) {
              p = 0;
              do
                h = Ex(h, d) | 0, d = V() | 0, p = p + 1 | 0;
              while ((p | 0) != (v | 0));
            }
          } else
            h = 0, d = 0;
        while (!1);
        return I = d, k = h, xe(I | 0), q = P, k | 0;
      }
      function Do(d) {
        return d = d | 0, (d | 0) % 2 | 0 | 0;
      }
      function Cx(d, h, p) {
        d = d | 0, h = h | 0, p = p | 0;
        var g = 0, x = 0;
        return x = q, q = q + 16 | 0, g = x, h >>> 0 > 15 ? (g = 4, q = x, g | 0) : (f[d + 4 >> 2] & 2146435072 | 0) == 2146435072 || (f[d + 8 + 4 >> 2] & 2146435072 | 0) == 2146435072 ? (g = 3, q = x, g | 0) : (pB(d, h, g), h = PB(g, h) | 0, g = V() | 0, f[p >> 2] = h, f[p + 4 >> 2] = g, (h | 0) == 0 & (g | 0) == 0 && Ve(27795, 27122, 1050, 27145), g = 0, q = x, g | 0);
      }
      function Px(d, h, p) {
        d = d | 0, h = h | 0, p = p | 0;
        var g = 0, x = 0, v = 0, w = 0;
        if (x = p + 4 | 0, v = qe(d | 0, h | 0, 52) | 0, V() | 0, v = v & 15, w = qe(d | 0, h | 0, 45) | 0, V() | 0, g = (v | 0) == 0, Ni(w & 127) | 0) {
          if (g)
            return w = 1, w | 0;
          g = 1;
        } else {
          if (g)
            return w = 0, w | 0;
          (f[x >> 2] | 0) == 0 && (f[p + 8 >> 2] | 0) == 0 ? g = (f[p + 12 >> 2] | 0) != 0 & 1 : g = 1;
        }
        for (p = 1; p & 1 ? Q0(x) : fc(x), w = qe(d | 0, h | 0, (15 - p | 0) * 3 | 0) | 0, V() | 0, Nw(x, w & 7), p >>> 0 < v >>> 0; )
          p = p + 1 | 0;
        return g | 0;
      }
      function hd(d, h, p) {
        d = d | 0, h = h | 0, p = p | 0;
        var g = 0, x = 0, v = 0, w = 0, M = 0, P = 0, I = 0, k = 0;
        if (k = q, q = q + 16 | 0, P = k, I = qe(d | 0, h | 0, 45) | 0, V() | 0, I = I & 127, I >>> 0 > 121)
          return f[p >> 2] = 0, f[p + 4 >> 2] = 0, f[p + 8 >> 2] = 0, f[p + 12 >> 2] = 0, I = 5, q = k, I | 0;
        e: do
          if ((Ni(I) | 0) != 0 && (v = qe(d | 0, h | 0, 52) | 0, V() | 0, v = v & 15, (v | 0) != 0)) {
            g = 1;
            t: for (; ; ) {
              switch (M = qe(d | 0, h | 0, (15 - g | 0) * 3 | 0) | 0, V() | 0, M & 7) {
                case 5:
                  break t;
                case 0:
                  break;
                default: {
                  g = h;
                  break e;
                }
              }
              if (g >>> 0 < v >>> 0)
                g = g + 1 | 0;
              else {
                g = h;
                break e;
              }
            }
            for (x = 1, g = h; h = (15 - x | 0) * 3 | 0, w = Ze(7, 0, h | 0) | 0, M = g & ~(V() | 0), g = qe(d | 0, g | 0, h | 0) | 0, V() | 0, g = Ze(iu(g & 7) | 0, 0, h | 0) | 0, d = d & ~w | g, g = M | (V() | 0), x >>> 0 < v >>> 0; )
              x = x + 1 | 0;
          } else
            g = h;
        while (!1);
        if (M = 7696 + (I * 28 | 0) | 0, f[p >> 2] = f[M >> 2], f[p + 4 >> 2] = f[M + 4 >> 2], f[p + 8 >> 2] = f[M + 8 >> 2], f[p + 12 >> 2] = f[M + 12 >> 2], !(Px(d, g, p) | 0))
          return I = 0, q = k, I | 0;
        if (w = p + 4 | 0, f[P >> 2] = f[w >> 2], f[P + 4 >> 2] = f[w + 4 >> 2], f[P + 8 >> 2] = f[w + 8 >> 2], v = qe(d | 0, g | 0, 52) | 0, V() | 0, M = v & 15, v & 1 ? (fc(w), v = M + 1 | 0) : v = M, !(Ni(I) | 0))
          g = 0;
        else {
          e: do
            if (!M)
              g = 0;
            else
              for (h = 1; ; ) {
                if (x = qe(d | 0, g | 0, (15 - h | 0) * 3 | 0) | 0, V() | 0, x = x & 7, x | 0) {
                  g = x;
                  break e;
                }
                if (h >>> 0 < M >>> 0)
                  h = h + 1 | 0;
                else {
                  g = 0;
                  break;
                }
              }
          while (!1);
          g = (g | 0) == 4 & 1;
        }
        if (!(cd(p, v, g, 0) | 0))
          (v | 0) != (M | 0) && (f[w >> 2] = f[P >> 2], f[w + 4 >> 2] = f[P + 4 >> 2], f[w + 8 >> 2] = f[P + 8 >> 2]);
        else {
          if (Ni(I) | 0)
            do
              ;
            while ((cd(p, v, 0, 0) | 0) != 0);
          (v | 0) != (M | 0) && Pw(w);
        }
        return I = 0, q = k, I | 0;
      }
      function mc(d, h, p) {
        d = d | 0, h = h | 0, p = p | 0;
        var g = 0, x = 0, v = 0;
        return v = q, q = q + 16 | 0, g = v, x = hd(d, h, g) | 0, x | 0 ? (q = v, x | 0) : (x = qe(d | 0, h | 0, 52) | 0, V() | 0, _B(g, x & 15, p), x = 0, q = v, x | 0);
      }
      function dd(d, h, p) {
        d = d | 0, h = h | 0, p = p | 0;
        var g = 0, x = 0, v = 0, w = 0, M = 0;
        if (w = q, q = q + 16 | 0, v = w, g = hd(d, h, v) | 0, g | 0)
          return v = g, q = w, v | 0;
        g = qe(d | 0, h | 0, 45) | 0, V() | 0, g = (Ni(g & 127) | 0) == 0, x = qe(d | 0, h | 0, 52) | 0, V() | 0, x = x & 15;
        e: do
          if (!g) {
            if (x | 0)
              for (g = 1; ; ) {
                if (M = Ze(7, 0, (15 - g | 0) * 3 | 0) | 0, !((M & d | 0) == 0 & ((V() | 0) & h | 0) == 0))
                  break e;
                if (g >>> 0 < x >>> 0)
                  g = g + 1 | 0;
                else
                  break;
              }
            return bx(v, x, 0, 5, p), M = 0, q = w, M | 0;
          }
        while (!1);
        return Sx(v, x, 0, 6, p), M = 0, q = w, M | 0;
      }
      function NB(d, h, p) {
        d = d | 0, h = h | 0, p = p | 0;
        var g = 0, x = 0, v = 0;
        if (x = qe(d | 0, h | 0, 45) | 0, V() | 0, !(Ni(x & 127) | 0))
          return x = 2, f[p >> 2] = x, 0;
        if (x = qe(d | 0, h | 0, 52) | 0, V() | 0, x = x & 15, !x)
          return x = 5, f[p >> 2] = x, 0;
        for (g = 1; ; ) {
          if (v = Ze(7, 0, (15 - g | 0) * 3 | 0) | 0, !((v & d | 0) == 0 & ((V() | 0) & h | 0) == 0)) {
            g = 2, d = 6;
            break;
          }
          if (g >>> 0 < x >>> 0)
            g = g + 1 | 0;
          else {
            g = 5, d = 6;
            break;
          }
        }
        return (d | 0) == 6 && (f[p >> 2] = g), 0;
      }
      function zw(d, h, p) {
        d = d | 0, h = h | 0, p = p | 0;
        var g = 0, x = 0, v = 0, w = 0, M = 0, P = 0, I = 0, k = 0, Q = 0;
        Q = q, q = q + 128 | 0, I = Q + 112 | 0, v = Q + 96 | 0, k = Q, x = qe(d | 0, h | 0, 52) | 0, V() | 0, M = x & 15, f[I >> 2] = M, w = qe(d | 0, h | 0, 45) | 0, V() | 0, w = w & 127;
        e: do
          if (Ni(w) | 0) {
            if (M | 0)
              for (g = 1; ; ) {
                if (P = Ze(7, 0, (15 - g | 0) * 3 | 0) | 0, !((P & d | 0) == 0 & ((V() | 0) & h | 0) == 0)) {
                  x = 0;
                  break e;
                }
                if (g >>> 0 < M >>> 0)
                  g = g + 1 | 0;
                else
                  break;
              }
            if (x & 1)
              x = 1;
            else
              return P = Ze(M + 1 | 0, 0, 52) | 0, k = V() | 0 | h & -15728641, I = Ze(7, 0, (14 - M | 0) * 3 | 0) | 0, k = zw((P | d) & ~I, k & ~(V() | 0), p) | 0, q = Q, k | 0;
          } else
            x = 0;
        while (!1);
        if (g = hd(d, h, v) | 0, !g) {
          x ? (Uw(v, I, k), P = 5) : (Ow(v, I, k), P = 6);
          e: do
            if (Ni(w) | 0)
              if (!M)
                d = 5;
              else
                for (g = 1; ; ) {
                  if (w = Ze(7, 0, (15 - g | 0) * 3 | 0) | 0, !((w & d | 0) == 0 & ((V() | 0) & h | 0) == 0)) {
                    d = 2;
                    break e;
                  }
                  if (g >>> 0 < M >>> 0)
                    g = g + 1 | 0;
                  else {
                    d = 5;
                    break;
                  }
                }
            else
              d = 2;
          while (!1);
          au(p | 0, -1, d << 2 | 0) | 0;
          e: do
            if (x)
              for (v = 0; ; ) {
                if (w = k + (v << 4) | 0, xB(w, f[I >> 2] | 0) | 0, w = f[w >> 2] | 0, M = f[p >> 2] | 0, (M | 0) == -1 | (M | 0) == (w | 0))
                  g = p;
                else {
                  x = 0;
                  do {
                    if (x = x + 1 | 0, x >>> 0 >= d >>> 0) {
                      g = 1;
                      break e;
                    }
                    g = p + (x << 2) | 0, M = f[g >> 2] | 0;
                  } while (!((M | 0) == -1 | (M | 0) == (w | 0)));
                }
                if (f[g >> 2] = w, v = v + 1 | 0, v >>> 0 >= P >>> 0) {
                  g = 0;
                  break;
                }
              }
            else
              for (v = 0; ; ) {
                if (w = k + (v << 4) | 0, cd(w, f[I >> 2] | 0, 0, 1) | 0, w = f[w >> 2] | 0, M = f[p >> 2] | 0, (M | 0) == -1 | (M | 0) == (w | 0))
                  g = p;
                else {
                  x = 0;
                  do {
                    if (x = x + 1 | 0, x >>> 0 >= d >>> 0) {
                      g = 1;
                      break e;
                    }
                    g = p + (x << 2) | 0, M = f[g >> 2] | 0;
                  } while (!((M | 0) == -1 | (M | 0) == (w | 0)));
                }
                if (f[g >> 2] = w, v = v + 1 | 0, v >>> 0 >= P >>> 0) {
                  g = 0;
                  break;
                }
              }
          while (!1);
        }
        return k = g, q = Q, k | 0;
      }
      function DB() {
        return 12;
      }
      function Nx(d, h) {
        d = d | 0, h = h | 0;
        var p = 0, g = 0, x = 0, v = 0, w = 0, M = 0, P = 0;
        if (d >>> 0 > 15)
          return M = 4, M | 0;
        if (Ze(d | 0, 0, 52) | 0, M = V() | 0 | 134225919, !d) {
          p = 0, g = 0;
          do
            Ni(g) | 0 && (Ze(g | 0, 0, 45) | 0, w = M | (V() | 0), d = h + (p << 3) | 0, f[d >> 2] = -1, f[d + 4 >> 2] = w, p = p + 1 | 0), g = g + 1 | 0;
          while ((g | 0) != 122);
          return p = 0, p | 0;
        }
        p = 0, w = 0;
        do {
          if (Ni(w) | 0) {
            for (Ze(w | 0, 0, 45) | 0, g = 1, x = -1, v = M | (V() | 0); P = Ze(7, 0, (15 - g | 0) * 3 | 0) | 0, x = x & ~P, v = v & ~(V() | 0), (g | 0) != (d | 0); )
              g = g + 1 | 0;
            P = h + (p << 3) | 0, f[P >> 2] = x, f[P + 4 >> 2] = v, p = p + 1 | 0;
          }
          w = w + 1 | 0;
        } while ((w | 0) != 122);
        return p = 0, p | 0;
      }
      function LB(d, h, p, g) {
        d = d | 0, h = h | 0, p = p | 0, g = g | 0;
        var x = 0, v = 0, w = 0, M = 0, P = 0, I = 0, k = 0, Q = 0, re = 0, se = 0, ae = 0, Ae = 0, ye = 0, Re = 0, we = 0;
        if (we = q, q = q + 16 | 0, ye = we, Re = qe(d | 0, h | 0, 52) | 0, V() | 0, Re = Re & 15, p >>> 0 > 15)
          return Re = 4, q = we, Re | 0;
        if ((Re | 0) < (p | 0))
          return Re = 12, q = we, Re | 0;
        if ((Re | 0) != (p | 0))
          if (v = Ze(p | 0, 0, 52) | 0, v = v | d, M = V() | 0 | h & -15728641, (Re | 0) > (p | 0)) {
            P = p;
            do
              Ae = Ze(7, 0, (14 - P | 0) * 3 | 0) | 0, P = P + 1 | 0, v = Ae | v, M = V() | 0 | M;
            while ((P | 0) < (Re | 0));
            Ae = v;
          } else
            Ae = v;
        else
          Ae = d, M = h;
        ae = qe(Ae | 0, M | 0, 45) | 0, V() | 0;
        e: do
          if (Ni(ae & 127) | 0) {
            if (P = qe(Ae | 0, M | 0, 52) | 0, V() | 0, P = P & 15, P | 0)
              for (v = 1; ; ) {
                if (ae = Ze(7, 0, (15 - v | 0) * 3 | 0) | 0, !((ae & Ae | 0) == 0 & ((V() | 0) & M | 0) == 0)) {
                  I = 33;
                  break e;
                }
                if (v >>> 0 < P >>> 0)
                  v = v + 1 | 0;
                else
                  break;
              }
            if (ae = g, f[ae >> 2] = 0, f[ae + 4 >> 2] = 0, (Re | 0) > (p | 0)) {
              for (ae = h & -15728641, se = Re; ; ) {
                if (re = se, se = se + -1 | 0, se >>> 0 > 15 | (Re | 0) < (se | 0)) {
                  I = 19;
                  break;
                }
                if ((Re | 0) != (se | 0))
                  if (v = Ze(se | 0, 0, 52) | 0, v = v | d, P = V() | 0 | ae, (Re | 0) < (re | 0))
                    Q = v;
                  else {
                    I = se;
                    do
                      Q = Ze(7, 0, (14 - I | 0) * 3 | 0) | 0, I = I + 1 | 0, v = Q | v, P = V() | 0 | P;
                    while ((I | 0) < (Re | 0));
                    Q = v;
                  }
                else
                  Q = d, P = h;
                if (k = qe(Q | 0, P | 0, 45) | 0, V() | 0, !(Ni(k & 127) | 0))
                  v = 0;
                else {
                  k = qe(Q | 0, P | 0, 52) | 0, V() | 0, k = k & 15;
                  t: do
                    if (!k)
                      v = 0;
                    else
                      for (I = 1; ; ) {
                        if (v = qe(Q | 0, P | 0, (15 - I | 0) * 3 | 0) | 0, V() | 0, v = v & 7, v | 0)
                          break t;
                        if (I >>> 0 < k >>> 0)
                          I = I + 1 | 0;
                        else {
                          v = 0;
                          break;
                        }
                      }
                  while (!1);
                  v = (v | 0) == 0 & 1;
                }
                if (P = qe(d | 0, h | 0, (15 - re | 0) * 3 | 0) | 0, V() | 0, P = P & 7, (P | 0) == 7) {
                  x = 5, I = 42;
                  break;
                }
                if (v = (v | 0) != 0, (P | 0) == 1 & v) {
                  x = 5, I = 42;
                  break;
                }
                if (Q = P + (((P | 0) != 0 & v) << 31 >> 31) | 0, Q | 0 && (I = Re - re | 0, I = ru(7, 0, I, ((I | 0) < 0) << 31 >> 31) | 0, k = V() | 0, v ? (v = Mr(I | 0, k | 0, 5, 0) | 0, v = jt(v | 0, V() | 0, -5, -1) | 0, v = ou(v | 0, V() | 0, 6, 0) | 0, v = jt(v | 0, V() | 0, 1, 0) | 0, P = V() | 0) : (v = I, P = k), re = Q + -1 | 0, re = Mr(I | 0, k | 0, re | 0, ((re | 0) < 0) << 31 >> 31 | 0) | 0, re = jt(v | 0, P | 0, re | 0, V() | 0) | 0, Q = V() | 0, k = g, k = jt(re | 0, Q | 0, f[k >> 2] | 0, f[k + 4 >> 2] | 0) | 0, Q = V() | 0, re = g, f[re >> 2] = k, f[re + 4 >> 2] = Q), (se | 0) <= (p | 0)) {
                  I = 37;
                  break;
                }
              }
              if ((I | 0) == 19)
                Ve(27795, 27122, 1367, 27158);
              else if ((I | 0) == 37) {
                w = g, x = f[w + 4 >> 2] | 0, w = f[w >> 2] | 0;
                break;
              } else if ((I | 0) == 42)
                return q = we, x | 0;
            } else
              x = 0, w = 0;
          } else
            I = 33;
        while (!1);
        e: do
          if ((I | 0) == 33)
            if (ae = g, f[ae >> 2] = 0, f[ae + 4 >> 2] = 0, (Re | 0) > (p | 0)) {
              for (v = Re; ; ) {
                if (x = qe(d | 0, h | 0, (15 - v | 0) * 3 | 0) | 0, V() | 0, x = x & 7, (x | 0) == 7) {
                  x = 5;
                  break;
                }
                if (w = Re - v | 0, w = ru(7, 0, w, ((w | 0) < 0) << 31 >> 31) | 0, x = Mr(w | 0, V() | 0, x | 0, 0) | 0, w = V() | 0, ae = g, w = jt(f[ae >> 2] | 0, f[ae + 4 >> 2] | 0, x | 0, w | 0) | 0, x = V() | 0, ae = g, f[ae >> 2] = w, f[ae + 4 >> 2] = x, v = v + -1 | 0, (v | 0) <= (p | 0))
                  break e;
              }
              return q = we, x | 0;
            } else
              x = 0, w = 0;
        while (!1);
        return xA(Ae, M, Re, ye) | 0 && Ve(27795, 27122, 1327, 27173), Re = ye, ye = f[Re + 4 >> 2] | 0, ((x | 0) > -1 | (x | 0) == -1 & w >>> 0 > 4294967295) & ((ye | 0) > (x | 0) | ((ye | 0) == (x | 0) ? (f[Re >> 2] | 0) >>> 0 > w >>> 0 : 0)) ? (Re = 0, q = we, Re | 0) : (Ve(27795, 27122, 1407, 27158), 0);
      }
      function IB(d, h, p, g, x, v) {
        d = d | 0, h = h | 0, p = p | 0, g = g | 0, x = x | 0, v = v | 0;
        var w = 0, M = 0, P = 0, I = 0, k = 0, Q = 0, re = 0, se = 0, ae = 0, Ae = 0;
        if (Q = q, q = q + 16 | 0, w = Q, x >>> 0 > 15)
          return v = 4, q = Q, v | 0;
        if (M = qe(p | 0, g | 0, 52) | 0, V() | 0, M = M & 15, (M | 0) > (x | 0))
          return v = 12, q = Q, v | 0;
        if (xA(p, g, x, w) | 0 && Ve(27795, 27122, 1327, 27173), k = w, I = f[k + 4 >> 2] | 0, !(((h | 0) > -1 | (h | 0) == -1 & d >>> 0 > 4294967295) & ((I | 0) > (h | 0) | ((I | 0) == (h | 0) ? (f[k >> 2] | 0) >>> 0 > d >>> 0 : 0))))
          return v = 2, q = Q, v | 0;
        k = x - M | 0, x = Ze(x | 0, 0, 52) | 0, P = V() | 0 | g & -15728641, I = v, f[I >> 2] = x | p, f[I + 4 >> 2] = P, I = qe(p | 0, g | 0, 45) | 0, V() | 0;
        e: do
          if (Ni(I & 127) | 0) {
            if (M | 0)
              for (w = 1; ; ) {
                if (I = Ze(7, 0, (15 - w | 0) * 3 | 0) | 0, !((I & p | 0) == 0 & ((V() | 0) & g | 0) == 0))
                  break e;
                if (w >>> 0 < M >>> 0)
                  w = w + 1 | 0;
                else
                  break;
              }
            if ((k | 0) < 1)
              return v = 0, q = Q, v | 0;
            for (I = M ^ 15, g = -1, P = 1, w = 1; ; ) {
              M = k - P | 0, M = ru(7, 0, M, ((M | 0) < 0) << 31 >> 31) | 0, p = V() | 0;
              do
                if (w)
                  if (w = Mr(M | 0, p | 0, 5, 0) | 0, w = jt(w | 0, V() | 0, -5, -1) | 0, w = ou(w | 0, V() | 0, 6, 0) | 0, x = V() | 0, (h | 0) > (x | 0) | (h | 0) == (x | 0) & d >>> 0 > w >>> 0) {
                    h = jt(d | 0, h | 0, -1, -1) | 0, h = wr(h | 0, V() | 0, w | 0, x | 0) | 0, w = V() | 0, re = v, ae = f[re >> 2] | 0, re = f[re + 4 >> 2] | 0, Ae = (I + g | 0) * 3 | 0, se = Ze(7, 0, Ae | 0) | 0, re = re & ~(V() | 0), g = ou(h | 0, w | 0, M | 0, p | 0) | 0, d = V() | 0, x = jt(g | 0, d | 0, 2, 0) | 0, Ae = Ze(x | 0, V() | 0, Ae | 0) | 0, re = V() | 0 | re, x = v, f[x >> 2] = Ae | ae & ~se, f[x + 4 >> 2] = re, d = Mr(g | 0, d | 0, M | 0, p | 0) | 0, d = wr(h | 0, w | 0, d | 0, V() | 0) | 0, w = 0, h = V() | 0;
                    break;
                  } else {
                    Ae = v, se = f[Ae >> 2] | 0, Ae = f[Ae + 4 >> 2] | 0, ae = Ze(7, 0, (I + g | 0) * 3 | 0) | 0, Ae = Ae & ~(V() | 0), w = v, f[w >> 2] = se & ~ae, f[w + 4 >> 2] = Ae, w = 1;
                    break;
                  }
                else
                  se = v, x = f[se >> 2] | 0, se = f[se + 4 >> 2] | 0, g = (I + g | 0) * 3 | 0, re = Ze(7, 0, g | 0) | 0, se = se & ~(V() | 0), Ae = ou(d | 0, h | 0, M | 0, p | 0) | 0, w = V() | 0, g = Ze(Ae | 0, w | 0, g | 0) | 0, se = V() | 0 | se, ae = v, f[ae >> 2] = g | x & ~re, f[ae + 4 >> 2] = se, w = Mr(Ae | 0, w | 0, M | 0, p | 0) | 0, d = wr(d | 0, h | 0, w | 0, V() | 0) | 0, w = 0, h = V() | 0;
              while (!1);
              if ((k | 0) > (P | 0))
                g = ~P, P = P + 1 | 0;
              else {
                h = 0;
                break;
              }
            }
            return q = Q, h | 0;
          }
        while (!1);
        if ((k | 0) < 1)
          return Ae = 0, q = Q, Ae | 0;
        for (x = M ^ 15, w = 1; ; )
          if (ae = k - w | 0, ae = ru(7, 0, ae, ((ae | 0) < 0) << 31 >> 31) | 0, Ae = V() | 0, P = v, p = f[P >> 2] | 0, P = f[P + 4 >> 2] | 0, M = (x - w | 0) * 3 | 0, g = Ze(7, 0, M | 0) | 0, P = P & ~(V() | 0), re = ou(d | 0, h | 0, ae | 0, Ae | 0) | 0, se = V() | 0, M = Ze(re | 0, se | 0, M | 0) | 0, P = V() | 0 | P, I = v, f[I >> 2] = M | p & ~g, f[I + 4 >> 2] = P, Ae = Mr(re | 0, se | 0, ae | 0, Ae | 0) | 0, d = wr(d | 0, h | 0, Ae | 0, V() | 0) | 0, h = V() | 0, (k | 0) <= (w | 0)) {
            h = 0;
            break;
          } else
            w = w + 1 | 0;
        return q = Q, h | 0;
      }
      function Dx(d, h, p, g) {
        d = d | 0, h = h | 0, p = p | 0, g = g | 0;
        var x = 0, v = 0, w = 0;
        x = qe(h | 0, p | 0, 52) | 0, V() | 0, x = x & 15, (h | 0) == 0 & (p | 0) == 0 | ((g | 0) > 15 | (x | 0) > (g | 0)) ? (v = -1, h = -1, p = 0, x = 0) : (h = Vw(h, p, x + 1 | 0, g) | 0, w = (V() | 0) & -15728641, p = Ze(g | 0, 0, 52) | 0, p = h | p, w = w | (V() | 0), h = (xi(p, w) | 0) == 0, v = x, h = h ? -1 : g, x = w), w = d, f[w >> 2] = p, f[w + 4 >> 2] = x, f[d + 8 >> 2] = v, f[d + 12 >> 2] = h;
      }
      function qw(d, h, p, g) {
        d = d | 0, h = h | 0, p = p | 0, g = g | 0;
        var x = 0, v = 0;
        if (x = qe(d | 0, h | 0, 52) | 0, V() | 0, x = x & 15, v = g + 8 | 0, f[v >> 2] = x, (d | 0) == 0 & (h | 0) == 0 | ((p | 0) > 15 | (x | 0) > (p | 0))) {
          p = g, f[p >> 2] = 0, f[p + 4 >> 2] = 0, f[v >> 2] = -1, f[g + 12 >> 2] = -1;
          return;
        }
        if (d = Vw(d, h, x + 1 | 0, p) | 0, v = (V() | 0) & -15728641, x = Ze(p | 0, 0, 52) | 0, x = d | x, v = v | (V() | 0), d = g, f[d >> 2] = x, f[d + 4 >> 2] = v, d = g + 12 | 0, xi(x, v) | 0) {
          f[d >> 2] = p;
          return;
        } else {
          f[d >> 2] = -1;
          return;
        }
      }
      function Lx(d) {
        d = d | 0;
        var h = 0, p = 0, g = 0, x = 0, v = 0, w = 0, M = 0, P = 0, I = 0;
        if (p = d, h = f[p >> 2] | 0, p = f[p + 4 >> 2] | 0, !((h | 0) == 0 & (p | 0) == 0) && (g = qe(h | 0, p | 0, 52) | 0, V() | 0, g = g & 15, M = Ze(1, 0, (g ^ 15) * 3 | 0) | 0, h = jt(M | 0, V() | 0, h | 0, p | 0) | 0, p = V() | 0, M = d, f[M >> 2] = h, f[M + 4 >> 2] = p, M = d + 8 | 0, w = f[M >> 2] | 0, !((g | 0) < (w | 0)))) {
          for (P = d + 12 | 0, v = g; ; ) {
            if ((v | 0) == (w | 0)) {
              g = 5;
              break;
            }
            if (I = (v | 0) == (f[P >> 2] | 0), x = (15 - v | 0) * 3 | 0, g = qe(h | 0, p | 0, x | 0) | 0, V() | 0, g = g & 7, I & ((g | 0) == 1 & !0)) {
              g = 7;
              break;
            }
            if (!((g | 0) == 7 & !0)) {
              g = 10;
              break;
            }
            if (I = Ze(1, 0, x | 0) | 0, h = jt(h | 0, p | 0, I | 0, V() | 0) | 0, p = V() | 0, I = d, f[I >> 2] = h, f[I + 4 >> 2] = p, (v | 0) > (w | 0))
              v = v + -1 | 0;
            else {
              g = 10;
              break;
            }
          }
          if ((g | 0) == 5) {
            I = d, f[I >> 2] = 0, f[I + 4 >> 2] = 0, f[M >> 2] = -1, f[P >> 2] = -1;
            return;
          } else if ((g | 0) == 7) {
            w = Ze(1, 0, x | 0) | 0, w = jt(h | 0, p | 0, w | 0, V() | 0) | 0, M = V() | 0, I = d, f[I >> 2] = w, f[I + 4 >> 2] = M, f[P >> 2] = v + -1;
            return;
          } else if ((g | 0) == 10)
            return;
        }
      }
      function yA(d) {
        d = +d;
        var h = 0;
        return h = d < 0 ? d + 6.283185307179586 : d, +(d >= 6.283185307179586 ? h + -6.283185307179586 : h);
      }
      function fd(d, h) {
        return d = d | 0, h = h | 0, +yn(+(+$[d >> 3] - +$[h >> 3])) < 17453292519943298e-27 ? (h = +yn(+(+$[d + 8 >> 3] - +$[h + 8 >> 3])) < 17453292519943298e-27, h | 0) : (h = 0, h | 0);
      }
      function ho(d, h) {
        switch (d = +d, h = h | 0, h | 0) {
          case 1: {
            d = d < 0 ? d + 6.283185307179586 : d;
            break;
          }
          case 2: {
            d = d > 0 ? d + -6.283185307179586 : d;
            break;
          }
        }
        return +d;
      }
      function BB(d, h) {
        d = d | 0, h = h | 0;
        var p = 0, g = 0, x = 0, v = 0;
        return x = +$[h >> 3], g = +$[d >> 3], v = +vn(+((x - g) * 0.5)), p = +vn(+((+$[h + 8 >> 3] - +$[d + 8 >> 3]) * 0.5)), p = v * v + p * (+On(+x) * +On(+g) * p), +(+ks(+ +Nn(+p), + +Nn(+(1 - p))) * 2);
      }
      function vA(d, h) {
        d = d | 0, h = h | 0;
        var p = 0, g = 0, x = 0, v = 0;
        return x = +$[h >> 3], g = +$[d >> 3], v = +vn(+((x - g) * 0.5)), p = +vn(+((+$[h + 8 >> 3] - +$[d + 8 >> 3]) * 0.5)), p = v * v + p * (+On(+x) * +On(+g) * p), +(+ks(+ +Nn(+p), + +Nn(+(1 - p))) * 2 * 6371.007180918475);
      }
      function FB(d, h) {
        d = d | 0, h = h | 0;
        var p = 0, g = 0, x = 0, v = 0;
        return x = +$[h >> 3], g = +$[d >> 3], v = +vn(+((x - g) * 0.5)), p = +vn(+((+$[h + 8 >> 3] - +$[d + 8 >> 3]) * 0.5)), p = v * v + p * (+On(+x) * +On(+g) * p), +(+ks(+ +Nn(+p), + +Nn(+(1 - p))) * 2 * 6371.007180918475 * 1e3);
      }
      function UB(d, h) {
        d = d | 0, h = h | 0;
        var p = 0, g = 0, x = 0, v = 0, w = 0;
        return v = +$[h >> 3], g = +On(+v), x = +$[h + 8 >> 3] - +$[d + 8 >> 3], w = g * +vn(+x), p = +$[d >> 3], + +ks(+w, +(+vn(+v) * +On(+p) - +On(+x) * (g * +vn(+p))));
      }
      function OB(d, h, p, g) {
        d = d | 0, h = +h, p = +p, g = g | 0;
        var x = 0, v = 0, w = 0, M = 0;
        if (p < 1e-16) {
          f[g >> 2] = f[d >> 2], f[g + 4 >> 2] = f[d + 4 >> 2], f[g + 8 >> 2] = f[d + 8 >> 2], f[g + 12 >> 2] = f[d + 12 >> 2];
          return;
        }
        v = h < 0 ? h + 6.283185307179586 : h, v = h >= 6.283185307179586 ? v + -6.283185307179586 : v;
        do
          if (v < 1e-16)
            h = +$[d >> 3] + p, $[g >> 3] = h, x = g;
          else {
            if (x = +yn(+(v + -3.141592653589793)) < 1e-16, h = +$[d >> 3], x) {
              h = h - p, $[g >> 3] = h, x = g;
              break;
            }
            if (w = +On(+p), p = +vn(+p), h = w * +vn(+h) + +On(+v) * (p * +On(+h)), h = h > 1 ? 1 : h, h = +Ax(+(h < -1 ? -1 : h)), $[g >> 3] = h, +yn(+(h + -1.5707963267948966)) < 1e-16) {
              $[g >> 3] = 1.5707963267948966, $[g + 8 >> 3] = 0;
              return;
            }
            if (+yn(+(h + 1.5707963267948966)) < 1e-16) {
              $[g >> 3] = -1.5707963267948966, $[g + 8 >> 3] = 0;
              return;
            }
            if (M = 1 / +On(+h), v = p * +vn(+v) * M, p = +$[d >> 3], h = M * ((w - +vn(+h) * +vn(+p)) / +On(+p)), w = v > 1 ? 1 : v, h = h > 1 ? 1 : h, h = +$[d + 8 >> 3] + +ks(+(w < -1 ? -1 : w), +(h < -1 ? -1 : h)), h > 3.141592653589793)
              do
                h = h + -6.283185307179586;
              while (h > 3.141592653589793);
            if (h < -3.141592653589793)
              do
                h = h + 6.283185307179586;
              while (h < -3.141592653589793);
            $[g + 8 >> 3] = h;
            return;
          }
        while (!1);
        if (+yn(+(h + -1.5707963267948966)) < 1e-16) {
          $[x >> 3] = 1.5707963267948966, $[g + 8 >> 3] = 0;
          return;
        }
        if (+yn(+(h + 1.5707963267948966)) < 1e-16) {
          $[x >> 3] = -1.5707963267948966, $[g + 8 >> 3] = 0;
          return;
        }
        if (h = +$[d + 8 >> 3], h > 3.141592653589793)
          do
            h = h + -6.283185307179586;
          while (h > 3.141592653589793);
        if (h < -3.141592653589793)
          do
            h = h + 6.283185307179586;
          while (h < -3.141592653589793);
        $[g + 8 >> 3] = h;
      }
      function Hw(d, h) {
        return d = d | 0, h = h | 0, d >>> 0 > 15 ? (h = 4, h | 0) : ($[h >> 3] = +$[20656 + (d << 3) >> 3], h = 0, h | 0);
      }
      function kB(d, h) {
        return d = d | 0, h = h | 0, d >>> 0 > 15 ? (h = 4, h | 0) : ($[h >> 3] = +$[20784 + (d << 3) >> 3], h = 0, h | 0);
      }
      function VB(d, h) {
        return d = d | 0, h = h | 0, d >>> 0 > 15 ? (h = 4, h | 0) : ($[h >> 3] = +$[20912 + (d << 3) >> 3], h = 0, h | 0);
      }
      function GB(d, h) {
        return d = d | 0, h = h | 0, d >>> 0 > 15 ? (h = 4, h | 0) : ($[h >> 3] = +$[21040 + (d << 3) >> 3], h = 0, h | 0);
      }
      function J0(d, h) {
        d = d | 0, h = h | 0;
        var p = 0;
        return d >>> 0 > 15 ? (h = 4, h | 0) : (p = ru(7, 0, d, ((d | 0) < 0) << 31 >> 31) | 0, p = Mr(p | 0, V() | 0, 120, 0) | 0, d = V() | 0, f[h >> 2] = p | 2, f[h + 4 >> 2] = d, h = 0, h | 0);
      }
      function Ww(d, h, p) {
        d = d | 0, h = h | 0, p = p | 0;
        var g = 0, x = 0, v = 0, w = 0, M = 0, P = 0, I = 0, k = 0, Q = 0, re = 0;
        return re = +$[h >> 3], k = +$[d >> 3], P = +vn(+((re - k) * 0.5)), v = +$[h + 8 >> 3], I = +$[d + 8 >> 3], w = +vn(+((v - I) * 0.5)), M = +On(+k), Q = +On(+re), w = P * P + w * (Q * M * w), w = +ks(+ +Nn(+w), + +Nn(+(1 - w))) * 2, P = +$[p >> 3], re = +vn(+((P - re) * 0.5)), g = +$[p + 8 >> 3], v = +vn(+((g - v) * 0.5)), x = +On(+P), v = re * re + v * (Q * x * v), v = +ks(+ +Nn(+v), + +Nn(+(1 - v))) * 2, P = +vn(+((k - P) * 0.5)), g = +vn(+((I - g) * 0.5)), g = P * P + g * (M * x * g), g = +ks(+ +Nn(+g), + +Nn(+(1 - g))) * 2, x = (w + v + g) * 0.5, +(+mA(+ +Nn(+(+ys(+(x * 0.5)) * +ys(+((x - w) * 0.5)) * +ys(+((x - v) * 0.5)) * +ys(+((x - g) * 0.5))))) * 4);
      }
      function Ix(d, h, p) {
        d = d | 0, h = h | 0, p = p | 0;
        var g = 0, x = 0, v = 0, w = 0, M = 0;
        if (M = q, q = q + 192 | 0, v = M + 168 | 0, w = M, x = mc(d, h, v) | 0, x | 0)
          return p = x, q = M, p | 0;
        if (dd(d, h, w) | 0 && Ve(27795, 27190, 415, 27199), h = f[w >> 2] | 0, (h | 0) > 0) {
          if (g = +Ww(w + 8 | 0, w + 8 + (((h | 0) != 1 & 1) << 4) | 0, v) + 0, (h | 0) != 1) {
            d = 1;
            do
              x = d, d = d + 1 | 0, g = g + +Ww(w + 8 + (x << 4) | 0, w + 8 + (((d | 0) % (h | 0) | 0) << 4) | 0, v);
            while ((d | 0) < (h | 0));
          }
        } else
          g = 0;
        return $[p >> 3] = g, p = 0, q = M, p | 0;
      }
      function zB(d, h, p) {
        return d = d | 0, h = h | 0, p = p | 0, d = Ix(d, h, p) | 0, d | 0 || ($[p >> 3] = +$[p >> 3] * 6371.007180918475 * 6371.007180918475), d | 0;
      }
      function qB(d, h, p) {
        return d = d | 0, h = h | 0, p = p | 0, d = Ix(d, h, p) | 0, d | 0 || ($[p >> 3] = +$[p >> 3] * 6371.007180918475 * 6371.007180918475 * 1e3 * 1e3), d | 0;
      }
      function HB(d, h, p) {
        d = d | 0, h = h | 0, p = p | 0;
        var g = 0, x = 0, v = 0, w = 0, M = 0, P = 0, I = 0, k = 0;
        if (M = q, q = q + 176 | 0, w = M, d = Z0(d, h, w) | 0, d | 0)
          return w = d, q = M, w | 0;
        if ($[p >> 3] = 0, d = f[w >> 2] | 0, (d | 0) <= 1)
          return w = 0, q = M, w | 0;
        h = d + -1 | 0, d = 0, g = +$[w + 8 >> 3], x = +$[w + 16 >> 3], v = 0;
        do
          d = d + 1 | 0, I = g, g = +$[w + 8 + (d << 4) >> 3], k = +vn(+((g - I) * 0.5)), P = x, x = +$[w + 8 + (d << 4) + 8 >> 3], P = +vn(+((x - P) * 0.5)), P = k * k + P * (+On(+g) * +On(+I) * P), v = v + +ks(+ +Nn(+P), + +Nn(+(1 - P))) * 2;
        while ((d | 0) < (h | 0));
        return $[p >> 3] = v, w = 0, q = M, w | 0;
      }
      function WB(d, h, p) {
        d = d | 0, h = h | 0, p = p | 0;
        var g = 0, x = 0, v = 0, w = 0, M = 0, P = 0, I = 0, k = 0;
        if (M = q, q = q + 176 | 0, w = M, d = Z0(d, h, w) | 0, d | 0)
          return w = d, v = +$[p >> 3], v = v * 6371.007180918475, $[p >> 3] = v, q = M, w | 0;
        if ($[p >> 3] = 0, d = f[w >> 2] | 0, (d | 0) <= 1)
          return w = 0, v = 0, v = v * 6371.007180918475, $[p >> 3] = v, q = M, w | 0;
        h = d + -1 | 0, d = 0, g = +$[w + 8 >> 3], x = +$[w + 16 >> 3], v = 0;
        do
          d = d + 1 | 0, I = g, g = +$[w + 8 + (d << 4) >> 3], k = +vn(+((g - I) * 0.5)), P = x, x = +$[w + 8 + (d << 4) + 8 >> 3], P = +vn(+((x - P) * 0.5)), P = k * k + P * (+On(+I) * +On(+g) * P), v = v + +ks(+ +Nn(+P), + +Nn(+(1 - P))) * 2;
        while ((d | 0) != (h | 0));
        return $[p >> 3] = v, w = 0, k = v, k = k * 6371.007180918475, $[p >> 3] = k, q = M, w | 0;
      }
      function $B(d, h, p) {
        d = d | 0, h = h | 0, p = p | 0;
        var g = 0, x = 0, v = 0, w = 0, M = 0, P = 0, I = 0, k = 0;
        if (M = q, q = q + 176 | 0, w = M, d = Z0(d, h, w) | 0, d | 0)
          return w = d, v = +$[p >> 3], v = v * 6371.007180918475, v = v * 1e3, $[p >> 3] = v, q = M, w | 0;
        if ($[p >> 3] = 0, d = f[w >> 2] | 0, (d | 0) <= 1)
          return w = 0, v = 0, v = v * 6371.007180918475, v = v * 1e3, $[p >> 3] = v, q = M, w | 0;
        h = d + -1 | 0, d = 0, g = +$[w + 8 >> 3], x = +$[w + 16 >> 3], v = 0;
        do
          d = d + 1 | 0, I = g, g = +$[w + 8 + (d << 4) >> 3], k = +vn(+((g - I) * 0.5)), P = x, x = +$[w + 8 + (d << 4) + 8 >> 3], P = +vn(+((x - P) * 0.5)), P = k * k + P * (+On(+I) * +On(+g) * P), v = v + +ks(+ +Nn(+P), + +Nn(+(1 - P))) * 2;
        while ((d | 0) != (h | 0));
        return $[p >> 3] = v, w = 0, k = v, k = k * 6371.007180918475, k = k * 1e3, $[p >> 3] = k, q = M, w | 0;
      }
      function jB(d) {
        d = d | 0;
        var h = 0, p = 0, g = 0;
        return h = Gs(1, 12) | 0, h || Ve(27280, 27235, 49, 27293), p = d + 4 | 0, g = f[p >> 2] | 0, g | 0 ? (g = g + 8 | 0, f[g >> 2] = h, f[p >> 2] = h, h | 0) : (f[d >> 2] | 0 && Ve(27310, 27235, 61, 27333), g = d, f[g >> 2] = h, f[p >> 2] = h, h | 0);
      }
      function XB(d, h) {
        d = d | 0, h = h | 0;
        var p = 0, g = 0;
        return g = Ra(24) | 0, g || Ve(27347, 27235, 78, 27361), f[g >> 2] = f[h >> 2], f[g + 4 >> 2] = f[h + 4 >> 2], f[g + 8 >> 2] = f[h + 8 >> 2], f[g + 12 >> 2] = f[h + 12 >> 2], f[g + 16 >> 2] = 0, h = d + 4 | 0, p = f[h >> 2] | 0, p | 0 ? (f[p + 16 >> 2] = g, f[h >> 2] = g, g | 0) : (f[d >> 2] | 0 && Ve(27376, 27235, 82, 27361), f[d >> 2] = g, f[h >> 2] = g, g | 0);
      }
      function $w(d) {
        d = d | 0;
        var h = 0, p = 0, g = 0, x = 0;
        if (d)
          for (g = 1; ; ) {
            if (h = f[d >> 2] | 0, h | 0)
              do {
                if (p = f[h >> 2] | 0, p | 0)
                  do
                    x = p, p = f[p + 16 >> 2] | 0, Qt(x);
                  while ((p | 0) != 0);
                x = h, h = f[h + 8 >> 2] | 0, Qt(x);
              } while ((h | 0) != 0);
            if (h = d, d = f[d + 8 >> 2] | 0, g || Qt(h), d)
              g = 0;
            else
              break;
          }
      }
      function YB(d) {
        d = d | 0;
        var h = 0, p = 0, g = 0, x = 0, v = 0, w = 0, M = 0, P = 0, I = 0, k = 0, Q = 0, re = 0, se = 0, ae = 0, Ae = 0, ye = 0, Re = 0, we = 0, be = 0, me = 0, nt = 0, qt = 0, Pt = 0, mn = 0, gn = 0, Pn = 0, an = 0, Ht = 0, et = 0, wn = 0, pi = 0, bn = 0;
        if (x = d + 8 | 0, f[x >> 2] | 0)
          return bn = 1, bn | 0;
        if (g = f[d >> 2] | 0, !g)
          return bn = 0, bn | 0;
        h = g, p = 0;
        do
          p = p + 1 | 0, h = f[h + 8 >> 2] | 0;
        while ((h | 0) != 0);
        if (p >>> 0 < 2)
          return bn = 0, bn | 0;
        wn = Ra(p << 2) | 0, wn || Ve(27396, 27235, 317, 27415), et = Ra(p << 5) | 0, et || Ve(27437, 27235, 321, 27415), f[d >> 2] = 0, qt = d + 4 | 0, f[qt >> 2] = 0, f[x >> 2] = 0, p = 0, Ht = 0, nt = 0, Q = 0;
        e: for (; ; ) {
          if (k = f[g >> 2] | 0, k) {
            v = 0, w = k;
            do {
              if (P = +$[w + 8 >> 3], h = w, w = f[w + 16 >> 2] | 0, I = (w | 0) == 0, x = I ? k : w, M = +$[x + 8 >> 3], +yn(+(P - M)) > 3.141592653589793) {
                bn = 14;
                break;
              }
              v = v + (M - P) * (+$[h >> 3] + +$[x >> 3]);
            } while (!I);
            if ((bn | 0) == 14) {
              bn = 0, v = 0, h = k;
              do
                me = +$[h + 8 >> 3], an = h + 16 | 0, Pn = f[an >> 2] | 0, Pn = (Pn | 0) == 0 ? k : Pn, be = +$[Pn + 8 >> 3], v = v + (+$[h >> 3] + +$[Pn >> 3]) * ((be < 0 ? be + 6.283185307179586 : be) - (me < 0 ? me + 6.283185307179586 : me)), h = f[((h | 0) == 0 ? g : an) >> 2] | 0;
              while ((h | 0) != 0);
            }
            v > 0 ? (f[wn + (Ht << 2) >> 2] = g, Ht = Ht + 1 | 0, x = nt, h = Q) : bn = 19;
          } else
            bn = 19;
          if ((bn | 0) == 19) {
            bn = 0;
            do
              if (p) {
                if (h = p + 8 | 0, f[h >> 2] | 0) {
                  bn = 21;
                  break e;
                }
                if (p = Gs(1, 12) | 0, !p) {
                  bn = 23;
                  break e;
                }
                f[h >> 2] = p, x = p + 4 | 0, w = p, h = Q;
              } else if (Q) {
                x = qt, w = Q + 8 | 0, h = g, p = d;
                break;
              } else if (f[d >> 2] | 0) {
                bn = 27;
                break e;
              } else {
                x = qt, w = d, h = g, p = d;
                break;
              }
            while (!1);
            if (f[w >> 2] = g, f[x >> 2] = g, w = et + (nt << 5) | 0, I = f[g >> 2] | 0, I) {
              for (k = et + (nt << 5) + 8 | 0, $[k >> 3] = 17976931348623157e292, Q = et + (nt << 5) + 24 | 0, $[Q >> 3] = 17976931348623157e292, $[w >> 3] = -17976931348623157e292, re = et + (nt << 5) + 16 | 0, $[re >> 3] = -17976931348623157e292, Re = 17976931348623157e292, we = -17976931348623157e292, x = 0, se = I, P = 17976931348623157e292, Ae = 17976931348623157e292, ye = -17976931348623157e292, M = -17976931348623157e292; v = +$[se >> 3], me = +$[se + 8 >> 3], se = f[se + 16 >> 2] | 0, ae = (se | 0) == 0, be = +$[(ae ? I : se) + 8 >> 3], v < P && ($[k >> 3] = v, P = v), me < Ae && ($[Q >> 3] = me, Ae = me), v > ye ? $[w >> 3] = v : v = ye, me > M && ($[re >> 3] = me, M = me), Re = me > 0 & me < Re ? me : Re, we = me < 0 & me > we ? me : we, x = x | +yn(+(me - be)) > 3.141592653589793, !ae; )
                ye = v;
              x && ($[re >> 3] = we, $[Q >> 3] = Re);
            } else
              f[w >> 2] = 0, f[w + 4 >> 2] = 0, f[w + 8 >> 2] = 0, f[w + 12 >> 2] = 0, f[w + 16 >> 2] = 0, f[w + 20 >> 2] = 0, f[w + 24 >> 2] = 0, f[w + 28 >> 2] = 0;
            x = nt + 1 | 0;
          }
          if (an = g + 8 | 0, g = f[an >> 2] | 0, f[an >> 2] = 0, g)
            nt = x, Q = h;
          else {
            bn = 45;
            break;
          }
        }
        if ((bn | 0) == 21)
          Ve(27213, 27235, 35, 27247);
        else if ((bn | 0) == 23)
          Ve(27267, 27235, 37, 27247);
        else if ((bn | 0) == 27)
          Ve(27310, 27235, 61, 27333);
        else if ((bn | 0) == 45) {
          e: do
            if ((Ht | 0) > 0) {
              for (an = (x | 0) == 0, gn = x << 2, Pn = (d | 0) == 0, mn = 0, h = 0; ; ) {
                if (Pt = f[wn + (mn << 2) >> 2] | 0, an)
                  bn = 73;
                else {
                  if (nt = Ra(gn) | 0, !nt) {
                    bn = 50;
                    break;
                  }
                  if (qt = Ra(gn) | 0, !qt) {
                    bn = 52;
                    break;
                  }
                  t: do
                    if (Pn)
                      p = 0;
                    else {
                      for (x = 0, p = 0, w = d; g = et + (x << 5) | 0, jw(f[w >> 2] | 0, g, f[Pt >> 2] | 0) | 0 ? (f[nt + (p << 2) >> 2] = w, f[qt + (p << 2) >> 2] = g, ae = p + 1 | 0) : ae = p, w = f[w + 8 >> 2] | 0, w; )
                        x = x + 1 | 0, p = ae;
                      if ((ae | 0) > 0)
                        if (g = f[nt >> 2] | 0, (ae | 0) == 1)
                          p = g;
                        else
                          for (re = 0, se = -1, p = g, Q = g; ; ) {
                            for (I = f[Q >> 2] | 0, g = 0, w = 0; x = f[f[nt + (w << 2) >> 2] >> 2] | 0, (x | 0) == (I | 0) ? k = g : k = g + ((jw(x, f[qt + (w << 2) >> 2] | 0, f[I >> 2] | 0) | 0) & 1) | 0, w = w + 1 | 0, (w | 0) != (ae | 0); )
                              g = k;
                            if (x = (k | 0) > (se | 0), p = x ? Q : p, g = re + 1 | 0, (g | 0) == (ae | 0))
                              break t;
                            re = g, se = x ? k : se, Q = f[nt + (g << 2) >> 2] | 0;
                          }
                      else
                        p = 0;
                    }
                  while (!1);
                  if (Qt(nt), Qt(qt), p) {
                    if (x = p + 4 | 0, g = f[x >> 2] | 0, g)
                      p = g + 8 | 0;
                    else if (f[p >> 2] | 0) {
                      bn = 70;
                      break;
                    }
                    f[p >> 2] = Pt, f[x >> 2] = Pt;
                  } else
                    bn = 73;
                }
                if ((bn | 0) == 73) {
                  if (bn = 0, h = f[Pt >> 2] | 0, h | 0)
                    do
                      qt = h, h = f[h + 16 >> 2] | 0, Qt(qt);
                    while ((h | 0) != 0);
                  Qt(Pt), h = 1;
                }
                if (mn = mn + 1 | 0, (mn | 0) >= (Ht | 0)) {
                  pi = h;
                  break e;
                }
              }
              (bn | 0) == 50 ? Ve(27452, 27235, 249, 27471) : (bn | 0) == 52 ? Ve(27490, 27235, 252, 27471) : (bn | 0) == 70 && Ve(27310, 27235, 61, 27333);
            } else
              pi = 0;
          while (!1);
          return Qt(wn), Qt(et), bn = pi, bn | 0;
        }
        return 0;
      }
      function jw(d, h, p) {
        d = d | 0, h = h | 0, p = p | 0;
        var g = 0, x = 0, v = 0, w = 0, M = 0, P = 0, I = 0, k = 0;
        if (!(_x(h, p) | 0) || (h = ww(h) | 0, g = +$[p >> 3], x = +$[p + 8 >> 3], x = h & x < 0 ? x + 6.283185307179586 : x, d = f[d >> 2] | 0, !d))
          return d = 0, d | 0;
        if (h) {
          h = 0, I = x, p = d;
          e: for (; ; ) {
            for (; w = +$[p >> 3], x = +$[p + 8 >> 3], p = p + 16 | 0, k = f[p >> 2] | 0, k = (k | 0) == 0 ? d : k, v = +$[k >> 3], M = +$[k + 8 >> 3], w > v ? (P = w, w = M) : (P = v, v = w, w = x, x = M), g = g == v | g == P ? g + 2220446049250313e-31 : g, !!(g < v | g > P); )
              if (p = f[p >> 2] | 0, !p) {
                p = 22;
                break e;
              }
            if (M = w < 0 ? w + 6.283185307179586 : w, w = x < 0 ? x + 6.283185307179586 : x, I = M == I | w == I ? I + -2220446049250313e-31 : I, P = M + (w - M) * ((g - v) / (P - v)), (P < 0 ? P + 6.283185307179586 : P) > I && (h = h ^ 1), p = f[p >> 2] | 0, !p) {
              p = 22;
              break;
            }
          }
          if ((p | 0) == 22)
            return h | 0;
        } else {
          h = 0, I = x, p = d;
          e: for (; ; ) {
            for (; w = +$[p >> 3], x = +$[p + 8 >> 3], p = p + 16 | 0, k = f[p >> 2] | 0, k = (k | 0) == 0 ? d : k, v = +$[k >> 3], M = +$[k + 8 >> 3], w > v ? (P = w, w = M) : (P = v, v = w, w = x, x = M), g = g == v | g == P ? g + 2220446049250313e-31 : g, !!(g < v | g > P); )
              if (p = f[p >> 2] | 0, !p) {
                p = 22;
                break e;
              }
            if (I = w == I | x == I ? I + -2220446049250313e-31 : I, w + (x - w) * ((g - v) / (P - v)) > I && (h = h ^ 1), p = f[p >> 2] | 0, !p) {
              p = 22;
              break;
            }
          }
          if ((p | 0) == 22)
            return h | 0;
        }
        return 0;
      }
      function fl(d, h, p, g, x) {
        d = d | 0, h = h | 0, p = p | 0, g = g | 0, x = x | 0;
        var v = 0, w = 0, M = 0, P = 0, I = 0, k = 0, Q = 0, re = 0, se = 0, ae = 0, Ae = 0, ye = 0, Re = 0, we = 0;
        if (we = q, q = q + 32 | 0, Re = we + 16 | 0, ye = we, v = qe(d | 0, h | 0, 52) | 0, V() | 0, v = v & 15, se = qe(p | 0, g | 0, 52) | 0, V() | 0, (v | 0) != (se & 15 | 0))
          return Re = 12, q = we, Re | 0;
        if (I = qe(d | 0, h | 0, 45) | 0, V() | 0, I = I & 127, k = qe(p | 0, g | 0, 45) | 0, V() | 0, k = k & 127, I >>> 0 > 121 | k >>> 0 > 121)
          return Re = 5, q = we, Re | 0;
        if (se = (I | 0) != (k | 0), se) {
          if (M = gx(I, k) | 0, (M | 0) == 7)
            return Re = 1, q = we, Re | 0;
          P = gx(k, I) | 0, (P | 0) == 7 ? Ve(27514, 27538, 161, 27548) : (ae = M, w = P);
        } else
          ae = 0, w = 0;
        Q = Ni(I) | 0, re = Ni(k) | 0, f[Re >> 2] = 0, f[Re + 4 >> 2] = 0, f[Re + 8 >> 2] = 0, f[Re + 12 >> 2] = 0;
        do
          if (ae) {
            if (k = f[4272 + (I * 28 | 0) + (ae << 2) >> 2] | 0, M = (k | 0) > 0, re)
              if (M) {
                I = 0, P = p, M = g;
                do
                  P = CB(P, M) | 0, M = V() | 0, w = iu(w) | 0, (w | 0) == 1 && (w = iu(1) | 0), I = I + 1 | 0;
                while ((I | 0) != (k | 0));
                k = w, I = P, P = M;
              } else
                k = w, I = p, P = g;
            else if (M) {
              I = 0, P = p, M = g;
              do
                P = Rx(P, M) | 0, M = V() | 0, w = iu(w) | 0, I = I + 1 | 0;
              while ((I | 0) != (k | 0));
              k = w, I = P, P = M;
            } else
              k = w, I = p, P = g;
            if (Px(I, P, Re) | 0, se || Ve(27563, 27538, 191, 27548), M = (Q | 0) != 0, w = (re | 0) != 0, M & w && Ve(27590, 27538, 192, 27548), M) {
              if (w = Vs(d, h) | 0, (w | 0) == 7) {
                v = 5;
                break;
              }
              if ($e[22e3 + (w * 7 | 0) + ae >> 0] | 0) {
                v = 1;
                break;
              }
              P = f[21168 + (w * 28 | 0) + (ae << 2) >> 2] | 0, I = P;
            } else if (w) {
              if (w = Vs(I, P) | 0, (w | 0) == 7) {
                v = 5;
                break;
              }
              if ($e[22e3 + (w * 7 | 0) + k >> 0] | 0) {
                v = 1;
                break;
              }
              I = 0, P = f[21168 + (k * 28 | 0) + (w << 2) >> 2] | 0;
            } else
              I = 0, P = 0;
            if ((I | P | 0) < 0)
              v = 5;
            else {
              if ((P | 0) > 0) {
                M = Re + 4 | 0, w = 0;
                do
                  K0(M), w = w + 1 | 0;
                while ((w | 0) != (P | 0));
              }
              if (f[ye >> 2] = 0, f[ye + 4 >> 2] = 0, f[ye + 8 >> 2] = 0, Nw(ye, ae), v | 0)
                for (; Do(v) | 0 ? Q0(ye) : fc(ye), (v | 0) > 1; )
                  v = v + -1 | 0;
              if ((I | 0) > 0) {
                v = 0;
                do
                  K0(ye), v = v + 1 | 0;
                while ((v | 0) != (I | 0));
              }
              Ae = Re + 4 | 0, vs(Ae, ye, Ae), rs(Ae), Ae = 51;
            }
          } else if (Px(p, g, Re) | 0, (Q | 0) != 0 & (re | 0) != 0)
            if ((k | 0) != (I | 0) && Ve(27621, 27538, 261, 27548), w = Vs(d, h) | 0, v = Vs(p, g) | 0, (w | 0) == 7 | (v | 0) == 7)
              v = 5;
            else if ($e[22e3 + (w * 7 | 0) + v >> 0] | 0)
              v = 1;
            else if (w = f[21168 + (w * 28 | 0) + (v << 2) >> 2] | 0, (w | 0) > 0) {
              M = Re + 4 | 0, v = 0;
              do
                K0(M), v = v + 1 | 0;
              while ((v | 0) != (w | 0));
              Ae = 51;
            } else
              Ae = 51;
          else
            Ae = 51;
        while (!1);
        return (Ae | 0) == 51 && (v = Re + 4 | 0, f[x >> 2] = f[v >> 2], f[x + 4 >> 2] = f[v + 4 >> 2], f[x + 8 >> 2] = f[v + 8 >> 2], v = 0), Re = v, q = we, Re | 0;
      }
      function Xw(d, h, p, g) {
        d = d | 0, h = h | 0, p = p | 0, g = g | 0;
        var x = 0, v = 0, w = 0, M = 0, P = 0, I = 0, k = 0, Q = 0, re = 0, se = 0, ae = 0, Ae = 0, ye = 0, Re = 0, we = 0, be = 0;
        if (Ae = q, q = q + 48 | 0, I = Ae + 36 | 0, w = Ae + 24 | 0, M = Ae + 12 | 0, P = Ae, x = qe(d | 0, h | 0, 52) | 0, V() | 0, x = x & 15, re = qe(d | 0, h | 0, 45) | 0, V() | 0, re = re & 127, re >>> 0 > 121)
          return g = 5, q = Ae, g | 0;
        if (k = Ni(re) | 0, Ze(x | 0, 0, 52) | 0, ye = V() | 0 | 134225919, v = g, f[v >> 2] = -1, f[v + 4 >> 2] = ye, !x)
          return x = Y0(p) | 0, (x | 0) == 7 || (x = mx(re, x) | 0, (x | 0) == 127) ? (ye = 1, q = Ae, ye | 0) : (se = Ze(x | 0, 0, 45) | 0, ae = V() | 0, re = g, ae = f[re + 4 >> 2] & -1040385 | ae, ye = g, f[ye >> 2] = f[re >> 2] | se, f[ye + 4 >> 2] = ae, ye = 0, q = Ae, ye | 0);
        for (f[I >> 2] = f[p >> 2], f[I + 4 >> 2] = f[p + 4 >> 2], f[I + 8 >> 2] = f[p + 8 >> 2], p = x; ; ) {
          if (v = p, p = p + -1 | 0, f[w >> 2] = f[I >> 2], f[w + 4 >> 2] = f[I + 4 >> 2], f[w + 8 >> 2] = f[I + 8 >> 2], Do(v) | 0) {
            if (x = iB(I) | 0, x | 0) {
              p = 13;
              break;
            }
            f[M >> 2] = f[I >> 2], f[M + 4 >> 2] = f[I + 4 >> 2], f[M + 8 >> 2] = f[I + 8 >> 2], Q0(M);
          } else {
            if (x = rB(I) | 0, x | 0) {
              p = 13;
              break;
            }
            f[M >> 2] = f[I >> 2], f[M + 4 >> 2] = f[I + 4 >> 2], f[M + 8 >> 2] = f[I + 8 >> 2], fc(M);
          }
          if (yx(w, M, P), rs(P), x = g, we = f[x >> 2] | 0, x = f[x + 4 >> 2] | 0, be = (15 - v | 0) * 3 | 0, Re = Ze(7, 0, be | 0) | 0, x = x & ~(V() | 0), be = Ze(Y0(P) | 0, 0, be | 0) | 0, x = V() | 0 | x, ye = g, f[ye >> 2] = be | we & ~Re, f[ye + 4 >> 2] = x, (v | 0) <= 1) {
            p = 14;
            break;
          }
        }
        e: do
          if ((p | 0) != 13 && (p | 0) == 14)
            if ((f[I >> 2] | 0) <= 1 && (f[I + 4 >> 2] | 0) <= 1 && (f[I + 8 >> 2] | 0) <= 1) {
              p = Y0(I) | 0, x = mx(re, p) | 0, (x | 0) == 127 ? P = 0 : P = Ni(x) | 0;
              t: do
                if (p) {
                  if (k) {
                    if (x = Vs(d, h) | 0, (x | 0) == 7) {
                      x = 5;
                      break e;
                    }
                    if (v = f[21376 + (x * 28 | 0) + (p << 2) >> 2] | 0, (v | 0) > 0) {
                      x = p, p = 0;
                      do
                        x = Ac(x) | 0, p = p + 1 | 0;
                      while ((p | 0) != (v | 0));
                    } else
                      x = p;
                    if ((x | 0) == 1) {
                      x = 9;
                      break e;
                    }
                    p = mx(re, x) | 0, (p | 0) == 127 && Ve(27648, 27538, 411, 27678), Ni(p) | 0 ? Ve(27693, 27538, 412, 27678) : (ae = p, se = v, Q = x);
                  } else
                    ae = x, se = 0, Q = p;
                  if (M = f[4272 + (re * 28 | 0) + (Q << 2) >> 2] | 0, (M | 0) <= -1 && Ve(27724, 27538, 419, 27678), !P) {
                    if ((se | 0) < 0) {
                      x = 5;
                      break e;
                    }
                    if (se | 0) {
                      v = g, x = 0, p = f[v >> 2] | 0, v = f[v + 4 >> 2] | 0;
                      do
                        p = pc(p, v) | 0, v = V() | 0, be = g, f[be >> 2] = p, f[be + 4 >> 2] = v, x = x + 1 | 0;
                      while ((x | 0) < (se | 0));
                    }
                    if ((M | 0) <= 0) {
                      x = ae, p = 58;
                      break;
                    }
                    for (v = g, x = 0, p = f[v >> 2] | 0, v = f[v + 4 >> 2] | 0; ; )
                      if (p = pc(p, v) | 0, v = V() | 0, be = g, f[be >> 2] = p, f[be + 4 >> 2] = v, x = x + 1 | 0, (x | 0) == (M | 0)) {
                        x = ae, p = 58;
                        break t;
                      }
                  }
                  if (w = gx(ae, re) | 0, (w | 0) == 7 && Ve(27514, 27538, 428, 27678), x = g, p = f[x >> 2] | 0, x = f[x + 4 >> 2] | 0, (M | 0) > 0) {
                    v = 0;
                    do
                      p = pc(p, x) | 0, x = V() | 0, be = g, f[be >> 2] = p, f[be + 4 >> 2] = x, v = v + 1 | 0;
                    while ((v | 0) != (M | 0));
                  }
                  if (x = Vs(p, x) | 0, (x | 0) == 7 && Ve(27795, 27538, 440, 27678), p = px(ae) | 0, p = f[(p ? 21792 : 21584) + (w * 28 | 0) + (x << 2) >> 2] | 0, (p | 0) < 0 && Ve(27795, 27538, 454, 27678), !p)
                    x = ae, p = 58;
                  else {
                    w = g, x = 0, v = f[w >> 2] | 0, w = f[w + 4 >> 2] | 0;
                    do
                      v = Ex(v, w) | 0, w = V() | 0, be = g, f[be >> 2] = v, f[be + 4 >> 2] = w, x = x + 1 | 0;
                    while ((x | 0) < (p | 0));
                    x = ae, p = 58;
                  }
                } else if ((k | 0) != 0 & (P | 0) != 0) {
                  if (p = Vs(d, h) | 0, v = g, v = Vs(f[v >> 2] | 0, f[v + 4 >> 2] | 0) | 0, (p | 0) == 7 | (v | 0) == 7) {
                    x = 5;
                    break e;
                  }
                  if (v = f[21376 + (p * 28 | 0) + (v << 2) >> 2] | 0, (v | 0) < 0) {
                    x = 5;
                    break e;
                  }
                  if (!v)
                    p = 59;
                  else {
                    M = g, p = 0, w = f[M >> 2] | 0, M = f[M + 4 >> 2] | 0;
                    do
                      w = pc(w, M) | 0, M = V() | 0, be = g, f[be >> 2] = w, f[be + 4 >> 2] = M, p = p + 1 | 0;
                    while ((p | 0) < (v | 0));
                    p = 58;
                  }
                } else
                  p = 58;
              while (!1);
              if ((p | 0) == 58 && P && (p = 59), (p | 0) == 59 && (be = g, (Vs(f[be >> 2] | 0, f[be + 4 >> 2] | 0) | 0) == 1)) {
                x = 9;
                break;
              }
              be = g, Re = f[be >> 2] | 0, be = f[be + 4 >> 2] & -1040385, we = Ze(x | 0, 0, 45) | 0, be = be | (V() | 0), x = g, f[x >> 2] = Re | we, f[x + 4 >> 2] = be, x = 0;
            } else
              x = 1;
        while (!1);
        return be = x, q = Ae, be | 0;
      }
      function QB(d, h, p, g, x, v) {
        d = d | 0, h = h | 0, p = p | 0, g = g | 0, x = x | 0, v = v | 0;
        var w = 0, M = 0;
        return M = q, q = q + 16 | 0, w = M, x ? d = 15 : (d = fl(d, h, p, g, w) | 0, d || (oB(w, v), d = 0)), q = M, d | 0;
      }
      function KB(d, h, p, g, x) {
        d = d | 0, h = h | 0, p = p | 0, g = g | 0, x = x | 0;
        var v = 0, w = 0;
        return w = q, q = q + 16 | 0, v = w, g ? p = 15 : (p = aB(p, v) | 0, p || (p = Xw(d, h, v, x) | 0)), q = w, p | 0;
      }
      function ZB(d, h, p, g, x) {
        d = d | 0, h = h | 0, p = p | 0, g = g | 0, x = x | 0;
        var v = 0, w = 0, M = 0, P = 0;
        return P = q, q = q + 32 | 0, w = P + 12 | 0, M = P, v = fl(d, h, d, h, w) | 0, v | 0 ? (M = v, q = P, M | 0) : (d = fl(d, h, p, g, M) | 0, d | 0 ? (M = d, q = P, M | 0) : (w = vx(w, M) | 0, M = x, f[M >> 2] = w, f[M + 4 >> 2] = ((w | 0) < 0) << 31 >> 31, M = 0, q = P, M | 0));
      }
      function JB(d, h, p, g, x) {
        d = d | 0, h = h | 0, p = p | 0, g = g | 0, x = x | 0;
        var v = 0, w = 0, M = 0, P = 0;
        return P = q, q = q + 32 | 0, w = P + 12 | 0, M = P, v = fl(d, h, d, h, w) | 0, !v && (v = fl(d, h, p, g, M) | 0, !v) ? (g = vx(w, M) | 0, g = jt(g | 0, ((g | 0) < 0) << 31 >> 31 | 0, 1, 0) | 0, w = V() | 0, M = x, f[M >> 2] = g, f[M + 4 >> 2] = w, M = 0, q = P, M | 0) : (M = v, q = P, M | 0);
      }
      function eF(d, h, p, g, x) {
        d = d | 0, h = h | 0, p = p | 0, g = g | 0, x = x | 0;
        var v = 0, w = 0, M = 0, P = 0, I = 0, k = 0, Q = 0, re = 0, se = 0, ae = 0, Ae = 0, ye = 0, Re = 0, we = 0, be = 0, me = 0, nt = 0, qt = 0, Pt = 0, mn = 0;
        if (Pt = q, q = q + 48 | 0, nt = Pt + 24 | 0, w = Pt + 12 | 0, qt = Pt, v = fl(d, h, d, h, nt) | 0, !v && (v = fl(d, h, p, g, w) | 0, !v)) {
          be = vx(nt, w) | 0, me = ((be | 0) < 0) << 31 >> 31, f[nt >> 2] = 0, f[nt + 4 >> 2] = 0, f[nt + 8 >> 2] = 0, f[w >> 2] = 0, f[w + 4 >> 2] = 0, f[w + 8 >> 2] = 0, fl(d, h, d, h, nt) | 0 && Ve(27795, 27538, 692, 27747), fl(d, h, p, g, w) | 0 && Ve(27795, 27538, 697, 27747), Bw(nt), Bw(w), k = (be | 0) == 0 ? 0 : 1 / +(be | 0), p = f[nt >> 2] | 0, Ae = k * +((f[w >> 2] | 0) - p | 0), ye = nt + 4 | 0, g = f[ye >> 2] | 0, Re = k * +((f[w + 4 >> 2] | 0) - g | 0), we = nt + 8 | 0, v = f[we >> 2] | 0, k = k * +((f[w + 8 >> 2] | 0) - v | 0), f[qt >> 2] = p, Q = qt + 4 | 0, f[Q >> 2] = g, re = qt + 8 | 0, f[re >> 2] = v;
          e: do
            if ((be | 0) < 0)
              v = 0;
            else
              for (se = 0, ae = 0; ; ) {
                P = +(ae >>> 0) + 4294967296 * +(se | 0), mn = Ae * P + +(p | 0), M = Re * P + +(g | 0), P = k * P + +(v | 0), p = ~~+im(+mn), w = ~~+im(+M), v = ~~+im(+P), mn = +yn(+(+(p | 0) - mn)), M = +yn(+(+(w | 0) - M)), P = +yn(+(+(v | 0) - P));
                do
                  if (mn > M & mn > P)
                    p = 0 - (w + v) | 0, g = w;
                  else if (I = 0 - p | 0, M > P) {
                    g = I - v | 0;
                    break;
                  } else {
                    g = w, v = I - w | 0;
                    break;
                  }
                while (!1);
                if (f[qt >> 2] = p, f[Q >> 2] = g, f[re >> 2] = v, lB(qt), v = Xw(d, h, qt, x + (ae << 3) | 0) | 0, v | 0)
                  break e;
                if (!((se | 0) < (me | 0) | (se | 0) == (me | 0) & ae >>> 0 < be >>> 0)) {
                  v = 0;
                  break e;
                }
                p = jt(ae | 0, se | 0, 1, 0) | 0, g = V() | 0, se = g, ae = p, p = f[nt >> 2] | 0, g = f[ye >> 2] | 0, v = f[we >> 2] | 0;
              }
          while (!1);
          return qt = v, q = Pt, qt | 0;
        }
        return qt = v, q = Pt, qt | 0;
      }
      function ru(d, h, p, g) {
        d = d | 0, h = h | 0, p = p | 0, g = g | 0;
        var x = 0, v = 0, w = 0;
        if ((p | 0) == 0 & (g | 0) == 0)
          return x = 0, v = 1, xe(x | 0), v | 0;
        v = d, x = h, d = 1, h = 0;
        do
          w = (p & 1 | 0) == 0 & !0, d = Mr((w ? 1 : v) | 0, (w ? 0 : x) | 0, d | 0, h | 0) | 0, h = V() | 0, p = aM(p | 0, g | 0, 1) | 0, g = V() | 0, v = Mr(v | 0, x | 0, v | 0, x | 0) | 0, x = V() | 0;
        while (!((p | 0) == 0 & (g | 0) == 0));
        return xe(h | 0), d | 0;
      }
      function Bx(d, h, p, g) {
        d = d | 0, h = h | 0, p = p | 0, g = g | 0;
        var x = 0, v = 0, w = 0, M = 0, P = 0, I = 0, k = 0;
        M = q, q = q + 16 | 0, v = M, w = qe(d | 0, h | 0, 52) | 0, V() | 0, w = w & 15;
        do
          if (w) {
            if (x = mc(d, h, v) | 0, !x) {
              I = +$[v >> 3], P = 1 / +On(+I), k = +$[25968 + (w << 3) >> 3], $[p >> 3] = I + k, $[p + 8 >> 3] = I - k, I = +$[v + 8 >> 3], P = k * P, $[p + 16 >> 3] = P + I, $[p + 24 >> 3] = I - P;
              break;
            }
            return w = x, q = M, w | 0;
          } else {
            if (x = qe(d | 0, h | 0, 45) | 0, V() | 0, x = x & 127, x >>> 0 > 121)
              return w = 5, q = M, w | 0;
            v = 22064 + (x << 5) | 0, f[p >> 2] = f[v >> 2], f[p + 4 >> 2] = f[v + 4 >> 2], f[p + 8 >> 2] = f[v + 8 >> 2], f[p + 12 >> 2] = f[v + 12 >> 2], f[p + 16 >> 2] = f[v + 16 >> 2], f[p + 20 >> 2] = f[v + 20 >> 2], f[p + 24 >> 2] = f[v + 24 >> 2], f[p + 28 >> 2] = f[v + 28 >> 2];
            break;
          }
        while (!1);
        return eB(p, g ? 1.4 : 1.1), g = 26096 + (w << 3) | 0, (f[g >> 2] | 0) == (d | 0) && (f[g + 4 >> 2] | 0) == (h | 0) && ($[p >> 3] = 1.5707963267948966), w = 26224 + (w << 3) | 0, (f[w >> 2] | 0) == (d | 0) && (f[w + 4 >> 2] | 0) == (h | 0) && ($[p + 8 >> 3] = -1.5707963267948966), +$[p >> 3] != 1.5707963267948966 && +$[p + 8 >> 3] != -1.5707963267948966 ? (w = 0, q = M, w | 0) : ($[p + 16 >> 3] = 3.141592653589793, $[p + 24 >> 3] = -3.141592653589793, w = 0, q = M, w | 0);
      }
      function tF(d, h, p, g) {
        d = d | 0, h = h | 0, p = p | 0, g = g | 0;
        var x = 0, v = 0, w = 0, M = 0, P = 0, I = 0, k = 0;
        I = q, q = q + 48 | 0, w = I + 32 | 0, v = I + 40 | 0, M = I, wx(w, 0, 0, 0), P = f[w >> 2] | 0, w = f[w + 4 >> 2] | 0;
        do
          if (p >>> 0 <= 15) {
            if (x = SA(g) | 0, x | 0) {
              g = M, f[g >> 2] = 0, f[g + 4 >> 2] = 0, f[M + 8 >> 2] = x, f[M + 12 >> 2] = -1, g = M + 16 | 0, P = M + 29 | 0, f[g >> 2] = 0, f[g + 4 >> 2] = 0, f[g + 8 >> 2] = 0, $e[g + 12 >> 0] = 0, $e[P >> 0] = $e[v >> 0] | 0, $e[P + 1 >> 0] = $e[v + 1 >> 0] | 0, $e[P + 2 >> 0] = $e[v + 2 >> 0] | 0;
              break;
            }
            if (x = Gs((f[h + 8 >> 2] | 0) + 1 | 0, 32) | 0, x) {
              Fx(h, x), k = M, f[k >> 2] = P, f[k + 4 >> 2] = w, f[M + 8 >> 2] = 0, f[M + 12 >> 2] = p, f[M + 16 >> 2] = g, f[M + 20 >> 2] = h, f[M + 24 >> 2] = x, $e[M + 28 >> 0] = 0, P = M + 29 | 0, $e[P >> 0] = $e[v >> 0] | 0, $e[P + 1 >> 0] = $e[v + 1 >> 0] | 0, $e[P + 2 >> 0] = $e[v + 2 >> 0] | 0;
              break;
            } else {
              g = M, f[g >> 2] = 0, f[g + 4 >> 2] = 0, f[M + 8 >> 2] = 13, f[M + 12 >> 2] = -1, g = M + 16 | 0, P = M + 29 | 0, f[g >> 2] = 0, f[g + 4 >> 2] = 0, f[g + 8 >> 2] = 0, $e[g + 12 >> 0] = 0, $e[P >> 0] = $e[v >> 0] | 0, $e[P + 1 >> 0] = $e[v + 1 >> 0] | 0, $e[P + 2 >> 0] = $e[v + 2 >> 0] | 0;
              break;
            }
          } else
            P = M, f[P >> 2] = 0, f[P + 4 >> 2] = 0, f[M + 8 >> 2] = 4, f[M + 12 >> 2] = -1, P = M + 16 | 0, k = M + 29 | 0, f[P >> 2] = 0, f[P + 4 >> 2] = 0, f[P + 8 >> 2] = 0, $e[P + 12 >> 0] = 0, $e[k >> 0] = $e[v >> 0] | 0, $e[k + 1 >> 0] = $e[v + 1 >> 0] | 0, $e[k + 2 >> 0] = $e[v + 2 >> 0] | 0;
        while (!1);
        em(M), f[d >> 2] = f[M >> 2], f[d + 4 >> 2] = f[M + 4 >> 2], f[d + 8 >> 2] = f[M + 8 >> 2], f[d + 12 >> 2] = f[M + 12 >> 2], f[d + 16 >> 2] = f[M + 16 >> 2], f[d + 20 >> 2] = f[M + 20 >> 2], f[d + 24 >> 2] = f[M + 24 >> 2], f[d + 28 >> 2] = f[M + 28 >> 2], q = I;
      }
      function em(d) {
        d = d | 0;
        var h = 0, p = 0, g = 0, x = 0, v = 0, w = 0, M = 0, P = 0, I = 0, k = 0, Q = 0, re = 0, se = 0, ae = 0, Ae = 0, ye = 0, Re = 0, we = 0, be = 0, me = 0;
        if (me = q, q = q + 336 | 0, se = me + 168 | 0, ae = me, g = d, p = f[g >> 2] | 0, g = f[g + 4 >> 2] | 0, (p | 0) == 0 & (g | 0) == 0) {
          q = me;
          return;
        }
        if (h = d + 28 | 0, $e[h >> 0] | 0 ? (p = Yw(p, g) | 0, g = V() | 0) : $e[h >> 0] = 1, be = d + 20 | 0, !(f[f[be >> 2] >> 2] | 0)) {
          h = d + 24 | 0, p = f[h >> 2] | 0, p | 0 && Qt(p), we = d, f[we >> 2] = 0, f[we + 4 >> 2] = 0, f[d + 8 >> 2] = 0, f[be >> 2] = 0, f[d + 12 >> 2] = -1, f[d + 16 >> 2] = 0, f[h >> 2] = 0, q = me;
          return;
        }
        we = d + 16 | 0, h = f[we >> 2] | 0, x = h & 15;
        e: do
          if ((p | 0) == 0 & (g | 0) == 0)
            Re = d + 24 | 0;
          else {
            Ae = d + 12 | 0, Q = (x | 0) == 3, k = h & 255, P = (x | 1 | 0) == 3, re = d + 24 | 0, I = (x + -1 | 0) >>> 0 < 3, w = (x | 2 | 0) == 3, M = ae + 8 | 0;
            t: for (; ; ) {
              if (v = qe(p | 0, g | 0, 52) | 0, V() | 0, v = v & 15, (v | 0) == (f[Ae >> 2] | 0)) {
                switch (k & 15) {
                  case 0:
                  case 2:
                  case 3: {
                    if (x = mc(p, g, se) | 0, x | 0) {
                      ye = 15;
                      break t;
                    }
                    if (Ux(f[be >> 2] | 0, f[re >> 2] | 0, se) | 0) {
                      ye = 19;
                      break t;
                    }
                    break;
                  }
                }
                if (P && (x = f[(f[be >> 2] | 0) + 4 >> 2] | 0, f[se >> 2] = f[x >> 2], f[se + 4 >> 2] = f[x + 4 >> 2], f[se + 8 >> 2] = f[x + 8 >> 2], f[se + 12 >> 2] = f[x + 12 >> 2], _x(26832, se) | 0)) {
                  if (Cx(f[(f[be >> 2] | 0) + 4 >> 2] | 0, v, ae) | 0) {
                    ye = 25;
                    break;
                  }
                  if (x = ae, (f[x >> 2] | 0) == (p | 0) && (f[x + 4 >> 2] | 0) == (g | 0)) {
                    ye = 29;
                    break;
                  }
                }
                if (I) {
                  if (x = dd(p, g, se) | 0, x | 0) {
                    ye = 32;
                    break;
                  }
                  if (Bx(p, g, ae, 0) | 0) {
                    ye = 36;
                    break;
                  }
                  if (w && Kw(f[be >> 2] | 0, f[re >> 2] | 0, se, ae) | 0) {
                    ye = 42;
                    break;
                  }
                  if (P && Zw(f[be >> 2] | 0, f[re >> 2] | 0, se, ae) | 0) {
                    ye = 42;
                    break;
                  }
                }
                if (Q) {
                  if (h = Bx(p, g, se, 1) | 0, x = f[re >> 2] | 0, h | 0) {
                    ye = 45;
                    break;
                  }
                  if (xx(x, se) | 0) {
                    if (Ew(ae, se), Mw(se, f[re >> 2] | 0) | 0) {
                      ye = 53;
                      break;
                    }
                    if (Ux(f[be >> 2] | 0, f[re >> 2] | 0, M) | 0) {
                      ye = 53;
                      break;
                    }
                    if (Zw(f[be >> 2] | 0, f[re >> 2] | 0, ae, se) | 0) {
                      ye = 53;
                      break;
                    }
                  }
                }
              }
              do
                if ((v | 0) < (f[Ae >> 2] | 0)) {
                  if (h = Bx(p, g, se, 1) | 0, x = f[re >> 2] | 0, h | 0) {
                    ye = 58;
                    break t;
                  }
                  if (!(xx(x, se) | 0)) {
                    ye = 73;
                    break;
                  }
                  if (Mw(f[re >> 2] | 0, se) | 0 && (Ew(ae, se), Kw(f[be >> 2] | 0, f[re >> 2] | 0, ae, se) | 0)) {
                    ye = 65;
                    break t;
                  }
                  if (p = Gw(p, g, v + 1 | 0, ae) | 0, p | 0) {
                    ye = 67;
                    break t;
                  }
                  g = ae, p = f[g >> 2] | 0, g = f[g + 4 >> 2] | 0;
                } else
                  ye = 73;
              while (!1);
              if ((ye | 0) == 73 && (ye = 0, p = Yw(p, g) | 0, g = V() | 0), (p | 0) == 0 & (g | 0) == 0) {
                Re = re;
                break e;
              }
            }
            switch (ye | 0) {
              case 15: {
                h = f[re >> 2] | 0, h | 0 && Qt(h), ye = d, f[ye >> 2] = 0, f[ye + 4 >> 2] = 0, f[be >> 2] = 0, f[Ae >> 2] = -1, f[we >> 2] = 0, f[re >> 2] = 0, f[d + 8 >> 2] = x, ye = 20;
                break;
              }
              case 19: {
                f[d >> 2] = p, f[d + 4 >> 2] = g, ye = 20;
                break;
              }
              case 25: {
                Ve(27795, 27761, 470, 27772);
                break;
              }
              case 29: {
                f[d >> 2] = p, f[d + 4 >> 2] = g, q = me;
                return;
              }
              case 32: {
                h = f[re >> 2] | 0, h | 0 && Qt(h), Re = d, f[Re >> 2] = 0, f[Re + 4 >> 2] = 0, f[be >> 2] = 0, f[Ae >> 2] = -1, f[we >> 2] = 0, f[re >> 2] = 0, f[d + 8 >> 2] = x, q = me;
                return;
              }
              case 36: {
                Ve(27795, 27761, 493, 27772);
                break;
              }
              case 42: {
                f[d >> 2] = p, f[d + 4 >> 2] = g, q = me;
                return;
              }
              case 45: {
                x | 0 && Qt(x), ye = d, f[ye >> 2] = 0, f[ye + 4 >> 2] = 0, f[be >> 2] = 0, f[Ae >> 2] = -1, f[we >> 2] = 0, f[re >> 2] = 0, f[d + 8 >> 2] = h, ye = 55;
                break;
              }
              case 53: {
                f[d >> 2] = p, f[d + 4 >> 2] = g, ye = 55;
                break;
              }
              case 58: {
                x | 0 && Qt(x), ye = d, f[ye >> 2] = 0, f[ye + 4 >> 2] = 0, f[be >> 2] = 0, f[Ae >> 2] = -1, f[we >> 2] = 0, f[re >> 2] = 0, f[d + 8 >> 2] = h, ye = 71;
                break;
              }
              case 65: {
                f[d >> 2] = p, f[d + 4 >> 2] = g, ye = 71;
                break;
              }
              case 67: {
                h = f[re >> 2] | 0, h | 0 && Qt(h), Re = d, f[Re >> 2] = 0, f[Re + 4 >> 2] = 0, f[be >> 2] = 0, f[Ae >> 2] = -1, f[we >> 2] = 0, f[re >> 2] = 0, f[d + 8 >> 2] = p, q = me;
                return;
              }
            }
            if ((ye | 0) == 20) {
              q = me;
              return;
            } else if ((ye | 0) == 55) {
              q = me;
              return;
            } else if ((ye | 0) == 71) {
              q = me;
              return;
            }
          }
        while (!1);
        h = f[Re >> 2] | 0, h | 0 && Qt(h), ye = d, f[ye >> 2] = 0, f[ye + 4 >> 2] = 0, f[d + 8 >> 2] = 0, f[be >> 2] = 0, f[d + 12 >> 2] = -1, f[we >> 2] = 0, f[Re >> 2] = 0, q = me;
      }
      function Yw(d, h) {
        d = d | 0, h = h | 0;
        var p = 0, g = 0, x = 0, v = 0, w = 0, M = 0, P = 0, I = 0, k = 0, Q = 0;
        Q = q, q = q + 16 | 0, k = Q, g = qe(d | 0, h | 0, 52) | 0, V() | 0, g = g & 15, p = qe(d | 0, h | 0, 45) | 0, V() | 0;
        do
          if (g) {
            for (; p = Ze(g + 4095 | 0, 0, 52) | 0, x = V() | 0 | h & -15728641, v = (15 - g | 0) * 3 | 0, w = Ze(7, 0, v | 0) | 0, M = V() | 0, p = p | d | w, x = x | M, P = qe(d | 0, h | 0, v | 0) | 0, V() | 0, P = P & 7, g = g + -1 | 0, !(P >>> 0 < 6); )
              if (g)
                h = x, d = p;
              else {
                I = 4;
                break;
              }
            if ((I | 0) == 4) {
              p = qe(p | 0, x | 0, 45) | 0, V() | 0;
              break;
            }
            return k = (P | 0) == 0 & (xi(p, x) | 0) != 0, k = Ze((k ? 2 : 1) + P | 0, 0, v | 0) | 0, I = V() | 0 | h & ~M, k = k | d & ~w, xe(I | 0), q = Q, k | 0;
          }
        while (!1);
        return p = p & 127, p >>> 0 > 120 ? (I = 0, k = 0, xe(I | 0), q = Q, k | 0) : (wx(k, 0, p + 1 | 0, 0), I = f[k + 4 >> 2] | 0, k = f[k >> 2] | 0, xe(I | 0), q = Q, k | 0);
      }
      function nF(d, h, p, g, x, v) {
        d = d | 0, h = h | 0, p = p | 0, g = g | 0, x = x | 0, v = v | 0;
        var w = 0, M = 0, P = 0, I = 0, k = 0, Q = 0, re = 0, se = 0, ae = 0, Ae = 0, ye = 0;
        ye = q, q = q + 160 | 0, Q = ye + 80 | 0, M = ye + 64 | 0, re = ye + 112 | 0, Ae = ye, tF(Q, d, h, p), I = Q, Dx(M, f[I >> 2] | 0, f[I + 4 >> 2] | 0, h), I = M, P = f[I >> 2] | 0, I = f[I + 4 >> 2] | 0, w = f[Q + 8 >> 2] | 0, se = re + 4 | 0, f[se >> 2] = f[Q >> 2], f[se + 4 >> 2] = f[Q + 4 >> 2], f[se + 8 >> 2] = f[Q + 8 >> 2], f[se + 12 >> 2] = f[Q + 12 >> 2], f[se + 16 >> 2] = f[Q + 16 >> 2], f[se + 20 >> 2] = f[Q + 20 >> 2], f[se + 24 >> 2] = f[Q + 24 >> 2], f[se + 28 >> 2] = f[Q + 28 >> 2], se = Ae, f[se >> 2] = P, f[se + 4 >> 2] = I, se = Ae + 8 | 0, f[se >> 2] = w, d = Ae + 12 | 0, h = re, p = d + 36 | 0;
        do
          f[d >> 2] = f[h >> 2], d = d + 4 | 0, h = h + 4 | 0;
        while ((d | 0) < (p | 0));
        if (re = Ae + 48 | 0, f[re >> 2] = f[M >> 2], f[re + 4 >> 2] = f[M + 4 >> 2], f[re + 8 >> 2] = f[M + 8 >> 2], f[re + 12 >> 2] = f[M + 12 >> 2], (P | 0) == 0 & (I | 0) == 0)
          return Ae = w, q = ye, Ae | 0;
        p = Ae + 16 | 0, k = Ae + 24 | 0, Q = Ae + 28 | 0, w = 0, M = 0, h = P, d = I;
        do {
          if (!((w | 0) < (x | 0) | (w | 0) == (x | 0) & M >>> 0 < g >>> 0)) {
            ae = 4;
            break;
          }
          if (I = M, M = jt(M | 0, w | 0, 1, 0) | 0, w = V() | 0, I = v + (I << 3) | 0, f[I >> 2] = h, f[I + 4 >> 2] = d, Lx(re), d = re, h = f[d >> 2] | 0, d = f[d + 4 >> 2] | 0, (h | 0) == 0 & (d | 0) == 0) {
            if (em(p), h = p, d = f[h >> 2] | 0, h = f[h + 4 >> 2] | 0, (d | 0) == 0 & (h | 0) == 0) {
              ae = 10;
              break;
            }
            qw(d, h, f[Q >> 2] | 0, re), d = re, h = f[d >> 2] | 0, d = f[d + 4 >> 2] | 0;
          }
          I = Ae, f[I >> 2] = h, f[I + 4 >> 2] = d;
        } while (!((h | 0) == 0 & (d | 0) == 0));
        return (ae | 0) == 4 ? (d = Ae + 40 | 0, h = f[d >> 2] | 0, h | 0 && Qt(h), ae = Ae + 16 | 0, f[ae >> 2] = 0, f[ae + 4 >> 2] = 0, f[k >> 2] = 0, f[Ae + 36 >> 2] = 0, f[Q >> 2] = -1, f[Ae + 32 >> 2] = 0, f[d >> 2] = 0, qw(0, 0, 0, re), f[Ae >> 2] = 0, f[Ae + 4 >> 2] = 0, f[se >> 2] = 0, Ae = 14, q = ye, Ae | 0) : ((ae | 0) == 10 && (f[Ae >> 2] = 0, f[Ae + 4 >> 2] = 0, f[se >> 2] = f[k >> 2]), Ae = f[se >> 2] | 0, q = ye, Ae | 0);
      }
      function iF(d, h, p, g) {
        d = d | 0, h = h | 0, p = p | 0, g = g | 0;
        var x = 0, v = 0, w = 0, M = 0, P = 0, I = 0, k = 0, Q = 0, re = 0, se = 0;
        if (Q = q, q = q + 48 | 0, P = Q + 32 | 0, M = Q + 40 | 0, I = Q, !(f[d >> 2] | 0))
          return k = g, f[k >> 2] = 0, f[k + 4 >> 2] = 0, k = 0, q = Q, k | 0;
        wx(P, 0, 0, 0), w = P, x = f[w >> 2] | 0, w = f[w + 4 >> 2] | 0;
        do
          if (h >>> 0 > 15)
            k = I, f[k >> 2] = 0, f[k + 4 >> 2] = 0, f[I + 8 >> 2] = 4, f[I + 12 >> 2] = -1, k = I + 16 | 0, p = I + 29 | 0, f[k >> 2] = 0, f[k + 4 >> 2] = 0, f[k + 8 >> 2] = 0, $e[k + 12 >> 0] = 0, $e[p >> 0] = $e[M >> 0] | 0, $e[p + 1 >> 0] = $e[M + 1 >> 0] | 0, $e[p + 2 >> 0] = $e[M + 2 >> 0] | 0, p = 4, k = 9;
          else {
            if (p = SA(p) | 0, p | 0) {
              P = I, f[P >> 2] = 0, f[P + 4 >> 2] = 0, f[I + 8 >> 2] = p, f[I + 12 >> 2] = -1, P = I + 16 | 0, k = I + 29 | 0, f[P >> 2] = 0, f[P + 4 >> 2] = 0, f[P + 8 >> 2] = 0, $e[P + 12 >> 0] = 0, $e[k >> 0] = $e[M >> 0] | 0, $e[k + 1 >> 0] = $e[M + 1 >> 0] | 0, $e[k + 2 >> 0] = $e[M + 2 >> 0] | 0, k = 9;
              break;
            }
            if (p = Gs((f[d + 8 >> 2] | 0) + 1 | 0, 32) | 0, !p) {
              k = I, f[k >> 2] = 0, f[k + 4 >> 2] = 0, f[I + 8 >> 2] = 13, f[I + 12 >> 2] = -1, k = I + 16 | 0, p = I + 29 | 0, f[k >> 2] = 0, f[k + 4 >> 2] = 0, f[k + 8 >> 2] = 0, $e[k + 12 >> 0] = 0, $e[p >> 0] = $e[M >> 0] | 0, $e[p + 1 >> 0] = $e[M + 1 >> 0] | 0, $e[p + 2 >> 0] = $e[M + 2 >> 0] | 0, p = 13, k = 9;
              break;
            }
            Fx(d, p), se = I, f[se >> 2] = x, f[se + 4 >> 2] = w, w = I + 8 | 0, f[w >> 2] = 0, f[I + 12 >> 2] = h, f[I + 20 >> 2] = d, f[I + 24 >> 2] = p, $e[I + 28 >> 0] = 0, x = I + 29 | 0, $e[x >> 0] = $e[M >> 0] | 0, $e[x + 1 >> 0] = $e[M + 1 >> 0] | 0, $e[x + 2 >> 0] = $e[M + 2 >> 0] | 0, f[I + 16 >> 2] = 3, re = +K7(p), re = re * +Q7(p), v = +yn(+ +$[p >> 3]), v = re / +On(+ +nm(+v, + +yn(+ +$[p + 8 >> 3]))) * 6371.007180918475 * 6371.007180918475, x = I + 12 | 0, p = f[x >> 2] | 0;
            e: do
              if ((p | 0) > 0)
                do {
                  if (Hw(p + -1 | 0, P) | 0, !(v / +$[P >> 3] > 10))
                    break e;
                  se = f[x >> 2] | 0, p = se + -1 | 0, f[x >> 2] = p;
                } while ((se | 0) > 1);
            while (!1);
            if (em(I), x = g, f[x >> 2] = 0, f[x + 4 >> 2] = 0, x = I, p = f[x >> 2] | 0, x = f[x + 4 >> 2] | 0, !((p | 0) == 0 & (x | 0) == 0))
              do
                xA(p, x, h, P) | 0, M = P, d = g, M = jt(f[d >> 2] | 0, f[d + 4 >> 2] | 0, f[M >> 2] | 0, f[M + 4 >> 2] | 0) | 0, d = V() | 0, se = g, f[se >> 2] = M, f[se + 4 >> 2] = d, em(I), se = I, p = f[se >> 2] | 0, x = f[se + 4 >> 2] | 0;
              while (!((p | 0) == 0 & (x | 0) == 0));
            p = f[w >> 2] | 0;
          }
        while (!1);
        return se = p, q = Q, se | 0;
      }
      function bA(d, h, p) {
        d = d | 0, h = h | 0, p = p | 0;
        var g = 0, x = 0, v = 0, w = 0, M = 0, P = 0, I = 0, k = 0, Q = 0, re = 0;
        if (!(_x(h, p) | 0) || (h = ww(h) | 0, g = +$[p >> 3], x = +$[p + 8 >> 3], x = h & x < 0 ? x + 6.283185307179586 : x, re = f[d >> 2] | 0, (re | 0) <= 0))
          return re = 0, re | 0;
        if (Q = f[d + 4 >> 2] | 0, h) {
          h = 0, k = x, p = -1, d = 0;
          e: for (; ; ) {
            for (I = d; w = +$[Q + (I << 4) >> 3], x = +$[Q + (I << 4) + 8 >> 3], d = (p + 2 | 0) % (re | 0) | 0, v = +$[Q + (d << 4) >> 3], M = +$[Q + (d << 4) + 8 >> 3], w > v ? (P = w, w = M) : (P = v, v = w, w = x, x = M), g = g == v | g == P ? g + 2220446049250313e-31 : g, !!(g < v | g > P); )
              if (p = I + 1 | 0, (p | 0) >= (re | 0)) {
                p = 22;
                break e;
              } else
                d = I, I = p, p = d;
            if (M = w < 0 ? w + 6.283185307179586 : w, w = x < 0 ? x + 6.283185307179586 : x, k = M == k | w == k ? k + -2220446049250313e-31 : k, P = M + (w - M) * ((g - v) / (P - v)), (P < 0 ? P + 6.283185307179586 : P) > k && (h = h ^ 1), d = I + 1 | 0, (d | 0) >= (re | 0)) {
              p = 22;
              break;
            } else
              p = I;
          }
          if ((p | 0) == 22)
            return h | 0;
        } else {
          h = 0, k = x, p = -1, d = 0;
          e: for (; ; ) {
            for (I = d; w = +$[Q + (I << 4) >> 3], x = +$[Q + (I << 4) + 8 >> 3], d = (p + 2 | 0) % (re | 0) | 0, v = +$[Q + (d << 4) >> 3], M = +$[Q + (d << 4) + 8 >> 3], w > v ? (P = w, w = M) : (P = v, v = w, w = x, x = M), g = g == v | g == P ? g + 2220446049250313e-31 : g, !!(g < v | g > P); )
              if (p = I + 1 | 0, (p | 0) >= (re | 0)) {
                p = 22;
                break e;
              } else
                d = I, I = p, p = d;
            if (k = w == k | x == k ? k + -2220446049250313e-31 : k, w + (x - w) * ((g - v) / (P - v)) > k && (h = h ^ 1), d = I + 1 | 0, (d | 0) >= (re | 0)) {
              p = 22;
              break;
            } else
              p = I;
          }
          if ((p | 0) == 22)
            return h | 0;
        }
        return 0;
      }
      function Qw(d, h) {
        d = d | 0, h = h | 0;
        var p = 0, g = 0, x = 0, v = 0, w = 0, M = 0, P = 0, I = 0, k = 0, Q = 0, re = 0, se = 0, ae = 0, Ae = 0, ye = 0, Re = 0, we = 0;
        if (ae = f[d >> 2] | 0, !ae) {
          f[h >> 2] = 0, f[h + 4 >> 2] = 0, f[h + 8 >> 2] = 0, f[h + 12 >> 2] = 0, f[h + 16 >> 2] = 0, f[h + 20 >> 2] = 0, f[h + 24 >> 2] = 0, f[h + 28 >> 2] = 0;
          return;
        }
        if (Ae = h + 8 | 0, $[Ae >> 3] = 17976931348623157e292, ye = h + 24 | 0, $[ye >> 3] = 17976931348623157e292, $[h >> 3] = -17976931348623157e292, Re = h + 16 | 0, $[Re >> 3] = -17976931348623157e292, !((ae | 0) <= 0)) {
          for (re = f[d + 4 >> 2] | 0, I = 17976931348623157e292, k = -17976931348623157e292, Q = 0, d = -1, v = 17976931348623157e292, w = 17976931348623157e292, P = -17976931348623157e292, g = -17976931348623157e292, se = 0; p = +$[re + (se << 4) >> 3], M = +$[re + (se << 4) + 8 >> 3], d = d + 2 | 0, x = +$[re + (((d | 0) == (ae | 0) ? 0 : d) << 4) + 8 >> 3], p < v && ($[Ae >> 3] = p, v = p), M < w && ($[ye >> 3] = M, w = M), p > P ? $[h >> 3] = p : p = P, M > g && ($[Re >> 3] = M, g = M), I = M > 0 & M < I ? M : I, k = M < 0 & M > k ? M : k, Q = Q | +yn(+(M - x)) > 3.141592653589793, d = se + 1 | 0, (d | 0) != (ae | 0); )
            we = se, P = p, se = d, d = we;
          Q && ($[Re >> 3] = k, $[ye >> 3] = I);
        }
      }
      function SA(d) {
        return d = d | 0, (d >>> 0 < 4 ? 0 : 15) | 0;
      }
      function Fx(d, h) {
        d = d | 0, h = h | 0;
        var p = 0, g = 0, x = 0, v = 0, w = 0, M = 0, P = 0, I = 0, k = 0, Q = 0, re = 0, se = 0, ae = 0, Ae = 0, ye = 0, Re = 0, we = 0, be = 0, me = 0, nt = 0, qt = 0, Pt = 0;
        if (ae = f[d >> 2] | 0, ae) {
          if (Ae = h + 8 | 0, $[Ae >> 3] = 17976931348623157e292, ye = h + 24 | 0, $[ye >> 3] = 17976931348623157e292, $[h >> 3] = -17976931348623157e292, Re = h + 16 | 0, $[Re >> 3] = -17976931348623157e292, (ae | 0) > 0) {
            for (x = f[d + 4 >> 2] | 0, re = 17976931348623157e292, se = -17976931348623157e292, g = 0, p = -1, P = 17976931348623157e292, I = 17976931348623157e292, Q = -17976931348623157e292, w = -17976931348623157e292, we = 0; v = +$[x + (we << 4) >> 3], k = +$[x + (we << 4) + 8 >> 3], qt = p + 2 | 0, M = +$[x + (((qt | 0) == (ae | 0) ? 0 : qt) << 4) + 8 >> 3], v < P && ($[Ae >> 3] = v, P = v), k < I && ($[ye >> 3] = k, I = k), v > Q ? $[h >> 3] = v : v = Q, k > w && ($[Re >> 3] = k, w = k), re = k > 0 & k < re ? k : re, se = k < 0 & k > se ? k : se, g = g | +yn(+(k - M)) > 3.141592653589793, p = we + 1 | 0, (p | 0) != (ae | 0); )
              qt = we, Q = v, we = p, p = qt;
            g && ($[Re >> 3] = se, $[ye >> 3] = re);
          }
        } else
          f[h >> 2] = 0, f[h + 4 >> 2] = 0, f[h + 8 >> 2] = 0, f[h + 12 >> 2] = 0, f[h + 16 >> 2] = 0, f[h + 20 >> 2] = 0, f[h + 24 >> 2] = 0, f[h + 28 >> 2] = 0;
        if (qt = d + 8 | 0, p = f[qt >> 2] | 0, !((p | 0) <= 0)) {
          nt = d + 12 | 0, me = 0;
          do
            if (x = f[nt >> 2] | 0, g = me, me = me + 1 | 0, ye = h + (me << 5) | 0, Re = f[x + (g << 3) >> 2] | 0, Re) {
              if (we = h + (me << 5) + 8 | 0, $[we >> 3] = 17976931348623157e292, d = h + (me << 5) + 24 | 0, $[d >> 3] = 17976931348623157e292, $[ye >> 3] = -17976931348623157e292, be = h + (me << 5) + 16 | 0, $[be >> 3] = -17976931348623157e292, (Re | 0) > 0) {
                for (ae = f[x + (g << 3) + 4 >> 2] | 0, re = 17976931348623157e292, se = -17976931348623157e292, x = 0, g = -1, Ae = 0, P = 17976931348623157e292, I = 17976931348623157e292, k = -17976931348623157e292, w = -17976931348623157e292; v = +$[ae + (Ae << 4) >> 3], Q = +$[ae + (Ae << 4) + 8 >> 3], g = g + 2 | 0, M = +$[ae + (((g | 0) == (Re | 0) ? 0 : g) << 4) + 8 >> 3], v < P && ($[we >> 3] = v, P = v), Q < I && ($[d >> 3] = Q, I = Q), v > k ? $[ye >> 3] = v : v = k, Q > w && ($[be >> 3] = Q, w = Q), re = Q > 0 & Q < re ? Q : re, se = Q < 0 & Q > se ? Q : se, x = x | +yn(+(Q - M)) > 3.141592653589793, g = Ae + 1 | 0, (g | 0) != (Re | 0); )
                  Pt = Ae, Ae = g, k = v, g = Pt;
                x && ($[be >> 3] = se, $[d >> 3] = re);
              }
            } else
              f[ye >> 2] = 0, f[ye + 4 >> 2] = 0, f[ye + 8 >> 2] = 0, f[ye + 12 >> 2] = 0, f[ye + 16 >> 2] = 0, f[ye + 20 >> 2] = 0, f[ye + 24 >> 2] = 0, f[ye + 28 >> 2] = 0, p = f[qt >> 2] | 0;
          while ((me | 0) < (p | 0));
        }
      }
      function Ux(d, h, p) {
        d = d | 0, h = h | 0, p = p | 0;
        var g = 0, x = 0, v = 0;
        if (!(bA(d, h, p) | 0))
          return x = 0, x | 0;
        if (x = d + 8 | 0, (f[x >> 2] | 0) <= 0)
          return x = 1, x | 0;
        for (g = d + 12 | 0, d = 0; ; ) {
          if (v = d, d = d + 1 | 0, bA((f[g >> 2] | 0) + (v << 3) | 0, h + (d << 5) | 0, p) | 0) {
            d = 0, g = 6;
            break;
          }
          if ((d | 0) >= (f[x >> 2] | 0)) {
            d = 1, g = 6;
            break;
          }
        }
        return (g | 0) == 6 ? d | 0 : 0;
      }
      function Kw(d, h, p, g) {
        d = d | 0, h = h | 0, p = p | 0, g = g | 0;
        var x = 0, v = 0, w = 0, M = 0, P = 0, I = 0, k = 0;
        if (I = q, q = q + 16 | 0, M = I, w = p + 8 | 0, !(bA(d, h, w) | 0))
          return P = 0, q = I, P | 0;
        P = d + 8 | 0;
        e: do
          if ((f[P >> 2] | 0) > 0) {
            for (v = d + 12 | 0, x = 0; ; ) {
              if (k = x, x = x + 1 | 0, bA((f[v >> 2] | 0) + (k << 3) | 0, h + (x << 5) | 0, w) | 0) {
                x = 0;
                break;
              }
              if ((x | 0) >= (f[P >> 2] | 0))
                break e;
            }
            return q = I, x | 0;
          }
        while (!1);
        if (tm(d, h, p, g) | 0)
          return k = 0, q = I, k | 0;
        f[M >> 2] = f[p >> 2], f[M + 4 >> 2] = w, x = f[P >> 2] | 0;
        e: do
          if ((x | 0) > 0)
            for (d = d + 12 | 0, w = 0, v = x; ; ) {
              if (x = f[d >> 2] | 0, (f[x + (w << 3) >> 2] | 0) > 0) {
                if (bA(M, g, f[x + (w << 3) + 4 >> 2] | 0) | 0) {
                  x = 0;
                  break e;
                }
                if (x = w + 1 | 0, tm((f[d >> 2] | 0) + (w << 3) | 0, h + (x << 5) | 0, p, g) | 0) {
                  x = 0;
                  break e;
                }
                v = f[P >> 2] | 0;
              } else
                x = w + 1 | 0;
              if ((x | 0) < (v | 0))
                w = x;
              else {
                x = 1;
                break;
              }
            }
          else
            x = 1;
        while (!1);
        return k = x, q = I, k | 0;
      }
      function tm(d, h, p, g) {
        d = d | 0, h = h | 0, p = p | 0, g = g | 0;
        var x = 0, v = 0, w = 0, M = 0, P = 0, I = 0, k = 0, Q = 0, re = 0, se = 0, ae = 0, Ae = 0, ye = 0, Re = 0, we = 0, be = 0, me = 0, nt = 0, qt = 0, Pt = 0, mn = 0;
        if (qt = q, q = q + 176 | 0, we = qt + 172 | 0, x = qt + 168 | 0, be = qt, !(xx(h, g) | 0))
          return d = 0, q = qt, d | 0;
        if (Z7(h, g, we, x), md(be | 0, p | 0, 168) | 0, (f[p >> 2] | 0) > 0) {
          h = 0;
          do
            Pt = be + 8 + (h << 4) + 8 | 0, Re = +ho(+$[Pt >> 3], f[x >> 2] | 0), $[Pt >> 3] = Re, h = h + 1 | 0;
          while ((h | 0) < (f[p >> 2] | 0));
        }
        Ae = +$[g >> 3], ye = +$[g + 8 >> 3], Re = +ho(+$[g + 16 >> 3], f[x >> 2] | 0), se = +ho(+$[g + 24 >> 3], f[x >> 2] | 0);
        e: do
          if ((f[d >> 2] | 0) > 0) {
            if (g = d + 4 | 0, x = f[be >> 2] | 0, (x | 0) <= 0) {
              for (h = 0; ; )
                if (h = h + 1 | 0, (h | 0) >= (f[d >> 2] | 0)) {
                  h = 0;
                  break e;
                }
            }
            for (p = 0; ; ) {
              if (h = f[g >> 2] | 0, re = +$[h + (p << 4) >> 3], ae = +ho(+$[h + (p << 4) + 8 >> 3], f[we >> 2] | 0), h = f[g >> 2] | 0, p = p + 1 | 0, Pt = (p | 0) % (f[d >> 2] | 0) | 0, v = +$[h + (Pt << 4) >> 3], w = +ho(+$[h + (Pt << 4) + 8 >> 3], f[we >> 2] | 0), !(re >= Ae) | !(v >= Ae) && !(re <= ye) | !(v <= ye) && !(ae <= se) | !(w <= se) && !(ae >= Re) | !(w >= Re)) {
                Q = v - re, I = w - ae, h = 0;
                do
                  if (mn = h, h = h + 1 | 0, Pt = (h | 0) == (x | 0) ? 0 : h, v = +$[be + 8 + (mn << 4) + 8 >> 3], w = +$[be + 8 + (Pt << 4) + 8 >> 3] - v, M = +$[be + 8 + (mn << 4) >> 3], P = +$[be + 8 + (Pt << 4) >> 3] - M, k = Q * w - I * P, k != 0 && (me = ae - v, nt = re - M, P = (me * P - w * nt) / k, !(P < 0 | P > 1)) && (k = (Q * me - I * nt) / k, k >= 0 & k <= 1)) {
                    h = 1;
                    break e;
                  }
                while ((h | 0) < (x | 0));
              }
              if ((p | 0) >= (f[d >> 2] | 0)) {
                h = 0;
                break;
              }
            }
          } else
            h = 0;
        while (!1);
        return mn = h, q = qt, mn | 0;
      }
      function Zw(d, h, p, g) {
        d = d | 0, h = h | 0, p = p | 0, g = g | 0;
        var x = 0, v = 0, w = 0;
        if (tm(d, h, p, g) | 0)
          return v = 1, v | 0;
        if (v = d + 8 | 0, (f[v >> 2] | 0) <= 0)
          return v = 0, v | 0;
        for (x = d + 12 | 0, d = 0; ; ) {
          if (w = d, d = d + 1 | 0, tm((f[x >> 2] | 0) + (w << 3) | 0, h + (d << 5) | 0, p, g) | 0) {
            d = 1, x = 6;
            break;
          }
          if ((d | 0) >= (f[v >> 2] | 0)) {
            d = 0, x = 6;
            break;
          }
        }
        return (x | 0) == 6 ? d | 0 : 0;
      }
      function rF() {
        return 8;
      }
      function sF() {
        return 16;
      }
      function oF() {
        return 168;
      }
      function aF() {
        return 8;
      }
      function lF() {
        return 16;
      }
      function uF() {
        return 12;
      }
      function cF() {
        return 8;
      }
      function hF(d) {
        return d = d | 0, +(+((f[d >> 2] | 0) >>> 0) + 4294967296 * +(f[d + 4 >> 2] | 0));
      }
      function dF(d) {
        d = d | 0;
        var h = 0, p = 0;
        return p = +$[d >> 3], h = +$[d + 8 >> 3], + +Nn(+(p * p + h * h));
      }
      function Jw(d, h, p, g, x) {
        d = d | 0, h = h | 0, p = p | 0, g = g | 0, x = x | 0;
        var v = 0, w = 0, M = 0, P = 0, I = 0, k = 0, Q = 0, re = 0;
        I = +$[d >> 3], P = +$[h >> 3] - I, M = +$[d + 8 >> 3], w = +$[h + 8 >> 3] - M, Q = +$[p >> 3], v = +$[g >> 3] - Q, re = +$[p + 8 >> 3], k = +$[g + 8 >> 3] - re, v = (v * (M - re) - (I - Q) * k) / (P * k - w * v), $[x >> 3] = I + P * v, $[x + 8 >> 3] = M + w * v;
      }
      function eM(d, h) {
        return d = d | 0, h = h | 0, +yn(+(+$[d >> 3] - +$[h >> 3])) < 11920928955078125e-23 ? (h = +yn(+(+$[d + 8 >> 3] - +$[h + 8 >> 3])) < 11920928955078125e-23, h | 0) : (h = 0, h | 0);
      }
      function ar(d, h) {
        d = d | 0, h = h | 0;
        var p = 0, g = 0, x = 0;
        return x = +$[d >> 3] - +$[h >> 3], g = +$[d + 8 >> 3] - +$[h + 8 >> 3], p = +$[d + 16 >> 3] - +$[h + 16 >> 3], +(x * x + g * g + p * p);
      }
      function fF(d, h) {
        d = d | 0, h = h | 0;
        var p = 0, g = 0, x = 0;
        p = +$[d >> 3], g = +On(+p), p = +vn(+p), $[h + 16 >> 3] = p, p = +$[d + 8 >> 3], x = g * +On(+p), $[h >> 3] = x, p = g * +vn(+p), $[h + 8 >> 3] = p;
      }
      function AF(d, h, p) {
        d = d | 0, h = h | 0, p = p | 0;
        var g = 0, x = 0, v = 0;
        if (v = q, q = q + 16 | 0, x = v, g = xi(d, h) | 0, (p + -1 | 0) >>> 0 > 5 || (g = (g | 0) != 0, (p | 0) == 1 & g))
          return x = -1, q = v, x | 0;
        do
          if (TA(d, h, x) | 0)
            g = -1;
          else if (g) {
            g = ((f[26352 + (p << 2) >> 2] | 0) + 5 - (f[x >> 2] | 0) | 0) % 5 | 0;
            break;
          } else {
            g = ((f[26384 + (p << 2) >> 2] | 0) + 6 - (f[x >> 2] | 0) | 0) % 6 | 0;
            break;
          }
        while (!1);
        return x = g, q = v, x | 0;
      }
      function TA(d, h, p) {
        d = d | 0, h = h | 0, p = p | 0;
        var g = 0, x = 0, v = 0, w = 0, M = 0, P = 0, I = 0, k = 0;
        if (k = q, q = q + 32 | 0, M = k + 16 | 0, P = k, g = hd(d, h, M) | 0, g | 0)
          return p = g, q = k, p | 0;
        v = kw(d, h) | 0, I = Vs(d, h) | 0, $7(v, P), g = j7(v, f[M >> 2] | 0) | 0;
        do
          if (Ni(v) | 0) {
            do
              switch (v | 0) {
                case 4: {
                  x = 0;
                  break;
                }
                case 14: {
                  x = 1;
                  break;
                }
                case 24: {
                  x = 2;
                  break;
                }
                case 38: {
                  x = 3;
                  break;
                }
                case 49: {
                  x = 4;
                  break;
                }
                case 58: {
                  x = 5;
                  break;
                }
                case 63: {
                  x = 6;
                  break;
                }
                case 72: {
                  x = 7;
                  break;
                }
                case 83: {
                  x = 8;
                  break;
                }
                case 97: {
                  x = 9;
                  break;
                }
                case 107: {
                  x = 10;
                  break;
                }
                case 117: {
                  x = 11;
                  break;
                }
                default:
                  Ve(27795, 27797, 75, 27806);
              }
            while (!1);
            if (w = f[26416 + (x * 24 | 0) + 8 >> 2] | 0, h = f[26416 + (x * 24 | 0) + 16 >> 2] | 0, d = f[M >> 2] | 0, (d | 0) != (f[P >> 2] | 0) && (P = px(v) | 0, d = f[M >> 2] | 0, P | (d | 0) == (h | 0) && (g = (g + 1 | 0) % 6 | 0)), (I | 0) == 3 & (d | 0) == (h | 0)) {
              g = (g + 5 | 0) % 6 | 0;
              break;
            }
            (I | 0) == 5 & (d | 0) == (w | 0) && (g = (g + 1 | 0) % 6 | 0);
          }
        while (!1);
        return f[p >> 2] = g, p = 0, q = k, p | 0;
      }
      function Lo(d, h, p, g) {
        d = d | 0, h = h | 0, p = p | 0, g = g | 0;
        var x = 0, v = 0, w = 0, M = 0, P = 0, I = 0, k = 0, Q = 0, re = 0, se = 0, ae = 0, Ae = 0, ye = 0, Re = 0, we = 0, be = 0;
        if (be = q, q = q + 32 | 0, we = be + 24 | 0, ye = be + 20 | 0, ae = be + 8 | 0, se = be + 16 | 0, re = be, P = (xi(d, h) | 0) == 0, P = P ? 6 : 5, k = qe(d | 0, h | 0, 52) | 0, V() | 0, k = k & 15, P >>> 0 <= p >>> 0)
          return g = 2, q = be, g | 0;
        Q = (k | 0) == 0, !Q && (Ae = Ze(7, 0, (k ^ 15) * 3 | 0) | 0, (Ae & d | 0) == 0 & ((V() | 0) & h | 0) == 0) ? x = p : v = 4;
        e: do
          if ((v | 0) == 4) {
            if (x = (xi(d, h) | 0) != 0, ((x ? 4 : 5) | 0) < (p | 0) || TA(d, h, we) | 0 || (v = (f[we >> 2] | 0) + p | 0, x ? x = 26704 + (((v | 0) % 5 | 0) << 2) | 0 : x = 26736 + (((v | 0) % 6 | 0) << 2) | 0, Ae = f[x >> 2] | 0, (Ae | 0) == 7))
              return g = 1, q = be, g | 0;
            f[ye >> 2] = 0, x = Zn(d, h, Ae, ye, ae) | 0;
            do
              if (!x) {
                if (M = ae, I = f[M >> 2] | 0, M = f[M + 4 >> 2] | 0, w = M >>> 0 < h >>> 0 | (M | 0) == (h | 0) & I >>> 0 < d >>> 0, v = w ? I : d, w = w ? M : h, !Q && (Q = Ze(7, 0, (k ^ 15) * 3 | 0) | 0, (I & Q | 0) == 0 & (M & (V() | 0) | 0) == 0))
                  x = p;
                else {
                  if (M = (p + -1 + P | 0) % (P | 0) | 0, x = xi(d, h) | 0, (M | 0) < 0 && Ve(27795, 27797, 248, 27822), P = (x | 0) != 0, ((P ? 4 : 5) | 0) < (M | 0) && Ve(27795, 27797, 248, 27822), TA(d, h, we) | 0 && Ve(27795, 27797, 248, 27822), x = (f[we >> 2] | 0) + M | 0, P ? x = 26704 + (((x | 0) % 5 | 0) << 2) | 0 : x = 26736 + (((x | 0) % 6 | 0) << 2) | 0, M = f[x >> 2] | 0, (M | 0) == 7 && Ve(27795, 27797, 248, 27822), f[se >> 2] = 0, x = Zn(d, h, M, se, re) | 0, x | 0)
                    break;
                  I = re, P = f[I >> 2] | 0, I = f[I + 4 >> 2] | 0;
                  do
                    if (I >>> 0 < w >>> 0 | (I | 0) == (w | 0) & P >>> 0 < v >>> 0) {
                      if (xi(P, I) | 0 ? v = is(P, I, d, h) | 0 : v = f[26800 + ((((f[se >> 2] | 0) + (f[26768 + (M << 2) >> 2] | 0) | 0) % 6 | 0) << 2) >> 2] | 0, x = xi(P, I) | 0, (v + -1 | 0) >>> 0 > 5) {
                        x = -1, v = P, w = I;
                        break;
                      }
                      if (x = (x | 0) != 0, (v | 0) == 1 & x) {
                        x = -1, v = P, w = I;
                        break;
                      }
                      do
                        if (TA(P, I, we) | 0)
                          x = -1;
                        else if (x) {
                          x = ((f[26352 + (v << 2) >> 2] | 0) + 5 - (f[we >> 2] | 0) | 0) % 5 | 0;
                          break;
                        } else {
                          x = ((f[26384 + (v << 2) >> 2] | 0) + 6 - (f[we >> 2] | 0) | 0) % 6 | 0;
                          break;
                        }
                      while (!1);
                      v = P, w = I;
                    } else
                      x = p;
                  while (!1);
                  M = ae, I = f[M >> 2] | 0, M = f[M + 4 >> 2] | 0;
                }
                if ((v | 0) == (I | 0) & (w | 0) == (M | 0)) {
                  if (P = (xi(I, M) | 0) != 0, P ? d = is(I, M, d, h) | 0 : d = f[26800 + ((((f[ye >> 2] | 0) + (f[26768 + (Ae << 2) >> 2] | 0) | 0) % 6 | 0) << 2) >> 2] | 0, x = xi(I, M) | 0, (d + -1 | 0) >>> 0 <= 5 && (Re = (x | 0) != 0, !((d | 0) == 1 & Re)))
                    do
                      if (TA(I, M, we) | 0)
                        x = -1;
                      else if (Re) {
                        x = ((f[26352 + (d << 2) >> 2] | 0) + 5 - (f[we >> 2] | 0) | 0) % 5 | 0;
                        break;
                      } else {
                        x = ((f[26384 + (d << 2) >> 2] | 0) + 6 - (f[we >> 2] | 0) | 0) % 6 | 0;
                        break;
                      }
                    while (!1);
                  else
                    x = -1;
                  x = x + 1 | 0, x = (x | 0) == 6 | P & (x | 0) == 5 ? 0 : x;
                }
                h = w, d = v;
                break e;
              }
            while (!1);
            return g = x, q = be, g | 0;
          }
        while (!1);
        return Re = Ze(x | 0, 0, 56) | 0, we = V() | 0 | h & -2130706433 | 536870912, f[g >> 2] = Re | d, f[g + 4 >> 2] = we, g = 0, q = be, g | 0;
      }
      function pF(d, h, p) {
        d = d | 0, h = h | 0, p = p | 0;
        var g = 0, x = 0, v = 0;
        return v = (xi(d, h) | 0) == 0, g = Lo(d, h, 0, p) | 0, x = (g | 0) == 0, v ? !x || (g = Lo(d, h, 1, p + 8 | 0) | 0, g | 0) || (g = Lo(d, h, 2, p + 16 | 0) | 0, g | 0) || (g = Lo(d, h, 3, p + 24 | 0) | 0, g | 0) || (g = Lo(d, h, 4, p + 32 | 0) | 0, g) ? (v = g, v | 0) : Lo(d, h, 5, p + 40 | 0) | 0 : !x || (g = Lo(d, h, 1, p + 8 | 0) | 0, g | 0) || (g = Lo(d, h, 2, p + 16 | 0) | 0, g | 0) || (g = Lo(d, h, 3, p + 24 | 0) | 0, g | 0) || (g = Lo(d, h, 4, p + 32 | 0) | 0, g | 0) ? (v = g, v | 0) : (v = p + 40 | 0, f[v >> 2] = 0, f[v + 4 >> 2] = 0, v = 0, v | 0);
      }
      function mF(d, h, p) {
        d = d | 0, h = h | 0, p = p | 0;
        var g = 0, x = 0, v = 0, w = 0, M = 0, P = 0;
        return P = q, q = q + 192 | 0, x = P, v = P + 168 | 0, w = qe(d | 0, h | 0, 56) | 0, V() | 0, w = w & 7, M = h & -2130706433 | 134217728, g = hd(d, M, v) | 0, g | 0 ? (M = g, q = P, M | 0) : (h = qe(d | 0, h | 0, 52) | 0, V() | 0, h = h & 15, xi(d, M) | 0 ? bx(v, h, w, 1, x) : Sx(v, h, w, 1, x), M = x + 8 | 0, f[p >> 2] = f[M >> 2], f[p + 4 >> 2] = f[M + 4 >> 2], f[p + 8 >> 2] = f[M + 8 >> 2], f[p + 12 >> 2] = f[M + 12 >> 2], M = 0, q = P, M | 0);
      }
      function tM(d, h) {
        d = d | 0, h = h | 0;
        var p = 0, g = 0, x = 0, v = 0;
        return x = q, q = q + 16 | 0, p = x, !(!0 & (h & 2013265920 | 0) == 536870912) || (g = h & -2130706433 | 134217728, !(Tx(d, g) | 0)) ? (g = 0, q = x, g | 0) : (v = qe(d | 0, h | 0, 56) | 0, V() | 0, v = (Lo(d, g, v & 7, p) | 0) == 0, g = p, g = v & ((f[g >> 2] | 0) == (d | 0) ? (f[g + 4 >> 2] | 0) == (h | 0) : 0) & 1, q = x, g | 0);
      }
      function nM(d, h, p) {
        d = d | 0, h = h | 0, p = p | 0;
        var g = 0;
        (h | 0) > 0 ? (g = Gs(h, 4) | 0, f[d >> 2] = g, g || Ve(27835, 27858, 40, 27872)) : f[d >> 2] = 0, f[d + 4 >> 2] = h, f[d + 8 >> 2] = 0, f[d + 12 >> 2] = p;
      }
      function iM(d) {
        d = d | 0;
        var h = 0, p = 0, g = 0, x = 0, v = 0, w = 0, M = 0;
        x = d + 4 | 0, v = d + 12 | 0, w = d + 8 | 0;
        e: for (; ; ) {
          for (p = f[x >> 2] | 0, h = 0; ; ) {
            if ((h | 0) >= (p | 0))
              break e;
            if (g = f[d >> 2] | 0, M = f[g + (h << 2) >> 2] | 0, !M)
              h = h + 1 | 0;
            else
              break;
          }
          h = g + (~~(+yn(+(+ta(10, + +(15 - (f[v >> 2] | 0) | 0)) * (+$[M >> 3] + +$[M + 8 >> 3]))) % +(p | 0)) >>> 0 << 2) | 0, p = f[h >> 2] | 0;
          t: do
            if (p | 0) {
              if (g = M + 32 | 0, (p | 0) == (M | 0))
                f[h >> 2] = f[g >> 2];
              else {
                if (p = p + 32 | 0, h = f[p >> 2] | 0, !h)
                  break;
                for (; (h | 0) != (M | 0); )
                  if (p = h + 32 | 0, h = f[p >> 2] | 0, !h)
                    break t;
                f[p >> 2] = f[g >> 2];
              }
              Qt(M), f[w >> 2] = (f[w >> 2] | 0) + -1;
            }
          while (!1);
        }
        Qt(f[d >> 2] | 0);
      }
      function rM(d) {
        d = d | 0;
        var h = 0, p = 0, g = 0;
        for (g = f[d + 4 >> 2] | 0, p = 0; ; ) {
          if ((p | 0) >= (g | 0)) {
            h = 0, p = 4;
            break;
          }
          if (h = f[(f[d >> 2] | 0) + (p << 2) >> 2] | 0, !h)
            p = p + 1 | 0;
          else {
            p = 4;
            break;
          }
        }
        return (p | 0) == 4 ? h | 0 : 0;
      }
      function sM(d, h) {
        d = d | 0, h = h | 0;
        var p = 0, g = 0, x = 0, v = 0;
        if (p = ~~(+yn(+(+ta(10, + +(15 - (f[d + 12 >> 2] | 0) | 0)) * (+$[h >> 3] + +$[h + 8 >> 3]))) % +(f[d + 4 >> 2] | 0)) >>> 0, p = (f[d >> 2] | 0) + (p << 2) | 0, g = f[p >> 2] | 0, !g)
          return v = 1, v | 0;
        v = h + 32 | 0;
        do
          if ((g | 0) != (h | 0)) {
            if (p = f[g + 32 >> 2] | 0, !p)
              return v = 1, v | 0;
            for (x = p; ; ) {
              if ((x | 0) == (h | 0)) {
                x = 8;
                break;
              }
              if (p = f[x + 32 >> 2] | 0, p)
                g = x, x = p;
              else {
                p = 1, x = 10;
                break;
              }
            }
            if ((x | 0) == 8) {
              f[g + 32 >> 2] = f[v >> 2];
              break;
            } else if ((x | 0) == 10)
              return p | 0;
          } else
            f[p >> 2] = f[v >> 2];
        while (!1);
        return Qt(h), v = d + 8 | 0, f[v >> 2] = (f[v >> 2] | 0) + -1, v = 0, v | 0;
      }
      function gF(d, h, p) {
        d = d | 0, h = h | 0, p = p | 0;
        var g = 0, x = 0, v = 0, w = 0;
        v = Ra(40) | 0, v || Ve(27888, 27858, 98, 27901), f[v >> 2] = f[h >> 2], f[v + 4 >> 2] = f[h + 4 >> 2], f[v + 8 >> 2] = f[h + 8 >> 2], f[v + 12 >> 2] = f[h + 12 >> 2], x = v + 16 | 0, f[x >> 2] = f[p >> 2], f[x + 4 >> 2] = f[p + 4 >> 2], f[x + 8 >> 2] = f[p + 8 >> 2], f[x + 12 >> 2] = f[p + 12 >> 2], f[v + 32 >> 2] = 0, x = ~~(+yn(+(+ta(10, + +(15 - (f[d + 12 >> 2] | 0) | 0)) * (+$[h >> 3] + +$[h + 8 >> 3]))) % +(f[d + 4 >> 2] | 0)) >>> 0, x = (f[d >> 2] | 0) + (x << 2) | 0, g = f[x >> 2] | 0;
        do
          if (!g)
            f[x >> 2] = v;
          else {
            for (; !(fd(g, h) | 0 && fd(g + 16 | 0, p) | 0); )
              if (x = f[g + 32 >> 2] | 0, g = (x | 0) == 0 ? g : x, !(f[g + 32 >> 2] | 0)) {
                w = 10;
                break;
              }
            if ((w | 0) == 10) {
              f[g + 32 >> 2] = v;
              break;
            }
            return Qt(v), w = g, w | 0;
          }
        while (!1);
        return w = d + 8 | 0, f[w >> 2] = (f[w >> 2] | 0) + 1, w = v, w | 0;
      }
      function _F(d, h, p) {
        d = d | 0, h = h | 0, p = p | 0;
        var g = 0, x = 0;
        if (x = ~~(+yn(+(+ta(10, + +(15 - (f[d + 12 >> 2] | 0) | 0)) * (+$[h >> 3] + +$[h + 8 >> 3]))) % +(f[d + 4 >> 2] | 0)) >>> 0, x = f[(f[d >> 2] | 0) + (x << 2) >> 2] | 0, !x)
          return p = 0, p | 0;
        if (!p) {
          for (d = x; ; ) {
            if (fd(d, h) | 0) {
              g = 10;
              break;
            }
            if (d = f[d + 32 >> 2] | 0, !d) {
              d = 0, g = 10;
              break;
            }
          }
          if ((g | 0) == 10)
            return d | 0;
        }
        for (d = x; ; ) {
          if (fd(d, h) | 0 && fd(d + 16 | 0, p) | 0) {
            g = 10;
            break;
          }
          if (d = f[d + 32 >> 2] | 0, !d) {
            d = 0, g = 10;
            break;
          }
        }
        return (g | 0) == 10 ? d | 0 : 0;
      }
      function xF(d, h) {
        d = d | 0, h = h | 0;
        var p = 0;
        if (p = ~~(+yn(+(+ta(10, + +(15 - (f[d + 12 >> 2] | 0) | 0)) * (+$[h >> 3] + +$[h + 8 >> 3]))) % +(f[d + 4 >> 2] | 0)) >>> 0, d = f[(f[d >> 2] | 0) + (p << 2) >> 2] | 0, !d)
          return p = 0, p | 0;
        for (; ; ) {
          if (fd(d, h) | 0) {
            h = 5;
            break;
          }
          if (d = f[d + 32 >> 2] | 0, !d) {
            d = 0, h = 5;
            break;
          }
        }
        return (h | 0) == 5 ? d | 0 : 0;
      }
      function yF() {
        return 27920;
      }
      function su(d) {
        return d = +d, ~~+uM(+d) | 0;
      }
      function Ra(d) {
        d = d | 0;
        var h = 0, p = 0, g = 0, x = 0, v = 0, w = 0, M = 0, P = 0, I = 0, k = 0, Q = 0, re = 0, se = 0, ae = 0, Ae = 0, ye = 0, Re = 0, we = 0, be = 0, me = 0, nt = 0;
        nt = q, q = q + 16 | 0, re = nt;
        do
          if (d >>> 0 < 245) {
            if (I = d >>> 0 < 11 ? 16 : d + 11 & -8, d = I >>> 3, Q = f[6981] | 0, p = Q >>> d, p & 3 | 0)
              return h = (p & 1 ^ 1) + d | 0, d = 27964 + (h << 1 << 2) | 0, p = d + 8 | 0, g = f[p >> 2] | 0, x = g + 8 | 0, v = f[x >> 2] | 0, (v | 0) == (d | 0) ? f[6981] = Q & ~(1 << h) : (f[v + 12 >> 2] = d, f[p >> 2] = v), me = h << 3, f[g + 4 >> 2] = me | 3, me = g + me + 4 | 0, f[me >> 2] = f[me >> 2] | 1, me = x, q = nt, me | 0;
            if (k = f[6983] | 0, I >>> 0 > k >>> 0) {
              if (p | 0)
                return h = 2 << d, h = p << d & (h | 0 - h), h = (h & 0 - h) + -1 | 0, M = h >>> 12 & 16, h = h >>> M, p = h >>> 5 & 8, h = h >>> p, v = h >>> 2 & 4, h = h >>> v, d = h >>> 1 & 2, h = h >>> d, g = h >>> 1 & 1, g = (p | M | v | d | g) + (h >>> g) | 0, h = 27964 + (g << 1 << 2) | 0, d = h + 8 | 0, v = f[d >> 2] | 0, M = v + 8 | 0, p = f[M >> 2] | 0, (p | 0) == (h | 0) ? (d = Q & ~(1 << g), f[6981] = d) : (f[p + 12 >> 2] = h, f[d >> 2] = p, d = Q), me = g << 3, w = me - I | 0, f[v + 4 >> 2] = I | 3, x = v + I | 0, f[x + 4 >> 2] = w | 1, f[v + me >> 2] = w, k | 0 && (g = f[6986] | 0, h = k >>> 3, p = 27964 + (h << 1 << 2) | 0, h = 1 << h, d & h ? (d = p + 8 | 0, h = f[d >> 2] | 0) : (f[6981] = d | h, h = p, d = p + 8 | 0), f[d >> 2] = g, f[h + 12 >> 2] = g, f[g + 8 >> 2] = h, f[g + 12 >> 2] = p), f[6983] = w, f[6986] = x, me = M, q = nt, me | 0;
              if (v = f[6982] | 0, v) {
                for (p = (v & 0 - v) + -1 | 0, x = p >>> 12 & 16, p = p >>> x, g = p >>> 5 & 8, p = p >>> g, w = p >>> 2 & 4, p = p >>> w, M = p >>> 1 & 2, p = p >>> M, P = p >>> 1 & 1, P = f[28228 + ((g | x | w | M | P) + (p >>> P) << 2) >> 2] | 0, p = P, M = P, P = (f[P + 4 >> 2] & -8) - I | 0; d = f[p + 16 >> 2] | 0, !(!d && (d = f[p + 20 >> 2] | 0, !d)); )
                  w = (f[d + 4 >> 2] & -8) - I | 0, x = w >>> 0 < P >>> 0, p = d, M = x ? d : M, P = x ? w : P;
                if (w = M + I | 0, w >>> 0 > M >>> 0) {
                  x = f[M + 24 >> 2] | 0, h = f[M + 12 >> 2] | 0;
                  do
                    if ((h | 0) == (M | 0)) {
                      if (d = M + 20 | 0, h = f[d >> 2] | 0, !h && (d = M + 16 | 0, h = f[d >> 2] | 0, !h)) {
                        p = 0;
                        break;
                      }
                      for (; ; )
                        if (g = h + 20 | 0, p = f[g >> 2] | 0, p)
                          h = p, d = g;
                        else if (g = h + 16 | 0, p = f[g >> 2] | 0, p)
                          h = p, d = g;
                        else
                          break;
                      f[d >> 2] = 0, p = h;
                    } else
                      p = f[M + 8 >> 2] | 0, f[p + 12 >> 2] = h, f[h + 8 >> 2] = p, p = h;
                  while (!1);
                  do
                    if (x | 0) {
                      if (h = f[M + 28 >> 2] | 0, d = 28228 + (h << 2) | 0, (M | 0) == (f[d >> 2] | 0)) {
                        if (f[d >> 2] = p, !p) {
                          f[6982] = v & ~(1 << h);
                          break;
                        }
                      } else if (me = x + 16 | 0, f[((f[me >> 2] | 0) == (M | 0) ? me : x + 20 | 0) >> 2] = p, !p)
                        break;
                      f[p + 24 >> 2] = x, h = f[M + 16 >> 2] | 0, h | 0 && (f[p + 16 >> 2] = h, f[h + 24 >> 2] = p), h = f[M + 20 >> 2] | 0, h | 0 && (f[p + 20 >> 2] = h, f[h + 24 >> 2] = p);
                    }
                  while (!1);
                  return P >>> 0 < 16 ? (me = P + I | 0, f[M + 4 >> 2] = me | 3, me = M + me + 4 | 0, f[me >> 2] = f[me >> 2] | 1) : (f[M + 4 >> 2] = I | 3, f[w + 4 >> 2] = P | 1, f[w + P >> 2] = P, k | 0 && (g = f[6986] | 0, h = k >>> 3, p = 27964 + (h << 1 << 2) | 0, h = 1 << h, h & Q ? (d = p + 8 | 0, h = f[d >> 2] | 0) : (f[6981] = h | Q, h = p, d = p + 8 | 0), f[d >> 2] = g, f[h + 12 >> 2] = g, f[g + 8 >> 2] = h, f[g + 12 >> 2] = p), f[6983] = P, f[6986] = w), me = M + 8 | 0, q = nt, me | 0;
                } else
                  Q = I;
              } else
                Q = I;
            } else
              Q = I;
          } else if (d >>> 0 <= 4294967231)
            if (d = d + 11 | 0, I = d & -8, g = f[6982] | 0, g) {
              x = 0 - I | 0, d = d >>> 8, d ? I >>> 0 > 16777215 ? P = 31 : (Q = (d + 1048320 | 0) >>> 16 & 8, Ae = d << Q, M = (Ae + 520192 | 0) >>> 16 & 4, Ae = Ae << M, P = (Ae + 245760 | 0) >>> 16 & 2, P = 14 - (M | Q | P) + (Ae << P >>> 15) | 0, P = I >>> (P + 7 | 0) & 1 | P << 1) : P = 0, p = f[28228 + (P << 2) >> 2] | 0;
              e: do
                if (!p)
                  p = 0, d = 0, Ae = 61;
                else
                  for (d = 0, M = I << ((P | 0) == 31 ? 0 : 25 - (P >>> 1) | 0), v = 0; ; ) {
                    if (w = (f[p + 4 >> 2] & -8) - I | 0, w >>> 0 < x >>> 0)
                      if (w)
                        d = p, x = w;
                      else {
                        d = p, x = 0, Ae = 65;
                        break e;
                      }
                    if (Ae = f[p + 20 >> 2] | 0, p = f[p + 16 + (M >>> 31 << 2) >> 2] | 0, v = (Ae | 0) == 0 | (Ae | 0) == (p | 0) ? v : Ae, p)
                      M = M << 1;
                    else {
                      p = v, Ae = 61;
                      break;
                    }
                  }
              while (!1);
              if ((Ae | 0) == 61) {
                if ((p | 0) == 0 & (d | 0) == 0) {
                  if (d = 2 << P, d = (d | 0 - d) & g, !d) {
                    Q = I;
                    break;
                  }
                  Q = (d & 0 - d) + -1 | 0, w = Q >>> 12 & 16, Q = Q >>> w, v = Q >>> 5 & 8, Q = Q >>> v, M = Q >>> 2 & 4, Q = Q >>> M, P = Q >>> 1 & 2, Q = Q >>> P, p = Q >>> 1 & 1, d = 0, p = f[28228 + ((v | w | M | P | p) + (Q >>> p) << 2) >> 2] | 0;
                }
                p ? Ae = 65 : (M = d, w = x);
              }
              if ((Ae | 0) == 65)
                for (v = p; ; )
                  if (Q = (f[v + 4 >> 2] & -8) - I | 0, p = Q >>> 0 < x >>> 0, x = p ? Q : x, d = p ? v : d, p = f[v + 16 >> 2] | 0, p || (p = f[v + 20 >> 2] | 0), p)
                    v = p;
                  else {
                    M = d, w = x;
                    break;
                  }
              if ((M | 0) != 0 && w >>> 0 < ((f[6983] | 0) - I | 0) >>> 0 && (k = M + I | 0, k >>> 0 > M >>> 0)) {
                v = f[M + 24 >> 2] | 0, h = f[M + 12 >> 2] | 0;
                do
                  if ((h | 0) == (M | 0)) {
                    if (d = M + 20 | 0, h = f[d >> 2] | 0, !h && (d = M + 16 | 0, h = f[d >> 2] | 0, !h)) {
                      h = 0;
                      break;
                    }
                    for (; ; )
                      if (x = h + 20 | 0, p = f[x >> 2] | 0, p)
                        h = p, d = x;
                      else if (x = h + 16 | 0, p = f[x >> 2] | 0, p)
                        h = p, d = x;
                      else
                        break;
                    f[d >> 2] = 0;
                  } else
                    me = f[M + 8 >> 2] | 0, f[me + 12 >> 2] = h, f[h + 8 >> 2] = me;
                while (!1);
                do
                  if (v) {
                    if (d = f[M + 28 >> 2] | 0, p = 28228 + (d << 2) | 0, (M | 0) == (f[p >> 2] | 0)) {
                      if (f[p >> 2] = h, !h) {
                        g = g & ~(1 << d), f[6982] = g;
                        break;
                      }
                    } else if (me = v + 16 | 0, f[((f[me >> 2] | 0) == (M | 0) ? me : v + 20 | 0) >> 2] = h, !h)
                      break;
                    f[h + 24 >> 2] = v, d = f[M + 16 >> 2] | 0, d | 0 && (f[h + 16 >> 2] = d, f[d + 24 >> 2] = h), d = f[M + 20 >> 2] | 0, d && (f[h + 20 >> 2] = d, f[d + 24 >> 2] = h);
                  }
                while (!1);
                e: do
                  if (w >>> 0 < 16)
                    me = w + I | 0, f[M + 4 >> 2] = me | 3, me = M + me + 4 | 0, f[me >> 2] = f[me >> 2] | 1;
                  else {
                    if (f[M + 4 >> 2] = I | 3, f[k + 4 >> 2] = w | 1, f[k + w >> 2] = w, h = w >>> 3, w >>> 0 < 256) {
                      p = 27964 + (h << 1 << 2) | 0, d = f[6981] | 0, h = 1 << h, d & h ? (d = p + 8 | 0, h = f[d >> 2] | 0) : (f[6981] = d | h, h = p, d = p + 8 | 0), f[d >> 2] = k, f[h + 12 >> 2] = k, f[k + 8 >> 2] = h, f[k + 12 >> 2] = p;
                      break;
                    }
                    if (h = w >>> 8, h ? w >>> 0 > 16777215 ? p = 31 : (be = (h + 1048320 | 0) >>> 16 & 8, me = h << be, we = (me + 520192 | 0) >>> 16 & 4, me = me << we, p = (me + 245760 | 0) >>> 16 & 2, p = 14 - (we | be | p) + (me << p >>> 15) | 0, p = w >>> (p + 7 | 0) & 1 | p << 1) : p = 0, h = 28228 + (p << 2) | 0, f[k + 28 >> 2] = p, d = k + 16 | 0, f[d + 4 >> 2] = 0, f[d >> 2] = 0, d = 1 << p, !(g & d)) {
                      f[6982] = g | d, f[h >> 2] = k, f[k + 24 >> 2] = h, f[k + 12 >> 2] = k, f[k + 8 >> 2] = k;
                      break;
                    }
                    h = f[h >> 2] | 0;
                    t: do
                      if ((f[h + 4 >> 2] & -8 | 0) != (w | 0)) {
                        for (g = w << ((p | 0) == 31 ? 0 : 25 - (p >>> 1) | 0); p = h + 16 + (g >>> 31 << 2) | 0, d = f[p >> 2] | 0, !!d; )
                          if ((f[d + 4 >> 2] & -8 | 0) == (w | 0)) {
                            h = d;
                            break t;
                          } else
                            g = g << 1, h = d;
                        f[p >> 2] = k, f[k + 24 >> 2] = h, f[k + 12 >> 2] = k, f[k + 8 >> 2] = k;
                        break e;
                      }
                    while (!1);
                    be = h + 8 | 0, me = f[be >> 2] | 0, f[me + 12 >> 2] = k, f[be >> 2] = k, f[k + 8 >> 2] = me, f[k + 12 >> 2] = h, f[k + 24 >> 2] = 0;
                  }
                while (!1);
                return me = M + 8 | 0, q = nt, me | 0;
              } else
                Q = I;
            } else
              Q = I;
          else
            Q = -1;
        while (!1);
        if (p = f[6983] | 0, p >>> 0 >= Q >>> 0)
          return h = p - Q | 0, d = f[6986] | 0, h >>> 0 > 15 ? (me = d + Q | 0, f[6986] = me, f[6983] = h, f[me + 4 >> 2] = h | 1, f[d + p >> 2] = h, f[d + 4 >> 2] = Q | 3) : (f[6983] = 0, f[6986] = 0, f[d + 4 >> 2] = p | 3, me = d + p + 4 | 0, f[me >> 2] = f[me >> 2] | 1), me = d + 8 | 0, q = nt, me | 0;
        if (w = f[6984] | 0, w >>> 0 > Q >>> 0)
          return we = w - Q | 0, f[6984] = we, me = f[6987] | 0, be = me + Q | 0, f[6987] = be, f[be + 4 >> 2] = we | 1, f[me + 4 >> 2] = Q | 3, me = me + 8 | 0, q = nt, me | 0;
        if (f[7099] | 0 ? d = f[7101] | 0 : (f[7101] = 4096, f[7100] = 4096, f[7102] = -1, f[7103] = -1, f[7104] = 0, f[7092] = 0, f[7099] = re & -16 ^ 1431655768, d = 4096), M = Q + 48 | 0, P = Q + 47 | 0, v = d + P | 0, x = 0 - d | 0, I = v & x, I >>> 0 <= Q >>> 0 || (d = f[7091] | 0, d | 0 && (k = f[7089] | 0, re = k + I | 0, re >>> 0 <= k >>> 0 | re >>> 0 > d >>> 0)))
          return me = 0, q = nt, me | 0;
        e: do
          if (f[7092] & 4)
            h = 0, Ae = 143;
          else {
            p = f[6987] | 0;
            t: do
              if (p) {
                for (g = 28372; re = f[g >> 2] | 0, !(re >>> 0 <= p >>> 0 && (re + (f[g + 4 >> 2] | 0) | 0) >>> 0 > p >>> 0); )
                  if (d = f[g + 8 >> 2] | 0, d)
                    g = d;
                  else {
                    Ae = 128;
                    break t;
                  }
                if (h = v - w & x, h >>> 0 < 2147483647)
                  if (d = lu(h | 0) | 0, (d | 0) == ((f[g >> 2] | 0) + (f[g + 4 >> 2] | 0) | 0)) {
                    if ((d | 0) != -1) {
                      w = h, v = d, Ae = 145;
                      break e;
                    }
                  } else
                    g = d, Ae = 136;
                else
                  h = 0;
              } else
                Ae = 128;
            while (!1);
            do
              if ((Ae | 0) == 128)
                if (p = lu(0) | 0, (p | 0) != -1 && (h = p, se = f[7100] | 0, ae = se + -1 | 0, h = ((ae & h | 0) == 0 ? 0 : (ae + h & 0 - se) - h | 0) + I | 0, se = f[7089] | 0, ae = h + se | 0, h >>> 0 > Q >>> 0 & h >>> 0 < 2147483647)) {
                  if (re = f[7091] | 0, re | 0 && ae >>> 0 <= se >>> 0 | ae >>> 0 > re >>> 0) {
                    h = 0;
                    break;
                  }
                  if (d = lu(h | 0) | 0, (d | 0) == (p | 0)) {
                    w = h, v = p, Ae = 145;
                    break e;
                  } else
                    g = d, Ae = 136;
                } else
                  h = 0;
            while (!1);
            do
              if ((Ae | 0) == 136) {
                if (p = 0 - h | 0, !(M >>> 0 > h >>> 0 & (h >>> 0 < 2147483647 & (g | 0) != -1)))
                  if ((g | 0) == -1) {
                    h = 0;
                    break;
                  } else {
                    w = h, v = g, Ae = 145;
                    break e;
                  }
                if (d = f[7101] | 0, d = P - h + d & 0 - d, d >>> 0 >= 2147483647) {
                  w = h, v = g, Ae = 145;
                  break e;
                }
                if ((lu(d | 0) | 0) == -1) {
                  lu(p | 0) | 0, h = 0;
                  break;
                } else {
                  w = d + h | 0, v = g, Ae = 145;
                  break e;
                }
              }
            while (!1);
            f[7092] = f[7092] | 4, Ae = 143;
          }
        while (!1);
        if ((Ae | 0) == 143 && I >>> 0 < 2147483647 && (we = lu(I | 0) | 0, ae = lu(0) | 0, ye = ae - we | 0, Re = ye >>> 0 > (Q + 40 | 0) >>> 0, !((we | 0) == -1 | Re ^ 1 | we >>> 0 < ae >>> 0 & ((we | 0) != -1 & (ae | 0) != -1) ^ 1)) && (w = Re ? ye : h, v = we, Ae = 145), (Ae | 0) == 145) {
          h = (f[7089] | 0) + w | 0, f[7089] = h, h >>> 0 > (f[7090] | 0) >>> 0 && (f[7090] = h), P = f[6987] | 0;
          e: do
            if (P) {
              for (h = 28372; ; ) {
                if (d = f[h >> 2] | 0, p = f[h + 4 >> 2] | 0, (v | 0) == (d + p | 0)) {
                  Ae = 154;
                  break;
                }
                if (g = f[h + 8 >> 2] | 0, g)
                  h = g;
                else
                  break;
              }
              if ((Ae | 0) == 154 && (be = h + 4 | 0, (f[h + 12 >> 2] & 8 | 0) == 0) && v >>> 0 > P >>> 0 & d >>> 0 <= P >>> 0) {
                f[be >> 2] = p + w, me = (f[6984] | 0) + w | 0, we = P + 8 | 0, we = (we & 7 | 0) == 0 ? 0 : 0 - we & 7, be = P + we | 0, we = me - we | 0, f[6987] = be, f[6984] = we, f[be + 4 >> 2] = we | 1, f[P + me + 4 >> 2] = 40, f[6988] = f[7103];
                break;
              }
              for (v >>> 0 < (f[6985] | 0) >>> 0 && (f[6985] = v), p = v + w | 0, h = 28372; ; ) {
                if ((f[h >> 2] | 0) == (p | 0)) {
                  Ae = 162;
                  break;
                }
                if (d = f[h + 8 >> 2] | 0, d)
                  h = d;
                else
                  break;
              }
              if ((Ae | 0) == 162 && (f[h + 12 >> 2] & 8 | 0) == 0) {
                f[h >> 2] = v, k = h + 4 | 0, f[k >> 2] = (f[k >> 2] | 0) + w, k = v + 8 | 0, k = v + ((k & 7 | 0) == 0 ? 0 : 0 - k & 7) | 0, h = p + 8 | 0, h = p + ((h & 7 | 0) == 0 ? 0 : 0 - h & 7) | 0, I = k + Q | 0, M = h - k - Q | 0, f[k + 4 >> 2] = Q | 3;
                t: do
                  if ((P | 0) == (h | 0))
                    me = (f[6984] | 0) + M | 0, f[6984] = me, f[6987] = I, f[I + 4 >> 2] = me | 1;
                  else {
                    if ((f[6986] | 0) == (h | 0)) {
                      me = (f[6983] | 0) + M | 0, f[6983] = me, f[6986] = I, f[I + 4 >> 2] = me | 1, f[I + me >> 2] = me;
                      break;
                    }
                    if (d = f[h + 4 >> 2] | 0, (d & 3 | 0) == 1) {
                      w = d & -8, g = d >>> 3;
                      n: do
                        if (d >>> 0 < 256)
                          if (d = f[h + 8 >> 2] | 0, p = f[h + 12 >> 2] | 0, (p | 0) == (d | 0)) {
                            f[6981] = f[6981] & ~(1 << g);
                            break;
                          } else {
                            f[d + 12 >> 2] = p, f[p + 8 >> 2] = d;
                            break;
                          }
                        else {
                          v = f[h + 24 >> 2] | 0, d = f[h + 12 >> 2] | 0;
                          do
                            if ((d | 0) == (h | 0)) {
                              if (p = h + 16 | 0, g = p + 4 | 0, d = f[g >> 2] | 0, d)
                                p = g;
                              else if (d = f[p >> 2] | 0, !d) {
                                d = 0;
                                break;
                              }
                              for (; ; )
                                if (x = d + 20 | 0, g = f[x >> 2] | 0, g)
                                  d = g, p = x;
                                else if (x = d + 16 | 0, g = f[x >> 2] | 0, g)
                                  d = g, p = x;
                                else
                                  break;
                              f[p >> 2] = 0;
                            } else
                              me = f[h + 8 >> 2] | 0, f[me + 12 >> 2] = d, f[d + 8 >> 2] = me;
                          while (!1);
                          if (!v)
                            break;
                          p = f[h + 28 >> 2] | 0, g = 28228 + (p << 2) | 0;
                          do
                            if ((f[g >> 2] | 0) != (h | 0)) {
                              if (me = v + 16 | 0, f[((f[me >> 2] | 0) == (h | 0) ? me : v + 20 | 0) >> 2] = d, !d)
                                break n;
                            } else {
                              if (f[g >> 2] = d, d | 0)
                                break;
                              f[6982] = f[6982] & ~(1 << p);
                              break n;
                            }
                          while (!1);
                          if (f[d + 24 >> 2] = v, p = h + 16 | 0, g = f[p >> 2] | 0, g | 0 && (f[d + 16 >> 2] = g, f[g + 24 >> 2] = d), p = f[p + 4 >> 2] | 0, !p)
                            break;
                          f[d + 20 >> 2] = p, f[p + 24 >> 2] = d;
                        }
                      while (!1);
                      h = h + w | 0, x = w + M | 0;
                    } else
                      x = M;
                    if (h = h + 4 | 0, f[h >> 2] = f[h >> 2] & -2, f[I + 4 >> 2] = x | 1, f[I + x >> 2] = x, h = x >>> 3, x >>> 0 < 256) {
                      p = 27964 + (h << 1 << 2) | 0, d = f[6981] | 0, h = 1 << h, d & h ? (d = p + 8 | 0, h = f[d >> 2] | 0) : (f[6981] = d | h, h = p, d = p + 8 | 0), f[d >> 2] = I, f[h + 12 >> 2] = I, f[I + 8 >> 2] = h, f[I + 12 >> 2] = p;
                      break;
                    }
                    h = x >>> 8;
                    do
                      if (!h)
                        g = 0;
                      else {
                        if (x >>> 0 > 16777215) {
                          g = 31;
                          break;
                        }
                        be = (h + 1048320 | 0) >>> 16 & 8, me = h << be, we = (me + 520192 | 0) >>> 16 & 4, me = me << we, g = (me + 245760 | 0) >>> 16 & 2, g = 14 - (we | be | g) + (me << g >>> 15) | 0, g = x >>> (g + 7 | 0) & 1 | g << 1;
                      }
                    while (!1);
                    if (h = 28228 + (g << 2) | 0, f[I + 28 >> 2] = g, d = I + 16 | 0, f[d + 4 >> 2] = 0, f[d >> 2] = 0, d = f[6982] | 0, p = 1 << g, !(d & p)) {
                      f[6982] = d | p, f[h >> 2] = I, f[I + 24 >> 2] = h, f[I + 12 >> 2] = I, f[I + 8 >> 2] = I;
                      break;
                    }
                    h = f[h >> 2] | 0;
                    n: do
                      if ((f[h + 4 >> 2] & -8 | 0) != (x | 0)) {
                        for (g = x << ((g | 0) == 31 ? 0 : 25 - (g >>> 1) | 0); p = h + 16 + (g >>> 31 << 2) | 0, d = f[p >> 2] | 0, !!d; )
                          if ((f[d + 4 >> 2] & -8 | 0) == (x | 0)) {
                            h = d;
                            break n;
                          } else
                            g = g << 1, h = d;
                        f[p >> 2] = I, f[I + 24 >> 2] = h, f[I + 12 >> 2] = I, f[I + 8 >> 2] = I;
                        break t;
                      }
                    while (!1);
                    be = h + 8 | 0, me = f[be >> 2] | 0, f[me + 12 >> 2] = I, f[be >> 2] = I, f[I + 8 >> 2] = me, f[I + 12 >> 2] = h, f[I + 24 >> 2] = 0;
                  }
                while (!1);
                return me = k + 8 | 0, q = nt, me | 0;
              }
              for (h = 28372; d = f[h >> 2] | 0, !(d >>> 0 <= P >>> 0 && (me = d + (f[h + 4 >> 2] | 0) | 0, me >>> 0 > P >>> 0)); )
                h = f[h + 8 >> 2] | 0;
              x = me + -47 | 0, d = x + 8 | 0, d = x + ((d & 7 | 0) == 0 ? 0 : 0 - d & 7) | 0, x = P + 16 | 0, d = d >>> 0 < x >>> 0 ? P : d, h = d + 8 | 0, p = w + -40 | 0, we = v + 8 | 0, we = (we & 7 | 0) == 0 ? 0 : 0 - we & 7, be = v + we | 0, we = p - we | 0, f[6987] = be, f[6984] = we, f[be + 4 >> 2] = we | 1, f[v + p + 4 >> 2] = 40, f[6988] = f[7103], p = d + 4 | 0, f[p >> 2] = 27, f[h >> 2] = f[7093], f[h + 4 >> 2] = f[7094], f[h + 8 >> 2] = f[7095], f[h + 12 >> 2] = f[7096], f[7093] = v, f[7094] = w, f[7096] = 0, f[7095] = h, h = d + 24 | 0;
              do
                be = h, h = h + 4 | 0, f[h >> 2] = 7;
              while ((be + 8 | 0) >>> 0 < me >>> 0);
              if ((d | 0) != (P | 0)) {
                if (v = d - P | 0, f[p >> 2] = f[p >> 2] & -2, f[P + 4 >> 2] = v | 1, f[d >> 2] = v, h = v >>> 3, v >>> 0 < 256) {
                  p = 27964 + (h << 1 << 2) | 0, d = f[6981] | 0, h = 1 << h, d & h ? (d = p + 8 | 0, h = f[d >> 2] | 0) : (f[6981] = d | h, h = p, d = p + 8 | 0), f[d >> 2] = P, f[h + 12 >> 2] = P, f[P + 8 >> 2] = h, f[P + 12 >> 2] = p;
                  break;
                }
                if (h = v >>> 8, h ? v >>> 0 > 16777215 ? g = 31 : (be = (h + 1048320 | 0) >>> 16 & 8, me = h << be, we = (me + 520192 | 0) >>> 16 & 4, me = me << we, g = (me + 245760 | 0) >>> 16 & 2, g = 14 - (we | be | g) + (me << g >>> 15) | 0, g = v >>> (g + 7 | 0) & 1 | g << 1) : g = 0, p = 28228 + (g << 2) | 0, f[P + 28 >> 2] = g, f[P + 20 >> 2] = 0, f[x >> 2] = 0, h = f[6982] | 0, d = 1 << g, !(h & d)) {
                  f[6982] = h | d, f[p >> 2] = P, f[P + 24 >> 2] = p, f[P + 12 >> 2] = P, f[P + 8 >> 2] = P;
                  break;
                }
                h = f[p >> 2] | 0;
                t: do
                  if ((f[h + 4 >> 2] & -8 | 0) != (v | 0)) {
                    for (g = v << ((g | 0) == 31 ? 0 : 25 - (g >>> 1) | 0); p = h + 16 + (g >>> 31 << 2) | 0, d = f[p >> 2] | 0, !!d; )
                      if ((f[d + 4 >> 2] & -8 | 0) == (v | 0)) {
                        h = d;
                        break t;
                      } else
                        g = g << 1, h = d;
                    f[p >> 2] = P, f[P + 24 >> 2] = h, f[P + 12 >> 2] = P, f[P + 8 >> 2] = P;
                    break e;
                  }
                while (!1);
                be = h + 8 | 0, me = f[be >> 2] | 0, f[me + 12 >> 2] = P, f[be >> 2] = P, f[P + 8 >> 2] = me, f[P + 12 >> 2] = h, f[P + 24 >> 2] = 0;
              }
            } else
              me = f[6985] | 0, (me | 0) == 0 | v >>> 0 < me >>> 0 && (f[6985] = v), f[7093] = v, f[7094] = w, f[7096] = 0, f[6990] = f[7099], f[6989] = -1, f[6994] = 27964, f[6993] = 27964, f[6996] = 27972, f[6995] = 27972, f[6998] = 27980, f[6997] = 27980, f[7e3] = 27988, f[6999] = 27988, f[7002] = 27996, f[7001] = 27996, f[7004] = 28004, f[7003] = 28004, f[7006] = 28012, f[7005] = 28012, f[7008] = 28020, f[7007] = 28020, f[7010] = 28028, f[7009] = 28028, f[7012] = 28036, f[7011] = 28036, f[7014] = 28044, f[7013] = 28044, f[7016] = 28052, f[7015] = 28052, f[7018] = 28060, f[7017] = 28060, f[7020] = 28068, f[7019] = 28068, f[7022] = 28076, f[7021] = 28076, f[7024] = 28084, f[7023] = 28084, f[7026] = 28092, f[7025] = 28092, f[7028] = 28100, f[7027] = 28100, f[7030] = 28108, f[7029] = 28108, f[7032] = 28116, f[7031] = 28116, f[7034] = 28124, f[7033] = 28124, f[7036] = 28132, f[7035] = 28132, f[7038] = 28140, f[7037] = 28140, f[7040] = 28148, f[7039] = 28148, f[7042] = 28156, f[7041] = 28156, f[7044] = 28164, f[7043] = 28164, f[7046] = 28172, f[7045] = 28172, f[7048] = 28180, f[7047] = 28180, f[7050] = 28188, f[7049] = 28188, f[7052] = 28196, f[7051] = 28196, f[7054] = 28204, f[7053] = 28204, f[7056] = 28212, f[7055] = 28212, me = w + -40 | 0, we = v + 8 | 0, we = (we & 7 | 0) == 0 ? 0 : 0 - we & 7, be = v + we | 0, we = me - we | 0, f[6987] = be, f[6984] = we, f[be + 4 >> 2] = we | 1, f[v + me + 4 >> 2] = 40, f[6988] = f[7103];
          while (!1);
          if (h = f[6984] | 0, h >>> 0 > Q >>> 0)
            return we = h - Q | 0, f[6984] = we, me = f[6987] | 0, be = me + Q | 0, f[6987] = be, f[be + 4 >> 2] = we | 1, f[me + 4 >> 2] = Q | 3, me = me + 8 | 0, q = nt, me | 0;
        }
        return me = yF() | 0, f[me >> 2] = 12, me = 0, q = nt, me | 0;
      }
      function Qt(d) {
        d = d | 0;
        var h = 0, p = 0, g = 0, x = 0, v = 0, w = 0, M = 0, P = 0;
        if (d) {
          p = d + -8 | 0, x = f[6985] | 0, d = f[d + -4 >> 2] | 0, h = d & -8, P = p + h | 0;
          do
            if (d & 1)
              M = p, w = p;
            else {
              if (g = f[p >> 2] | 0, !(d & 3) || (w = p + (0 - g) | 0, v = g + h | 0, w >>> 0 < x >>> 0))
                return;
              if ((f[6986] | 0) == (w | 0)) {
                if (d = P + 4 | 0, h = f[d >> 2] | 0, (h & 3 | 0) != 3) {
                  M = w, h = v;
                  break;
                }
                f[6983] = v, f[d >> 2] = h & -2, f[w + 4 >> 2] = v | 1, f[w + v >> 2] = v;
                return;
              }
              if (p = g >>> 3, g >>> 0 < 256)
                if (d = f[w + 8 >> 2] | 0, h = f[w + 12 >> 2] | 0, (h | 0) == (d | 0)) {
                  f[6981] = f[6981] & ~(1 << p), M = w, h = v;
                  break;
                } else {
                  f[d + 12 >> 2] = h, f[h + 8 >> 2] = d, M = w, h = v;
                  break;
                }
              x = f[w + 24 >> 2] | 0, d = f[w + 12 >> 2] | 0;
              do
                if ((d | 0) == (w | 0)) {
                  if (h = w + 16 | 0, p = h + 4 | 0, d = f[p >> 2] | 0, d)
                    h = p;
                  else if (d = f[h >> 2] | 0, !d) {
                    d = 0;
                    break;
                  }
                  for (; ; )
                    if (g = d + 20 | 0, p = f[g >> 2] | 0, p)
                      d = p, h = g;
                    else if (g = d + 16 | 0, p = f[g >> 2] | 0, p)
                      d = p, h = g;
                    else
                      break;
                  f[h >> 2] = 0;
                } else
                  M = f[w + 8 >> 2] | 0, f[M + 12 >> 2] = d, f[d + 8 >> 2] = M;
              while (!1);
              if (x) {
                if (h = f[w + 28 >> 2] | 0, p = 28228 + (h << 2) | 0, (f[p >> 2] | 0) == (w | 0)) {
                  if (f[p >> 2] = d, !d) {
                    f[6982] = f[6982] & ~(1 << h), M = w, h = v;
                    break;
                  }
                } else if (M = x + 16 | 0, f[((f[M >> 2] | 0) == (w | 0) ? M : x + 20 | 0) >> 2] = d, !d) {
                  M = w, h = v;
                  break;
                }
                f[d + 24 >> 2] = x, h = w + 16 | 0, p = f[h >> 2] | 0, p | 0 && (f[d + 16 >> 2] = p, f[p + 24 >> 2] = d), h = f[h + 4 >> 2] | 0, h ? (f[d + 20 >> 2] = h, f[h + 24 >> 2] = d, M = w, h = v) : (M = w, h = v);
              } else
                M = w, h = v;
            }
          while (!1);
          if (!(w >>> 0 >= P >>> 0) && (d = P + 4 | 0, g = f[d >> 2] | 0, !!(g & 1))) {
            if (g & 2)
              f[d >> 2] = g & -2, f[M + 4 >> 2] = h | 1, f[w + h >> 2] = h, x = h;
            else {
              if ((f[6987] | 0) == (P | 0)) {
                if (P = (f[6984] | 0) + h | 0, f[6984] = P, f[6987] = M, f[M + 4 >> 2] = P | 1, (M | 0) != (f[6986] | 0))
                  return;
                f[6986] = 0, f[6983] = 0;
                return;
              }
              if ((f[6986] | 0) == (P | 0)) {
                P = (f[6983] | 0) + h | 0, f[6983] = P, f[6986] = w, f[M + 4 >> 2] = P | 1, f[w + P >> 2] = P;
                return;
              }
              x = (g & -8) + h | 0, p = g >>> 3;
              do
                if (g >>> 0 < 256)
                  if (h = f[P + 8 >> 2] | 0, d = f[P + 12 >> 2] | 0, (d | 0) == (h | 0)) {
                    f[6981] = f[6981] & ~(1 << p);
                    break;
                  } else {
                    f[h + 12 >> 2] = d, f[d + 8 >> 2] = h;
                    break;
                  }
                else {
                  v = f[P + 24 >> 2] | 0, d = f[P + 12 >> 2] | 0;
                  do
                    if ((d | 0) == (P | 0)) {
                      if (h = P + 16 | 0, p = h + 4 | 0, d = f[p >> 2] | 0, d)
                        h = p;
                      else if (d = f[h >> 2] | 0, !d) {
                        p = 0;
                        break;
                      }
                      for (; ; )
                        if (g = d + 20 | 0, p = f[g >> 2] | 0, p)
                          d = p, h = g;
                        else if (g = d + 16 | 0, p = f[g >> 2] | 0, p)
                          d = p, h = g;
                        else
                          break;
                      f[h >> 2] = 0, p = d;
                    } else
                      p = f[P + 8 >> 2] | 0, f[p + 12 >> 2] = d, f[d + 8 >> 2] = p, p = d;
                  while (!1);
                  if (v | 0) {
                    if (d = f[P + 28 >> 2] | 0, h = 28228 + (d << 2) | 0, (f[h >> 2] | 0) == (P | 0)) {
                      if (f[h >> 2] = p, !p) {
                        f[6982] = f[6982] & ~(1 << d);
                        break;
                      }
                    } else if (g = v + 16 | 0, f[((f[g >> 2] | 0) == (P | 0) ? g : v + 20 | 0) >> 2] = p, !p)
                      break;
                    f[p + 24 >> 2] = v, d = P + 16 | 0, h = f[d >> 2] | 0, h | 0 && (f[p + 16 >> 2] = h, f[h + 24 >> 2] = p), d = f[d + 4 >> 2] | 0, d | 0 && (f[p + 20 >> 2] = d, f[d + 24 >> 2] = p);
                  }
                }
              while (!1);
              if (f[M + 4 >> 2] = x | 1, f[w + x >> 2] = x, (M | 0) == (f[6986] | 0)) {
                f[6983] = x;
                return;
              }
            }
            if (d = x >>> 3, x >>> 0 < 256) {
              p = 27964 + (d << 1 << 2) | 0, h = f[6981] | 0, d = 1 << d, h & d ? (h = p + 8 | 0, d = f[h >> 2] | 0) : (f[6981] = h | d, d = p, h = p + 8 | 0), f[h >> 2] = M, f[d + 12 >> 2] = M, f[M + 8 >> 2] = d, f[M + 12 >> 2] = p;
              return;
            }
            d = x >>> 8, d ? x >>> 0 > 16777215 ? g = 31 : (w = (d + 1048320 | 0) >>> 16 & 8, P = d << w, v = (P + 520192 | 0) >>> 16 & 4, P = P << v, g = (P + 245760 | 0) >>> 16 & 2, g = 14 - (v | w | g) + (P << g >>> 15) | 0, g = x >>> (g + 7 | 0) & 1 | g << 1) : g = 0, d = 28228 + (g << 2) | 0, f[M + 28 >> 2] = g, f[M + 20 >> 2] = 0, f[M + 16 >> 2] = 0, h = f[6982] | 0, p = 1 << g;
            e: do
              if (!(h & p))
                f[6982] = h | p, f[d >> 2] = M, f[M + 24 >> 2] = d, f[M + 12 >> 2] = M, f[M + 8 >> 2] = M;
              else {
                d = f[d >> 2] | 0;
                t: do
                  if ((f[d + 4 >> 2] & -8 | 0) != (x | 0)) {
                    for (g = x << ((g | 0) == 31 ? 0 : 25 - (g >>> 1) | 0); p = d + 16 + (g >>> 31 << 2) | 0, h = f[p >> 2] | 0, !!h; )
                      if ((f[h + 4 >> 2] & -8 | 0) == (x | 0)) {
                        d = h;
                        break t;
                      } else
                        g = g << 1, d = h;
                    f[p >> 2] = M, f[M + 24 >> 2] = d, f[M + 12 >> 2] = M, f[M + 8 >> 2] = M;
                    break e;
                  }
                while (!1);
                w = d + 8 | 0, P = f[w >> 2] | 0, f[P + 12 >> 2] = M, f[w >> 2] = M, f[M + 8 >> 2] = P, f[M + 12 >> 2] = d, f[M + 24 >> 2] = 0;
              }
            while (!1);
            if (P = (f[6989] | 0) + -1 | 0, f[6989] = P, !(P | 0)) {
              for (d = 28380; d = f[d >> 2] | 0, d; )
                d = d + 8 | 0;
              f[6989] = -1;
            }
          }
        }
      }
      function Gs(d, h) {
        d = d | 0, h = h | 0;
        var p = 0;
        return d ? (p = No(h, d) | 0, (h | d) >>> 0 > 65535 && (p = ((p >>> 0) / (d >>> 0) | 0 | 0) == (h | 0) ? p : -1)) : p = 0, d = Ra(p) | 0, !d || !(f[d + -4 >> 2] & 3) || au(d | 0, 0, p | 0) | 0, d | 0;
      }
      function jt(d, h, p, g) {
        return d = d | 0, h = h | 0, p = p | 0, g = g | 0, p = d + p >>> 0, xe(h + g + (p >>> 0 < d >>> 0 | 0) >>> 0 | 0), p | 0 | 0;
      }
      function wr(d, h, p, g) {
        return d = d | 0, h = h | 0, p = p | 0, g = g | 0, g = h - g - (p >>> 0 > d >>> 0 | 0) >>> 0, xe(g | 0), d - p >>> 0 | 0 | 0;
      }
      function oM(d) {
        return d = d | 0, (d ? 31 - (Ne(d ^ d - 1) | 0) | 0 : 32) | 0;
      }
      function Ox(d, h, p, g, x) {
        d = d | 0, h = h | 0, p = p | 0, g = g | 0, x = x | 0;
        var v = 0, w = 0, M = 0, P = 0, I = 0, k = 0, Q = 0, re = 0, se = 0, ae = 0;
        if (k = d, P = h, I = P, w = p, re = g, M = re, !I)
          return v = (x | 0) != 0, M ? v ? (f[x >> 2] = d | 0, f[x + 4 >> 2] = h & 0, re = 0, x = 0, xe(re | 0), x | 0) : (re = 0, x = 0, xe(re | 0), x | 0) : (v && (f[x >> 2] = (k >>> 0) % (w >>> 0), f[x + 4 >> 2] = 0), re = 0, x = (k >>> 0) / (w >>> 0) >>> 0, xe(re | 0), x | 0);
        v = (M | 0) == 0;
        do
          if (w) {
            if (!v) {
              if (v = (Ne(M | 0) | 0) - (Ne(I | 0) | 0) | 0, v >>> 0 <= 31) {
                Q = v + 1 | 0, M = 31 - v | 0, h = v - 31 >> 31, w = Q, d = k >>> (Q >>> 0) & h | I << M, h = I >>> (Q >>> 0) & h, v = 0, M = k << M;
                break;
              }
              return x ? (f[x >> 2] = d | 0, f[x + 4 >> 2] = P | h & 0, re = 0, x = 0, xe(re | 0), x | 0) : (re = 0, x = 0, xe(re | 0), x | 0);
            }
            if (v = w - 1 | 0, v & w | 0) {
              M = (Ne(w | 0) | 0) + 33 - (Ne(I | 0) | 0) | 0, ae = 64 - M | 0, Q = 32 - M | 0, P = Q >> 31, se = M - 32 | 0, h = se >> 31, w = M, d = Q - 1 >> 31 & I >>> (se >>> 0) | (I << Q | k >>> (M >>> 0)) & h, h = h & I >>> (M >>> 0), v = k << ae & P, M = (I << ae | k >>> (se >>> 0)) & P | k << Q & M - 33 >> 31;
              break;
            }
            return x | 0 && (f[x >> 2] = v & k, f[x + 4 >> 2] = 0), (w | 0) == 1 ? (se = P | h & 0, ae = d | 0 | 0, xe(se | 0), ae | 0) : (ae = oM(w | 0) | 0, se = I >>> (ae >>> 0) | 0, ae = I << 32 - ae | k >>> (ae >>> 0) | 0, xe(se | 0), ae | 0);
          } else {
            if (v)
              return x | 0 && (f[x >> 2] = (I >>> 0) % (w >>> 0), f[x + 4 >> 2] = 0), se = 0, ae = (I >>> 0) / (w >>> 0) >>> 0, xe(se | 0), ae | 0;
            if (!k)
              return x | 0 && (f[x >> 2] = 0, f[x + 4 >> 2] = (I >>> 0) % (M >>> 0)), se = 0, ae = (I >>> 0) / (M >>> 0) >>> 0, xe(se | 0), ae | 0;
            if (v = M - 1 | 0, !(v & M))
              return x | 0 && (f[x >> 2] = d | 0, f[x + 4 >> 2] = v & I | h & 0), se = 0, ae = I >>> ((oM(M | 0) | 0) >>> 0), xe(se | 0), ae | 0;
            if (v = (Ne(M | 0) | 0) - (Ne(I | 0) | 0) | 0, v >>> 0 <= 30) {
              h = v + 1 | 0, M = 31 - v | 0, w = h, d = I << M | k >>> (h >>> 0), h = I >>> (h >>> 0), v = 0, M = k << M;
              break;
            }
            return x ? (f[x >> 2] = d | 0, f[x + 4 >> 2] = P | h & 0, se = 0, ae = 0, xe(se | 0), ae | 0) : (se = 0, ae = 0, xe(se | 0), ae | 0);
          }
        while (!1);
        if (!w)
          I = M, P = 0, M = 0;
        else {
          Q = p | 0 | 0, k = re | g & 0, I = jt(Q | 0, k | 0, -1, -1) | 0, p = V() | 0, P = M, M = 0;
          do
            g = P, P = v >>> 31 | P << 1, v = M | v << 1, g = d << 1 | g >>> 31 | 0, re = d >>> 31 | h << 1 | 0, wr(I | 0, p | 0, g | 0, re | 0) | 0, ae = V() | 0, se = ae >> 31 | ((ae | 0) < 0 ? -1 : 0) << 1, M = se & 1, d = wr(g | 0, re | 0, se & Q | 0, (((ae | 0) < 0 ? -1 : 0) >> 31 | ((ae | 0) < 0 ? -1 : 0) << 1) & k | 0) | 0, h = V() | 0, w = w - 1 | 0;
          while ((w | 0) != 0);
          I = P, P = 0;
        }
        return w = 0, x | 0 && (f[x >> 2] = d, f[x + 4 >> 2] = h), se = (v | 0) >>> 31 | (I | w) << 1 | (w << 1 | v >>> 31) & 0 | P, ae = (v << 1 | 0) & -2 | M, xe(se | 0), ae | 0;
      }
      function ou(d, h, p, g) {
        d = d | 0, h = h | 0, p = p | 0, g = g | 0;
        var x = 0, v = 0, w = 0, M = 0, P = 0, I = 0;
        return I = h >> 31 | ((h | 0) < 0 ? -1 : 0) << 1, P = ((h | 0) < 0 ? -1 : 0) >> 31 | ((h | 0) < 0 ? -1 : 0) << 1, v = g >> 31 | ((g | 0) < 0 ? -1 : 0) << 1, x = ((g | 0) < 0 ? -1 : 0) >> 31 | ((g | 0) < 0 ? -1 : 0) << 1, M = wr(I ^ d | 0, P ^ h | 0, I | 0, P | 0) | 0, w = V() | 0, d = v ^ I, h = x ^ P, wr((Ox(M, w, wr(v ^ p | 0, x ^ g | 0, v | 0, x | 0) | 0, V() | 0, 0) | 0) ^ d | 0, (V() | 0) ^ h | 0, d | 0, h | 0) | 0;
      }
      function vF(d, h) {
        d = d | 0, h = h | 0;
        var p = 0, g = 0, x = 0, v = 0;
        return v = d & 65535, x = h & 65535, p = No(x, v) | 0, g = d >>> 16, d = (p >>> 16) + (No(x, g) | 0) | 0, x = h >>> 16, h = No(x, v) | 0, xe((d >>> 16) + (No(x, g) | 0) + (((d & 65535) + h | 0) >>> 16) | 0), d + h << 16 | p & 65535 | 0 | 0;
      }
      function Mr(d, h, p, g) {
        d = d | 0, h = h | 0, p = p | 0, g = g | 0;
        var x = 0, v = 0;
        return x = d, v = p, p = vF(x, v) | 0, d = V() | 0, xe((No(h, v) | 0) + (No(g, x) | 0) + d | d & 0 | 0), p | 0 | 0 | 0;
      }
      function Ad(d, h, p, g) {
        d = d | 0, h = h | 0, p = p | 0, g = g | 0;
        var x = 0, v = 0, w = 0, M = 0, P = 0, I = 0;
        return x = q, q = q + 16 | 0, M = x | 0, w = h >> 31 | ((h | 0) < 0 ? -1 : 0) << 1, v = ((h | 0) < 0 ? -1 : 0) >> 31 | ((h | 0) < 0 ? -1 : 0) << 1, I = g >> 31 | ((g | 0) < 0 ? -1 : 0) << 1, P = ((g | 0) < 0 ? -1 : 0) >> 31 | ((g | 0) < 0 ? -1 : 0) << 1, d = wr(w ^ d | 0, v ^ h | 0, w | 0, v | 0) | 0, h = V() | 0, Ox(d, h, wr(I ^ p | 0, P ^ g | 0, I | 0, P | 0) | 0, V() | 0, M) | 0, g = wr(f[M >> 2] ^ w | 0, f[M + 4 >> 2] ^ v | 0, w | 0, v | 0) | 0, p = V() | 0, q = x, xe(p | 0), g | 0;
      }
      function pd(d, h, p, g) {
        d = d | 0, h = h | 0, p = p | 0, g = g | 0;
        var x = 0, v = 0;
        return v = q, q = q + 16 | 0, x = v | 0, Ox(d, h, p, g, x) | 0, q = v, xe(f[x + 4 >> 2] | 0), f[x >> 2] | 0 | 0;
      }
      function aM(d, h, p) {
        return d = d | 0, h = h | 0, p = p | 0, (p | 0) < 32 ? (xe(h >> p | 0), d >>> p | (h & (1 << p) - 1) << 32 - p) : (xe(((h | 0) < 0 ? -1 : 0) | 0), h >> p - 32 | 0);
      }
      function qe(d, h, p) {
        return d = d | 0, h = h | 0, p = p | 0, (p | 0) < 32 ? (xe(h >>> p | 0), d >>> p | (h & (1 << p) - 1) << 32 - p) : (xe(0), h >>> p - 32 | 0);
      }
      function Ze(d, h, p) {
        return d = d | 0, h = h | 0, p = p | 0, (p | 0) < 32 ? (xe(h << p | (d & (1 << p) - 1 << 32 - p) >>> 32 - p | 0), d << p) : (xe(d << p - 32 | 0), 0);
      }
      function kx(d, h, p) {
        return d = d | 0, h = h | 0, h = Ne(h) | 0, (h | 0) == 32 && (h = h + (Ne(d) | 0) | 0), xe(0), h | 0;
      }
      function lM(d, h) {
        return d = +d, h = +h, d != d ? +h : h != h ? +d : +ve(+d, +h);
      }
      function nm(d, h) {
        return d = +d, h = +h, d != d ? +h : h != h ? +d : +Z(+d, +h);
      }
      function im(d) {
        return d = +d, d >= 0 ? +nr(d + 0.5) : +nu(d - 0.5);
      }
      function md(d, h, p) {
        d = d | 0, h = h | 0, p = p | 0;
        var g = 0, x = 0, v = 0;
        if ((p | 0) >= 8192)
          return Bt(d | 0, h | 0, p | 0) | 0, d | 0;
        if (v = d | 0, x = d + p | 0, (d & 3) == (h & 3)) {
          for (; d & 3; ) {
            if (!p)
              return v | 0;
            $e[d >> 0] = $e[h >> 0] | 0, d = d + 1 | 0, h = h + 1 | 0, p = p - 1 | 0;
          }
          for (p = x & -4 | 0, g = p - 64 | 0; (d | 0) <= (g | 0); )
            f[d >> 2] = f[h >> 2], f[d + 4 >> 2] = f[h + 4 >> 2], f[d + 8 >> 2] = f[h + 8 >> 2], f[d + 12 >> 2] = f[h + 12 >> 2], f[d + 16 >> 2] = f[h + 16 >> 2], f[d + 20 >> 2] = f[h + 20 >> 2], f[d + 24 >> 2] = f[h + 24 >> 2], f[d + 28 >> 2] = f[h + 28 >> 2], f[d + 32 >> 2] = f[h + 32 >> 2], f[d + 36 >> 2] = f[h + 36 >> 2], f[d + 40 >> 2] = f[h + 40 >> 2], f[d + 44 >> 2] = f[h + 44 >> 2], f[d + 48 >> 2] = f[h + 48 >> 2], f[d + 52 >> 2] = f[h + 52 >> 2], f[d + 56 >> 2] = f[h + 56 >> 2], f[d + 60 >> 2] = f[h + 60 >> 2], d = d + 64 | 0, h = h + 64 | 0;
          for (; (d | 0) < (p | 0); )
            f[d >> 2] = f[h >> 2], d = d + 4 | 0, h = h + 4 | 0;
        } else
          for (p = x - 4 | 0; (d | 0) < (p | 0); )
            $e[d >> 0] = $e[h >> 0] | 0, $e[d + 1 >> 0] = $e[h + 1 >> 0] | 0, $e[d + 2 >> 0] = $e[h + 2 >> 0] | 0, $e[d + 3 >> 0] = $e[h + 3 >> 0] | 0, d = d + 4 | 0, h = h + 4 | 0;
        for (; (d | 0) < (x | 0); )
          $e[d >> 0] = $e[h >> 0] | 0, d = d + 1 | 0, h = h + 1 | 0;
        return v | 0;
      }
      function au(d, h, p) {
        d = d | 0, h = h | 0, p = p | 0;
        var g = 0, x = 0, v = 0, w = 0;
        if (v = d + p | 0, h = h & 255, (p | 0) >= 67) {
          for (; d & 3; )
            $e[d >> 0] = h, d = d + 1 | 0;
          for (g = v & -4 | 0, w = h | h << 8 | h << 16 | h << 24, x = g - 64 | 0; (d | 0) <= (x | 0); )
            f[d >> 2] = w, f[d + 4 >> 2] = w, f[d + 8 >> 2] = w, f[d + 12 >> 2] = w, f[d + 16 >> 2] = w, f[d + 20 >> 2] = w, f[d + 24 >> 2] = w, f[d + 28 >> 2] = w, f[d + 32 >> 2] = w, f[d + 36 >> 2] = w, f[d + 40 >> 2] = w, f[d + 44 >> 2] = w, f[d + 48 >> 2] = w, f[d + 52 >> 2] = w, f[d + 56 >> 2] = w, f[d + 60 >> 2] = w, d = d + 64 | 0;
          for (; (d | 0) < (g | 0); )
            f[d >> 2] = w, d = d + 4 | 0;
        }
        for (; (d | 0) < (v | 0); )
          $e[d >> 0] = h, d = d + 1 | 0;
        return v - p | 0;
      }
      function uM(d) {
        return d = +d, d >= 0 ? +nr(d + 0.5) : +nu(d - 0.5);
      }
      function lu(d) {
        d = d | 0;
        var h = 0, p = 0, g = 0;
        return g = yt() | 0, p = f[jn >> 2] | 0, h = p + d | 0, (d | 0) > 0 & (h | 0) < (p | 0) | (h | 0) < 0 ? (ln(h | 0) | 0, Dt(12), -1) : (h | 0) > (g | 0) && !($t(h | 0) | 0) ? (Dt(12), -1) : (f[jn >> 2] = h, p | 0);
      }
      return {
        ___divdi3: ou,
        ___muldi3: Mr,
        ___remdi3: Ad,
        ___uremdi3: pd,
        _areNeighborCells: uB,
        _bitshift64Ashr: aM,
        _bitshift64Lshr: qe,
        _bitshift64Shl: Ze,
        _calloc: Gs,
        _cellAreaKm2: zB,
        _cellAreaM2: qB,
        _cellAreaRads2: Ix,
        _cellToBoundary: dd,
        _cellToCenterChild: Gw,
        _cellToChildPos: LB,
        _cellToChildren: TB,
        _cellToChildrenSize: xA,
        _cellToLatLng: mc,
        _cellToLocalIj: QB,
        _cellToParent: Mx,
        _cellToVertex: Lo,
        _cellToVertexes: pF,
        _cellsToDirectedEdge: cB,
        _cellsToLinkedMultiPolygon: H7,
        _childPosToCell: IB,
        _compactCells: wB,
        _constructCell: bB,
        _destroyLinkedMultiPolygon: $w,
        _directedEdgeToBoundary: Z0,
        _directedEdgeToCells: fB,
        _edgeLengthKm: WB,
        _edgeLengthM: $B,
        _edgeLengthRads: HB,
        _emscripten_replace_memory: Cn,
        _free: Qt,
        _getBaseCellNumber: kw,
        _getDirectedEdgeDestination: dB,
        _getDirectedEdgeOrigin: hB,
        _getHexagonAreaAvgKm2: Hw,
        _getHexagonAreaAvgM2: kB,
        _getHexagonEdgeLengthAvgKm: VB,
        _getHexagonEdgeLengthAvgM: GB,
        _getIcosahedronFaces: zw,
        _getIndexDigit: vB,
        _getNumCells: J0,
        _getPentagons: Nx,
        _getRes0Cells: Y7,
        _getResolution: yB,
        _greatCircleDistanceKm: vA,
        _greatCircleDistanceM: FB,
        _greatCircleDistanceRads: BB,
        _gridDisk: Kn,
        _gridDiskDistances: Hn,
        _gridDistance: ZB,
        _gridPathCells: eF,
        _gridPathCellsSize: JB,
        _gridRing: hc,
        _gridRingUnsafe: Ai,
        _i64Add: jt,
        _i64Subtract: wr,
        _isPentagon: xi,
        _isResClassIII: RB,
        _isValidCell: Tx,
        _isValidDirectedEdge: Fw,
        _isValidIndex: SB,
        _isValidVertex: tM,
        _latLngToCell: Cx,
        _llvm_ctlz_i64: kx,
        _llvm_maxnum_f64: lM,
        _llvm_minnum_f64: nm,
        _llvm_round_f64: im,
        _localIjToCell: KB,
        _malloc: Ra,
        _maxFaceCount: NB,
        _maxGridDiskSize: Jt,
        _maxPolygonToCellsSize: kr,
        _maxPolygonToCellsSizeExperimental: iF,
        _memcpy: md,
        _memset: au,
        _originToDirectedEdges: AB,
        _pentagonCount: DB,
        _polygonToCells: gA,
        _polygonToCellsExperimental: nF,
        _readInt64AsDoubleFromPointer: hF,
        _res0CellCount: X7,
        _round: uM,
        _sbrk: lu,
        _sizeOfCellBoundary: oF,
        _sizeOfCoordIJ: cF,
        _sizeOfGeoLoop: aF,
        _sizeOfGeoPolygon: lF,
        _sizeOfH3Index: rF,
        _sizeOfLatLng: sF,
        _sizeOfLinkedGeoPolygon: uF,
        _uncompactCells: MB,
        _uncompactCellsSize: EB,
        _vertexToLatLng: mF,
        establishStackSpace: fi,
        stackAlloc: oi,
        stackRestore: Ui,
        stackSave: Fi
      };
    })(pt, Rn, G)
  );
  e.___divdi3 = ie.___divdi3, e.___muldi3 = ie.___muldi3, e.___remdi3 = ie.___remdi3, e.___uremdi3 = ie.___uremdi3, e._areNeighborCells = ie._areNeighborCells, e._bitshift64Ashr = ie._bitshift64Ashr, e._bitshift64Lshr = ie._bitshift64Lshr, e._bitshift64Shl = ie._bitshift64Shl, e._calloc = ie._calloc, e._cellAreaKm2 = ie._cellAreaKm2, e._cellAreaM2 = ie._cellAreaM2, e._cellAreaRads2 = ie._cellAreaRads2, e._cellToBoundary = ie._cellToBoundary, e._cellToCenterChild = ie._cellToCenterChild, e._cellToChildPos = ie._cellToChildPos, e._cellToChildren = ie._cellToChildren, e._cellToChildrenSize = ie._cellToChildrenSize, e._cellToLatLng = ie._cellToLatLng, e._cellToLocalIj = ie._cellToLocalIj, e._cellToParent = ie._cellToParent, e._cellToVertex = ie._cellToVertex, e._cellToVertexes = ie._cellToVertexes, e._cellsToDirectedEdge = ie._cellsToDirectedEdge, e._cellsToLinkedMultiPolygon = ie._cellsToLinkedMultiPolygon, e._childPosToCell = ie._childPosToCell, e._compactCells = ie._compactCells, e._constructCell = ie._constructCell, e._destroyLinkedMultiPolygon = ie._destroyLinkedMultiPolygon, e._directedEdgeToBoundary = ie._directedEdgeToBoundary, e._directedEdgeToCells = ie._directedEdgeToCells, e._edgeLengthKm = ie._edgeLengthKm, e._edgeLengthM = ie._edgeLengthM, e._edgeLengthRads = ie._edgeLengthRads;
  var bt = e._emscripten_replace_memory = ie._emscripten_replace_memory;
  e._free = ie._free, e._getBaseCellNumber = ie._getBaseCellNumber, e._getDirectedEdgeDestination = ie._getDirectedEdgeDestination, e._getDirectedEdgeOrigin = ie._getDirectedEdgeOrigin, e._getHexagonAreaAvgKm2 = ie._getHexagonAreaAvgKm2, e._getHexagonAreaAvgM2 = ie._getHexagonAreaAvgM2, e._getHexagonEdgeLengthAvgKm = ie._getHexagonEdgeLengthAvgKm, e._getHexagonEdgeLengthAvgM = ie._getHexagonEdgeLengthAvgM, e._getIcosahedronFaces = ie._getIcosahedronFaces, e._getIndexDigit = ie._getIndexDigit, e._getNumCells = ie._getNumCells, e._getPentagons = ie._getPentagons, e._getRes0Cells = ie._getRes0Cells, e._getResolution = ie._getResolution, e._greatCircleDistanceKm = ie._greatCircleDistanceKm, e._greatCircleDistanceM = ie._greatCircleDistanceM, e._greatCircleDistanceRads = ie._greatCircleDistanceRads, e._gridDisk = ie._gridDisk, e._gridDiskDistances = ie._gridDiskDistances, e._gridDistance = ie._gridDistance, e._gridPathCells = ie._gridPathCells, e._gridPathCellsSize = ie._gridPathCellsSize, e._gridRing = ie._gridRing, e._gridRingUnsafe = ie._gridRingUnsafe, e._i64Add = ie._i64Add, e._i64Subtract = ie._i64Subtract, e._isPentagon = ie._isPentagon, e._isResClassIII = ie._isResClassIII, e._isValidCell = ie._isValidCell, e._isValidDirectedEdge = ie._isValidDirectedEdge, e._isValidIndex = ie._isValidIndex, e._isValidVertex = ie._isValidVertex, e._latLngToCell = ie._latLngToCell, e._llvm_ctlz_i64 = ie._llvm_ctlz_i64, e._llvm_maxnum_f64 = ie._llvm_maxnum_f64, e._llvm_minnum_f64 = ie._llvm_minnum_f64, e._llvm_round_f64 = ie._llvm_round_f64, e._localIjToCell = ie._localIjToCell, e._malloc = ie._malloc, e._maxFaceCount = ie._maxFaceCount, e._maxGridDiskSize = ie._maxGridDiskSize, e._maxPolygonToCellsSize = ie._maxPolygonToCellsSize, e._maxPolygonToCellsSizeExperimental = ie._maxPolygonToCellsSizeExperimental, e._memcpy = ie._memcpy, e._memset = ie._memset, e._originToDirectedEdges = ie._originToDirectedEdges, e._pentagonCount = ie._pentagonCount, e._polygonToCells = ie._polygonToCells, e._polygonToCellsExperimental = ie._polygonToCellsExperimental, e._readInt64AsDoubleFromPointer = ie._readInt64AsDoubleFromPointer, e._res0CellCount = ie._res0CellCount, e._round = ie._round, e._sbrk = ie._sbrk, e._sizeOfCellBoundary = ie._sizeOfCellBoundary, e._sizeOfCoordIJ = ie._sizeOfCoordIJ, e._sizeOfGeoLoop = ie._sizeOfGeoLoop, e._sizeOfGeoPolygon = ie._sizeOfGeoPolygon, e._sizeOfH3Index = ie._sizeOfH3Index, e._sizeOfLatLng = ie._sizeOfLatLng, e._sizeOfLinkedGeoPolygon = ie._sizeOfLinkedGeoPolygon, e._uncompactCells = ie._uncompactCells, e._uncompactCellsSize = ie._uncompactCellsSize, e._vertexToLatLng = ie._vertexToLatLng, e.establishStackSpace = ie.establishStackSpace;
  var lt = e.stackAlloc = ie.stackAlloc, Ct = e.stackRestore = ie.stackRestore, it = e.stackSave = ie.stackSave;
  if (e.asm = ie, e.cwrap = R, e.setValue = _, e.getValue = y, Nt) {
    ne(Nt) || (Nt = s(Nt));
    {
      Et();
      var He = function(De) {
        De.byteLength && (De = new Uint8Array(De)), Y.set(De, m), e.memoryInitializerRequest && delete e.memoryInitializerRequest.response, dt();
      }, At = function() {
        o(Nt, He, function() {
          throw "could not load memory initializer " + Nt;
        });
      }, pn = Vt(Nt);
      if (pn)
        He(pn.buffer);
      else if (e.memoryInitializerRequest) {
        var di = function() {
          var De = e.memoryInitializerRequest, ze = De.response;
          if (De.status !== 200 && De.status !== 0) {
            var mt = Vt(e.memoryInitializerRequestURL);
            if (mt)
              ze = mt.buffer;
            else {
              console.warn("a problem seems to have happened with Module.memoryInitializerRequest, status: " + De.status + ", retrying " + Nt), At();
              return;
            }
          }
          He(ze);
        };
        e.memoryInitializerRequest.response ? setTimeout(di, 0) : e.memoryInitializerRequest.addEventListener("load", di);
      } else
        At();
    }
  }
  var $n;
  te = function De() {
    $n || Os(), $n || (te = De);
  };
  function Os(De) {
    if (Ye > 0 || (ke(), Ye > 0))
      return;
    function ze() {
      $n || ($n = !0, !T && (at(), wt(), e.onRuntimeInitialized && e.onRuntimeInitialized(), ot()));
    }
    e.setStatus ? (e.setStatus("Running..."), setTimeout(function() {
      setTimeout(function() {
        e.setStatus("");
      }, 1), ze();
    }, 1)) : ze();
  }
  e.run = Os;
  function es(De) {
    throw e.onAbort && e.onAbort(De), De += "", a(De), l(De), T = !0, "abort(" + De + "). Build with -s ASSERTIONS=1 for more info.";
  }
  if (e.abort = es, e.preInit)
    for (typeof e.preInit == "function" && (e.preInit = [e.preInit]); e.preInit.length > 0; )
      e.preInit.pop()();
  return Os(), i;
})(typeof zn == "object" ? zn : {}), rn = "number", tn = rn, Wd = rn, un = rn, cn = rn, Rr = rn, Rt = rn, tQ = [
  // The size functions are inserted via build/sizes.h
  ["sizeOfH3Index", rn],
  ["sizeOfLatLng", rn],
  ["sizeOfCellBoundary", rn],
  ["sizeOfGeoLoop", rn],
  ["sizeOfGeoPolygon", rn],
  ["sizeOfLinkedGeoPolygon", rn],
  ["sizeOfCoordIJ", rn],
  ["readInt64AsDoubleFromPointer", rn],
  // The remaining functions are defined in the core lib in h3Api.h
  ["isValidCell", Wd, [un, cn]],
  ["isValidIndex", Wd, [un, cn]],
  ["latLngToCell", tn, [rn, rn, Rr, Rt]],
  ["cellToLatLng", tn, [un, cn, Rt]],
  ["cellToBoundary", tn, [un, cn, Rt]],
  ["maxGridDiskSize", tn, [rn, Rt]],
  ["gridDisk", tn, [un, cn, rn, Rt]],
  ["gridDiskDistances", tn, [un, cn, rn, Rt, Rt]],
  ["gridRing", tn, [un, cn, rn, Rt]],
  ["gridRingUnsafe", tn, [un, cn, rn, Rt]],
  ["maxPolygonToCellsSize", tn, [Rt, Rr, rn, Rt]],
  ["polygonToCells", tn, [Rt, Rr, rn, Rt]],
  ["maxPolygonToCellsSizeExperimental", tn, [Rt, Rr, rn, Rt]],
  ["polygonToCellsExperimental", tn, [Rt, Rr, rn, rn, rn, Rt]],
  ["cellsToLinkedMultiPolygon", tn, [Rt, rn, Rt]],
  ["destroyLinkedMultiPolygon", null, [Rt]],
  ["compactCells", tn, [Rt, Rt, rn, rn]],
  ["uncompactCells", tn, [Rt, rn, rn, Rt, rn, Rr]],
  ["uncompactCellsSize", tn, [Rt, rn, rn, Rr, Rt]],
  ["isPentagon", Wd, [un, cn]],
  ["isResClassIII", Wd, [un, cn]],
  ["getBaseCellNumber", rn, [un, cn]],
  ["getResolution", rn, [un, cn]],
  ["getIndexDigit", rn, [un, cn, rn]],
  ["constructCell", tn, [rn, rn, Rt, Rt]],
  ["maxFaceCount", tn, [un, cn, Rt]],
  ["getIcosahedronFaces", tn, [un, cn, Rt]],
  ["cellToParent", tn, [un, cn, Rr, Rt]],
  ["cellToChildren", tn, [un, cn, Rr, Rt]],
  ["cellToCenterChild", tn, [un, cn, Rr, Rt]],
  ["cellToChildrenSize", tn, [un, cn, Rr, Rt]],
  ["cellToChildPos", tn, [un, cn, Rr, Rt]],
  ["childPosToCell", tn, [rn, rn, un, cn, Rr, Rt]],
  ["areNeighborCells", tn, [un, cn, un, cn, Rt]],
  ["cellsToDirectedEdge", tn, [un, cn, un, cn, Rt]],
  ["getDirectedEdgeOrigin", tn, [un, cn, Rt]],
  ["getDirectedEdgeDestination", tn, [un, cn, Rt]],
  ["isValidDirectedEdge", Wd, [un, cn]],
  ["directedEdgeToCells", tn, [un, cn, Rt]],
  ["originToDirectedEdges", tn, [un, cn, Rt]],
  ["directedEdgeToBoundary", tn, [un, cn, Rt]],
  ["gridDistance", tn, [un, cn, un, cn, Rt]],
  ["gridPathCells", tn, [un, cn, un, cn, Rt]],
  ["gridPathCellsSize", tn, [un, cn, un, cn, Rt]],
  ["cellToLocalIj", tn, [un, cn, un, cn, rn, Rt]],
  ["localIjToCell", tn, [un, cn, Rt, rn, Rt]],
  ["getHexagonAreaAvgM2", tn, [Rr, Rt]],
  ["getHexagonAreaAvgKm2", tn, [Rr, Rt]],
  ["getHexagonEdgeLengthAvgM", tn, [Rr, Rt]],
  ["getHexagonEdgeLengthAvgKm", tn, [Rr, Rt]],
  ["greatCircleDistanceM", rn, [Rt, Rt]],
  ["greatCircleDistanceKm", rn, [Rt, Rt]],
  ["greatCircleDistanceRads", rn, [Rt, Rt]],
  ["cellAreaM2", tn, [un, cn, Rt]],
  ["cellAreaKm2", tn, [un, cn, Rt]],
  ["cellAreaRads2", tn, [un, cn, Rt]],
  ["edgeLengthM", tn, [un, cn, Rt]],
  ["edgeLengthKm", tn, [un, cn, Rt]],
  ["edgeLengthRads", tn, [un, cn, Rt]],
  ["getNumCells", tn, [Rr, Rt]],
  ["getRes0Cells", tn, [Rt]],
  ["res0CellCount", rn],
  ["getPentagons", tn, [rn, Rt]],
  ["pentagonCount", rn],
  ["cellToVertex", tn, [un, cn, rn, Rt]],
  ["cellToVertexes", tn, [un, cn, Rt]],
  ["vertexToLatLng", tn, [un, cn, Rt]],
  ["isValidVertex", Wd, [un, cn]]
], nQ = 0, iQ = 1, rQ = 2, sQ = 3, OP = 4, oQ = 5, aQ = 6, lQ = 7, uQ = 8, cQ = 9, hQ = 10, dQ = 11, fQ = 12, AQ = 13, pQ = 14, mQ = 15, gQ = 16, _Q = 17, xQ = 18, yQ = 19, or = {};
or[nQ] = "Success";
or[iQ] = "The operation failed but a more specific error is not available";
or[rQ] = "Argument was outside of acceptable range";
or[sQ] = "Latitude or longitude arguments were outside of acceptable range";
or[OP] = "Resolution argument was outside of acceptable range";
or[oQ] = "Cell argument was not valid";
or[aQ] = "Directed edge argument was not valid";
or[lQ] = "Undirected edge argument was not valid";
or[uQ] = "Vertex argument was not valid";
or[cQ] = "Pentagon distortion was encountered";
or[hQ] = "Duplicate input";
or[dQ] = "Cell arguments were not neighbors";
or[fQ] = "Cell arguments had incompatible resolutions";
or[AQ] = "Memory allocation failed";
or[pQ] = "Bounds of provided memory were insufficient";
or[mQ] = "Mode or flags argument was not valid";
or[gQ] = "Index argument was not valid";
or[_Q] = "Base cell number was outside of acceptable range";
or[xQ] = "Child indexing digits invalid";
or[yQ] = "Child indexing digits refer to a deleted subsequence";
var vQ = 1e3, kP = 1001, VP = 1002, w2 = {};
w2[vQ] = "Unknown unit";
w2[kP] = "Array length out of bounds";
w2[VP] = "Got unexpected null value for H3 index";
var bQ = "Unknown error";
function GP(i, e, t) {
  var n = t && "value" in t, r = new Error((i[e] || bQ) + " (code: " + e + (n ? ", value: " + t.value : "") + ")");
  return r.code = e, r;
}
function zP(i, e) {
  var t = arguments.length === 2 ? {
    value: e
  } : {};
  return GP(or, i, t);
}
function qP(i, e) {
  var t = arguments.length === 2 ? {
    value: e
  } : {};
  return GP(w2, i, t);
}
function n0(i) {
  if (i !== 0)
    throw zP(i);
}
var ro = {};
tQ.forEach(function(e) {
  ro[e[0]] = zn.cwrap.apply(zn, e);
});
var hf = 16, i0 = 4, jf = 8, SQ = 8, e_ = ro.sizeOfH3Index(), LS = ro.sizeOfLatLng(), TQ = ro.sizeOfCellBoundary(), wQ = ro.sizeOfGeoPolygon(), Ep = ro.sizeOfGeoLoop();
ro.sizeOfLinkedGeoPolygon();
ro.sizeOfCoordIJ();
function MQ(i) {
  if (typeof i != "number" || i < 0 || i > 15 || Math.floor(i) !== i)
    throw zP(OP, i);
  return i;
}
function EQ(i) {
  if (!i)
    throw qP(VP);
  return i;
}
var RQ = Math.pow(2, 32) - 1;
function CQ(i) {
  if (i > RQ)
    throw qP(kP, i);
  return i;
}
var PQ = /[^0-9a-fA-F]/;
function HP(i) {
  if (Array.isArray(i) && i.length === 2 && Number.isInteger(i[0]) && Number.isInteger(i[1]))
    return i;
  if (typeof i != "string" || PQ.test(i))
    return [0, 0];
  var e = parseInt(i.substring(0, i.length - 8), hf), t = parseInt(i.substring(i.length - 8), hf);
  return [t, e];
}
function hR(i) {
  if (i >= 0)
    return i.toString(hf);
  i = i & 2147483647;
  var e = WP(8, i.toString(hf)), t = (parseInt(e[0], hf) + 8).toString(hf);
  return e = t + e.substring(1), e;
}
function NQ(i, e) {
  return hR(e) + WP(8, hR(i));
}
function WP(i, e) {
  for (var t = i - e.length, n = "", r = 0; r < t; r++)
    n += "0";
  return n = n + e, n;
}
function dR(i, e, t) {
  for (var n = i.length, r = zn._calloc(n, LS), s = t ? 1 : 0, o = t ? 0 : 1, a = 0; a < n * 2; a += 2)
    zn.HEAPF64.set([i[a / 2][s], i[a / 2][o]].map(YP), r / jf + a);
  return zn.HEAPU32.set([n, r], e / i0), e;
}
function DQ(i, e) {
  var t = i.length - 1, n = zn._calloc(wQ), r = 0, s = r + Ep, o = s + i0;
  dR(i[0], n + r, e);
  var a;
  if (t > 0) {
    a = zn._calloc(t, Ep);
    for (var l = 0; l < t; l++)
      dR(i[l + 1], a + Ep * l, e);
  }
  return zn.setValue(n + s, t, "i32"), zn.setValue(n + o, a, "i32"), n;
}
function LQ(i) {
  var e = 0, t = e + Ep, n = t + i0, r = i0;
  zn._free(zn.getValue(i + e + r, "i8*"));
  var s = zn.getValue(i + t, "i32");
  if (s > 0) {
    for (var o = zn.getValue(i + n, "i32"), a = 0; a < s; a++)
      zn._free(zn.getValue(o + Ep * a + r, "i8*"));
    zn._free(o);
  }
  zn._free(i);
}
function $P(i, e) {
  e === void 0 && (e = 0);
  var t = zn.getValue(i + e_ * e, "i32"), n = zn.getValue(i + e_ * e + i0, "i32");
  return n ? NQ(t, n) : null;
}
function IQ(i) {
  return ro.readInt64AsDoubleFromPointer(i);
}
function BQ(i, e) {
  for (var t = [], n = 0; n < e; n++) {
    var r = $P(i, n);
    r !== null && t.push(r);
  }
  return t;
}
function t_(i) {
  return VQ(zn.getValue(i, "double"));
}
function FQ(i) {
  return [t_(i), t_(i + jf)];
}
function UQ(i) {
  return [t_(i + jf), t_(i)];
}
function OQ(i, e, t) {
  for (var n = zn.getValue(i, "i32"), r = i + jf, s = [], o = UQ, a = 0; a < n * 2; a += 2)
    s.push(o(r + jf * a));
  return s.push(s[0]), s;
}
function kQ(i, e, t) {
  var n = zn._malloc(LS);
  zn.HEAPF64.set([i, e].map(YP), n / jf);
  var r = zn._malloc(e_);
  try {
    return n0(ro.latLngToCell(n, t, r)), EQ($P(r));
  } finally {
    zn._free(r), zn._free(n);
  }
}
function jP(i) {
  var e = zn._malloc(LS), t = HP(i), n = t[0], r = t[1];
  try {
    return n0(ro.cellToLatLng(n, r, e)), FQ(e);
  } finally {
    zn._free(e);
  }
}
function XP(i, e) {
  var t = zn._malloc(TQ), n = HP(i), r = n[0], s = n[1];
  try {
    return n0(ro.cellToBoundary(r, s, t)), OQ(t, e, e);
  } finally {
    zn._free(t);
  }
}
function fR(i, e, t) {
  if (MQ(e), t = !!t, i.length === 0 || i[0].length === 0)
    return [];
  var n = typeof i[0][0] == "number" ? [i] : i, r = DQ(
    // @ts-expect-error - There's no way to convince TS that polygon is now number[][][]
    n,
    t
  ), s = zn._malloc(SQ);
  try {
    n0(ro.maxPolygonToCellsSize(r, e, 0, s));
    var o = CQ(IQ(s)), a = zn._calloc(o, e_);
    try {
      return n0(ro.polygonToCells(r, e, 0, a)), BQ(a, o);
    } finally {
      zn._free(a);
    }
  } finally {
    zn._free(s), LQ(r);
  }
}
function YP(i) {
  return i * Math.PI / 180;
}
function VQ(i) {
  return i * 180 / Math.PI;
}
function GQ(i) {
  return i = Math.max(0, Math.min(1, i)), "rgb(" + Math.max(0, Math.min(255, Math.round(34.61 + i * (1172.33 - i * (10793.56 - i * (33300.12 - i * (38394.49 - i * 14825.05))))))) + ", " + Math.max(0, Math.min(255, Math.round(23.31 + i * (557.33 + i * (1225.33 - i * (3574.96 - i * (1073.77 + i * 707.56))))))) + ", " + Math.max(0, Math.min(255, Math.round(27.2 + i * (3211.1 - i * (15327.97 - i * (27814 - i * (22569.18 - i * 6838.66))))))) + ")";
}
const zQ = [
  "alphaMap",
  "alphaTest",
  "anisotropy",
  "anisotropyMap",
  "anisotropyRotation",
  "aoMap",
  "aoMapIntensity",
  "attenuationColor",
  "attenuationDistance",
  "bumpMap",
  "clearcoat",
  "clearcoatMap",
  "clearcoatNormalMap",
  "clearcoatNormalScale",
  "clearcoatRoughness",
  "color",
  "dispersion",
  "displacementMap",
  "emissive",
  "emissiveIntensity",
  "emissiveMap",
  "envMap",
  "envMapIntensity",
  "gradientMap",
  "ior",
  "iridescence",
  "iridescenceIOR",
  "iridescenceMap",
  "iridescenceThicknessMap",
  "lightMap",
  "lightMapIntensity",
  "map",
  "matcap",
  "metalness",
  "metalnessMap",
  "normalMap",
  "normalScale",
  "opacity",
  "roughness",
  "roughnessMap",
  "sheen",
  "sheenColor",
  "sheenColorMap",
  "sheenRoughnessMap",
  "shininess",
  "specular",
  "specularColor",
  "specularColorMap",
  "specularIntensity",
  "specularIntensityMap",
  "specularMap",
  "thickness",
  "transmission",
  "transmissionMap"
], qy = /* @__PURE__ */ new WeakMap();
class qQ {
  /**
   * Constructs a new node material observer.
   *
   * @param {NodeBuilder} builder - The node builder.
   */
  constructor(e) {
    this.renderObjects = /* @__PURE__ */ new WeakMap(), this.hasNode = this.containsNode(e), this.hasAnimation = e.object.isSkinnedMesh === !0, this.refreshUniforms = zQ, this.renderId = 0;
  }
  /**
   * Returns `true` if the given render object is verified for the first time of this observer.
   *
   * @param {RenderObject} renderObject - The render object.
   * @return {boolean} Whether the given render object is verified for the first time of this observer.
   */
  firstInitialization(e) {
    return this.renderObjects.has(e) === !1 ? (this.getRenderObjectData(e), !0) : !1;
  }
  /**
   * Returns `true` if the current rendering produces motion vectors.
   *
   * @param {Renderer} renderer - The renderer.
   * @return {boolean} Whether the current rendering produces motion vectors or not.
   */
  needsVelocity(e) {
    const t = e.getMRT();
    return t !== null && t.has("velocity");
  }
  /**
   * Returns monitoring data for the given render object.
   *
   * @param {RenderObject} renderObject - The render object.
   * @return {Object} The monitoring data.
   */
  getRenderObjectData(e) {
    let t = this.renderObjects.get(e);
    if (t === void 0) {
      const { geometry: n, material: r, object: s } = e;
      if (t = {
        material: this.getMaterialData(r),
        geometry: {
          id: n.id,
          attributes: this.getAttributesData(n.attributes),
          indexVersion: n.index ? n.index.version : null,
          drawRange: { start: n.drawRange.start, count: n.drawRange.count }
        },
        worldMatrix: s.matrixWorld.clone()
      }, s.center && (t.center = s.center.clone()), s.morphTargetInfluences && (t.morphTargetInfluences = s.morphTargetInfluences.slice()), e.bundle !== null && (t.version = e.bundle.version), t.material.transmission > 0) {
        const { width: o, height: a } = e.context;
        t.bufferWidth = o, t.bufferHeight = a;
      }
      t.lights = this.getLightsData(e.lightsNode.getLights()), this.renderObjects.set(e, t);
    }
    return t;
  }
  /**
   * Returns an attribute data structure holding the attributes versions for
   * monitoring.
   *
   * @param {Object} attributes - The geometry attributes.
   * @return {Object} An object for monitoring the versions of attributes.
   */
  getAttributesData(e) {
    const t = {};
    for (const n in e) {
      const r = e[n];
      t[n] = {
        version: r.version
      };
    }
    return t;
  }
  /**
   * Returns `true` if the node builder's material uses
   * node properties.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {boolean} Whether the node builder's material uses node properties or not.
   */
  containsNode(e) {
    const t = e.material;
    for (const n in t)
      if (t[n] && t[n].isNode)
        return !0;
    return !!(e.context.modelViewMatrix || e.context.modelNormalViewMatrix || e.context.getAO || e.context.getShadow);
  }
  /**
   * Returns a material data structure holding the material property values for
   * monitoring.
   *
   * @param {Material} material - The material.
   * @return {Object} An object for monitoring material properties.
   */
  getMaterialData(e) {
    const t = {};
    for (const n of this.refreshUniforms) {
      const r = e[n];
      r != null && (typeof r == "object" && r.clone !== void 0 ? r.isTexture === !0 ? t[n] = { id: r.id, version: r.version } : t[n] = r.clone() : t[n] = r);
    }
    return t;
  }
  /**
   * Returns `true` if the given render object has not changed its state.
   *
   * @param {RenderObject} renderObject - The render object.
   * @param {Array<Light>} lightsData - The current material lights.
   * @return {boolean} Whether the given render object has changed its state or not.
   */
  equals(e, t) {
    const { object: n, material: r, geometry: s } = e, o = this.getRenderObjectData(e);
    if (o.worldMatrix.equals(n.matrixWorld) !== !0)
      return o.worldMatrix.copy(n.matrixWorld), !1;
    const a = o.material;
    for (const b in a) {
      const S = a[b], E = r[b];
      if (S.equals !== void 0) {
        if (S.equals(E) === !1)
          return S.copy(E), !1;
      } else if (E.isTexture === !0) {
        if (S.id !== E.id || S.version !== E.version)
          return S.id = E.id, S.version = E.version, !1;
      } else if (S !== E)
        return a[b] = E, !1;
    }
    if (a.transmission > 0) {
      const { width: b, height: S } = e.context;
      if (o.bufferWidth !== b || o.bufferHeight !== S)
        return o.bufferWidth = b, o.bufferHeight = S, !1;
    }
    const l = o.geometry, u = s.attributes, c = l.attributes, A = Object.keys(c), m = Object.keys(u);
    if (l.id !== s.id)
      return l.id = s.id, !1;
    if (A.length !== m.length)
      return o.geometry.attributes = this.getAttributesData(u), !1;
    for (const b of A) {
      const S = c[b], E = u[b];
      if (E === void 0)
        return delete c[b], !1;
      if (S.version !== E.version)
        return S.version = E.version, !1;
    }
    const _ = s.index, y = l.indexVersion, T = _ ? _.version : null;
    if (y !== T)
      return l.indexVersion = T, !1;
    if (l.drawRange.start !== s.drawRange.start || l.drawRange.count !== s.drawRange.count)
      return l.drawRange.start = s.drawRange.start, l.drawRange.count = s.drawRange.count, !1;
    if (o.morphTargetInfluences) {
      let b = !1;
      for (let S = 0; S < o.morphTargetInfluences.length; S++)
        o.morphTargetInfluences[S] !== n.morphTargetInfluences[S] && (o.morphTargetInfluences[S] = n.morphTargetInfluences[S], b = !0);
      if (b) return !1;
    }
    if (o.lights) {
      for (let b = 0; b < t.length; b++)
        if (o.lights[b].map !== t[b].map)
          return !1;
    }
    return o.center && o.center.equals(n.center) === !1 ? (o.center.copy(n.center), !0) : (e.bundle !== null && (o.version = e.bundle.version), !0);
  }
  /**
   * Returns the lights data for the given material lights.
   *
   * @param {Array<Light>} materialLights - The material lights.
   * @return {Array<Object>} The lights data for the given material lights.
   */
  getLightsData(e) {
    const t = [];
    for (const n of e)
      n.isSpotLight === !0 && n.map !== null && t.push({ map: n.map.version });
    return t;
  }
  /**
   * Returns the lights for the given lights node and render ID.
   *
   * @param {LightsNode} lightsNode - The lights node.
   * @param {number} renderId - The render ID.
   * @return {Array<Object>} The lights for the given lights node and render ID.
   */
  getLights(e, t) {
    if (qy.has(e)) {
      const r = qy.get(e);
      if (r.renderId === t)
        return r.lightsData;
    }
    const n = this.getLightsData(e.getLights());
    return qy.set(e, { renderId: t, lightsData: n }), n;
  }
  /**
   * Checks if the given render object requires a refresh.
   *
   * @param {RenderObject} renderObject - The render object.
   * @param {NodeFrame} nodeFrame - The current node frame.
   * @return {boolean} Whether the given render object requires a refresh or not.
   */
  needsRefresh(e, t) {
    if (this.hasNode || this.hasAnimation || this.firstInitialization(e) || this.needsVelocity(t.renderer))
      return !0;
    const { renderId: n } = t;
    if (this.renderId !== n)
      return this.renderId = n, !0;
    const r = e.object.static === !0, s = e.bundle !== null && e.bundle.static === !0 && this.getRenderObjectData(e).version === e.bundle.version;
    if (r || s)
      return !1;
    const o = this.getLights(e.lightsNode, n);
    return this.equals(e, o) !== !0;
  }
}
function IS(i, e = 0) {
  let t = 3735928559 ^ e, n = 1103547991 ^ e;
  if (i instanceof Array)
    for (let r = 0, s; r < i.length; r++)
      s = i[r], t = Math.imul(t ^ s, 2654435761), n = Math.imul(n ^ s, 1597334677);
  else
    for (let r = 0, s; r < i.length; r++)
      s = i.charCodeAt(r), t = Math.imul(t ^ s, 2654435761), n = Math.imul(n ^ s, 1597334677);
  return t = Math.imul(t ^ t >>> 16, 2246822507), t ^= Math.imul(n ^ n >>> 13, 3266489909), n = Math.imul(n ^ n >>> 16, 2246822507), n ^= Math.imul(t ^ t >>> 13, 3266489909), 4294967296 * (2097151 & n) + (t >>> 0);
}
const F0 = (i) => IS(i), cA = (i) => IS(i), Rp = (...i) => IS(i), HQ = /* @__PURE__ */ new Map([
  [1, "float"],
  [2, "vec2"],
  [3, "vec3"],
  [4, "vec4"],
  [9, "mat3"],
  [16, "mat4"]
]), AR = /* @__PURE__ */ new WeakMap();
function QP(i) {
  return HQ.get(i);
}
function n_(i) {
  if (/[iu]?vec\d/.test(i))
    return i.startsWith("ivec") ? Int32Array : i.startsWith("uvec") ? Uint32Array : Float32Array;
  if (/mat\d/.test(i) || /float/.test(i)) return Float32Array;
  if (/uint/.test(i)) return Uint32Array;
  if (/int/.test(i)) return Int32Array;
  throw new Error(`THREE.NodeUtils: Unsupported type: ${i}`);
}
function KP(i) {
  if (/float|int|uint/.test(i)) return 1;
  if (/vec2/.test(i)) return 2;
  if (/vec3/.test(i)) return 3;
  if (/vec4/.test(i) || /mat2/.test(i)) return 4;
  if (/mat3/.test(i)) return 9;
  if (/mat4/.test(i)) return 16;
  Ie("TSL: Unsupported type:", i);
}
function WQ(i) {
  if (/float|int|uint/.test(i)) return 1;
  if (/vec2/.test(i)) return 2;
  if (/vec3/.test(i)) return 3;
  if (/vec4/.test(i) || /mat2/.test(i)) return 4;
  if (/mat3/.test(i)) return 12;
  if (/mat4/.test(i)) return 16;
  Ie("TSL: Unsupported type:", i);
}
function $Q(i) {
  if (/float|int|uint/.test(i)) return 4;
  if (/vec2/.test(i)) return 8;
  if (/vec3/.test(i) || /vec4/.test(i)) return 16;
  if (/mat2/.test(i)) return 8;
  if (/mat3/.test(i) || /mat4/.test(i)) return 16;
  Ie("TSL: Unsupported type:", i);
}
function Bu(i) {
  if (i == null) return null;
  const e = typeof i;
  return i.isNode === !0 ? "node" : e === "number" ? "float" : e === "boolean" ? "bool" : e === "string" ? "string" : e === "function" ? "shader" : i.isVector2 === !0 ? "vec2" : i.isVector3 === !0 ? "vec3" : i.isVector4 === !0 ? "vec4" : i.isMatrix2 === !0 ? "mat2" : i.isMatrix3 === !0 ? "mat3" : i.isMatrix4 === !0 ? "mat4" : i.isColor === !0 ? "color" : i instanceof ArrayBuffer ? "ArrayBuffer" : null;
}
function BS(i, ...e) {
  const t = i ? i.slice(-4) : void 0;
  return e.length === 1 && (t === "vec2" ? e = [e[0], e[0]] : t === "vec3" ? e = [e[0], e[0], e[0]] : t === "vec4" && (e = [e[0], e[0], e[0], e[0]])), i === "color" ? new ct(...e) : t === "vec2" ? new Le(...e) : t === "vec3" ? new j(...e) : t === "vec4" ? new Kt(...e) : t === "mat2" ? new D0(...e) : t === "mat3" ? new fn(...e) : t === "mat4" ? new Mt(...e) : i === "bool" ? e[0] || !1 : i === "float" || i === "int" || i === "uint" ? e[0] || 0 : i === "string" ? e[0] || "" : i === "ArrayBuffer" ? eN(e[0]) : null;
}
function ZP(i) {
  let e = AR.get(i);
  return e === void 0 && (e = {}, AR.set(i, e)), e;
}
function JP(i) {
  let e = "";
  const t = new Uint8Array(i);
  for (let n = 0; n < t.length; n++)
    e += String.fromCharCode(t[n]);
  return btoa(e);
}
function eN(i) {
  return Uint8Array.from(atob(i), (e) => e.charCodeAt(0)).buffer;
}
const _p = {
  VERTEX: "vertex",
  FRAGMENT: "fragment"
}, hn = {
  NONE: "none",
  FRAME: "frame",
  RENDER: "render",
  OBJECT: "object"
}, jQ = {
  BOOLEAN: "bool",
  INTEGER: "int",
  FLOAT: "float",
  VECTOR2: "vec2",
  VECTOR3: "vec3",
  VECTOR4: "vec4",
  MATRIX2: "mat2",
  MATRIX3: "mat3",
  MATRIX4: "mat4"
}, Xr = {
  READ_ONLY: "readOnly",
  WRITE_ONLY: "writeOnly",
  READ_WRITE: "readWrite"
}, tN = ["fragment", "vertex"], Db = ["setup", "analyze", "generate"], Lb = [...tN, "compute"], rd = ["x", "y", "z", "w"], XQ = {
  analyze: "setup",
  generate: "analyze"
};
let YQ = 0;
class St extends lo {
  static get type() {
    return "Node";
  }
  /**
   * Constructs a new node.
   *
   * @param {?string} nodeType - The node type.
   */
  constructor(e = null) {
    super(), this.nodeType = e, this.updateType = hn.NONE, this.updateBeforeType = hn.NONE, this.updateAfterType = hn.NONE, this.uuid = zh.generateUUID(), this.version = 0, this.name = "", this.global = !1, this.parents = !1, this.isNode = !0, this._beforeNodes = null, this._cacheKey = null, this._cacheKeyVersion = 0, Object.defineProperty(this, "id", { value: YQ++ });
  }
  /**
   * Set this property to `true` when the node should be regenerated.
   *
   * @type {boolean}
   * @default false
   * @param {boolean} value
   */
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  /**
   * The type of the class. The value is usually the constructor name.
   *
   * @type {string}
  	 * @readonly
   */
  get type() {
    return this.constructor.type;
  }
  /**
   * Convenient method for defining {@link Node#update}.
   *
   * @param {Function} callback - The update method.
   * @param {string} updateType - The update type.
   * @return {Node} A reference to this node.
   */
  onUpdate(e, t) {
    return this.updateType = t, this.update = e.bind(this), this;
  }
  /**
   * Convenient method for defining {@link Node#update}. Similar to {@link Node#onUpdate}, but
   * this method automatically sets the update type to `FRAME`.
   *
   * @param {Function} callback - The update method.
   * @return {Node} A reference to this node.
   */
  onFrameUpdate(e) {
    return this.onUpdate(e, hn.FRAME);
  }
  /**
   * Convenient method for defining {@link Node#update}. Similar to {@link Node#onUpdate}, but
   * this method automatically sets the update type to `RENDER`.
   *
   * @param {Function} callback - The update method.
   * @return {Node} A reference to this node.
   */
  onRenderUpdate(e) {
    return this.onUpdate(e, hn.RENDER);
  }
  /**
   * Convenient method for defining {@link Node#update}. Similar to {@link Node#onUpdate}, but
   * this method automatically sets the update type to `OBJECT`.
   *
   * @param {Function} callback - The update method.
   * @return {Node} A reference to this node.
   */
  onObjectUpdate(e) {
    return this.onUpdate(e, hn.OBJECT);
  }
  /**
   * Convenient method for defining {@link Node#updateReference}.
   *
   * @param {Function} callback - The update method.
   * @return {Node} A reference to this node.
   */
  onReference(e) {
    return this.updateReference = e.bind(this), this;
  }
  /**
   * Nodes might refer to other objects like materials. This method allows to dynamically update the reference
   * to such objects based on a given state (e.g. the current node frame or builder).
   *
   * @param {any} state - This method can be invocated in different contexts so `state` can refer to any object type.
   * @return {any} The updated reference.
   */
  updateReference() {
    return this;
  }
  /**
   * By default this method returns the value of the {@link Node#global} flag. This method
   * can be overwritten in derived classes if an analytical way is required to determine the
   * global cache referring to the current shader-stage.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {boolean} Whether this node is global or not.
   */
  isGlobal() {
    return this.global;
  }
  /**
   * Generator function that can be used to iterate over the child nodes.
   *
   * @generator
   * @yields {Node} A child node.
   */
  *getChildren() {
    for (const { childNode: e } of this._getChildren())
      yield e;
  }
  /**
   * Calling this method dispatches the `dispose` event. This event can be used
   * to register event listeners for clean up tasks.
   */
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  /**
   * Callback for {@link Node#traverse}.
   *
   * @callback traverseCallback
   * @param {Node} node - The current node.
   */
  /**
   * Can be used to traverse through the node's hierarchy.
   *
   * @param {traverseCallback} callback - A callback that is executed per node.
   */
  traverse(e) {
    e(this);
    for (const t of this.getChildren())
      t.traverse(e);
  }
  /**
   * Returns the child nodes of this node.
   *
   * @private
   * @param {Set<Node>} [ignores=new Set()] - A set of nodes to ignore during the search to avoid circular references.
   * @returns {Array<Object>} An array of objects describing the child nodes.
   */
  _getChildren(e = /* @__PURE__ */ new Set()) {
    const t = [];
    e.add(this);
    for (const n of Object.getOwnPropertyNames(this)) {
      const r = this[n];
      if (!(n.startsWith("_") === !0 || e.has(r))) {
        if (Array.isArray(r) === !0)
          for (let s = 0; s < r.length; s++) {
            const o = r[s];
            o && o.isNode === !0 && t.push({ property: n, index: s, childNode: o });
          }
        else if (r && r.isNode === !0)
          t.push({ property: n, childNode: r });
        else if (r && Object.getPrototypeOf(r) === Object.prototype)
          for (const s in r) {
            if (s.startsWith("_") === !0) continue;
            const o = r[s];
            o && o.isNode === !0 && t.push({ property: n, index: s, childNode: o });
          }
      }
    }
    return t;
  }
  /**
   * Returns the cache key for this node.
   *
   * @param {boolean} [force=false] - When set to `true`, a recomputation of the cache key is forced.
   * @param {Set<Node>} [ignores=null] - A set of nodes to ignore during the computation of the cache key.
   * @return {number} The cache key of the node.
   */
  getCacheKey(e = !1, t = null) {
    if (e = e || this.version !== this._cacheKeyVersion, e === !0 || this._cacheKey === null) {
      t === null && (t = /* @__PURE__ */ new Set());
      const n = [];
      for (const { property: r, childNode: s } of this._getChildren(t))
        n.push(F0(r.slice(0, -4)), s.getCacheKey(e, t));
      this._cacheKey = Rp(cA(n), this.customCacheKey()), this._cacheKeyVersion = this.version;
    }
    return this._cacheKey;
  }
  /**
   * Generate a custom cache key for this node.
   *
   * @return {number} The cache key of the node.
   */
  customCacheKey() {
    return this.id;
  }
  /**
   * Returns the references to this node which is by default `this`.
   *
   * @return {Node} A reference to this node.
   */
  getScope() {
    return this;
  }
  /**
   * Returns the hash of the node which is used to identify the node. By default it's
   * the {@link Node#uuid} however derived node classes might have to overwrite this method
   * depending on their implementation.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The hash.
   */
  getHash() {
    return this.uuid;
  }
  /**
   * Returns the update type of {@link Node#update}.
   *
   * @return {NodeUpdateType} The update type.
   */
  getUpdateType() {
    return this.updateType;
  }
  /**
   * Returns the update type of {@link Node#updateBefore}.
   *
   * @return {NodeUpdateType} The update type.
   */
  getUpdateBeforeType() {
    return this.updateBeforeType;
  }
  /**
   * Returns the update type of {@link Node#updateAfter}.
   *
   * @return {NodeUpdateType} The update type.
   */
  getUpdateAfterType() {
    return this.updateAfterType;
  }
  /**
   * Certain types are composed of multiple elements. For example a `vec3`
   * is composed of three `float` values. This method returns the type of
   * these elements.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The type of the node.
   */
  getElementType(e) {
    const t = this.getNodeType(e);
    return e.getElementType(t);
  }
  /**
   * Returns the node member type for the given name.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {string} name - The name of the member.
   * @return {string} The type of the node.
   */
  getMemberType() {
    return "void";
  }
  /**
   * Returns the node's type.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The type of the node.
   */
  getNodeType(e) {
    const t = e.getNodeProperties(this);
    return t.outputNode ? t.outputNode.getNodeType(e) : this.nodeType;
  }
  /**
   * This method is used during the build process of a node and ensures
   * equal nodes are not built multiple times but just once. For example if
   * `attribute( 'uv' )` is used multiple times by the user, the build
   * process makes sure to process just the first node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node} The shared node if possible. Otherwise `this` is returned.
   */
  getShared(e) {
    const t = this.getHash(e);
    return e.getNodeFromHash(t) || this;
  }
  /**
   * Returns the number of elements in the node array.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {?number} The number of elements in the node array.
   */
  getArrayCount() {
    return null;
  }
  /**
   * Represents the setup stage which is the first step of the build process, see {@link Node#build} method.
   * This method is often overwritten in derived modules to prepare the node which is used as a node's output/result.
   * If an output node is prepared, then it must be returned in the `return` statement of the derived module's setup function.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {?Node} The output node.
   */
  setup(e) {
    const t = e.getNodeProperties(this);
    let n = 0;
    for (const r of this.getChildren())
      t["node" + n++] = r;
    return t.outputNode || null;
  }
  /**
   * Represents the analyze stage which is the second step of the build process, see {@link Node#build} method.
   * This stage analyzes the node hierarchy and ensures descendent nodes are built.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {?Node} output - The target output node.
   */
  analyze(e, t = null) {
    const n = e.increaseUsage(this);
    if (this.parents === !0) {
      const r = e.getDataFromNode(this, "any");
      r.stages = r.stages || {}, r.stages[e.shaderStage] = r.stages[e.shaderStage] || [], r.stages[e.shaderStage].push(t);
    }
    if (n === 1) {
      const r = e.getNodeProperties(this);
      for (const s of Object.values(r))
        s && s.isNode === !0 && s.build(e, this);
    }
  }
  /**
   * Represents the generate stage which is the third step of the build process, see {@link Node#build} method.
   * This state builds the output node and returns the resulting shader string.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {?string} [output] - Can be used to define the output type.
   * @return {?string} The generated shader string.
   */
  generate(e, t) {
    const { outputNode: n } = e.getNodeProperties(this);
    if (n && n.isNode === !0)
      return n.build(e, t);
  }
  /**
   * The method can be implemented to update the node's internal state before it is used to render an object.
   * The {@link Node#updateBeforeType} property defines how often the update is executed.
   *
   * @abstract
   * @param {NodeFrame} frame - A reference to the current node frame.
   * @return {?boolean} An optional bool that indicates whether the implementation actually performed an update or not (e.g. due to caching).
   */
  updateBefore() {
    Me("Abstract function.");
  }
  /**
   * The method can be implemented to update the node's internal state after it was used to render an object.
   * The {@link Node#updateAfterType} property defines how often the update is executed.
   *
   * @abstract
   * @param {NodeFrame} frame - A reference to the current node frame.
   * @return {?boolean} An optional bool that indicates whether the implementation actually performed an update or not (e.g. due to caching).
   */
  updateAfter() {
    Me("Abstract function.");
  }
  /**
   * The method can be implemented to update the node's internal state when it is used to render an object.
   * The {@link Node#updateType} property defines how often the update is executed.
   *
   * @abstract
   * @param {NodeFrame} frame - A reference to the current node frame.
   * @return {?boolean} An optional bool that indicates whether the implementation actually performed an update or not (e.g. due to caching).
   */
  update() {
    Me("Abstract function.");
  }
  before(e) {
    return this._beforeNodes === null && (this._beforeNodes = []), this._beforeNodes.push(e), this;
  }
  /**
   * This method performs the build of a node. The behavior and return value depend on the current build stage:
   * - **setup**: Prepares the node and its children for the build process. This process can also create new nodes. Returns the node itself or a variant.
   * - **analyze**: Analyzes the node hierarchy for optimizations in the code generation stage. Returns `null`.
   * - **generate**: Generates the shader code for the node. Returns the generated shader string.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {?(string|Node)} [output=null] - Can be used to define the output type.
   * @return {?(Node|string)} The result of the build process, depending on the build stage.
   */
  build(e, t = null) {
    const n = this.getShared(e);
    if (this !== n)
      return n.build(e, t);
    if (this._beforeNodes !== null) {
      const l = this._beforeNodes;
      this._beforeNodes = null;
      for (const u of l)
        u.build(e, t);
      this._beforeNodes = l;
    }
    const r = e.getDataFromNode(this);
    r.buildStages = r.buildStages || {}, r.buildStages[e.buildStage] = !0;
    const s = XQ[e.buildStage];
    if (s && r.buildStages[s] !== !0) {
      const l = e.getBuildStage();
      e.setBuildStage(s), this.build(e), e.setBuildStage(l);
    }
    e.addNode(this), e.addChain(this);
    let o = null;
    const a = e.getBuildStage();
    if (a === "setup") {
      this.updateReference(e);
      const l = e.getNodeProperties(this);
      if (l.initialized !== !0) {
        l.initialized = !0, l.outputNode = this.setup(e) || l.outputNode || null;
        for (const u of Object.values(l))
          if (u && u.isNode === !0) {
            if (u.parents === !0) {
              const c = e.getNodeProperties(u);
              c.parents = c.parents || [], c.parents.push(this);
            }
            u.build(e);
          }
      }
      o = l.outputNode;
    } else if (a === "analyze")
      this.analyze(e, t);
    else if (a === "generate") {
      if (this.generate.length < 2) {
        const u = this.getNodeType(e), c = e.getDataFromNode(this);
        o = c.snippet, o === void 0 ? c.generated === void 0 ? (c.generated = !0, o = this.generate(e) || "", c.snippet = o) : (Me("Node: Recursion detected.", this), o = "/* Recursion detected. */") : c.flowCodes !== void 0 && e.context.nodeBlock !== void 0 && e.addFlowCodeHierarchy(this, e.context.nodeBlock), o = e.format(o, u, t);
      } else
        o = this.generate(e, t) || "";
      o === "" && t !== null && t !== "void" && t !== "OutputType" && (Ie(`TSL: Invalid generated code, expected a "${t}".`), o = e.generateConst(t));
    }
    return e.removeChain(this), e.addSequentialNode(this), o;
  }
  /**
   * Returns the child nodes as a JSON object.
   *
   * @return {Generator<Object>} An iterable list of serialized child objects as JSON.
   */
  getSerializeChildren() {
    return this._getChildren();
  }
  /**
   * Serializes the node to JSON.
   *
   * @param {Object} json - The output JSON object.
   */
  serialize(e) {
    const t = this.getSerializeChildren(), n = {};
    for (const { property: r, index: s, childNode: o } of t)
      s !== void 0 ? (n[r] === void 0 && (n[r] = Number.isInteger(s) ? [] : {}), n[r][s] = o.toJSON(e.meta).uuid) : n[r] = o.toJSON(e.meta).uuid;
    Object.keys(n).length > 0 && (e.inputNodes = n);
  }
  /**
   * Deserializes the node from the given JSON.
   *
   * @param {Object} json - The JSON object.
   */
  deserialize(e) {
    if (e.inputNodes !== void 0) {
      const t = e.meta.nodes;
      for (const n in e.inputNodes)
        if (Array.isArray(e.inputNodes[n])) {
          const r = [];
          for (const s of e.inputNodes[n])
            r.push(t[s]);
          this[n] = r;
        } else if (typeof e.inputNodes[n] == "object") {
          const r = {};
          for (const s in e.inputNodes[n]) {
            const o = e.inputNodes[n][s];
            r[s] = t[o];
          }
          this[n] = r;
        } else {
          const r = e.inputNodes[n];
          this[n] = t[r];
        }
    }
  }
  /**
   * Serializes the node into the three.js JSON Object/Scene format.
   *
   * @param {?Object} meta - An optional JSON object that already holds serialized data from other scene objects.
   * @return {Object} The serialized node.
   */
  toJSON(e) {
    const { uuid: t, type: n } = this, r = e === void 0 || typeof e == "string";
    r && (e = {
      textures: {},
      images: {},
      nodes: {}
    });
    let s = e.nodes[t];
    s === void 0 && (s = {
      uuid: t,
      type: n,
      meta: e,
      metadata: {
        version: 4.7,
        type: "Node",
        generator: "Node.toJSON"
      }
    }, r !== !0 && (e.nodes[s.uuid] = s), this.serialize(s), delete s.meta);
    function o(a) {
      const l = [];
      for (const u in a) {
        const c = a[u];
        delete c.metadata, l.push(c);
      }
      return l;
    }
    if (r) {
      const a = o(e.textures), l = o(e.images), u = o(e.nodes);
      a.length > 0 && (s.textures = a), l.length > 0 && (s.images = l), u.length > 0 && (s.nodes = u);
    }
    return s;
  }
}
class sd extends St {
  // @TODO: If extending from TempNode it breaks webgpu_compute
  static get type() {
    return "ArrayElementNode";
  }
  /**
   * Constructs an array element node.
   *
   * @param {Node} node - The array-like node.
   * @param {Node} indexNode - The index node that defines the element access.
   */
  constructor(e, t) {
    super(), this.node = e, this.indexNode = t, this.isArrayElementNode = !0;
  }
  /**
   * This method is overwritten since the node type is inferred from the array-like node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(e) {
    return this.node.getElementType(e);
  }
  /**
   * This method is overwritten since the member type is inferred from the array-like node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {string} name - The member name.
   * @return {string} The member type.
   */
  getMemberType(e, t) {
    return this.node.getMemberType(e, t);
  }
  generate(e) {
    const t = this.indexNode.getNodeType(e), n = this.node.build(e), r = this.indexNode.build(e, !e.isVector(t) && e.isInteger(t) ? t : "uint");
    return `${n}[ ${r} ]`;
  }
}
class nN extends St {
  static get type() {
    return "ConvertNode";
  }
  /**
   * Constructs a new convert node.
   *
   * @param {Node} node - The node which type should be converted.
   * @param {string} convertTo - The target node type. Multiple types can be defined by separating them with a `|` sign.
   */
  constructor(e, t) {
    super(), this.node = e, this.convertTo = t;
  }
  /**
   * This method is overwritten since the implementation tries to infer the best
   * matching type from the {@link ConvertNode#convertTo} property.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(e) {
    const t = this.node.getNodeType(e);
    let n = null;
    for (const r of this.convertTo.split("|"))
      (n === null || e.getTypeLength(t) === e.getTypeLength(r)) && (n = r);
    return n;
  }
  serialize(e) {
    super.serialize(e), e.convertTo = this.convertTo;
  }
  deserialize(e) {
    super.deserialize(e), this.convertTo = e.convertTo;
  }
  generate(e, t) {
    const n = this.node, r = this.getNodeType(e), s = n.build(e, r);
    return e.format(s, r, t);
  }
}
class Hi extends St {
  static get type() {
    return "TempNode";
  }
  /**
   * Constructs a temp node.
   *
   * @param {?string} nodeType - The node type.
   */
  constructor(e = null) {
    super(e), this.isTempNode = !0;
  }
  /**
   * Whether this node is used more than once in context of other nodes.
   *
   * @param {NodeBuilder} builder - The node builder.
   * @return {boolean} A flag that indicates if there is more than one dependency to other nodes.
   */
  hasDependencies(e) {
    return e.getDataFromNode(this).usageCount > 1;
  }
  build(e, t) {
    if (e.getBuildStage() === "generate") {
      const r = e.getVectorType(this.getNodeType(e, t)), s = e.getDataFromNode(this);
      if (s.propertyName !== void 0)
        return e.format(s.propertyName, r, t);
      if (r !== "void" && t !== "void" && this.hasDependencies(e)) {
        const o = super.build(e, r), a = e.getVarFromNode(this, null, r), l = e.getPropertyName(a);
        return e.addLineFlowCode(`${l} = ${o}`, this), s.snippet = o, s.propertyName = l, e.format(s.propertyName, r, t);
      }
    }
    return super.build(e, t);
  }
}
class QQ extends Hi {
  static get type() {
    return "JoinNode";
  }
  /**
   * Constructs a new join node.
   *
   * @param {Array<Node>} nodes - An array of nodes that should be joined.
   * @param {?string} [nodeType=null] - The node type.
   */
  constructor(e = [], t = null) {
    super(t), this.nodes = e;
  }
  /**
   * This method is overwritten since the node type must be inferred from the
   * joined data length if not explicitly defined.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(e) {
    return this.nodeType !== null ? e.getVectorType(this.nodeType) : e.getTypeFromLength(this.nodes.reduce((t, n) => t + e.getTypeLength(n.getNodeType(e)), 0));
  }
  generate(e, t) {
    const n = this.getNodeType(e), r = e.getTypeLength(n), s = this.nodes, o = e.getComponentType(n), a = [];
    let l = 0;
    for (const c of s) {
      if (l >= r) {
        Ie(`TSL: Length of parameters exceeds maximum length of function '${n}()' type.`);
        break;
      }
      let A = c.getNodeType(e), m = e.getTypeLength(A), _;
      if (l + m > r && (Ie(`TSL: Length of '${n}()' data exceeds maximum length of output type.`), m = r - l, A = e.getTypeFromLength(m)), l += m, _ = c.build(e, A), e.getComponentType(A) !== o) {
        const T = e.getTypeFromLength(m, o);
        _ = e.format(_, A, T);
      }
      a.push(_);
    }
    const u = `${e.getType(n)}( ${a.join(", ")} )`;
    return e.format(u, n, t);
  }
}
const KQ = rd.join("");
class iN extends St {
  static get type() {
    return "SplitNode";
  }
  /**
   * Constructs a new split node.
   *
   * @param {Node} node - The node that should be accessed.
   * @param {string} [components='x'] - The components that should be accessed.
   */
  constructor(e, t = "x") {
    super(), this.node = e, this.components = t, this.isSplitNode = !0;
  }
  /**
   * Returns the vector length which is computed based on the requested components.
   *
   * @return {number} The vector length.
   */
  getVectorLength() {
    let e = this.components.length;
    for (const t of this.components)
      e = Math.max(rd.indexOf(t) + 1, e);
    return e;
  }
  /**
   * Returns the component type of the node's type.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The component type.
   */
  getComponentType(e) {
    return e.getComponentType(this.node.getNodeType(e));
  }
  /**
   * This method is overwritten since the node type is inferred from requested components.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(e) {
    return e.getTypeFromLength(this.components.length, this.getComponentType(e));
  }
  /**
   * Returns the scope of the node.
   *
   * @return {Node} The scope of the node.
   */
  getScope() {
    return this.node.getScope();
  }
  generate(e, t) {
    const n = this.node, r = e.getTypeLength(n.getNodeType(e));
    let s = null;
    if (r > 1) {
      let o = null;
      this.getVectorLength() >= r && (o = e.getTypeFromLength(this.getVectorLength(), this.getComponentType(e)));
      const l = n.build(e, o);
      this.components.length === r && this.components === KQ.slice(0, this.components.length) ? s = e.format(l, o, t) : s = e.format(`${l}.${this.components}`, this.getNodeType(e), t);
    } else
      s = n.build(e, t);
    return s;
  }
  serialize(e) {
    super.serialize(e), e.components = this.components;
  }
  deserialize(e) {
    super.deserialize(e), this.components = e.components;
  }
}
class ZQ extends Hi {
  static get type() {
    return "SetNode";
  }
  /**
   * Constructs a new set node.
   *
   * @param {Node} sourceNode - The node that should be updated.
   * @param {string} components - The components that should be updated.
   * @param {Node} targetNode - The value node.
   */
  constructor(e, t, n) {
    super(), this.sourceNode = e, this.components = t, this.targetNode = n;
  }
  /**
   * This method is overwritten since the node type is inferred from {@link SetNode#sourceNode}.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(e) {
    return this.sourceNode.getNodeType(e);
  }
  generate(e) {
    const { sourceNode: t, components: n, targetNode: r } = this, s = this.getNodeType(e), o = e.getComponentType(r.getNodeType(e)), a = e.getTypeFromLength(n.length, o), l = r.build(e, a), u = t.build(e, s), c = e.getTypeLength(s), A = [];
    for (let m = 0; m < c; m++) {
      const _ = rd[m];
      _ === n[0] ? (A.push(l), m += n.length - 1) : A.push(u + "." + _);
    }
    return `${e.getType(s)}( ${A.join(", ")} )`;
  }
}
class JQ extends Hi {
  static get type() {
    return "FlipNode";
  }
  /**
   * Constructs a new flip node.
   *
   * @param {Node} sourceNode - The node which component(s) should be flipped.
   * @param {string} components - The components that should be flipped e.g. `'x'` or `'xy'`.
   */
  constructor(e, t) {
    super(), this.sourceNode = e, this.components = t;
  }
  /**
   * This method is overwritten since the node type is inferred from the source node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(e) {
    return this.sourceNode.getNodeType(e);
  }
  generate(e) {
    const { components: t, sourceNode: n } = this, r = this.getNodeType(e), s = n.build(e), o = e.getVarFromNode(this), a = e.getPropertyName(o);
    e.addLineFlowCode(a + " = " + s, this);
    const l = e.getTypeLength(r), u = [];
    let c = 0;
    for (let A = 0; A < l; A++) {
      const m = rd[A];
      m === t[c] ? (u.push("1.0 - " + (a + "." + m)), c++) : u.push(a + "." + m);
    }
    return `${e.getType(r)}( ${u.join(", ")} )`;
  }
}
class FS extends St {
  static get type() {
    return "InputNode";
  }
  /**
   * Constructs a new input node.
   *
   * @param {any} value - The value of this node. This can be any JS primitive, functions, array buffers or even three.js objects (vector, matrices, colors).
   * @param {?string} nodeType - The node type. If no explicit type is defined, the node tries to derive the type from its value.
   */
  constructor(e, t = null) {
    super(t), this.isInputNode = !0, this.value = e, this.precision = null;
  }
  getNodeType() {
    return this.nodeType === null ? Bu(this.value) : this.nodeType;
  }
  /**
   * Returns the input type of the node which is by default the node type. Derived modules
   * might overwrite this method and use a fixed type or compute one analytically.
   *
   * A typical example for different input and node types are textures. The input type of a
   * normal RGBA texture is `texture` whereas its node type is `vec4`.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The input type.
   */
  getInputType(e) {
    return this.getNodeType(e);
  }
  /**
   * Sets the precision to the given value. The method can be
   * overwritten in derived classes if the final precision must be computed
   * analytically.
   *
   * @param {('low'|'medium'|'high')} precision - The precision of the input value in the shader.
   * @return {InputNode} A reference to this node.
   */
  setPrecision(e) {
    return this.precision = e, this;
  }
  serialize(e) {
    super.serialize(e), e.value = this.value, this.value && this.value.toArray && (e.value = this.value.toArray()), e.valueType = Bu(this.value), e.nodeType = this.nodeType, e.valueType === "ArrayBuffer" && (e.value = JP(e.value)), e.precision = this.precision;
  }
  deserialize(e) {
    super.deserialize(e), this.nodeType = e.nodeType, this.value = Array.isArray(e.value) ? BS(e.valueType, ...e.value) : e.value, this.precision = e.precision || null, this.value && this.value.fromArray && (this.value = this.value.fromArray(e.value));
  }
  generate() {
    Me("Abstract function.");
  }
}
const pR = /float|u?int/;
class Jo extends FS {
  static get type() {
    return "ConstNode";
  }
  /**
   * Constructs a new input node.
   *
   * @param {any} value - The value of this node. Usually a JS primitive or three.js object (vector, matrix, color).
   * @param {?string} nodeType - The node type. If no explicit type is defined, the node tries to derive the type from its value.
   */
  constructor(e, t = null) {
    super(e, t), this.isConstNode = !0;
  }
  /**
   * Generates the shader string of the value with the current node builder.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The generated value as a shader string.
   */
  generateConst(e) {
    return e.generateConst(this.getNodeType(e), this.value);
  }
  generate(e, t) {
    const n = this.getNodeType(e);
    return pR.test(n) && pR.test(t) ? e.generateConst(t, this.value) : e.format(this.generateConst(e), n, t);
  }
}
class eK extends St {
  static get type() {
    return "MemberNode";
  }
  /**
   * Constructs a member node.
   *
   * @param {Node} structNode - The struct node.
   * @param {string} property - The property name.
   */
  constructor(e, t) {
    super(), this.structNode = e, this.property = t, this.isMemberNode = !0;
  }
  hasMember(e) {
    return this.structNode.isMemberNode && this.structNode.hasMember(e) === !1 ? !1 : this.structNode.getMemberType(e, this.property) !== "void";
  }
  getNodeType(e) {
    return this.hasMember(e) === !1 ? "float" : this.structNode.getMemberType(e, this.property);
  }
  getMemberType(e, t) {
    if (this.hasMember(e) === !1)
      return "float";
    const n = this.getNodeType(e);
    return e.getStructTypeNode(n).getMemberType(e, t);
  }
  generate(e) {
    if (this.hasMember(e) === !1) {
      Me(`TSL: Member "${this.property}" does not exist in struct.`);
      const n = this.getNodeType(e);
      return e.generateConst(n);
    }
    return this.structNode.build(e) + "." + this.property;
  }
}
let Xu = null;
const Ib = /* @__PURE__ */ new Map();
function Be(i, e) {
  if (Ib.has(i)) {
    Me(`TSL: Redefinition of method chaining '${i}'.`);
    return;
  }
  if (typeof e != "function") throw new Error(`THREE.TSL: Node element ${i} is not a function`);
  Ib.set(i, e), i !== "assign" && (St.prototype[i] = function(...t) {
    return this.isStackNode ? this.addToStack(e(...t)) : e(this, ...t);
  }, St.prototype[i + "Assign"] = function(...t) {
    return this.isStackNode ? this.assign(t[0], e(...t)) : this.assign(e(this, ...t));
  });
}
const tK = (i) => i.replace(/r|s/g, "x").replace(/g|t/g, "y").replace(/b|p/g, "z").replace(/a|q/g, "w"), mR = (i) => tK(i).split("").sort().join("");
St.prototype.assign = function(...i) {
  if (this.isStackNode !== !0)
    return Xu !== null ? Xu.assign(this, ...i) : Ie("TSL: No stack defined for assign operation. Make sure the assign is inside a Fn()."), this;
  {
    const e = Ib.get("assign");
    return this.addToStack(e(...i));
  }
};
St.prototype.toVarIntent = function() {
  return this;
};
St.prototype.get = function(i) {
  return new eK(this, i);
};
const Cp = {};
function lg(i, e, t) {
  Cp[i] = Cp[e] = Cp[t] = {
    get() {
      this._cache = this._cache || {};
      let o = this._cache[i];
      return o === void 0 && (o = new iN(this, i), this._cache[i] = o), o;
    },
    set(o) {
      this[i].assign(ut(o));
    }
  };
  const n = i.toUpperCase(), r = e.toUpperCase(), s = t.toUpperCase();
  St.prototype["set" + n] = St.prototype["set" + r] = St.prototype["set" + s] = function(o) {
    const a = mR(i);
    return new ZQ(this, a, ut(o));
  }, St.prototype["flip" + n] = St.prototype["flip" + r] = St.prototype["flip" + s] = function() {
    const o = mR(i);
    return new JQ(this, o);
  };
}
const Da = ["x", "y", "z", "w"], La = ["r", "g", "b", "a"], Ia = ["s", "t", "p", "q"];
for (let i = 0; i < 4; i++) {
  let e = Da[i], t = La[i], n = Ia[i];
  lg(e, t, n);
  for (let r = 0; r < 4; r++) {
    e = Da[i] + Da[r], t = La[i] + La[r], n = Ia[i] + Ia[r], lg(e, t, n);
    for (let s = 0; s < 4; s++) {
      e = Da[i] + Da[r] + Da[s], t = La[i] + La[r] + La[s], n = Ia[i] + Ia[r] + Ia[s], lg(e, t, n);
      for (let o = 0; o < 4; o++)
        e = Da[i] + Da[r] + Da[s] + Da[o], t = La[i] + La[r] + La[s] + La[o], n = Ia[i] + Ia[r] + Ia[s] + Ia[o], lg(e, t, n);
    }
  }
}
for (let i = 0; i < 32; i++)
  Cp[i] = {
    get() {
      this._cache = this._cache || {};
      let e = this._cache[i];
      return e === void 0 && (e = new sd(this, new Jo(i, "uint")), this._cache[i] = e), e;
    },
    set(e) {
      this[i].assign(ut(e));
    }
  };
Object.defineProperties(St.prototype, Cp);
const gR = /* @__PURE__ */ new WeakMap(), nK = function(i, e = null) {
  const t = Bu(i);
  return t === "node" ? i : e === null && (t === "float" || t === "boolean") || t && t !== "shader" && t !== "string" ? ut(Bb(i, e)) : t === "shader" ? i.isFn ? i : pe(i) : i;
}, iK = function(i, e = null) {
  for (const t in i)
    i[t] = ut(i[t], e);
  return i;
}, rK = function(i, e = null) {
  const t = i.length;
  for (let n = 0; n < t; n++)
    i[n] = ut(i[n], e);
  return i;
}, rN = function(i, e = null, t = null, n = null) {
  function r(c) {
    return n !== null ? (c = ut(Object.assign(c, n)), n.intent === !0 && (c = c.toVarIntent())) : c = ut(c), c;
  }
  let s, o = e, a, l;
  function u(c) {
    let A;
    return o ? A = /[a-z]/i.test(o) ? o + "()" : o : A = i.type, a !== void 0 && c.length < a ? (Ie(`TSL: "${A}" parameter length is less than minimum required.`), c.concat(new Array(a - c.length).fill(0))) : l !== void 0 && c.length > l ? (Ie(`TSL: "${A}" parameter length exceeds limit.`), c.slice(0, l)) : c;
  }
  return e === null ? s = (...c) => r(new i(...ch(u(c)))) : t !== null ? (t = ut(t), s = (...c) => r(new i(e, ...ch(u(c)), t))) : s = (...c) => r(new i(e, ...ch(u(c)))), s.setParameterLength = (...c) => (c.length === 1 ? a = l = c[0] : c.length === 2 && ([a, l] = c), s), s.setName = (c) => (o = c, s), s;
}, sK = function(i, ...e) {
  return new i(...ch(e));
};
class oK extends St {
  constructor(e, t) {
    super(), this.shaderNode = e, this.rawInputs = t, this.isShaderCallNodeInternal = !0;
  }
  getNodeType(e) {
    return this.shaderNode.nodeType || this.getOutputNode(e).getNodeType(e);
  }
  getElementType(e) {
    return this.getOutputNode(e).getElementType(e);
  }
  getMemberType(e, t) {
    return this.getOutputNode(e).getMemberType(e, t);
  }
  call(e) {
    const { shaderNode: t, rawInputs: n } = this, r = e.getNodeProperties(t), s = e.getClosestSubBuild(t.subBuilds) || "", o = s || "default";
    if (r[o])
      return r[o];
    const a = e.subBuildFn, l = e.fnCall;
    e.subBuildFn = s, e.fnCall = this;
    let u = null;
    if (t.layout) {
      let c = gR.get(e.constructor);
      c === void 0 && (c = /* @__PURE__ */ new WeakMap(), gR.set(e.constructor, c));
      let A = c.get(t);
      A === void 0 && (A = ut(e.buildFunctionNode(t)), c.set(t, A)), e.addInclude(A);
      const m = n ? aK(n) : null;
      u = ut(A.call(m));
    } else {
      const c = new Proxy(e, {
        get: (T, b, S) => {
          let E;
          return Symbol.iterator === b ? E = function* () {
            yield void 0;
          } : E = Reflect.get(T, b, S), E;
        }
      }), A = n ? lK(n) : null, m = Array.isArray(n) ? n.length > 0 : n !== null, _ = t.jsFunc, y = m || _.length > 1 ? _(A, c) : _(c);
      u = ut(y);
    }
    return e.subBuildFn = a, e.fnCall = l, t.once && (r[o] = u), u;
  }
  setupOutput(e) {
    return e.addStack(), e.stack.outputNode = this.call(e), e.removeStack();
  }
  getOutputNode(e) {
    const t = e.getNodeProperties(this), n = e.getSubBuildOutput(this);
    return t[n] = t[n] || this.setupOutput(e), t[n].subBuild = e.getClosestSubBuild(this), t[n];
  }
  build(e, t = null) {
    let n = null;
    const r = e.getBuildStage(), s = e.getNodeProperties(this), o = e.getSubBuildOutput(this), a = this.getOutputNode(e), l = e.fnCall;
    if (e.fnCall = this, r === "setup") {
      const u = e.getSubBuildProperty("initialized", this);
      if (s[u] !== !0 && (s[u] = !0, s[o] = this.getOutputNode(e), s[o].build(e), this.shaderNode.subBuilds))
        for (const c of e.chaining) {
          const A = e.getDataFromNode(c, "any");
          A.subBuilds = A.subBuilds || /* @__PURE__ */ new Set();
          for (const m of this.shaderNode.subBuilds)
            A.subBuilds.add(m);
        }
      n = s[o];
    } else r === "analyze" ? a.build(e, t) : r === "generate" && (n = a.build(e, t) || "");
    return e.fnCall = l, n;
  }
}
function aK(i) {
  let e;
  return R2(i), i[0] && (i[0].isNode || Object.getPrototypeOf(i[0]) !== Object.prototype) ? e = [...i] : e = i[0], e;
}
function lK(i) {
  let e = 0;
  return R2(i), new Proxy(i, {
    get: (t, n, r) => {
      let s;
      if (n === "length")
        return s = i.length, s;
      if (Symbol.iterator === n)
        s = function* () {
          for (const o of i)
            yield ut(o);
        };
      else {
        if (i.length > 0)
          if (Object.getPrototypeOf(i[0]) === Object.prototype) {
            const o = i[0];
            o[n] === void 0 ? s = o[e++] : s = Reflect.get(o, n, r);
          } else i[0] instanceof St && (i[n] === void 0 ? s = i[e++] : s = Reflect.get(i, n, r));
        else
          s = Reflect.get(t, n, r);
        s = ut(s);
      }
      return s;
    }
  });
}
class uK extends St {
  constructor(e, t) {
    super(t), this.jsFunc = e, this.layout = null, this.global = !0, this.once = !1;
  }
  setLayout(e) {
    return this.layout = e, this;
  }
  getLayout() {
    return this.layout;
  }
  call(e = null) {
    return new oK(this, e);
  }
  setup() {
    return this.call();
  }
}
const cK = [!1, !0], hK = [0, 1, 2, 3], dK = [-1, -2], sN = [0.5, 1.5, 1 / 3, 1e-6, 1e6, Math.PI, Math.PI * 2, 1 / Math.PI, 2 / Math.PI, 1 / (Math.PI * 2), Math.PI / 2], US = /* @__PURE__ */ new Map();
for (const i of cK) US.set(i, new Jo(i));
const OS = /* @__PURE__ */ new Map();
for (const i of hK) OS.set(i, new Jo(i, "uint"));
const kS = new Map([...OS].map((i) => new Jo(i.value, "int")));
for (const i of dK) kS.set(i, new Jo(i, "int"));
const M2 = new Map([...kS].map((i) => new Jo(i.value)));
for (const i of sN) M2.set(i, new Jo(i));
for (const i of sN) M2.set(-i, new Jo(-i));
const E2 = { bool: US, uint: OS, ints: kS, float: M2 }, _R = new Map([...US, ...M2]), Bb = (i, e) => _R.has(i) ? _R.get(i) : i.isNode === !0 ? i : new Jo(i, e), pr = function(i, e = null) {
  return (...t) => {
    for (const r of t)
      if (r === void 0)
        return Ie(`TSL: Invalid parameter for the type "${i}".`), new Jo(0, i);
    if ((t.length === 0 || !["bool", "float", "int", "uint"].includes(i) && t.every((r) => {
      const s = typeof r;
      return s !== "object" && s !== "function";
    })) && (t = [BS(i, ...t)]), t.length === 1 && e !== null && e.has(t[0]))
      return xp(e.get(t[0]));
    if (t.length === 1) {
      const r = Bb(t[0], i);
      return r.nodeType === i ? xp(r) : xp(new nN(r, i));
    }
    const n = t.map((r) => Bb(r));
    return xp(new QQ(n, i));
  };
}, r0 = (i) => typeof i == "object" && i !== null ? i.value : i, oN = (i) => i != null ? i.nodeType || i.convertTo || (typeof i == "string" ? i : null) : null;
function df(i, e) {
  return new uK(i, e);
}
const ut = (i, e = null) => (
  /* new */
  nK(i, e)
), xp = (i, e = null) => (
  /* new */
  ut(i, e).toVarIntent()
), R2 = (i, e = null) => new iK(i, e), ch = (i, e = null) => new rK(i, e), on = (i, e = null, t = null, n = null) => new rN(i, e, t, n), st = (i, ...e) => new sK(i, ...e), Ke = (i, e = null, t = null, n = {}) => new rN(i, e, t, { ...n, intent: !0 });
let fK = 0;
class AK extends St {
  constructor(e, t = null) {
    super();
    let n = null;
    t !== null && (typeof t == "object" ? n = t.return : (typeof t == "string" ? n = t : Ie("TSL: Invalid layout type."), t = null)), this.shaderNode = new df(e, n), t !== null && this.setLayout(t), this.isFn = !0;
  }
  setLayout(e) {
    const t = this.shaderNode.nodeType;
    if (typeof e.inputs != "object") {
      const n = {
        name: "fn" + fK++,
        type: t,
        inputs: []
      };
      for (const r in e)
        r !== "return" && n.inputs.push({
          name: r,
          type: e[r]
        });
      e = n;
    }
    return this.shaderNode.setLayout(e), this;
  }
  getNodeType(e) {
    return this.shaderNode.getNodeType(e) || "float";
  }
  call(...e) {
    const t = this.shaderNode.call(e);
    return this.shaderNode.nodeType === "void" && t.toStack(), t.toVarIntent();
  }
  once(e = null) {
    return this.shaderNode.once = !0, this.shaderNode.subBuilds = e, this;
  }
  generate(e) {
    const t = this.getNodeType(e);
    return Ie('TSL: "Fn()" was declared but not invoked. Try calling it like "Fn()( ...params )".'), e.generateConst(t);
  }
}
function pe(i, e = null) {
  const t = new AK(i, e);
  return new Proxy(() => {
  }, {
    apply(n, r, s) {
      return t.call(...s);
    },
    get(n, r, s) {
      return Reflect.get(t, r, s);
    },
    set(n, r, s, o) {
      return Reflect.set(t, r, s, o);
    }
  });
}
const s0 = (i) => {
  Xu = i;
}, VS = () => Xu, Ot = (...i) => Xu.If(...i), pK = (...i) => Xu.Switch(...i);
function C2(i) {
  return Xu && Xu.addToStack(i), i;
}
Be("toStack", C2);
const aN = new pr("color"), J = new pr("float", E2.float), le = new pr("int", E2.ints), Ge = new pr("uint", E2.uint), Wo = new pr("bool", E2.bool), Xe = new pr("vec2"), ur = new pr("ivec2"), GS = new pr("uvec2"), lN = new pr("bvec2"), ce = new pr("vec3"), zS = new pr("ivec3"), od = new pr("uvec3"), qS = new pr("bvec3"), Gt = new pr("vec4"), HS = new pr("ivec4"), WS = new pr("uvec4"), uN = new pr("bvec4"), P2 = new pr("mat2"), Kr = new pr("mat3"), Vu = new pr("mat4"), mK = (i = "") => new Jo(i, "string"), gK = (i) => new Jo(i, "ArrayBuffer");
Be("toColor", aN);
Be("toFloat", J);
Be("toInt", le);
Be("toUint", Ge);
Be("toBool", Wo);
Be("toVec2", Xe);
Be("toIVec2", ur);
Be("toUVec2", GS);
Be("toBVec2", lN);
Be("toVec3", ce);
Be("toIVec3", zS);
Be("toUVec3", od);
Be("toBVec3", qS);
Be("toVec4", Gt);
Be("toIVec4", HS);
Be("toUVec4", WS);
Be("toBVec4", uN);
Be("toMat2", P2);
Be("toMat3", Kr);
Be("toMat4", Vu);
const cN = /* @__PURE__ */ on(sd).setParameterLength(2), hN = (i, e) => ut(new nN(ut(i), e)), _K = (i, e) => ut(new iN(ut(i), e));
Be("element", cN);
Be("convert", hN);
const xK = (i) => (Me("TSL: append() has been renamed to Stack()."), C2(i));
Be("append", (i) => (Me("TSL: .append() has been renamed to .toStack()."), C2(i)));
class Qn extends St {
  static get type() {
    return "PropertyNode";
  }
  /**
   * Constructs a new property node.
   *
   * @param {string} nodeType - The type of the node.
   * @param {?string} [name=null] - The name of the property in the shader.
   * @param {boolean} [varying=false] - Whether this property is a varying or not.
   */
  constructor(e, t = null, n = !1) {
    super(e), this.name = t, this.varying = n, this.isPropertyNode = !0, this.global = !0;
  }
  customCacheKey() {
    return F0(this.type + ":" + (this.name || "") + ":" + (this.varying ? "1" : "0"));
  }
  getHash(e) {
    return this.name || super.getHash(e);
  }
  generate(e) {
    let t;
    return this.varying === !0 ? (t = e.getVaryingFromNode(this, this.name), t.needsInterpolation = !0) : t = e.getVarFromNode(this, this.name), e.getPropertyName(t);
  }
}
const Bl = (i, e) => new Qn(i, e), o0 = (i, e) => new Qn(i, e, !0), ni = /* @__PURE__ */ st(Qn, "vec4", "DiffuseColor"), Hc = /* @__PURE__ */ st(Qn, "vec3", "DiffuseContribution"), Fb = /* @__PURE__ */ st(Qn, "vec3", "EmissiveColor"), Ha = /* @__PURE__ */ st(Qn, "float", "Roughness"), El = /* @__PURE__ */ st(Qn, "float", "Metalness"), i_ = /* @__PURE__ */ st(Qn, "float", "Clearcoat"), a0 = /* @__PURE__ */ st(Qn, "float", "ClearcoatRoughness"), go = /* @__PURE__ */ st(Qn, "vec3", "Sheen"), Ru = /* @__PURE__ */ st(Qn, "float", "SheenRoughness"), N2 = /* @__PURE__ */ st(Qn, "float", "Iridescence"), r_ = /* @__PURE__ */ st(Qn, "float", "IridescenceIOR"), s_ = /* @__PURE__ */ st(Qn, "float", "IridescenceThickness"), o_ = /* @__PURE__ */ st(Qn, "float", "AlphaT"), Mu = /* @__PURE__ */ st(Qn, "float", "Anisotropy"), Pp = /* @__PURE__ */ st(Qn, "vec3", "AnisotropyT"), hh = /* @__PURE__ */ st(Qn, "vec3", "AnisotropyB"), Yu = /* @__PURE__ */ st(Qn, "color", "SpecularColor"), nh = /* @__PURE__ */ st(Qn, "color", "SpecularColorBlended"), xf = /* @__PURE__ */ st(Qn, "float", "SpecularF90"), a_ = /* @__PURE__ */ st(Qn, "float", "Shininess"), yf = /* @__PURE__ */ st(Qn, "vec4", "Output"), t1 = /* @__PURE__ */ st(Qn, "float", "dashSize"), Ub = /* @__PURE__ */ st(Qn, "float", "gapSize"), yK = /* @__PURE__ */ st(Qn, "float", "pointWidth"), Np = /* @__PURE__ */ st(Qn, "float", "IOR"), l_ = /* @__PURE__ */ st(Qn, "float", "Transmission"), $S = /* @__PURE__ */ st(Qn, "float", "Thickness"), jS = /* @__PURE__ */ st(Qn, "float", "AttenuationDistance"), XS = /* @__PURE__ */ st(Qn, "color", "AttenuationColor"), YS = /* @__PURE__ */ st(Qn, "float", "Dispersion");
class dN extends St {
  static get type() {
    return "UniformGroupNode";
  }
  /**
   * Constructs a new uniform group node.
   *
   * @param {string} name - The name of the uniform group node.
   * @param {boolean} [shared=false] - Whether this uniform group node is shared or not.
   * @param {number} [order=1] - Influences the internal sorting.
   */
  constructor(e, t = !1, n = 1) {
    super("string"), this.name = e, this.shared = t, this.order = n, this.isUniformGroup = !0;
  }
  serialize(e) {
    super.serialize(e), e.name = this.name, e.version = this.version, e.shared = this.shared;
  }
  deserialize(e) {
    super.deserialize(e), this.name = e.name, this.version = e.version, this.shared = e.shared;
  }
}
const fN = (i) => new dN(i), D2 = (i, e = 0) => new dN(i, !0, e), AN = /* @__PURE__ */ D2("frame"), Lt = /* @__PURE__ */ D2("render"), QS = /* @__PURE__ */ fN("object");
class U0 extends FS {
  static get type() {
    return "UniformNode";
  }
  /**
   * Constructs a new uniform node.
   *
   * @param {any} value - The value of this node. Usually a JS primitive or three.js object (vector, matrix, color, texture).
   * @param {?string} nodeType - The node type. If no explicit type is defined, the node tries to derive the type from its value.
   */
  constructor(e, t = null) {
    super(e, t), this.isUniformNode = !0, this.name = "", this.groupNode = QS;
  }
  /**
   * Sets the {@link UniformNode#name} property.
   *
   * @param {string} name - The name of the uniform.
   * @return {UniformNode} A reference to this node.
   */
  setName(e) {
    return this.name = e, this;
  }
  /**
   * Sets the {@link UniformNode#name} property.
   *
   * @deprecated
   * @param {string} name - The name of the uniform.
   * @return {UniformNode} A reference to this node.
   */
  label(e) {
    return Me('TSL: "label()" has been deprecated. Use "setName()" instead.'), this.setName(e);
  }
  /**
   * Sets the {@link UniformNode#groupNode} property.
   *
   * @param {UniformGroupNode} group - The uniform group.
   * @return {UniformNode} A reference to this node.
   */
  setGroup(e) {
    return this.groupNode = e, this;
  }
  /**
   * Returns the {@link UniformNode#groupNode}.
   *
   * @return {UniformGroupNode} The uniform group.
   */
  getGroup() {
    return this.groupNode;
  }
  /**
   * By default, this method returns the result of {@link Node#getHash} but derived
   * classes might overwrite this method with a different implementation.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The uniform hash.
   */
  getUniformHash(e) {
    return this.getHash(e);
  }
  onUpdate(e, t) {
    return e = e.bind(this), super.onUpdate((n) => {
      const r = e(n, this);
      r !== void 0 && (this.value = r);
    }, t);
  }
  getInputType(e) {
    let t = super.getInputType(e);
    return t === "bool" && (t = "uint"), t;
  }
  generate(e, t) {
    const n = this.getNodeType(e), r = this.getUniformHash(e);
    let s = e.getNodeFromHash(r);
    s === void 0 && (e.setHashNode(this, r), s = this);
    const o = s.getInputType(e), a = e.getUniformFromNode(s, o, e.shaderStage, this.name || e.context.nodeName), l = e.getPropertyName(a);
    e.context.nodeName !== void 0 && delete e.context.nodeName;
    let u = l;
    if (n === "bool") {
      const c = e.getDataFromNode(this);
      let A = c.propertyName;
      if (A === void 0) {
        const m = e.getVarFromNode(this, null, "bool");
        A = e.getPropertyName(m), c.propertyName = A, u = e.format(l, o, n), e.addLineFlowCode(`${A} = ${u}`, this);
      }
      u = A;
    }
    return e.format(u, n, t);
  }
}
const It = (i, e) => {
  const t = oN(e || i);
  if (t === i && (i = BS(t)), i && i.isNode === !0) {
    let n = i.value;
    i.traverse((r) => {
      r.isConstNode === !0 && (n = r.value);
    }), i = n;
  }
  return new U0(i, t);
};
class xR extends Hi {
  static get type() {
    return "ArrayNode";
  }
  /**
   * Constructs a new array node.
   *
   * @param {?string} nodeType - The data type of the elements.
   * @param {number} count - Size of the array.
   * @param {?Array<Node>} [values=null] - Array default values.
   */
  constructor(e, t, n = null) {
    super(e), this.count = t, this.values = n, this.isArrayNode = !0;
  }
  /**
   * Returns the number of elements in the node array.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {number} The number of elements in the node array.
   */
  getArrayCount() {
    return this.count;
  }
  /**
   * Returns the node's type.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The type of the node.
   */
  getNodeType(e) {
    return this.nodeType === null ? this.values[0].getNodeType(e) : this.nodeType;
  }
  /**
   * Returns the node's type.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The type of the node.
   */
  getElementType(e) {
    return this.getNodeType(e);
  }
  /**
   * Returns the type of a member variable.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {string} name - The name of the member variable.
   * @return {string} The type of the member variable.
   */
  getMemberType(e, t) {
    return this.nodeType === null ? this.values[0].getMemberType(e, t) : super.getMemberType(e, t);
  }
  /**
   * This method builds the output node and returns the resulting array as a shader string.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The generated shader string.
   */
  generate(e) {
    const t = this.getNodeType(e);
    return e.generateArray(t, this.count, this.values);
  }
}
const pN = (...i) => {
  let e;
  if (i.length === 1) {
    const t = i[0];
    e = new xR(null, t.length, t);
  } else {
    const t = i[0], n = i[1];
    e = new xR(t, n);
  }
  return ut(e);
};
Be("toArray", (i, e) => pN(Array(e).fill(i)));
class vK extends Hi {
  static get type() {
    return "AssignNode";
  }
  /**
   * Constructs a new assign node.
   *
   * @param {Node} targetNode - The target node.
   * @param {Node} sourceNode - The source type.
   */
  constructor(e, t) {
    super(), this.targetNode = e, this.sourceNode = t, this.isAssignNode = !0;
  }
  /**
   * Whether this node is used more than once in context of other nodes. This method
   * is overwritten since it always returns `false` (assigns are unique).
   *
   * @return {boolean} A flag that indicates if there is more than one dependency to other nodes. Always `false`.
   */
  hasDependencies() {
    return !1;
  }
  getNodeType(e, t) {
    return t !== "void" ? this.targetNode.getNodeType(e) : "void";
  }
  /**
   * Whether a split is required when assigning source to target. This can happen when the component length of
   * target and source data type does not match.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {boolean} Whether a split is required when assigning source to target.
   */
  needsSplitAssign(e) {
    const { targetNode: t } = this;
    if (e.isAvailable("swizzleAssign") === !1 && t.isSplitNode && t.components.length > 1) {
      const n = e.getTypeLength(t.node.getNodeType(e));
      return rd.join("").slice(0, n) !== t.components;
    }
    return !1;
  }
  setup(e) {
    const { targetNode: t, sourceNode: n } = this, r = t.getScope(), s = e.getDataFromNode(r);
    s.assign = !0;
    const o = e.getNodeProperties(this);
    o.sourceNode = n, o.targetNode = t.context({ assign: !0 });
  }
  generate(e, t) {
    const { targetNode: n, sourceNode: r } = e.getNodeProperties(this), s = this.needsSplitAssign(e), o = n.build(e), a = n.getNodeType(e), l = r.build(e, a), u = r.getNodeType(e), c = e.getDataFromNode(this);
    let A;
    if (c.initialized === !0)
      t !== "void" && (A = o);
    else if (s) {
      const m = e.getVarFromNode(this, null, a), _ = e.getPropertyName(m);
      e.addLineFlowCode(`${_} = ${l}`, this);
      const y = n.node, b = y.node.context({ assign: !0 }).build(e);
      for (let S = 0; S < y.components.length; S++) {
        const E = y.components[S];
        e.addLineFlowCode(`${b}.${E} = ${_}[ ${S} ]`, this);
      }
      t !== "void" && (A = o);
    } else
      A = `${o} = ${l}`, (t === "void" || u === "void") && (e.addLineFlowCode(A, this), t !== "void" && (A = o));
    return c.initialized = !0, e.format(A, a, t);
  }
}
const mN = /* @__PURE__ */ on(vK).setParameterLength(2);
Be("assign", mN);
class bK extends Hi {
  static get type() {
    return "FunctionCallNode";
  }
  /**
   * Constructs a new function call node.
   *
   * @param {?FunctionNode} functionNode - The function node.
   * @param {Object<string, Node>} [parameters={}] - The parameters for the function call.
   */
  constructor(e = null, t = {}) {
    super(), this.functionNode = e, this.parameters = t;
  }
  /**
   * Sets the parameters of the function call node.
   *
   * @param {Object<string, Node>} parameters - The parameters to set.
   * @return {FunctionCallNode} A reference to this node.
   */
  setParameters(e) {
    return this.parameters = e, this;
  }
  /**
   * Returns the parameters of the function call node.
   *
   * @return {Object<string, Node>} The parameters of this node.
   */
  getParameters() {
    return this.parameters;
  }
  /**
   * Returns the type of this function call node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @returns {string} The type of this node.
   */
  getNodeType(e) {
    return this.functionNode.getNodeType(e);
  }
  /**
   * Returns the function node of this function call node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {string} [name] - The name of the member.
   * @returns {string} The type of the member.
   */
  getMemberType(e, t) {
    return this.functionNode.getMemberType(e, t);
  }
  generate(e) {
    const t = [], n = this.functionNode, r = n.getInputs(e), s = this.parameters, o = (l, u) => {
      const c = u.type, A = c === "pointer";
      let m;
      return A ? m = "&" + l.build(e) : m = l.build(e, c), m;
    };
    if (Array.isArray(s)) {
      if (s.length > r.length)
        Ie("TSL: The number of provided parameters exceeds the expected number of inputs in 'Fn()'."), s.length = r.length;
      else if (s.length < r.length)
        for (Ie("TSL: The number of provided parameters is less than the expected number of inputs in 'Fn()'."); s.length < r.length; )
          s.push(J(0));
      for (let l = 0; l < s.length; l++)
        t.push(o(s[l], r[l]));
    } else
      for (const l of r) {
        const u = s[l.name];
        u !== void 0 ? t.push(o(u, l)) : (Ie(`TSL: Input '${l.name}' not found in 'Fn()'.`), t.push(o(J(0), l)));
      }
    return `${n.build(e, "property")}( ${t.join(", ")} )`;
  }
}
const gN = (i, ...e) => (e = e.length > 1 || e[0] && e[0].isNode === !0 ? ch(e) : R2(e[0]), new bK(ut(i), e));
Be("call", gN);
const SK = {
  "==": "equal",
  "!=": "notEqual",
  "<": "lessThan",
  ">": "greaterThan",
  "<=": "lessThanEqual",
  ">=": "greaterThanEqual",
  "%": "mod"
};
class zi extends Hi {
  static get type() {
    return "OperatorNode";
  }
  /**
   * Constructs a new operator node.
   *
   * @param {string} op - The operator.
   * @param {Node} aNode - The first input.
   * @param {Node} bNode - The second input.
   * @param {...Node} params - Additional input parameters.
   */
  constructor(e, t, n, ...r) {
    if (super(), r.length > 0) {
      let s = new zi(e, t, n);
      for (let o = 0; o < r.length - 1; o++)
        s = new zi(e, s, r[o]);
      t = s, n = r[r.length - 1];
    }
    this.op = e, this.aNode = t, this.bNode = n, this.isOperatorNode = !0;
  }
  /**
   * Returns the operator method name.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {string} output - The output type.
   * @returns {string} The operator method name.
   */
  getOperatorMethod(e, t) {
    return e.getMethod(SK[this.op], t);
  }
  /**
   * This method is overwritten since the node type is inferred from the operator
   * and the input node types.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {?string} [output=null] - The output type.
   * @return {string} The node type.
   */
  getNodeType(e, t = null) {
    const n = this.op, r = this.aNode, s = this.bNode, o = r.getNodeType(e), a = s ? s.getNodeType(e) : null;
    if (o === "void" || a === "void")
      return t || "void";
    if (n === "%")
      return o;
    if (n === "~" || n === "&" || n === "|" || n === "^" || n === ">>" || n === "<<")
      return e.getIntegerType(o);
    if (n === "!" || n === "&&" || n === "||" || n === "^^")
      return "bool";
    if (n === "==" || n === "!=" || n === "<" || n === ">" || n === "<=" || n === ">=") {
      const l = Math.max(e.getTypeLength(o), e.getTypeLength(a));
      return l > 1 ? `bvec${l}` : "bool";
    } else {
      if (e.isMatrix(o)) {
        if (a === "float")
          return o;
        if (e.isVector(a))
          return e.getVectorFromMatrix(o);
        if (e.isMatrix(a))
          return o;
      } else if (e.isMatrix(a)) {
        if (o === "float")
          return a;
        if (e.isVector(o))
          return e.getVectorFromMatrix(a);
      }
      return e.getTypeLength(a) > e.getTypeLength(o) ? a : o;
    }
  }
  generate(e, t) {
    const n = this.op, { aNode: r, bNode: s } = this, o = this.getNodeType(e, t);
    let a = null, l = null;
    o !== "void" ? (a = r.getNodeType(e), l = s ? s.getNodeType(e) : null, n === "<" || n === ">" || n === "<=" || n === ">=" || n === "==" || n === "!=" ? e.isVector(a) ? l = a : e.isVector(l) ? a = l : a !== l && (a = l = "float") : n === ">>" || n === "<<" ? (a = o, l = e.changeComponentType(l, "uint")) : n === "%" ? (a = o, l = e.isInteger(a) && e.isInteger(l) ? l : a) : e.isMatrix(a) ? l === "float" ? l = "float" : e.isVector(l) ? l = e.getVectorFromMatrix(a) : e.isMatrix(l) || (a = l = o) : e.isMatrix(l) ? a === "float" ? a = "float" : e.isVector(a) ? a = e.getVectorFromMatrix(l) : a = l = o : a = l = o) : a = l = o;
    const u = r.build(e, a), c = s ? s.build(e, l) : null, A = e.getFunctionOperator(n);
    if (t !== "void") {
      const m = e.renderer.coordinateSystem === jr;
      if (n === "==" || n === "!=" || n === "<" || n === ">" || n === "<=" || n === ">=")
        return m ? e.isVector(a) ? e.format(`${this.getOperatorMethod(e, t)}( ${u}, ${c} )`, o, t) : e.format(`( ${u} ${n} ${c} )`, o, t) : e.format(`( ${u} ${n} ${c} )`, o, t);
      if (n === "%")
        return e.isInteger(l) ? e.format(`( ${u} % ${c} )`, o, t) : e.format(`${this.getOperatorMethod(e, o)}( ${u}, ${c} )`, o, t);
      if (n === "!" || n === "~")
        return e.format(`(${n}${u})`, a, t);
      if (A)
        return e.format(`${A}( ${u}, ${c} )`, o, t);
      if (e.isMatrix(a) && l === "float")
        return e.format(`( ${c} ${n} ${u} )`, o, t);
      if (a === "float" && e.isMatrix(l))
        return e.format(`${u} ${n} ${c}`, o, t);
      {
        let _ = `( ${u} ${n} ${c} )`;
        return !m && o === "bool" && e.isVector(a) && e.isVector(l) && (_ = `all${_}`), e.format(_, o, t);
      }
    } else if (a !== "void")
      return A ? e.format(`${A}( ${u}, ${c} )`, o, t) : e.isMatrix(a) && l === "float" ? e.format(`${c} ${n} ${u}`, o, t) : e.format(`${u} ${n} ${c}`, o, t);
  }
  serialize(e) {
    super.serialize(e), e.op = this.op;
  }
  deserialize(e) {
    super.deserialize(e), this.op = e.op;
  }
}
const sr = /* @__PURE__ */ Ke(zi, "+").setParameterLength(2, 1 / 0).setName("add"), Un = /* @__PURE__ */ Ke(zi, "-").setParameterLength(2, 1 / 0).setName("sub"), sn = /* @__PURE__ */ Ke(zi, "*").setParameterLength(2, 1 / 0).setName("mul"), Ro = /* @__PURE__ */ Ke(zi, "/").setParameterLength(2, 1 / 0).setName("div"), O0 = /* @__PURE__ */ Ke(zi, "%").setParameterLength(2).setName("mod"), KS = /* @__PURE__ */ Ke(zi, "==").setParameterLength(2).setName("equal"), _N = /* @__PURE__ */ Ke(zi, "!=").setParameterLength(2).setName("notEqual"), xN = /* @__PURE__ */ Ke(zi, "<").setParameterLength(2).setName("lessThan"), ZS = /* @__PURE__ */ Ke(zi, ">").setParameterLength(2).setName("greaterThan"), yN = /* @__PURE__ */ Ke(zi, "<=").setParameterLength(2).setName("lessThanEqual"), vN = /* @__PURE__ */ Ke(zi, ">=").setParameterLength(2).setName("greaterThanEqual"), bN = /* @__PURE__ */ Ke(zi, "&&").setParameterLength(2, 1 / 0).setName("and"), SN = /* @__PURE__ */ Ke(zi, "||").setParameterLength(2, 1 / 0).setName("or"), TN = /* @__PURE__ */ Ke(zi, "!").setParameterLength(1).setName("not"), wN = /* @__PURE__ */ Ke(zi, "^^").setParameterLength(2).setName("xor"), MN = /* @__PURE__ */ Ke(zi, "&").setParameterLength(2).setName("bitAnd"), EN = /* @__PURE__ */ Ke(zi, "~").setParameterLength(1).setName("bitNot"), RN = /* @__PURE__ */ Ke(zi, "|").setParameterLength(2).setName("bitOr"), CN = /* @__PURE__ */ Ke(zi, "^").setParameterLength(2).setName("bitXor"), PN = /* @__PURE__ */ Ke(zi, "<<").setParameterLength(2).setName("shiftLeft"), NN = /* @__PURE__ */ Ke(zi, ">>").setParameterLength(2).setName("shiftRight"), DN = pe(([i]) => (i.addAssign(1), i)), LN = pe(([i]) => (i.subAssign(1), i)), IN = /* @__PURE__ */ pe(([i]) => {
  const e = le(i).toConst();
  return i.addAssign(1), e;
}), BN = /* @__PURE__ */ pe(([i]) => {
  const e = le(i).toConst();
  return i.subAssign(1), e;
});
Be("add", sr);
Be("sub", Un);
Be("mul", sn);
Be("div", Ro);
Be("mod", O0);
Be("equal", KS);
Be("notEqual", _N);
Be("lessThan", xN);
Be("greaterThan", ZS);
Be("lessThanEqual", yN);
Be("greaterThanEqual", vN);
Be("and", bN);
Be("or", SN);
Be("not", TN);
Be("xor", wN);
Be("bitAnd", MN);
Be("bitNot", EN);
Be("bitOr", RN);
Be("bitXor", CN);
Be("shiftLeft", PN);
Be("shiftRight", NN);
Be("incrementBefore", DN);
Be("decrementBefore", LN);
Be("increment", IN);
Be("decrement", BN);
const FN = (i, e) => (Me('TSL: "modInt()" is deprecated. Use "mod( int( ... ) )" instead.'), O0(le(i), le(e)));
Be("modInt", FN);
class Se extends Hi {
  static get type() {
    return "MathNode";
  }
  /**
   * Constructs a new math node.
   *
   * @param {string} method - The method name.
   * @param {Node} aNode - The first input.
   * @param {?Node} [bNode=null] - The second input.
   * @param {?Node} [cNode=null] - The third input.
   */
  constructor(e, t, n = null, r = null) {
    if (super(), (e === Se.MAX || e === Se.MIN) && arguments.length > 3) {
      let s = new Se(e, t, n);
      for (let o = 2; o < arguments.length - 1; o++)
        s = new Se(e, s, arguments[o]);
      t = s, n = arguments[arguments.length - 1], r = null;
    }
    this.method = e, this.aNode = t, this.bNode = n, this.cNode = r, this.isMathNode = !0;
  }
  /**
   * The input type is inferred from the node types of the input nodes.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The input type.
   */
  getInputType(e) {
    const t = this.aNode.getNodeType(e), n = this.bNode ? this.bNode.getNodeType(e) : null, r = this.cNode ? this.cNode.getNodeType(e) : null, s = e.isMatrix(t) ? 0 : e.getTypeLength(t), o = e.isMatrix(n) ? 0 : e.getTypeLength(n), a = e.isMatrix(r) ? 0 : e.getTypeLength(r);
    return s > o && s > a ? t : o > a ? n : a > s ? r : t;
  }
  /**
   * The selected method as well as the input type determine the node type of this node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(e) {
    const t = this.method;
    return t === Se.LENGTH || t === Se.DISTANCE || t === Se.DOT ? "float" : t === Se.CROSS ? "vec3" : t === Se.ALL || t === Se.ANY ? "bool" : t === Se.EQUALS ? e.changeComponentType(this.aNode.getNodeType(e), "bool") : this.getInputType(e);
  }
  setup(e) {
    const { aNode: t, bNode: n, method: r } = this;
    let s = null;
    if (r === Se.ONE_MINUS)
      s = Un(1, t);
    else if (r === Se.RECIPROCAL)
      s = Ro(1, t);
    else if (r === Se.DIFFERENCE)
      s = vi(Un(t, n));
    else if (r === Se.TRANSFORM_DIRECTION) {
      let o = t, a = n;
      e.isMatrix(o.getNodeType(e)) ? a = Gt(ce(a), 0) : o = Gt(ce(o), 0);
      const l = sn(o, a).xyz;
      s = Fs(l);
    }
    return s !== null ? s : super.setup(e);
  }
  generate(e, t) {
    if (e.getNodeProperties(this).outputNode)
      return super.generate(e, t);
    let r = this.method;
    const s = this.getNodeType(e), o = this.getInputType(e), a = this.aNode, l = this.bNode, u = this.cNode, c = e.renderer.coordinateSystem;
    if (r === Se.NEGATE)
      return e.format("( - " + a.build(e, o) + " )", s, t);
    {
      const A = [];
      return r === Se.CROSS ? A.push(
        a.build(e, s),
        l.build(e, s)
      ) : c === jr && r === Se.STEP ? A.push(
        a.build(e, e.getTypeLength(a.getNodeType(e)) === 1 ? "float" : o),
        l.build(e, o)
      ) : c === jr && (r === Se.MIN || r === Se.MAX) ? A.push(
        a.build(e, o),
        l.build(e, e.getTypeLength(l.getNodeType(e)) === 1 ? "float" : o)
      ) : r === Se.REFRACT ? A.push(
        a.build(e, o),
        l.build(e, o),
        u.build(e, "float")
      ) : r === Se.MIX ? A.push(
        a.build(e, o),
        l.build(e, o),
        u.build(e, e.getTypeLength(u.getNodeType(e)) === 1 ? "float" : o)
      ) : (c === io && r === Se.ATAN && l !== null && (r = "atan2"), e.shaderStage !== "fragment" && (r === Se.DFDX || r === Se.DFDY) && (Me(`TSL: '${r}' is not supported in the ${e.shaderStage} stage.`), r = "/*" + r + "*/"), A.push(a.build(e, o)), l !== null && A.push(l.build(e, o)), u !== null && A.push(u.build(e, o))), e.format(`${e.getMethod(r, s)}( ${A.join(", ")} )`, s, t);
    }
  }
  serialize(e) {
    super.serialize(e), e.method = this.method;
  }
  deserialize(e) {
    super.deserialize(e), this.method = e.method;
  }
}
Se.ALL = "all";
Se.ANY = "any";
Se.RADIANS = "radians";
Se.DEGREES = "degrees";
Se.EXP = "exp";
Se.EXP2 = "exp2";
Se.LOG = "log";
Se.LOG2 = "log2";
Se.SQRT = "sqrt";
Se.INVERSE_SQRT = "inversesqrt";
Se.FLOOR = "floor";
Se.CEIL = "ceil";
Se.NORMALIZE = "normalize";
Se.FRACT = "fract";
Se.SIN = "sin";
Se.COS = "cos";
Se.TAN = "tan";
Se.ASIN = "asin";
Se.ACOS = "acos";
Se.ATAN = "atan";
Se.ABS = "abs";
Se.SIGN = "sign";
Se.LENGTH = "length";
Se.NEGATE = "negate";
Se.ONE_MINUS = "oneMinus";
Se.DFDX = "dFdx";
Se.DFDY = "dFdy";
Se.ROUND = "round";
Se.RECIPROCAL = "reciprocal";
Se.TRUNC = "trunc";
Se.FWIDTH = "fwidth";
Se.TRANSPOSE = "transpose";
Se.DETERMINANT = "determinant";
Se.INVERSE = "inverse";
Se.EQUALS = "equals";
Se.MIN = "min";
Se.MAX = "max";
Se.STEP = "step";
Se.REFLECT = "reflect";
Se.DISTANCE = "distance";
Se.DIFFERENCE = "difference";
Se.DOT = "dot";
Se.CROSS = "cross";
Se.POW = "pow";
Se.TRANSFORM_DIRECTION = "transformDirection";
Se.MIX = "mix";
Se.CLAMP = "clamp";
Se.REFRACT = "refract";
Se.SMOOTHSTEP = "smoothstep";
Se.FACEFORWARD = "faceforward";
const JS = /* @__PURE__ */ J(1e-6), TK = /* @__PURE__ */ J(1e6), u_ = /* @__PURE__ */ J(Math.PI), wK = /* @__PURE__ */ J(Math.PI * 2), MK = /* @__PURE__ */ J(Math.PI * 2), EK = /* @__PURE__ */ J(Math.PI * 0.5), UN = /* @__PURE__ */ Ke(Se, Se.ALL).setParameterLength(1), ON = /* @__PURE__ */ Ke(Se, Se.ANY).setParameterLength(1), kN = /* @__PURE__ */ Ke(Se, Se.RADIANS).setParameterLength(1), VN = /* @__PURE__ */ Ke(Se, Se.DEGREES).setParameterLength(1), eT = /* @__PURE__ */ Ke(Se, Se.EXP).setParameterLength(1), Xf = /* @__PURE__ */ Ke(Se, Se.EXP2).setParameterLength(1), L2 = /* @__PURE__ */ Ke(Se, Se.LOG).setParameterLength(1), Za = /* @__PURE__ */ Ke(Se, Se.LOG2).setParameterLength(1), ps = /* @__PURE__ */ Ke(Se, Se.SQRT).setParameterLength(1), tT = /* @__PURE__ */ Ke(Se, Se.INVERSE_SQRT).setParameterLength(1), Ja = /* @__PURE__ */ Ke(Se, Se.FLOOR).setParameterLength(1), I2 = /* @__PURE__ */ Ke(Se, Se.CEIL).setParameterLength(1), Fs = /* @__PURE__ */ Ke(Se, Se.NORMALIZE).setParameterLength(1), ba = /* @__PURE__ */ Ke(Se, Se.FRACT).setParameterLength(1), Ns = /* @__PURE__ */ Ke(Se, Se.SIN).setParameterLength(1), ha = /* @__PURE__ */ Ke(Se, Se.COS).setParameterLength(1), GN = /* @__PURE__ */ Ke(Se, Se.TAN).setParameterLength(1), zN = /* @__PURE__ */ Ke(Se, Se.ASIN).setParameterLength(1), nT = /* @__PURE__ */ Ke(Se, Se.ACOS).setParameterLength(1), B2 = /* @__PURE__ */ Ke(Se, Se.ATAN).setParameterLength(1, 2), vi = /* @__PURE__ */ Ke(Se, Se.ABS).setParameterLength(1), iT = /* @__PURE__ */ Ke(Se, Se.SIGN).setParameterLength(1), el = /* @__PURE__ */ Ke(Se, Se.LENGTH).setParameterLength(1), rT = /* @__PURE__ */ Ke(Se, Se.NEGATE).setParameterLength(1), qN = /* @__PURE__ */ Ke(Se, Se.ONE_MINUS).setParameterLength(1), sT = /* @__PURE__ */ Ke(Se, Se.DFDX).setParameterLength(1), oT = /* @__PURE__ */ Ke(Se, Se.DFDY).setParameterLength(1), HN = /* @__PURE__ */ Ke(Se, Se.ROUND).setParameterLength(1), WN = /* @__PURE__ */ Ke(Se, Se.RECIPROCAL).setParameterLength(1), aT = /* @__PURE__ */ Ke(Se, Se.TRUNC).setParameterLength(1), lT = /* @__PURE__ */ Ke(Se, Se.FWIDTH).setParameterLength(1), $N = /* @__PURE__ */ Ke(Se, Se.TRANSPOSE).setParameterLength(1), jN = /* @__PURE__ */ Ke(Se, Se.DETERMINANT).setParameterLength(1), XN = /* @__PURE__ */ Ke(Se, Se.INVERSE).setParameterLength(1), YN = (i, e) => (Me('TSL: "equals" is deprecated. Use "equal" inside a vector instead, like: "bvec*( equal( ... ) )"'), KS(i, e)), so = /* @__PURE__ */ Ke(Se, Se.MIN).setParameterLength(2, 1 / 0), qi = /* @__PURE__ */ Ke(Se, Se.MAX).setParameterLength(2, 1 / 0), F2 = /* @__PURE__ */ Ke(Se, Se.STEP).setParameterLength(2), QN = /* @__PURE__ */ Ke(Se, Se.REFLECT).setParameterLength(2), KN = /* @__PURE__ */ Ke(Se, Se.DISTANCE).setParameterLength(2), ZN = /* @__PURE__ */ Ke(Se, Se.DIFFERENCE).setParameterLength(2), $o = /* @__PURE__ */ Ke(Se, Se.DOT).setParameterLength(2), Kl = /* @__PURE__ */ Ke(Se, Se.CROSS).setParameterLength(2), ko = /* @__PURE__ */ Ke(Se, Se.POW).setParameterLength(2), uT = (i) => sn(i, i), JN = (i) => sn(i, i, i), cT = (i) => sn(i, i, i, i), e6 = /* @__PURE__ */ Ke(Se, Se.TRANSFORM_DIRECTION).setParameterLength(2), t6 = (i) => sn(iT(i), ko(vi(i), 1 / 3)), hT = (i) => $o(i, i), Bn = /* @__PURE__ */ Ke(Se, Se.MIX).setParameterLength(3), Sa = (i, e = 0, t = 1) => ut(new Se(Se.CLAMP, ut(i), ut(e), ut(t))), U2 = (i) => Sa(i), dT = /* @__PURE__ */ Ke(Se, Se.REFRACT).setParameterLength(3), Ta = /* @__PURE__ */ Ke(Se, Se.SMOOTHSTEP).setParameterLength(3), fT = /* @__PURE__ */ Ke(Se, Se.FACEFORWARD).setParameterLength(3), n6 = /* @__PURE__ */ pe(([i]) => {
  const n = 43758.5453, r = $o(i.xy, Xe(12.9898, 78.233)), s = O0(r, u_);
  return ba(Ns(s).mul(n));
}), i6 = (i, e, t) => Bn(e, t, i), r6 = (i, e, t) => Ta(e, t, i), s6 = (i, e) => F2(e, i), o6 = (i, e) => (Me('TSL: "atan2" is overloaded. Use "atan" instead.'), B2(i, e)), RK = fT, CK = tT;
Be("all", UN);
Be("any", ON);
Be("equals", YN);
Be("radians", kN);
Be("degrees", VN);
Be("exp", eT);
Be("exp2", Xf);
Be("log", L2);
Be("log2", Za);
Be("sqrt", ps);
Be("inverseSqrt", tT);
Be("floor", Ja);
Be("ceil", I2);
Be("normalize", Fs);
Be("fract", ba);
Be("sin", Ns);
Be("cos", ha);
Be("tan", GN);
Be("asin", zN);
Be("acos", nT);
Be("atan", B2);
Be("abs", vi);
Be("sign", iT);
Be("length", el);
Be("lengthSq", hT);
Be("negate", rT);
Be("oneMinus", qN);
Be("dFdx", sT);
Be("dFdy", oT);
Be("round", HN);
Be("reciprocal", WN);
Be("trunc", aT);
Be("fwidth", lT);
Be("atan2", o6);
Be("min", so);
Be("max", qi);
Be("step", s6);
Be("reflect", QN);
Be("distance", KN);
Be("dot", $o);
Be("cross", Kl);
Be("pow", ko);
Be("pow2", uT);
Be("pow3", JN);
Be("pow4", cT);
Be("transformDirection", e6);
Be("mix", i6);
Be("clamp", Sa);
Be("refract", dT);
Be("smoothstep", r6);
Be("faceForward", fT);
Be("difference", ZN);
Be("saturate", U2);
Be("cbrt", t6);
Be("transpose", $N);
Be("determinant", jN);
Be("inverse", XN);
Be("rand", n6);
class PK extends St {
  static get type() {
    return "ConditionalNode";
  }
  /**
   * Constructs a new conditional node.
   *
   * @param {Node} condNode - The node that defines the condition.
   * @param {Node} ifNode - The node that is evaluate when the condition ends up `true`.
   * @param {?Node} [elseNode=null] - The node that is evaluate when the condition ends up `false`.
   */
  constructor(e, t, n = null) {
    super(), this.condNode = e, this.ifNode = t, this.elseNode = n;
  }
  /**
   * This method is overwritten since the node type is inferred from the if/else
   * nodes.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(e) {
    const { ifNode: t, elseNode: n } = e.getNodeProperties(this);
    if (t === void 0)
      return e.flowBuildStage(this, "setup"), this.getNodeType(e);
    const r = t.getNodeType(e);
    if (n !== null) {
      const s = n.getNodeType(e);
      if (e.getTypeLength(s) > e.getTypeLength(r))
        return s;
    }
    return r;
  }
  setup(e) {
    const t = this.condNode, n = this.ifNode.isolate(), r = this.elseNode ? this.elseNode.isolate() : null, s = e.context.nodeBlock;
    e.getDataFromNode(n).parentNodeBlock = s, r !== null && (e.getDataFromNode(r).parentNodeBlock = s);
    const o = e.context.uniformFlow, a = e.getNodeProperties(this);
    a.condNode = t, a.ifNode = o ? n : n.context({ nodeBlock: n }), a.elseNode = r ? o ? r : r.context({ nodeBlock: r }) : null;
  }
  generate(e, t) {
    const n = this.getNodeType(e), r = e.getDataFromNode(this);
    if (r.nodeProperty !== void 0)
      return r.nodeProperty;
    const { condNode: s, ifNode: o, elseNode: a } = e.getNodeProperties(this), l = e.currentFunctionNode, u = t !== "void", c = u ? Bl(n).build(e) : "";
    r.nodeProperty = c;
    const A = s.build(e, "bool");
    if (e.context.uniformFlow && a !== null) {
      const y = o.build(e, n), T = a.build(e, n), b = e.getTernary(A, y, T);
      return e.format(b, n, t);
    }
    e.addFlowCode(`
${e.tab}if ( ${A} ) {

`).addFlowTab();
    let _ = o.build(e, n);
    if (_ && (u ? _ = c + " = " + _ + ";" : (_ = "return " + _ + ";", l === null && (Me("TSL: Return statement used in an inline 'Fn()'. Define a layout struct to allow return values."), _ = "// " + _))), e.removeFlowTab().addFlowCode(e.tab + "	" + _ + `

` + e.tab + "}"), a !== null) {
      e.addFlowCode(` else {

`).addFlowTab();
      let y = a.build(e, n);
      y && (u ? y = c + " = " + y + ";" : (y = "return " + y + ";", l === null && (Me("TSL: Return statement used in an inline 'Fn()'. Define a layout struct to allow return values."), y = "// " + y))), e.removeFlowTab().addFlowCode(e.tab + "	" + y + `

` + e.tab + `}

`);
    } else
      e.addFlowCode(`

`);
    return e.format(c, n, t);
  }
}
const Yr = /* @__PURE__ */ on(PK).setParameterLength(2, 3);
Be("select", Yr);
class a6 extends St {
  static get type() {
    return "ContextNode";
  }
  /**
   * Constructs a new context node.
   *
   * @param {Node} node - The node whose context should be modified.
   * @param {Object} [value={}] - The modified context data.
   */
  constructor(e = null, t = {}) {
    super(), this.isContextNode = !0, this.node = e, this.value = t;
  }
  /**
   * This method is overwritten to ensure it returns the reference to {@link ContextNode#node}.
   *
   * @return {Node} A reference to {@link ContextNode#node}.
   */
  getScope() {
    return this.node.getScope();
  }
  /**
   * This method is overwritten to ensure it returns the type of {@link ContextNode#node}.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(e) {
    return this.node.getNodeType(e);
  }
  /**
   * Gathers the context data from all parent context nodes.
   *
   * @return {Object} The gathered context data.
   */
  getFlowContextData() {
    const e = [];
    return this.traverse((t) => {
      t.isContextNode === !0 && e.push(t.value);
    }), Object.assign({}, ...e);
  }
  /**
   * This method is overwritten to ensure it returns the member type of {@link ContextNode#node}.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {string} name - The member name.
   * @returns {string} The member type.
   */
  getMemberType(e, t) {
    return this.node.getMemberType(e, t);
  }
  analyze(e) {
    const t = e.addContext(this.value);
    this.node.build(e), e.setContext(t);
  }
  setup(e) {
    const t = e.addContext(this.value);
    this.node.build(e), e.setContext(t);
  }
  generate(e, t) {
    const n = e.addContext(this.value), r = this.node.build(e, t);
    return e.setContext(n), r;
  }
}
const eu = (i = null, e = {}) => {
  let t = i;
  return (t === null || t.isNode !== !0) && (e = t || e, t = null), new a6(t, e);
}, l6 = (i) => eu(i, { uniformFlow: !0 }), AT = (i, e) => eu(i, { nodeName: e });
function u6(i, e, t = null) {
  return eu(t, {
    getShadow: ({ light: n, shadowColorNode: r }) => e === n ? r.mul(i) : r
  });
}
function c6(i, e = null) {
  return eu(e, {
    getAO: (t, { material: n }) => n.transparent === !0 ? t : t !== null ? t.mul(i) : i
  });
}
function h6(i, e) {
  return Me('TSL: "label()" has been deprecated. Use "setName()" instead.'), AT(i, e);
}
Be("context", eu);
Be("label", h6);
Be("uniformFlow", l6);
Be("setName", AT);
Be("builtinShadowContext", (i, e, t) => u6(e, t, i));
Be("builtinAOContext", (i, e) => c6(e, i));
class n1 extends St {
  static get type() {
    return "VarNode";
  }
  /**
   * Constructs a new variable node.
   *
   * @param {Node} node - The node for which a variable should be created.
   * @param {?string} [name=null] - The name of the variable in the shader.
   * @param {boolean} [readOnly=false] - The read-only flag.
   */
  constructor(e, t = null, n = !1) {
    super(), this.node = e, this.name = t, this.global = !0, this.isVarNode = !0, this.readOnly = n, this.parents = !0, this.intent = !1;
  }
  /**
   * Sets the intent flag for this node.
   *
   * This flag is used to indicate that this node is used for intent
   * and should not be built directly. Instead, it is used to indicate that
   * the node should be treated as a variable intent.
   *
   * It's useful for assigning variables without needing creating a new variable node.
   *
   * @param {boolean} value - The value to set for the intent flag.
   * @returns {VarNode} This node.
   */
  setIntent(e) {
    return this.intent = e, this;
  }
  /**
   * Checks if this node is used for intent.
   *
   * @param {NodeBuilder} builder - The node builder.
   * @returns {boolean} Whether this node is used for intent.
   */
  isIntent(e) {
    return e.getDataFromNode(this).forceDeclaration === !0 ? !1 : this.intent;
  }
  /**
   * Returns the intent flag of this node.
   *
   * @return {boolean} The intent flag.
   */
  getIntent() {
    return this.intent;
  }
  getMemberType(e, t) {
    return this.node.getMemberType(e, t);
  }
  getElementType(e) {
    return this.node.getElementType(e);
  }
  getNodeType(e) {
    return this.node.getNodeType(e);
  }
  getArrayCount(e) {
    return this.node.getArrayCount(e);
  }
  isAssign(e) {
    return e.getDataFromNode(this).assign;
  }
  build(...e) {
    const t = e[0];
    if (this._hasStack(t) === !1 && t.buildStage === "setup" && (t.context.nodeLoop || t.context.nodeBlock)) {
      let n = !1;
      if (this.node.isShaderCallNodeInternal && this.node.shaderNode.getLayout() === null && t.fnCall && t.fnCall.shaderNode && t.getDataFromNode(this.node.shaderNode).hasLoop) {
        const o = t.getDataFromNode(this);
        o.forceDeclaration = !0, n = !0;
      }
      const r = t.getBaseStack();
      n ? r.addToStackBefore(this) : r.addToStack(this);
    }
    return this.isIntent(t) && this.isAssign(t) !== !0 ? this.node.build(...e) : super.build(...e);
  }
  generate(e) {
    const { node: t, name: n, readOnly: r } = this, { renderer: s } = e, o = s.backend.isWebGPUBackend === !0;
    let a = !1, l = !1;
    r && (a = e.isDeterministic(t), l = o ? r : a);
    const u = this.getNodeType(e);
    if (u == "void")
      return this.isIntent(e) !== !0 && Ie('TSL: ".toVar()" can not be used with void type.'), t.build(e);
    const c = e.getVectorType(u), A = t.build(e, c), m = e.getVarFromNode(this, n, c, void 0, l), _ = e.getPropertyName(m);
    let y = _;
    if (l)
      if (o)
        y = a ? `const ${_}` : `let ${_}`;
      else {
        const T = t.getArrayCount(e);
        y = `const ${e.getVar(m.type, _, T)}`;
      }
    return e.addLineFlowCode(`${y} = ${A}`, this), _;
  }
  _hasStack(e) {
    return e.getDataFromNode(this).stack !== void 0;
  }
}
const pT = /* @__PURE__ */ on(n1), d6 = (i, e = null) => pT(i, e).toStack(), f6 = (i, e = null) => pT(i, e, !0).toStack(), A6 = (i) => pT(i).setIntent(!0).toStack();
Be("toVar", d6);
Be("toConst", f6);
Be("toVarIntent", A6);
class NK extends St {
  static get type() {
    return "SubBuild";
  }
  constructor(e, t, n = null) {
    super(n), this.node = e, this.name = t, this.isSubBuildNode = !0;
  }
  getNodeType(e) {
    if (this.nodeType !== null) return this.nodeType;
    e.addSubBuild(this.name);
    const t = this.node.getNodeType(e);
    return e.removeSubBuild(), t;
  }
  build(e, ...t) {
    e.addSubBuild(this.name);
    const n = this.node.build(e, ...t);
    return e.removeSubBuild(), n;
  }
}
const vf = (i, e, t = null) => ut(new NK(ut(i), e, t));
class DK extends St {
  static get type() {
    return "VaryingNode";
  }
  /**
   * Constructs a new varying node.
   *
   * @param {Node} node - The node for which a varying should be created.
   * @param {?string} name - The name of the varying in the shader.
   */
  constructor(e, t = null) {
    super(), this.node = e, this.name = t, this.isVaryingNode = !0, this.interpolationType = null, this.interpolationSampling = null, this.global = !0;
  }
  /**
   * Defines the interpolation type of the varying.
   *
   * @param {string} type - The interpolation type.
   * @param {?string} sampling - The interpolation sampling type
   * @return {VaryingNode} A reference to this node.
   */
  setInterpolation(e, t = null) {
    return this.interpolationType = e, this.interpolationSampling = t, this;
  }
  getHash(e) {
    return this.name || super.getHash(e);
  }
  getNodeType(e) {
    return this.node.getNodeType(e);
  }
  /**
   * This method performs the setup of a varying node with the current node builder.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {NodeVarying} The node varying from the node builder.
   */
  setupVarying(e) {
    const t = e.getNodeProperties(this);
    let n = t.varying;
    if (n === void 0) {
      const r = this.name, s = this.getNodeType(e), o = this.interpolationType, a = this.interpolationSampling;
      t.varying = n = e.getVaryingFromNode(this, r, s, o, a), t.node = vf(this.node, "VERTEX");
    }
    return n.needsInterpolation || (n.needsInterpolation = e.shaderStage === "fragment"), n;
  }
  setup(e) {
    this.setupVarying(e), e.flowNodeFromShaderStage(_p.VERTEX, this.node);
  }
  analyze(e) {
    this.setupVarying(e), e.flowNodeFromShaderStage(_p.VERTEX, this.node);
  }
  generate(e) {
    const t = e.getSubBuildProperty("property", e.currentStack), n = e.getNodeProperties(this), r = this.setupVarying(e);
    if (n[t] === void 0) {
      const s = this.getNodeType(e), o = e.getPropertyName(r, _p.VERTEX);
      e.flowNodeFromShaderStage(_p.VERTEX, n.node, s, o), n[t] = o;
    }
    return e.getPropertyName(r);
  }
}
const cl = /* @__PURE__ */ on(DK).setParameterLength(1, 2), p6 = (i) => cl(i);
Be("toVarying", cl);
Be("toVertexStage", p6);
Be("varying", (...i) => (Me("TSL: .varying() has been renamed to .toVarying()."), cl(...i)));
Be("vertexStage", (...i) => (Me("TSL: .vertexStage() has been renamed to .toVertexStage()."), cl(...i)));
const m6 = /* @__PURE__ */ pe(([i]) => {
  const e = i.mul(0.9478672986).add(0.0521327014).pow(2.4), t = i.mul(0.0773993808), n = i.lessThanEqual(0.04045);
  return Bn(e, t, n);
}).setLayout({
  name: "sRGBTransferEOTF",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" }
  ]
}), g6 = /* @__PURE__ */ pe(([i]) => {
  const e = i.pow(0.41666).mul(1.055).sub(0.055), t = i.mul(12.92), n = i.lessThanEqual(31308e-7);
  return Bn(e, t, n);
}).setLayout({
  name: "sRGBTransferOETF",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" }
  ]
}), mT = "WorkingColorSpace", LK = "OutputColorSpace";
class gT extends Hi {
  static get type() {
    return "ColorSpaceNode";
  }
  /**
   * Constructs a new color space node.
   *
   * @param {Node} colorNode - Represents the color to convert.
   * @param {string} source - The source color space.
   * @param {string} target - The target color space.
   */
  constructor(e, t, n) {
    super("vec4"), this.colorNode = e, this.source = t, this.target = n;
  }
  /**
   * This method resolves the constants `WORKING_COLOR_SPACE` and
   * `OUTPUT_COLOR_SPACE` based on the current configuration of the
   * color management and renderer.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {string} colorSpace - The color space to resolve.
   * @return {string} The resolved color space.
   */
  resolveColorSpace(e, t) {
    return t === mT ? Xt.workingColorSpace : t === LK ? e.context.outputColorSpace || e.renderer.outputColorSpace : t;
  }
  setup(e) {
    const { colorNode: t } = this, n = this.resolveColorSpace(e, this.source), r = this.resolveColorSpace(e, this.target);
    let s = t;
    return Xt.enabled === !1 || n === r || !n || !r || (Xt.getTransfer(n) === vt && (s = Gt(m6(s.rgb), s.a)), Xt.getPrimaries(n) !== Xt.getPrimaries(r) && (s = Gt(
      Kr(Xt._getMatrix(new fn(), n, r)).mul(s.rgb),
      s.a
    )), Xt.getTransfer(r) === vt && (s = Gt(g6(s.rgb), s.a))), s;
  }
}
const _6 = (i, e) => ut(new gT(ut(i), mT, e)), O2 = (i, e) => ut(new gT(ut(i), e, mT)), IK = (i, e, t) => ut(new gT(ut(i), e, t));
Be("workingToColorSpace", _6);
Be("colorSpaceToWorking", O2);
let BK = class extends sd {
  static get type() {
    return "ReferenceElementNode";
  }
  /**
   * Constructs a new reference element node.
   *
   * @param {ReferenceBaseNode} referenceNode - The reference node.
   * @param {Node} indexNode - The index node that defines the element access.
   */
  constructor(e, t) {
    super(e, t), this.referenceNode = e, this.isReferenceElementNode = !0;
  }
  /**
   * This method is overwritten since the node type is inferred from
   * the uniform type of the reference node.
   *
   * @return {string} The node type.
   */
  getNodeType() {
    return this.referenceNode.uniformType;
  }
  generate(e) {
    const t = super.generate(e), n = this.referenceNode.getNodeType(), r = this.getNodeType();
    return e.format(t, n, r);
  }
};
class x6 extends St {
  static get type() {
    return "ReferenceBaseNode";
  }
  /**
   * Constructs a new reference base node.
   *
   * @param {string} property - The name of the property the node refers to.
   * @param {string} uniformType - The uniform type that should be used to represent the property value.
   * @param {?Object} [object=null] - The object the property belongs to.
   * @param {?number} [count=null] - When the linked property is an array-like, this parameter defines its length.
   */
  constructor(e, t, n = null, r = null) {
    super(), this.property = e, this.uniformType = t, this.object = n, this.count = r, this.properties = e.split("."), this.reference = n, this.node = null, this.group = null, this.updateType = hn.OBJECT;
  }
  /**
   * Sets the uniform group for this reference node.
   *
   * @param {UniformGroupNode} group - The uniform group to set.
   * @return {ReferenceBaseNode} A reference to this node.
   */
  setGroup(e) {
    return this.group = e, this;
  }
  /**
   * When the referred property is array-like, this method can be used
   * to access elements via an index node.
   *
   * @param {IndexNode} indexNode - indexNode.
   * @return {ReferenceElementNode} A reference to an element.
   */
  element(e) {
    return new BK(this, ut(e));
  }
  /**
   * Sets the node type which automatically defines the internal
   * uniform type.
   *
   * @param {string} uniformType - The type to set.
   */
  setNodeType(e) {
    const t = It(null, e);
    this.group !== null && t.setGroup(this.group), this.node = t;
  }
  /**
   * This method is overwritten since the node type is inferred from
   * the type of the reference node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(e) {
    return this.node === null && (this.updateReference(e), this.updateValue()), this.node.getNodeType(e);
  }
  /**
   * Returns the property value from the given referred object.
   *
   * @param {Object} [object=this.reference] - The object to retrieve the property value from.
   * @return {any} The value.
   */
  getValueFromReference(e = this.reference) {
    const { properties: t } = this;
    let n = e[t[0]];
    for (let r = 1; r < t.length; r++)
      n = n[t[r]];
    return n;
  }
  /**
   * Allows to update the reference based on the given state. The state is only
   * evaluated {@link ReferenceBaseNode#object} is not set.
   *
   * @param {(NodeFrame|NodeBuilder)} state - The current state.
   * @return {Object} The updated reference.
   */
  updateReference(e) {
    return this.reference = this.object !== null ? this.object : e.object, this.reference;
  }
  /**
   * The output of the reference node is the internal uniform node.
   *
   * @return {UniformNode} The output node.
   */
  setup() {
    return this.updateValue(), this.node;
  }
  /**
   * Overwritten to update the internal uniform value.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  update() {
    this.updateValue();
  }
  /**
   * Retrieves the value from the referred object property and uses it
   * to updated the internal uniform.
   */
  updateValue() {
    this.node === null && this.setNodeType(this.uniformType);
    const e = this.getValueFromReference();
    Array.isArray(e) ? this.node.array = e : this.node.value = e;
  }
}
const FK = (i, e, t) => new x6(i, e, t);
class UK extends x6 {
  static get type() {
    return "RendererReferenceNode";
  }
  /**
   * Constructs a new renderer reference node.
   *
   * @param {string} property - The name of the property the node refers to.
   * @param {string} inputType - The uniform type that should be used to represent the property value.
   * @param {?Renderer} [renderer=null] - The renderer the property belongs to. When no renderer is set,
   * the node refers to the renderer of the current state.
   */
  constructor(e, t, n = null) {
    super(e, t, n), this.renderer = n, this.setGroup(Lt);
  }
  /**
   * Updates the reference based on the given state. The state is only evaluated
   * {@link RendererReferenceNode#renderer} is not set.
   *
   * @param {(NodeFrame|NodeBuilder)} state - The current state.
   * @return {Object} The updated reference.
   */
  updateReference(e) {
    return this.reference = this.renderer !== null ? this.renderer : e.renderer, this.reference;
  }
}
const y6 = (i, e, t = null) => new UK(i, e, t);
class OK extends Hi {
  static get type() {
    return "ToneMappingNode";
  }
  /**
   * Constructs a new tone mapping node.
   *
   * @param {number} toneMapping - The tone mapping type.
   * @param {Node} exposureNode - The tone mapping exposure.
   * @param {Node} [colorNode=null] - The color node to process.
   */
  constructor(e, t = b6, n = null) {
    super("vec3"), this._toneMapping = e, this.exposureNode = t, this.colorNode = n;
  }
  /**
   * Overwrites the default `customCacheKey()` implementation by including the tone
   * mapping type into the cache key.
   *
   * @return {number} The hash.
   */
  customCacheKey() {
    return Rp(this._toneMapping);
  }
  /**
   * Sets the tone mapping type.
   *
   * @param {number} value - The tone mapping type.
   * @return {ToneMappingNode} A reference to this node.
   */
  setToneMapping(e) {
    return this._toneMapping = e, this;
  }
  /**
   * Gets the tone mapping type.
   *
   * @returns {number} The tone mapping type.
   */
  getToneMapping() {
    return this._toneMapping;
  }
  setup(e) {
    const t = this.colorNode || e.context.color, n = this._toneMapping;
    if (n === Dr) return t;
    let r = null;
    const s = e.renderer.library.getToneMappingFunction(n);
    return s !== null ? r = Gt(s(t.rgb, this.exposureNode), t.a) : (Ie("ToneMappingNode: Unsupported Tone Mapping configuration.", n), r = t), r;
  }
}
const v6 = (i, e, t) => ut(new OK(i, ut(e), ut(t))), b6 = /* @__PURE__ */ y6("toneMappingExposure", "float");
Be("toneMapping", (i, e, t) => v6(e, t, i));
const yR = /* @__PURE__ */ new WeakMap();
function vR(i, e) {
  let t = yR.get(i);
  return t === void 0 && (t = new aA(i, e), yR.set(i, t)), t;
}
class _u extends FS {
  static get type() {
    return "BufferAttributeNode";
  }
  /**
   * Constructs a new buffer attribute node.
   *
   * @param {BufferAttribute|InterleavedBuffer|TypedArray} value - The attribute data.
   * @param {?string} [bufferType=null] - The buffer type (e.g. `'vec3'`).
   * @param {number} [bufferStride=0] - The buffer stride.
   * @param {number} [bufferOffset=0] - The buffer offset.
   */
  constructor(e, t = null, n = 0, r = 0) {
    super(e, t), this.isBufferNode = !0, this.bufferType = t, this.bufferStride = n, this.bufferOffset = r, this.usage = Wu, this.instanced = !1, this.attribute = null, this.global = !0, e && e.isBufferAttribute === !0 && e.itemSize <= 4 && (this.attribute = e, this.usage = e.usage, this.instanced = e.isInstancedBufferAttribute);
  }
  /**
   * This method is overwritten since the attribute data might be shared
   * and thus the hash should be shared as well.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The hash.
   */
  getHash(e) {
    if (this.bufferStride === 0 && this.bufferOffset === 0) {
      let t = e.globalCache.getData(this.value);
      return t === void 0 && (t = {
        node: this
      }, e.globalCache.setData(this.value, t)), t.node.uuid;
    }
    return this.uuid;
  }
  /**
   * This method is overwritten since the node type is inferred from
   * the buffer attribute.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(e) {
    return this.bufferType === null && (this.bufferType = e.getTypeFromAttribute(this.attribute)), this.bufferType;
  }
  /**
   * Depending on which value was passed to the node, `setup()` behaves
   * differently. If no instance of `BufferAttribute` was passed, the method
   * creates an internal attribute and configures it respectively.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  setup(e) {
    if (this.attribute !== null) return;
    const t = this.getNodeType(e), n = e.getTypeLength(t), r = this.value, s = this.bufferStride || n, o = this.bufferOffset;
    let a;
    r.isInterleavedBuffer === !0 ? a = r : r.isBufferAttribute === !0 ? a = vR(r.array, s) : a = vR(r, s);
    const l = new Bs(a, n, o);
    a.setUsage(this.usage), this.attribute = l, this.attribute.isInstancedBufferAttribute = this.instanced;
  }
  /**
   * Generates the code snippet of the buffer attribute node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The generated code snippet.
   */
  generate(e) {
    const t = this.getNodeType(e), n = e.getBufferAttributeFromNode(this, t), r = e.getPropertyName(n);
    let s = null;
    return e.shaderStage === "vertex" || e.shaderStage === "compute" ? (this.name = r, s = r) : s = cl(this).build(e, t), s;
  }
  /**
   * Overwrites the default implementation to return a fixed value `'bufferAttribute'`.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The input type.
   */
  getInputType() {
    return "bufferAttribute";
  }
  /**
   * Sets the `usage` property to the given value.
   *
   * @param {number} value - The usage to set.
   * @return {BufferAttributeNode} A reference to this node.
   */
  setUsage(e) {
    return this.usage = e, this.attribute && this.attribute.isBufferAttribute === !0 && (this.attribute.usage = e), this;
  }
  /**
   * Sets the `instanced` property to the given value.
   *
   * @param {boolean} value - The value to set.
   * @return {BufferAttributeNode} A reference to this node.
   */
  setInstanced(e) {
    return this.instanced = e, this;
  }
}
function k2(i, e = null, t = 0, n = 0, r = Wu, s = !1) {
  return e === "mat3" || e === null && i.itemSize === 9 ? Kr(
    new _u(i, "vec3", 9, 0).setUsage(r).setInstanced(s),
    new _u(i, "vec3", 9, 3).setUsage(r).setInstanced(s),
    new _u(i, "vec3", 9, 6).setUsage(r).setInstanced(s)
  ) : e === "mat4" || e === null && i.itemSize === 16 ? Vu(
    new _u(i, "vec4", 16, 0).setUsage(r).setInstanced(s),
    new _u(i, "vec4", 16, 4).setUsage(r).setInstanced(s),
    new _u(i, "vec4", 16, 8).setUsage(r).setInstanced(s),
    new _u(i, "vec4", 16, 12).setUsage(r).setInstanced(s)
  ) : new _u(i, e, t, n);
}
const _T = (i, e = null, t = 0, n = 0) => k2(i, e, t, n), kK = (i, e = null, t = 0, n = 0) => k2(i, e, t, n, Du), c_ = (i, e = null, t = 0, n = 0) => k2(i, e, t, n, Wu, !0), Ob = (i, e = null, t = 0, n = 0) => k2(i, e, t, n, Du, !0);
Be("toAttribute", (i) => _T(i.value));
class VK extends St {
  static get type() {
    return "ComputeNode";
  }
  /**
   * Constructs a new compute node.
   *
   * @param {Node} computeNode - TODO
   * @param {Array<number>} workgroupSize - TODO.
   */
  constructor(e, t) {
    super("void"), this.isComputeNode = !0, this.computeNode = e, this.workgroupSize = t, this.count = null, this.version = 1, this.name = "", this.updateBeforeType = hn.OBJECT, this.onInitFunction = null;
  }
  /**
   * TODO
   *
   * @param {number|Array<number>} count - Array with [ x, y, z ] values for dispatch or a single number for the count
   * @return {ComputeNode}
   */
  setCount(e) {
    return this.count = e, this;
  }
  /**
   * TODO
   *
   * @return {number|Array<number>}
   */
  getCount() {
    return this.count;
  }
  /**
   * Executes the `dispose` event for this node.
   */
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  /**
   * Sets the {@link ComputeNode#name} property.
   *
   * @param {string} name - The name of the uniform.
   * @return {ComputeNode} A reference to this node.
   */
  setName(e) {
    return this.name = e, this;
  }
  /**
   * Sets the {@link ComputeNode#name} property.
   *
   * @deprecated
   * @param {string} name - The name of the uniform.
   * @return {ComputeNode} A reference to this node.
   */
  label(e) {
    return Me('TSL: "label()" has been deprecated. Use "setName()" instead.'), this.setName(e);
  }
  /**
   * TODO
   *
   * @param {Function} callback - TODO.
   * @return {ComputeNode} A reference to this node.
   */
  onInit(e) {
    return this.onInitFunction = e, this;
  }
  /**
   * The method execute the compute for this node.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  updateBefore({ renderer: e }) {
    e.compute(this);
  }
  setup(e) {
    const t = this.computeNode.build(e);
    if (t) {
      const n = e.getNodeProperties(this);
      n.outputComputeNode = t.outputNode, t.outputNode = null;
    }
    return t;
  }
  generate(e, t) {
    const { shaderStage: n } = e;
    if (n === "compute") {
      const r = this.computeNode.build(e, "void");
      r !== "" && e.addLineFlowCode(r, this);
    } else {
      const s = e.getNodeProperties(this).outputComputeNode;
      if (s)
        return s.build(e, t);
    }
  }
}
const xT = (i, e = [64]) => {
  (e.length === 0 || e.length > 3) && Ie("TSL: compute() workgroupSize must have 1, 2, or 3 elements");
  for (let t = 0; t < e.length; t++) {
    const n = e[t];
    (typeof n != "number" || n <= 0 || !Number.isInteger(n)) && Ie(`TSL: compute() workgroupSize element at index [ ${t} ] must be a positive integer`);
  }
  for (; e.length < 3; ) e.push(1);
  return ut(new VK(ut(i), e));
}, S6 = (i, e, t) => xT(i, t).setCount(e);
Be("compute", S6);
Be("computeKernel", xT);
class GK extends St {
  static get type() {
    return "IsolateNode";
  }
  /**
   * Constructs a new cache node.
   *
   * @param {Node} node - The node that should be cached.
   * @param {boolean} [parent=true] - Whether this node refers to a shared parent cache or not.
   */
  constructor(e, t = !0) {
    super(), this.node = e, this.parent = t, this.isIsolateNode = !0;
  }
  getNodeType(e) {
    const t = e.getCache(), n = e.getCacheFromNode(this, this.parent);
    e.setCache(n);
    const r = this.node.getNodeType(e);
    return e.setCache(t), r;
  }
  build(e, ...t) {
    const n = e.getCache(), r = e.getCacheFromNode(this, this.parent);
    e.setCache(r);
    const s = this.node.build(e, ...t);
    return e.setCache(n), s;
  }
  setParent(e) {
    return this.parent = e, this;
  }
  getParent() {
    return this.parent;
  }
}
const bf = (i) => new GK(ut(i));
function T6(i, e = !0) {
  return Me('TSL: "cache()" has been deprecated. Use "isolate()" instead.'), bf(i).setParent(e);
}
Be("cache", T6);
Be("isolate", bf);
class zK extends St {
  static get type() {
    return "BypassNode";
  }
  /**
   * Constructs a new bypass node.
   *
   * @param {Node} outputNode - The output node.
   * @param {Node} callNode - The call node.
   */
  constructor(e, t) {
    super(), this.isBypassNode = !0, this.outputNode = e, this.callNode = t;
  }
  getNodeType(e) {
    return this.outputNode.getNodeType(e);
  }
  generate(e) {
    const t = this.callNode.build(e, "void");
    return t !== "" && e.addLineFlowCode(t, this), this.outputNode.build(e);
  }
}
const w6 = /* @__PURE__ */ on(zK).setParameterLength(2);
Be("bypass", w6);
class M6 extends St {
  static get type() {
    return "RemapNode";
  }
  /**
   * Constructs a new remap node.
   *
   * @param {Node} node - The node that should be remapped.
   * @param {Node} inLowNode - The source or current lower bound of the range.
   * @param {Node} inHighNode - The source or current upper bound of the range.
   * @param {Node} [outLowNode=float(0)] - The target lower bound of the range.
   * @param {Node} [outHighNode=float(1)] - The target upper bound of the range.
   */
  constructor(e, t, n, r = J(0), s = J(1)) {
    super(), this.node = e, this.inLowNode = t, this.inHighNode = n, this.outLowNode = r, this.outHighNode = s, this.doClamp = !0;
  }
  setup() {
    const { node: e, inLowNode: t, inHighNode: n, outLowNode: r, outHighNode: s, doClamp: o } = this;
    let a = e.sub(t).div(n.sub(t));
    return o === !0 && (a = a.clamp()), a.mul(s.sub(r)).add(r);
  }
}
const E6 = /* @__PURE__ */ on(M6, null, null, { doClamp: !1 }).setParameterLength(3, 5), R6 = /* @__PURE__ */ on(M6).setParameterLength(3, 5);
Be("remap", E6);
Be("remapClamp", R6);
class i1 extends St {
  static get type() {
    return "ExpressionNode";
  }
  /**
   * Constructs a new expression node.
   *
   * @param {string} [snippet=''] - The native code snippet.
   * @param {string} [nodeType='void'] - The node type.
   */
  constructor(e = "", t = "void") {
    super(t), this.snippet = e;
  }
  generate(e, t) {
    const n = this.getNodeType(e), r = this.snippet;
    if (n === "void")
      e.addLineFlowCode(r, this);
    else
      return e.format(r, n, t);
  }
}
const Zl = /* @__PURE__ */ on(i1).setParameterLength(1, 2), C6 = (i) => (i ? Yr(i, Zl("discard")) : Zl("discard")).toStack(), qK = () => Zl("return").toStack();
Be("discard", C6);
class HK extends Hi {
  static get type() {
    return "RenderOutputNode";
  }
  /**
   * Constructs a new render output node.
   *
   * @param {Node} colorNode - The color node to process.
   * @param {?number} toneMapping - The tone mapping type.
   * @param {?string} outputColorSpace - The output color space.
   */
  constructor(e, t, n) {
    super("vec4"), this.colorNode = e, this._toneMapping = t, this.outputColorSpace = n, this.isRenderOutputNode = !0;
  }
  /**
   * Sets the tone mapping type.
   *
   * @param {number} value - The tone mapping type.
   * @return {ToneMappingNode} A reference to this node.
   */
  setToneMapping(e) {
    return this._toneMapping = e, this;
  }
  /**
   * Gets the tone mapping type.
   *
   * @returns {number} The tone mapping type.
   */
  getToneMapping() {
    return this._toneMapping;
  }
  setup({ context: e }) {
    let t = this.colorNode || e.color;
    const n = (this._toneMapping !== null ? this._toneMapping : e.toneMapping) || Dr, r = (this.outputColorSpace !== null ? this.outputColorSpace : e.outputColorSpace) || Ds;
    return n !== Dr && (t = t.toneMapping(n)), r !== Ds && r !== Xt.workingColorSpace && (t = t.workingToColorSpace(r)), t;
  }
}
const P6 = (i, e = null, t = null) => ut(new HK(ut(i), e, t));
Be("renderOutput", P6);
class WK extends Hi {
  static get type() {
    return "DebugNode";
  }
  constructor(e, t = null) {
    super(), this.node = e, this.callback = t;
  }
  getNodeType(e) {
    return this.node.getNodeType(e);
  }
  setup(e) {
    return this.node.build(e);
  }
  analyze(e) {
    return this.node.build(e);
  }
  generate(e) {
    const t = this.callback, n = this.node.build(e), r = "--- TSL debug - " + e.shaderStage + " shader ---", s = "-".repeat(r.length);
    let o = "";
    return o += "// #" + r + `#
`, o += e.flow.code.replace(/^\t/mg, "") + `
`, o += "/* ... */ " + n + ` /* ... */
`, o += "// #" + s + `#
`, t !== null ? t(e, o) : Of(o), n;
  }
}
const N6 = (i, e = null) => ut(new WK(ut(i), e)).toStack();
Be("debug", N6);
class D6 {
  /**
   * Creates a new InspectorBase.
   */
  constructor() {
    this._renderer = null, this.currentFrame = null;
  }
  /**
   * Returns the node frame for the current renderer.
   *
   * @return {Object} The node frame.
   */
  get nodeFrame() {
    return this._renderer._nodes.nodeFrame;
  }
  /**
   * Sets the renderer for this inspector.
   *
   * @param {WebGLRenderer} renderer - The renderer to associate with this inspector.
   * @return {InspectorBase} This inspector instance.
   */
  setRenderer(e) {
    return this._renderer = e, this;
  }
  /**
   * Returns the renderer associated with this inspector.
   *
   * @return {WebGLRenderer} The associated renderer.
   */
  getRenderer() {
    return this._renderer;
  }
  /**
   * Initializes the inspector.
   */
  init() {
  }
  /**
   * Called when a frame begins.
   */
  begin() {
  }
  /**
   * Called when a frame ends.
   */
  finish() {
  }
  /**
   * Inspects a node.
   *
   * @param {Node} node - The node to inspect.
   */
  inspect() {
  }
  /**
   * When a compute operation is performed.
   *
   * @param {ComputeNode} computeNode - The compute node being executed.
   * @param {number|Array<number>} dispatchSizeOrCount - The dispatch size or count.
   */
  computeAsync() {
  }
  /**
   * Called when a compute operation begins.
   *
   * @param {string} uid - A unique identifier for the render context.
   * @param {ComputeNode} computeNode - The compute node being executed.
   */
  beginCompute() {
  }
  /**
   * Called when a compute operation ends.
   *
   * @param {string} uid - A unique identifier for the render context.
   * @param {ComputeNode} computeNode - The compute node being executed.
   */
  finishCompute() {
  }
  /**
   * Called when a render operation begins.
   *
   * @param {string} uid - A unique identifier for the render context.
   * @param {Scene} scene - The scene being rendered.
   * @param {Camera} camera - The camera being used for rendering.
   * @param {?WebGLRenderTarget} renderTarget - The render target, if any.
   */
  beginRender() {
  }
  /**
   * Called when an animation loop ends.
   *
   * @param {string} uid - A unique identifier for the render context.
   */
  finishRender() {
  }
  /**
   * Called when a texture copy operation is performed.
   *
   * @param {Texture} srcTexture - The source texture.
   * @param {Texture} dstTexture - The destination texture.
   */
  copyTextureToTexture() {
  }
  /**
   * Called when a framebuffer copy operation is performed.
   *
   * @param {Texture} framebufferTexture - The texture associated with the framebuffer.
   */
  copyFramebufferToTexture() {
  }
}
class $K extends St {
  /**
   * Returns the type of the node.
   *
   * @returns {string}
   */
  static get type() {
    return "InspectorNode";
  }
  /**
   * Creates an InspectorNode.
   *
   * @param {Node} node - The node to inspect.
   * @param {string} [name=''] - Optional name for the inspector node.
   * @param {Function|null} [callback=null] - Optional callback to modify the node during setup.
   */
  constructor(e, t = "", n = null) {
    super(), this.node = e, this.name = t, this.callback = n, this.updateType = hn.FRAME, this.isInspectorNode = !0;
  }
  /**
   * Returns the name of the inspector node.
   *
   * @returns {string}
   */
  getName() {
    return this.name || this.node.name;
  }
  /**
   * Updates the inspector node, allowing inspection of the wrapped node.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  update(e) {
    e.renderer.inspector.inspect(this);
  }
  /**
   * Returns the type of the wrapped node.
   *
   * @param {NodeBuilder} builder - The node builder.
   * @returns {string}
   */
  getNodeType(e) {
    return this.node.getNodeType(e);
  }
  /**
   * Sets up the inspector node.
   *
   * @param {NodeBuilder} builder - The node builder.
   * @returns {Node} The setup node.
   */
  setup(e) {
    let t = this.node;
    return e.context.inspector === !0 && this.callback !== null && (t = this.callback(t)), e.renderer.backend.isWebGPUBackend !== !0 && e.renderer.inspector.constructor !== D6 && li('TSL: ".toInspector()" is only available with WebGPU.'), t;
  }
}
function L6(i, e = "", t = null) {
  return i = ut(i), i.before(new $K(i, e, t));
}
Be("toInspector", L6);
function jK(i) {
  Me("TSL: AddNodeElement has been removed in favor of tree-shaking. Trying add", i);
}
class I6 extends St {
  static get type() {
    return "AttributeNode";
  }
  /**
   * Constructs a new attribute node.
   *
   * @param {string} attributeName - The name of the attribute.
   * @param {?string} nodeType - The node type.
   */
  constructor(e, t = null) {
    super(t), this.global = !0, this._attributeName = e;
  }
  getHash(e) {
    return this.getAttributeName(e);
  }
  getNodeType(e) {
    let t = this.nodeType;
    if (t === null) {
      const n = this.getAttributeName(e);
      if (e.hasGeometryAttribute(n)) {
        const r = e.geometry.getAttribute(n);
        t = e.getTypeFromAttribute(r);
      } else
        t = "float";
    }
    return t;
  }
  /**
   * Sets the attribute name to the given value. The method can be
   * overwritten in derived classes if the final name must be computed
   * analytically.
   *
   * @param {string} attributeName - The name of the attribute.
   * @return {AttributeNode} A reference to this node.
   */
  setAttributeName(e) {
    return this._attributeName = e, this;
  }
  /**
   * Returns the attribute name of this node. The method can be
   * overwritten in derived classes if the final name must be computed
   * analytically.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The attribute name.
   */
  getAttributeName() {
    return this._attributeName;
  }
  generate(e) {
    const t = this.getAttributeName(e), n = this.getNodeType(e);
    if (e.hasGeometryAttribute(t) === !0) {
      const s = e.geometry.getAttribute(t), o = e.getTypeFromAttribute(s), a = e.getAttribute(t, o);
      return e.shaderStage === "vertex" ? e.format(a.name, o, n) : cl(this).build(e, n);
    } else
      return Me(`AttributeNode: Vertex attribute "${t}" not found on geometry.`), e.generateConst(n);
  }
  serialize(e) {
    super.serialize(e), e.global = this.global, e._attributeName = this._attributeName;
  }
  deserialize(e) {
    super.deserialize(e), this.global = e.global, this._attributeName = e._attributeName;
  }
}
const Jl = (i, e = null) => new I6(i, e), hi = (i = 0) => Jl("uv" + (i > 0 ? i : ""), "vec2");
class XK extends St {
  static get type() {
    return "TextureSizeNode";
  }
  /**
   * Constructs a new texture size node.
   *
   * @param {TextureNode} textureNode - A texture node which size should be retrieved.
   * @param {?Node<int>} [levelNode=null] - A level node which defines the requested mip.
   */
  constructor(e, t = null) {
    super("uvec2"), this.isTextureSizeNode = !0, this.textureNode = e, this.levelNode = t;
  }
  generate(e, t) {
    const n = this.textureNode.build(e, "property"), r = this.levelNode === null ? "0" : this.levelNode.build(e, "int");
    return e.format(`${e.getMethod("textureDimensions")}( ${n}, ${r} )`, this.getNodeType(e), t);
  }
}
const Fl = /* @__PURE__ */ on(XK).setParameterLength(1, 2);
class YK extends U0 {
  static get type() {
    return "MaxMipLevelNode";
  }
  /**
   * Constructs a new max mip level node.
   *
   * @param {TextureNode} textureNode - The texture node to compute the max mip level for.
   */
  constructor(e) {
    super(0), this._textureNode = e, this.updateType = hn.FRAME;
  }
  /**
   * The texture node to compute the max mip level for.
   *
   * @readonly
   * @type {TextureNode}
   */
  get textureNode() {
    return this._textureNode;
  }
  /**
   * The texture.
   *
   * @readonly
   * @type {Texture}
   */
  get texture() {
    return this._textureNode.value;
  }
  update() {
    const e = this.texture, t = e.images, n = t && t.length > 0 ? t[0] && t[0].image || t[0] : e.image;
    if (n && n.width !== void 0) {
      const { width: r, height: s } = n;
      this.value = Math.log2(Math.max(r, s));
    }
  }
}
const yT = /* @__PURE__ */ on(YK).setParameterLength(1), vT = /* @__PURE__ */ new Ii();
class sl extends U0 {
  static get type() {
    return "TextureNode";
  }
  /**
   * Constructs a new texture node.
   *
   * @param {Texture} [value=EmptyTexture] - The texture.
   * @param {?Node<vec2|vec3>} [uvNode=null] - The uv node.
   * @param {?Node<int>} [levelNode=null] - The level node.
   * @param {?Node<float>} [biasNode=null] - The bias node.
   */
  constructor(e = vT, t = null, n = null, r = null) {
    super(e), this.isTextureNode = !0, this.uvNode = t, this.levelNode = n, this.biasNode = r, this.compareNode = null, this.depthNode = null, this.gradNode = null, this.offsetNode = null, this.sampler = !0, this.updateMatrix = !1, this.updateType = hn.NONE, this.referenceNode = null, this._value = e, this._matrixUniform = null, this._flipYUniform = null, this.setUpdateMatrix(t === null);
  }
  set value(e) {
    this.referenceNode ? this.referenceNode.value = e : this._value = e;
  }
  /**
   * The texture value.
   *
   * @type {Texture}
   */
  get value() {
    return this.referenceNode ? this.referenceNode.value : this._value;
  }
  /**
   * Overwritten since the uniform hash is defined by the texture's UUID.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The uniform hash.
   */
  getUniformHash() {
    return this.value.uuid;
  }
  /**
   * Overwritten since the node type is inferred from the texture type.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType() {
    return this.value.isDepthTexture === !0 ? "float" : this.value.type === Jn ? "uvec4" : this.value.type === _r ? "ivec4" : "vec4";
  }
  /**
   * Overwrites the default implementation to return a fixed value `'texture'`.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The input type.
   */
  getInputType() {
    return "texture";
  }
  /**
   * Returns a default uvs based on the current texture's channel.
   *
   * @return {AttributeNode<vec2>} The default uvs.
   */
  getDefaultUV() {
    return hi(this.value.channel);
  }
  /**
   * Overwritten to always return the texture reference of the node.
   *
   * @param {any} state - This method can be invocated in different contexts so `state` can refer to any object type.
   * @return {Texture} The texture reference.
   */
  updateReference() {
    return this.value;
  }
  /**
   * Transforms the given uv node with the texture transformation matrix.
   *
   * @param {Node} uvNode - The uv node to transform.
   * @return {Node} The transformed uv node.
   */
  getTransformedUV(e) {
    return this._matrixUniform === null && (this._matrixUniform = It(this.value.matrix)), this._matrixUniform.mul(ce(e, 1)).xy;
  }
  /**
   * Defines whether the uv transformation matrix should automatically be updated or not.
   *
   * @param {boolean} value - The update toggle.
   * @return {TextureNode} A reference to this node.
   */
  setUpdateMatrix(e) {
    return this.updateMatrix = e, this;
  }
  /**
   * Setups the uv node. Depending on the backend as well as texture's image and type, it might be necessary
   * to modify the uv node for correct sampling.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {Node} uvNode - The uv node to setup.
   * @return {Node} The updated uv node.
   */
  setupUV(e, t) {
    return e.isFlipY() && (this._flipYUniform === null && (this._flipYUniform = It(!1)), t = t.toVar(), this.sampler ? t = this._flipYUniform.select(t.flipY(), t) : t = this._flipYUniform.select(t.setY(le(Fl(this, this.levelNode).y).sub(t.y).sub(1)), t)), t;
  }
  /**
   * Setups texture node by preparing the internal nodes for code generation.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  setup(e) {
    const t = e.getNodeProperties(this);
    t.referenceNode = this.referenceNode;
    const n = this.value;
    if (!n || n.isTexture !== !0)
      throw new Error("THREE.TSL: `texture( value )` function expects a valid instance of THREE.Texture().");
    const r = pe(() => {
      let o = this.uvNode;
      return (o === null || e.context.forceUVContext === !0) && e.context.getUV && (o = e.context.getUV(this, e)), o || (o = this.getDefaultUV()), this.updateMatrix === !0 && (o = this.getTransformedUV(o)), o = this.setupUV(e, o), this.updateType = this._matrixUniform !== null || this._flipYUniform !== null ? hn.OBJECT : hn.NONE, o;
    })();
    let s = this.levelNode;
    s === null && e.context.getTextureLevel && (s = e.context.getTextureLevel(this)), t.uvNode = r, t.levelNode = s, t.biasNode = this.biasNode, t.compareNode = this.compareNode, t.gradNode = this.gradNode, t.depthNode = this.depthNode, t.offsetNode = this.offsetNode;
  }
  /**
   * Generates the uv code snippet.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {Node} uvNode - The uv node to generate code for.
   * @return {string} The generated code snippet.
   */
  generateUV(e, t) {
    return t.build(e, this.sampler === !0 ? "vec2" : "ivec2");
  }
  /**
   * Generates the offset code snippet.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {Node} offsetNode - The offset node to generate code for.
   * @return {string} The generated code snippet.
   */
  generateOffset(e, t) {
    return t.build(e, "ivec2");
  }
  /**
   * Generates the snippet for the texture sampling.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {string} textureProperty - The texture property.
   * @param {string} uvSnippet - The uv snippet.
   * @param {?string} levelSnippet - The level snippet.
   * @param {?string} biasSnippet - The bias snippet.
   * @param {?string} depthSnippet - The depth snippet.
   * @param {?string} compareSnippet - The compare snippet.
   * @param {?Array<string>} gradSnippet - The grad snippet.
   * @param {?string} offsetSnippet - The offset snippet.
   * @return {string} The generated code snippet.
   */
  generateSnippet(e, t, n, r, s, o, a, l, u) {
    const c = this.value;
    let A;
    return s ? A = e.generateTextureBias(c, t, n, s, o, u) : l ? A = e.generateTextureGrad(c, t, n, l, o, u) : a ? A = e.generateTextureCompare(c, t, n, a, o, u) : this.sampler === !1 ? A = e.generateTextureLoad(c, t, n, r, o, u) : r ? A = e.generateTextureLevel(c, t, n, r, o, u) : A = e.generateTexture(c, t, n, o, u), A;
  }
  /**
   * Generates the code snippet of the texture node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {string} output - The current output.
   * @return {string} The generated code snippet.
   */
  generate(e, t) {
    const n = this.value, r = e.getNodeProperties(this), s = super.generate(e, "property");
    if (/^sampler/.test(t))
      return s + "_sampler";
    if (e.isReference(t))
      return s;
    {
      const o = e.getDataFromNode(this);
      let a = o.propertyName;
      if (a === void 0) {
        const { uvNode: c, levelNode: A, biasNode: m, compareNode: _, depthNode: y, gradNode: T, offsetNode: b } = r, S = this.generateUV(e, c), E = A ? A.build(e, "float") : null, R = m ? m.build(e, "float") : null, C = y ? y.build(e, "int") : null, L = _ ? _.build(e, "float") : null, D = T ? [T[0].build(e, "vec2"), T[1].build(e, "vec2")] : null, B = b ? this.generateOffset(e, b) : null, U = e.getVarFromNode(this);
        a = e.getPropertyName(U);
        const N = this.generateSnippet(e, s, S, E, R, C, L, D, B);
        e.addLineFlowCode(`${a} = ${N}`, this), o.snippet = N, o.propertyName = a;
      }
      let l = a;
      const u = this.getNodeType(e);
      return e.needsToWorkingColorSpace(n) && (l = O2(Zl(l, u), n.colorSpace).setup(e).build(e, u)), e.format(l, u, t);
    }
  }
  /**
   * Sets the sampler value.
   *
   * @param {boolean} value - The sampler value to set.
   * @return {TextureNode} A reference to this texture node.
   */
  setSampler(e) {
    return this.sampler = e, this;
  }
  /**
   * Returns the sampler value.
   *
   * @return {boolean} The sampler value.
   */
  getSampler() {
    return this.sampler;
  }
  // @TODO: Move to TSL
  /**
   * @function
   * @deprecated since r172. Use {@link TextureNode#sample} instead.
   *
   * @param {Node} uvNode - The uv node.
   * @return {TextureNode} A texture node representing the texture sample.
   */
  uv(e) {
    return Me("TextureNode: .uv() has been renamed. Use .sample() instead."), this.sample(e);
  }
  /**
   * Samples the texture with the given uv node.
   *
   * @param {Node} uvNode - The uv node.
   * @return {TextureNode} A texture node representing the texture sample.
   */
  sample(e) {
    const t = this.clone();
    return t.uvNode = ut(e), t.referenceNode = this.getBase(), ut(t);
  }
  /**
   * TSL function for creating a texture node that fetches/loads texels without interpolation.
   *
   * @param {Node<uvec2>} uvNode - The uv node.
   * @returns {TextureNode} A texture node representing the texture load.
   */
  load(e) {
    return this.sample(e).setSampler(!1);
  }
  /**
   * Samples a blurred version of the texture by defining an internal bias.
   *
   * @param {Node<float>} amountNode - How blurred the texture should be.
   * @return {TextureNode} A texture node representing the texture sample.
   */
  blur(e) {
    const t = this.clone();
    t.biasNode = ut(e).mul(yT(t)), t.referenceNode = this.getBase();
    const n = t.value;
    return t.generateMipmaps === !1 && (n && n.generateMipmaps === !1 || n.minFilter === ei || n.magFilter === ei) && (Me("TSL: texture().blur() requires mipmaps and sampling. Use .generateMipmaps=true and .minFilter/.magFilter=THREE.LinearFilter in the Texture."), t.biasNode = null), ut(t);
  }
  /**
   * Samples a specific mip of the texture.
   *
   * @param {Node<int>} levelNode - The mip level to sample.
   * @return {TextureNode} A texture node representing the texture sample.
   */
  level(e) {
    const t = this.clone();
    return t.levelNode = ut(e), t.referenceNode = this.getBase(), ut(t);
  }
  /**
   * Returns the texture size of the requested level.
   *
   * @param {Node<int>} levelNode - The level to compute the size for.
   * @return {TextureSizeNode} The texture size.
   */
  size(e) {
    return Fl(this, e);
  }
  /**
   * Samples the texture with the given bias.
   *
   * @param {Node<float>} biasNode - The bias node.
   * @return {TextureNode} A texture node representing the texture sample.
   */
  bias(e) {
    const t = this.clone();
    return t.biasNode = ut(e), t.referenceNode = this.getBase(), ut(t);
  }
  /**
   * Returns the base texture of this node.
   * @return {TextureNode} The base texture node.
   */
  getBase() {
    return this.referenceNode ? this.referenceNode.getBase() : this;
  }
  /**
   * Samples the texture by executing a compare operation.
   *
   * @param {Node<float>} compareNode - The node that defines the compare value.
   * @return {TextureNode} A texture node representing the texture sample.
   */
  compare(e) {
    const t = this.clone();
    return t.compareNode = ut(e), t.referenceNode = this.getBase(), ut(t);
  }
  /**
   * Samples the texture using an explicit gradient.
   *
   * @param {Node<vec2>} gradNodeX - The gradX node.
   * @param {Node<vec2>} gradNodeY - The gradY node.
   * @return {TextureNode} A texture node representing the texture sample.
   */
  grad(e, t) {
    const n = this.clone();
    return n.gradNode = [ut(e), ut(t)], n.referenceNode = this.getBase(), ut(n);
  }
  /**
   * Samples the texture by defining a depth node.
   *
   * @param {Node<int>} depthNode - The depth node.
   * @return {TextureNode} A texture node representing the texture sample.
   */
  depth(e) {
    const t = this.clone();
    return t.depthNode = ut(e), t.referenceNode = this.getBase(), ut(t);
  }
  /**
   * Samples the texture by defining an offset node.
   *
   * @param {Node<ivec2>} offsetNode - The offset node.
   * @return {TextureNode} A texture node representing the texture sample.
   */
  offset(e) {
    const t = this.clone();
    return t.offsetNode = ut(e), t.referenceNode = this.getBase(), ut(t);
  }
  // --
  serialize(e) {
    super.serialize(e), e.value = this.value.toJSON(e.meta).uuid, e.sampler = this.sampler, e.updateMatrix = this.updateMatrix, e.updateType = this.updateType;
  }
  deserialize(e) {
    super.deserialize(e), this.value = e.meta.textures[e.value], this.sampler = e.sampler, this.updateMatrix = e.updateMatrix, this.updateType = e.updateType;
  }
  /**
   * The update is used to implement the update of the uv transformation matrix.
   */
  update() {
    const e = this.value, t = this._matrixUniform;
    t !== null && (t.value = e.matrix), e.matrixAutoUpdate === !0 && e.updateMatrix();
    const n = this._flipYUniform;
    n !== null && (n.value = e.image instanceof ImageBitmap && e.flipY === !0 || e.isRenderTargetTexture === !0 || e.isFramebufferTexture === !0 || e.isDepthTexture === !0);
  }
  /**
   * Clones the texture node.
   *
   * @return {TextureNode} The cloned texture node.
   */
  clone() {
    const e = new this.constructor(this.value, this.uvNode, this.levelNode, this.biasNode);
    return e.sampler = this.sampler, e.depthNode = this.depthNode, e.compareNode = this.compareNode, e.gradNode = this.gradNode, e.offsetNode = this.offsetNode, e;
  }
}
const QK = /* @__PURE__ */ on(sl).setParameterLength(1, 4).setName("texture"), Wn = (i = vT, e = null, t = null, n = null) => {
  let r;
  return i && i.isTextureNode === !0 ? (r = ut(i.clone()), r.referenceNode = i.getBase(), e !== null && (r.uvNode = ut(e)), t !== null && (r.levelNode = ut(t)), n !== null && (r.biasNode = ut(n))) : r = QK(i, e, t, n), r;
}, KK = (i = vT) => Wn(i), $i = (...i) => Wn(...i).setSampler(!1), ZK = (i, e, t) => Wn(i, e).level(t), JK = (i) => (i.isNode === !0 ? i : Wn(i)).convert("sampler"), eZ = (i) => (i.isNode === !0 ? i : Wn(i)).convert("samplerComparison");
class bT extends U0 {
  static get type() {
    return "BufferNode";
  }
  /**
   * Constructs a new buffer node.
   *
   * @param {Array<number>} value - Array-like buffer data.
   * @param {string} bufferType - The data type of the buffer.
   * @param {number} [bufferCount=0] - The count of buffer elements.
   */
  constructor(e, t, n = 0) {
    super(e, t), this.isBufferNode = !0, this.bufferType = t, this.bufferCount = n, this.updateRanges = [];
  }
  /**
   * Adds a range of data in the data array to be updated on the GPU.
   *
   * @param {number} start - Position at which to start update.
   * @param {number} count - The number of components to update.
   */
  addUpdateRange(e, t) {
    this.updateRanges.push({ start: e, count: t });
  }
  /**
   * Clears the update ranges.
   */
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  /**
   * The data type of the buffer elements.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The element type.
   */
  getElementType(e) {
    return this.getNodeType(e);
  }
  /**
   * Overwrites the default implementation to return a fixed value `'buffer'`.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The input type.
   */
  getInputType() {
    return "buffer";
  }
}
const k0 = (i, e, t) => new bT(i, e, t);
class tZ extends sd {
  static get type() {
    return "UniformArrayElementNode";
  }
  /**
   * Constructs a new buffer node.
   *
   * @param {UniformArrayNode} uniformArrayNode - The uniform array node to access.
   * @param {IndexNode} indexNode - The index data that define the position of the accessed element in the array.
   */
  constructor(e, t) {
    super(e, t), this.isArrayBufferElementNode = !0;
  }
  generate(e) {
    const t = super.generate(e), n = this.getNodeType(), r = this.node.getPaddedType();
    return e.format(t, r, n);
  }
}
class nZ extends bT {
  static get type() {
    return "UniformArrayNode";
  }
  /**
   * Constructs a new uniform array node.
   *
   * @param {Array<any>} value - Array holding the buffer data.
   * @param {?string} [elementType=null] - The data type of a buffer element.
   */
  constructor(e, t = null) {
    super(null), this.array = e, this.elementType = t === null ? Bu(e[0]) : t, this.paddedType = this.getPaddedType(), this.updateType = hn.RENDER, this.isArrayBufferNode = !0;
  }
  /**
   * This method is overwritten since the node type is inferred from the
   * {@link UniformArrayNode#paddedType}.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType() {
    return this.paddedType;
  }
  /**
   * The data type of the array elements.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The element type.
   */
  getElementType() {
    return this.elementType;
  }
  /**
   * Returns the padded type based on the element type.
   *
   * @return {string} The padded type.
   */
  getPaddedType() {
    const e = this.elementType;
    let t = "vec4";
    return e === "mat2" ? t = "mat2" : /mat/.test(e) === !0 ? t = "mat4" : e.charAt(0) === "i" ? t = "ivec4" : e.charAt(0) === "u" && (t = "uvec4"), t;
  }
  /**
   * The update makes sure to correctly transfer the data from the (complex) objects
   * in the array to the internal, correctly padded value buffer.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  update() {
    const { array: e, value: t } = this, n = this.elementType;
    if (n === "float" || n === "int" || n === "uint")
      for (let r = 0; r < e.length; r++) {
        const s = r * 4;
        t[s] = e[r];
      }
    else if (n === "color")
      for (let r = 0; r < e.length; r++) {
        const s = r * 4, o = e[r];
        t[s] = o.r, t[s + 1] = o.g, t[s + 2] = o.b || 0;
      }
    else if (n === "mat2")
      for (let r = 0; r < e.length; r++) {
        const s = r * 4, o = e[r];
        t[s] = o.elements[0], t[s + 1] = o.elements[1], t[s + 2] = o.elements[2], t[s + 3] = o.elements[3];
      }
    else if (n === "mat3")
      for (let r = 0; r < e.length; r++) {
        const s = r * 16, o = e[r];
        t[s] = o.elements[0], t[s + 1] = o.elements[1], t[s + 2] = o.elements[2], t[s + 4] = o.elements[3], t[s + 5] = o.elements[4], t[s + 6] = o.elements[5], t[s + 8] = o.elements[6], t[s + 9] = o.elements[7], t[s + 10] = o.elements[8], t[s + 15] = 1;
      }
    else if (n === "mat4")
      for (let r = 0; r < e.length; r++) {
        const s = r * 16, o = e[r];
        for (let a = 0; a < o.elements.length; a++)
          t[s + a] = o.elements[a];
      }
    else
      for (let r = 0; r < e.length; r++) {
        const s = r * 4, o = e[r];
        t[s] = o.x, t[s + 1] = o.y, t[s + 2] = o.z || 0, t[s + 3] = o.w || 0;
      }
  }
  /**
   * Implement the value buffer creation based on the array data.
   *
   * @param {NodeBuilder} builder - A reference to the current node builder.
   * @return {null}
   */
  setup(e) {
    const t = this.array.length, n = this.elementType;
    let r = Float32Array;
    const s = this.paddedType, o = e.getTypeLength(s);
    return n.charAt(0) === "i" && (r = Int32Array), n.charAt(0) === "u" && (r = Uint32Array), this.value = new r(t * o), this.bufferCount = t, this.bufferType = s, super.setup(e);
  }
  /**
   * Overwrites the default `element()` method to provide element access
   * based on {@link UniformArrayNode}.
   *
   * @param {IndexNode} indexNode - The index node.
   * @return {UniformArrayElementNode}
   */
  element(e) {
    return new tZ(this, ut(e));
  }
}
const hs = (i, e) => new nZ(i, e);
class iZ extends St {
  /**
   * Constructs a new builtin node.
   *
   * @param {string} name - The name of the built-in shader variable.
   */
  constructor(e) {
    super("float"), this.name = e, this.isBuiltinNode = !0;
  }
  /**
   * Generates the code snippet of the builtin node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The generated code snippet.
   */
  generate() {
    return this.name;
  }
}
const tu = on(iZ).setParameterLength(1);
let qA, HA;
class Ti extends St {
  static get type() {
    return "ScreenNode";
  }
  /**
   * Constructs a new screen node.
   *
   * @param {('coordinate'|'viewport'|'size'|'uv'|'dpr')} scope - The node's scope.
   */
  constructor(e) {
    super(), this.scope = e, this._output = null, this.isViewportNode = !0;
  }
  /**
   * This method is overwritten since the node type depends on the selected scope.
   *
   * @return {('float'|'vec2'|'vec4')} The node type.
   */
  getNodeType() {
    return this.scope === Ti.DPR ? "float" : this.scope === Ti.VIEWPORT ? "vec4" : "vec2";
  }
  /**
   * This method is overwritten since the node's update type depends on the selected scope.
   *
   * @return {NodeUpdateType} The update type.
   */
  getUpdateType() {
    let e = hn.NONE;
    return (this.scope === Ti.SIZE || this.scope === Ti.VIEWPORT || this.scope === Ti.DPR) && (e = hn.RENDER), this.updateType = e, e;
  }
  /**
   * `ScreenNode` implements {@link Node#update} to retrieve viewport and size information
   * from the current renderer.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  update({ renderer: e }) {
    const t = e.getRenderTarget();
    this.scope === Ti.VIEWPORT ? t !== null ? HA.copy(t.viewport) : (e.getViewport(HA), HA.multiplyScalar(e.getPixelRatio())) : this.scope === Ti.DPR ? this._output.value = e.getPixelRatio() : t !== null ? (qA.width = t.width, qA.height = t.height) : e.getDrawingBufferSize(qA);
  }
  setup() {
    const e = this.scope;
    let t = null;
    return e === Ti.SIZE ? t = It(qA || (qA = new Le())) : e === Ti.VIEWPORT ? t = It(HA || (HA = new Kt())) : e === Ti.DPR ? t = It(1) : t = Xe(ad.div(jh)), this._output = t, t;
  }
  generate(e) {
    if (this.scope === Ti.COORDINATE) {
      let t = e.getFragCoord();
      if (e.isFlipY()) {
        const n = e.getNodeProperties(jh).outputNode.build(e);
        t = `${e.getType("vec2")}( ${t}.x, ${n}.y - ${t}.y )`;
      }
      return t;
    }
    return super.generate(e);
  }
}
Ti.COORDINATE = "coordinate";
Ti.VIEWPORT = "viewport";
Ti.SIZE = "size";
Ti.UV = "uv";
Ti.DPR = "dpr";
const B6 = /* @__PURE__ */ st(Ti, Ti.DPR), Ul = /* @__PURE__ */ st(Ti, Ti.UV), jh = /* @__PURE__ */ st(Ti, Ti.SIZE), ad = /* @__PURE__ */ st(Ti, Ti.COORDINATE), ST = /* @__PURE__ */ st(Ti, Ti.VIEWPORT), TT = ST.zw, F6 = /* @__PURE__ */ ad.sub(ST.xy), rZ = /* @__PURE__ */ F6.div(TT), sZ = /* @__PURE__ */ pe(() => (Me('TSL: "viewportResolution" is deprecated. Use "screenSize" instead.'), jh), "vec2").once()(), rc = /* @__PURE__ */ It(0, "uint").setName("u_cameraIndex").setGroup(D2("cameraIndex")).toVarying("v_cameraIndex"), Cu = /* @__PURE__ */ It("float").setName("cameraNear").setGroup(Lt).onRenderUpdate(({ camera: i }) => i.near), Pu = /* @__PURE__ */ It("float").setName("cameraFar").setGroup(Lt).onRenderUpdate(({ camera: i }) => i.far), Ol = /* @__PURE__ */ pe(({ camera: i }) => {
  let e;
  if (i.isArrayCamera && i.cameras.length > 0) {
    const t = [];
    for (const r of i.cameras)
      t.push(r.projectionMatrix);
    e = hs(t).setGroup(Lt).setName("cameraProjectionMatrices").element(i.isMultiViewCamera ? tu("gl_ViewID_OVR") : rc).toConst("cameraProjectionMatrix");
  } else
    e = It("mat4").setName("cameraProjectionMatrix").setGroup(Lt).onRenderUpdate(({ camera: t }) => t.projectionMatrix);
  return e;
}).once()(), oZ = /* @__PURE__ */ pe(({ camera: i }) => {
  let e;
  if (i.isArrayCamera && i.cameras.length > 0) {
    const t = [];
    for (const r of i.cameras)
      t.push(r.projectionMatrixInverse);
    e = hs(t).setGroup(Lt).setName("cameraProjectionMatricesInverse").element(i.isMultiViewCamera ? tu("gl_ViewID_OVR") : rc).toConst("cameraProjectionMatrixInverse");
  } else
    e = It("mat4").setName("cameraProjectionMatrixInverse").setGroup(Lt).onRenderUpdate(({ camera: t }) => t.projectionMatrixInverse);
  return e;
}).once()(), ea = /* @__PURE__ */ pe(({ camera: i }) => {
  let e;
  if (i.isArrayCamera && i.cameras.length > 0) {
    const t = [];
    for (const r of i.cameras)
      t.push(r.matrixWorldInverse);
    e = hs(t).setGroup(Lt).setName("cameraViewMatrices").element(i.isMultiViewCamera ? tu("gl_ViewID_OVR") : rc).toConst("cameraViewMatrix");
  } else
    e = It("mat4").setName("cameraViewMatrix").setGroup(Lt).onRenderUpdate(({ camera: t }) => t.matrixWorldInverse);
  return e;
}).once()(), aZ = /* @__PURE__ */ pe(({ camera: i }) => {
  let e;
  if (i.isArrayCamera && i.cameras.length > 0) {
    const t = [];
    for (const r of i.cameras)
      t.push(r.matrixWorld);
    e = hs(t).setGroup(Lt).setName("cameraWorldMatrices").element(i.isMultiViewCamera ? tu("gl_ViewID_OVR") : rc).toConst("cameraWorldMatrix");
  } else
    e = It("mat4").setName("cameraWorldMatrix").setGroup(Lt).onRenderUpdate(({ camera: t }) => t.matrixWorld);
  return e;
}).once()(), lZ = /* @__PURE__ */ pe(({ camera: i }) => {
  let e;
  if (i.isArrayCamera && i.cameras.length > 0) {
    const t = [];
    for (const r of i.cameras)
      t.push(r.normalMatrix);
    e = hs(t).setGroup(Lt).setName("cameraNormalMatrices").element(i.isMultiViewCamera ? tu("gl_ViewID_OVR") : rc).toConst("cameraNormalMatrix");
  } else
    e = It("mat3").setName("cameraNormalMatrix").setGroup(Lt).onRenderUpdate(({ camera: t }) => t.normalMatrix);
  return e;
}).once()(), U6 = /* @__PURE__ */ pe(({ camera: i }) => {
  let e;
  if (i.isArrayCamera && i.cameras.length > 0) {
    const t = [];
    for (let r = 0, s = i.cameras.length; r < s; r++)
      t.push(new j());
    e = hs(t).setGroup(Lt).setName("cameraPositions").onRenderUpdate(({ camera: r }, s) => {
      const o = r.cameras, a = s.array;
      for (let l = 0, u = o.length; l < u; l++)
        a[l].setFromMatrixPosition(o[l].matrixWorld);
    }).element(i.isMultiViewCamera ? tu("gl_ViewID_OVR") : rc).toConst("cameraPosition");
  } else
    e = It(new j()).setName("cameraPosition").setGroup(Lt).onRenderUpdate(({ camera: t }, n) => n.value.setFromMatrixPosition(t.matrixWorld));
  return e;
}).once()(), uZ = /* @__PURE__ */ pe(({ camera: i }) => {
  let e;
  if (i.isArrayCamera && i.cameras.length > 0) {
    const t = [];
    for (const r of i.cameras)
      t.push(r.viewport);
    e = hs(t, "vec4").setGroup(Lt).setName("cameraViewports").element(rc).toConst("cameraViewport");
  } else
    e = Gt(0, 0, jh.x, jh.y).toConst("cameraViewport");
  return e;
}).once()(), bR = /* @__PURE__ */ new fr();
class In extends St {
  static get type() {
    return "Object3DNode";
  }
  /**
   * Constructs a new object 3D node.
   *
   * @param {('position'|'viewPosition'|'direction'|'scale'|'worldMatrix')} scope - The node represents a different type of transformation depending on the scope.
   * @param {?Object3D} [object3d=null] - The 3D object.
   */
  constructor(e, t = null) {
    super(), this.scope = e, this.object3d = t, this.updateType = hn.OBJECT, this.uniformNode = new U0(null);
  }
  /**
   * Overwritten since the node type is inferred from the scope.
   *
   * @return {('mat4'|'vec3'|'float')} The node type.
   */
  getNodeType() {
    const e = this.scope;
    if (e === In.WORLD_MATRIX)
      return "mat4";
    if (e === In.POSITION || e === In.VIEW_POSITION || e === In.DIRECTION || e === In.SCALE)
      return "vec3";
    if (e === In.RADIUS)
      return "float";
  }
  /**
   * Updates the uniform value depending on the scope.
   *
   * @param {NodeFrame} frame - The current node frame.
   */
  update(e) {
    const t = this.object3d, n = this.uniformNode, r = this.scope;
    if (r === In.WORLD_MATRIX)
      n.value = t.matrixWorld;
    else if (r === In.POSITION)
      n.value = n.value || new j(), n.value.setFromMatrixPosition(t.matrixWorld);
    else if (r === In.SCALE)
      n.value = n.value || new j(), n.value.setFromMatrixScale(t.matrixWorld);
    else if (r === In.DIRECTION)
      n.value = n.value || new j(), t.getWorldDirection(n.value);
    else if (r === In.VIEW_POSITION) {
      const s = e.camera;
      n.value = n.value || new j(), n.value.setFromMatrixPosition(t.matrixWorld), n.value.applyMatrix4(s.matrixWorldInverse);
    } else if (r === In.RADIUS) {
      const s = e.object.geometry;
      s.boundingSphere === null && s.computeBoundingSphere(), bR.copy(s.boundingSphere).applyMatrix4(t.matrixWorld), n.value = bR.radius;
    }
  }
  /**
   * Generates the code snippet of the uniform node. The node type of the uniform
   * node also depends on the selected scope.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The generated code snippet.
   */
  generate(e) {
    const t = this.scope;
    return t === In.WORLD_MATRIX ? this.uniformNode.nodeType = "mat4" : t === In.POSITION || t === In.VIEW_POSITION || t === In.DIRECTION || t === In.SCALE ? this.uniformNode.nodeType = "vec3" : t === In.RADIUS && (this.uniformNode.nodeType = "float"), this.uniformNode.build(e);
  }
  serialize(e) {
    super.serialize(e), e.scope = this.scope;
  }
  deserialize(e) {
    super.deserialize(e), this.scope = e.scope;
  }
}
In.WORLD_MATRIX = "worldMatrix";
In.POSITION = "position";
In.SCALE = "scale";
In.VIEW_POSITION = "viewPosition";
In.DIRECTION = "direction";
In.RADIUS = "radius";
const cZ = /* @__PURE__ */ on(In, In.DIRECTION).setParameterLength(1), hZ = /* @__PURE__ */ on(In, In.WORLD_MATRIX).setParameterLength(1), O6 = /* @__PURE__ */ on(In, In.POSITION).setParameterLength(1), dZ = /* @__PURE__ */ on(In, In.SCALE).setParameterLength(1), fZ = /* @__PURE__ */ on(In, In.VIEW_POSITION).setParameterLength(1), AZ = /* @__PURE__ */ on(In, In.RADIUS).setParameterLength(1);
class jo extends In {
  static get type() {
    return "ModelNode";
  }
  /**
   * Constructs a new object model node.
   *
   * @param {('position'|'viewPosition'|'direction'|'scale'|'worldMatrix')} scope - The node represents a different type of transformation depending on the scope.
   */
  constructor(e) {
    super(e);
  }
  /**
   * Extracts the model reference from the frame state and then
   * updates the uniform value depending on the scope.
   *
   * @param {NodeFrame} frame - The current node frame.
   */
  update(e) {
    this.object3d = e.object, super.update(e);
  }
}
const pZ = /* @__PURE__ */ st(jo, jo.DIRECTION), Vo = /* @__PURE__ */ st(jo, jo.WORLD_MATRIX), mZ = /* @__PURE__ */ st(jo, jo.POSITION), gZ = /* @__PURE__ */ st(jo, jo.SCALE), _Z = /* @__PURE__ */ st(jo, jo.VIEW_POSITION), xZ = /* @__PURE__ */ st(jo, jo.RADIUS), k6 = /* @__PURE__ */ It(new fn()).onObjectUpdate(({ object: i }, e) => e.value.getNormalMatrix(i.matrixWorld)), yZ = /* @__PURE__ */ It(new Mt()).onObjectUpdate(({ object: i }, e) => e.value.copy(i.matrixWorld).invert()), sc = /* @__PURE__ */ pe((i) => i.context.modelViewMatrix || V6).once()().toVar("modelViewMatrix"), V6 = /* @__PURE__ */ ea.mul(Vo), kb = /* @__PURE__ */ pe((i) => (i.context.isHighPrecisionModelViewMatrix = !0, It("mat4").onObjectUpdate(({ object: e, camera: t }) => e.modelViewMatrix.multiplyMatrices(t.matrixWorldInverse, e.matrixWorld)))).once()().toVar("highpModelViewMatrix"), Vb = /* @__PURE__ */ pe((i) => {
  const e = i.context.isHighPrecisionModelViewMatrix;
  return It("mat3").onObjectUpdate(({ object: t, camera: n }) => (e !== !0 && t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, t.matrixWorld), t.normalMatrix.getNormalMatrix(t.modelViewMatrix)));
}).once()().toVar("highpModelNormalViewMatrix"), V0 = /* @__PURE__ */ Jl("position", "vec3"), Vi = /* @__PURE__ */ V0.toVarying("positionLocal"), h_ = /* @__PURE__ */ V0.toVarying("positionPrevious"), tl = /* @__PURE__ */ pe((i) => Vo.mul(Vi).xyz.toVarying(i.getSubBuildProperty("v_positionWorld")), "vec3").once(["POSITION"])(), wT = /* @__PURE__ */ pe(() => Vi.transformDirection(Vo).toVarying("v_positionWorldDirection").normalize().toVar("positionWorldDirection"), "vec3").once(["POSITION"])(), tr = /* @__PURE__ */ pe((i) => i.context.setupPositionView().toVarying("v_positionView"), "vec3").once(["POSITION"])(), gi = /* @__PURE__ */ pe((i) => {
  let e;
  return i.camera.isOrthographicCamera ? e = ce(0, 0, 1) : e = tr.negate().toVarying("v_positionViewDirection").normalize(), e.toVar("positionViewDirection");
}, "vec3").once(["POSITION"])();
class vZ extends St {
  static get type() {
    return "FrontFacingNode";
  }
  /**
   * Constructs a new front facing node.
   */
  constructor() {
    super("bool"), this.isFrontFacingNode = !0;
  }
  generate(e) {
    if (e.shaderStage !== "fragment") return "true";
    const { material: t } = e;
    return t.side === si ? "false" : e.getFrontFacing();
  }
}
const G6 = /* @__PURE__ */ st(vZ), MT = /* @__PURE__ */ J(G6).mul(2).sub(1), hA = /* @__PURE__ */ pe(([i], { material: e }) => {
  const t = e.side;
  return t === si ? i = i.mul(-1) : t === er && (i = i.mul(MT)), i;
}), V2 = /* @__PURE__ */ Jl("normal", "vec3"), oo = /* @__PURE__ */ pe((i) => i.geometry.hasAttribute("normal") === !1 ? (Me('TSL: Vertex attribute "normal" not found on geometry.'), ce(0, 1, 0)) : V2, "vec3").once()().toVar("normalLocal"), z6 = /* @__PURE__ */ tr.dFdx().cross(tr.dFdy()).normalize().toVar("normalFlat"), Yf = /* @__PURE__ */ pe((i) => {
  let e;
  return i.material.flatShading === !0 ? e = z6 : e = ET(oo).toVarying("v_normalViewGeometry").normalize(), e;
}, "vec3").once()().toVar("normalViewGeometry"), q6 = /* @__PURE__ */ pe((i) => {
  let e = Yf.transformDirection(ea);
  return i.material.flatShading !== !0 && (e = e.toVarying("v_normalWorldGeometry")), e.normalize().toVar("normalWorldGeometry");
}, "vec3").once()(), Gn = /* @__PURE__ */ pe(({ subBuildFn: i, material: e, context: t }) => {
  let n;
  return i === "NORMAL" || i === "VERTEX" ? (n = Yf, e.flatShading !== !0 && (n = hA(n))) : n = t.setupNormal().context({ getUV: null }), n;
}, "vec3").once(["NORMAL", "VERTEX"])().toVar("normalView"), oc = /* @__PURE__ */ Gn.transformDirection(ea).toVar("normalWorld"), ih = /* @__PURE__ */ pe(({ subBuildFn: i, context: e }) => {
  let t;
  return i === "NORMAL" || i === "VERTEX" ? t = Gn : t = e.setupClearcoatNormal().context({ getUV: null }), t;
}, "vec3").once(["NORMAL", "VERTEX"])().toVar("clearcoatNormalView"), H6 = /* @__PURE__ */ pe(([i, e = Vo]) => {
  const t = Kr(e), n = i.div(ce(t[0].dot(t[0]), t[1].dot(t[1]), t[2].dot(t[2])));
  return t.mul(n).xyz;
}), ET = /* @__PURE__ */ pe(([i], e) => {
  const t = e.context.modelNormalViewMatrix;
  if (t)
    return t.transformDirection(i);
  const n = k6.mul(i);
  return ea.transformDirection(n);
}), bZ = pe(() => (Me('TSL: "transformedNormalView" is deprecated. Use "normalView" instead.'), Gn)).once(["NORMAL", "VERTEX"])(), SZ = pe(() => (Me('TSL: "transformedNormalWorld" is deprecated. Use "normalWorld" instead.'), oc)).once(["NORMAL", "VERTEX"])(), TZ = pe(() => (Me('TSL: "transformedClearcoatNormalView" is deprecated. Use "clearcoatNormalView" instead.'), ih)).once(["NORMAL", "VERTEX"])(), SR = /* @__PURE__ */ new Ir(), Hy = /* @__PURE__ */ new Mt(), W6 = /* @__PURE__ */ It(0).onReference(({ material: i }) => i).onObjectUpdate(({ material: i }) => i.refractionRatio), r1 = /* @__PURE__ */ It(1).onReference(({ material: i }) => i).onObjectUpdate(function({ material: i, scene: e }) {
  return i.envMap ? i.envMapIntensity : e.environmentIntensity;
}), RT = /* @__PURE__ */ It(new Mt()).onReference(function(i) {
  return i.material;
}).onObjectUpdate(function({ material: i, scene: e }) {
  const t = e.environment !== null && i.envMap === null ? e.environmentRotation : i.envMapRotation;
  return t ? (SR.copy(t), Hy.makeRotationFromEuler(SR)) : Hy.identity(), Hy;
}), $6 = /* @__PURE__ */ gi.negate().reflect(Gn), j6 = /* @__PURE__ */ gi.negate().refract(Gn, W6), X6 = /* @__PURE__ */ $6.transformDirection(ea).toVar("reflectVector"), Y6 = /* @__PURE__ */ j6.transformDirection(ea).toVar("reflectVector"), Q6 = /* @__PURE__ */ new Ju();
class wZ extends sl {
  static get type() {
    return "CubeTextureNode";
  }
  /**
   * Constructs a new cube texture node.
   *
   * @param {CubeTexture} value - The cube texture.
   * @param {?Node<vec3>} [uvNode=null] - The uv node.
   * @param {?Node<int>} [levelNode=null] - The level node.
   * @param {?Node<float>} [biasNode=null] - The bias node.
   */
  constructor(e, t = null, n = null, r = null) {
    super(e, t, n, r), this.isCubeTextureNode = !0;
  }
  /**
   * Overwrites the default implementation to return the appropriate cube texture type.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The input type.
   */
  getInputType() {
    return this.value.isDepthTexture === !0 ? "cubeDepthTexture" : "cubeTexture";
  }
  /**
   * Returns a default uvs based on the mapping type of the cube texture.
   *
   * @return {Node<vec3>} The default uv attribute.
   */
  getDefaultUV() {
    const e = this.value;
    return e.mapping === no ? X6 : e.mapping === qo ? Y6 : (Ie('CubeTextureNode: Mapping "%s" not supported.', e.mapping), ce(0, 0, 0));
  }
  /**
   * Overwritten with an empty implementation since the `updateMatrix` flag is ignored
   * for cube textures. The uv transformation matrix is not applied to cube textures.
   *
   * @param {boolean} value - The update toggle.
   */
  setUpdateMatrix() {
  }
  // Ignore .updateMatrix for CubeTextureNode
  /**
   * Setups the uv node. Depending on the backend as well as the texture type, it might be necessary
   * to modify the uv node for correct sampling.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {Node} uvNode - The uv node to setup.
   * @return {Node} The updated uv node.
   */
  setupUV(e, t) {
    const n = this.value;
    return n.isDepthTexture === !0 ? e.renderer.coordinateSystem === io ? ce(t.x, t.y.negate(), t.z) : t : ((e.renderer.coordinateSystem === io || !n.isRenderTargetTexture) && (t = ce(t.x.negate(), t.yz)), RT.mul(t));
  }
  /**
   * Generates the uv code snippet.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {Node} cubeUV - The uv node to generate code for.
   * @return {string} The generated code snippet.
   */
  generateUV(e, t) {
    return t.build(e, this.sampler === !0 ? "vec3" : "ivec3");
  }
}
const CT = /* @__PURE__ */ on(wZ).setParameterLength(1, 4).setName("cubeTexture"), Is = (i = Q6, e = null, t = null, n = null) => {
  let r;
  return i && i.isCubeTextureNode === !0 ? (r = ut(i.clone()), r.referenceNode = i, e !== null && (r.uvNode = ut(e)), t !== null && (r.levelNode = ut(t)), n !== null && (r.biasNode = ut(n))) : r = CT(i, e, t, n), r;
}, MZ = (i = Q6) => CT(i);
class EZ extends sd {
  static get type() {
    return "ReferenceElementNode";
  }
  /**
   * Constructs a new reference element node.
   *
   * @param {?ReferenceNode} referenceNode - The reference node.
   * @param {Node} indexNode - The index node that defines the element access.
   */
  constructor(e, t) {
    super(e, t), this.referenceNode = e, this.isReferenceElementNode = !0;
  }
  /**
   * This method is overwritten since the node type is inferred from
   * the uniform type of the reference node.
   *
   * @return {string} The node type.
   */
  getNodeType() {
    return this.referenceNode.uniformType;
  }
  generate(e) {
    const t = super.generate(e), n = this.referenceNode.getNodeType(), r = this.getNodeType();
    return e.format(t, n, r);
  }
}
class G2 extends St {
  static get type() {
    return "ReferenceNode";
  }
  /**
   * Constructs a new reference node.
   *
   * @param {string} property - The name of the property the node refers to.
   * @param {string} uniformType - The uniform type that should be used to represent the property value.
   * @param {?Object} [object=null] - The object the property belongs to.
   * @param {?number} [count=null] - When the linked property is an array-like, this parameter defines its length.
   */
  constructor(e, t, n = null, r = null) {
    super(), this.property = e, this.uniformType = t, this.object = n, this.count = r, this.properties = e.split("."), this.reference = n, this.node = null, this.group = null, this.name = null, this.updateType = hn.OBJECT;
  }
  /**
   * When the referred property is array-like, this method can be used
   * to access elements via an index node.
   *
   * @param {IndexNode} indexNode - indexNode.
   * @return {ReferenceElementNode} A reference to an element.
   */
  element(e) {
    return new EZ(this, ut(e));
  }
  /**
   * Sets the uniform group for this reference node.
   *
   * @param {UniformGroupNode} group - The uniform group to set.
   * @return {ReferenceNode} A reference to this node.
   */
  setGroup(e) {
    return this.group = e, this;
  }
  /**
   * Sets the name for the internal uniform.
   *
   * @param {string} name - The label to set.
   * @return {ReferenceNode} A reference to this node.
   */
  setName(e) {
    return this.name = e, this;
  }
  /**
   * Sets the label for the internal uniform.
   *
   * @deprecated
   * @param {string} name - The label to set.
   * @return {ReferenceNode} A reference to this node.
   */
  label(e) {
    return Me('TSL: "label()" has been deprecated. Use "setName()" instead.'), this.setName(e);
  }
  /**
   * Sets the node type which automatically defines the internal
   * uniform type.
   *
   * @param {string} uniformType - The type to set.
   */
  setNodeType(e) {
    let t = null;
    this.count !== null ? t = k0(null, e, this.count) : Array.isArray(this.getValueFromReference()) ? t = hs(null, e) : e === "texture" ? t = Wn(null) : e === "cubeTexture" ? t = Is(null) : t = It(null, e), this.group !== null && t.setGroup(this.group), this.name !== null && t.setName(this.name), this.node = t;
  }
  /**
   * This method is overwritten since the node type is inferred from
   * the type of the reference node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(e) {
    return this.node === null && (this.updateReference(e), this.updateValue()), this.node.getNodeType(e);
  }
  /**
   * Returns the property value from the given referred object.
   *
   * @param {Object} [object=this.reference] - The object to retrieve the property value from.
   * @return {any} The value.
   */
  getValueFromReference(e = this.reference) {
    const { properties: t } = this;
    let n = e[t[0]];
    for (let r = 1; r < t.length; r++)
      n = n[t[r]];
    return n;
  }
  /**
   * Allows to update the reference based on the given state. The state is only
   * evaluated {@link ReferenceNode#object} is not set.
   *
   * @param {(NodeFrame|NodeBuilder)} state - The current state.
   * @return {Object} The updated reference.
   */
  updateReference(e) {
    return this.reference = this.object !== null ? this.object : e.object, this.reference;
  }
  /**
   * The output of the reference node is the internal uniform node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {UniformNode} The output node.
   */
  setup() {
    return this.updateValue(), this.node;
  }
  /**
   * Overwritten to update the internal uniform value.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  update() {
    this.updateValue();
  }
  /**
   * Retrieves the value from the referred object property and uses it
   * to updated the internal uniform.
   */
  updateValue() {
    this.node === null && this.setNodeType(this.uniformType);
    const e = this.getValueFromReference();
    Array.isArray(e) ? this.node.array = e : this.node.value = e;
  }
}
const ui = (i, e, t) => new G2(i, e, t), Gb = (i, e, t, n) => new G2(i, e, n, t);
class RZ extends G2 {
  static get type() {
    return "MaterialReferenceNode";
  }
  /**
   * Constructs a new material reference node.
   *
   * @param {string} property - The name of the property the node refers to.
   * @param {string} inputType - The uniform type that should be used to represent the property value.
   * @param {?Material} [material=null] - The material the property belongs to. When no material is set,
   * the node refers to the material of the current rendered object.
   */
  constructor(e, t, n = null) {
    super(e, t, n), this.material = n, this.isMaterialReferenceNode = !0;
  }
  /**
   * Updates the reference based on the given state. The state is only evaluated
   * {@link MaterialReferenceNode#material} is not set.
   *
   * @param {(NodeFrame|NodeBuilder)} state - The current state.
   * @return {Object} The updated reference.
   */
  updateReference(e) {
    return this.reference = this.material !== null ? this.material : e.material, this.reference;
  }
}
const wl = (i, e, t = null) => new RZ(i, e, t), K6 = hi(), CZ = tr.dFdx(), PZ = tr.dFdy(), Z6 = K6.dFdx(), J6 = K6.dFdy(), eD = Gn, tD = PZ.cross(eD), nD = eD.cross(CZ), zb = tD.mul(Z6.x).add(nD.mul(J6.x)), qb = tD.mul(Z6.y).add(nD.mul(J6.y)), TR = zb.dot(zb).max(qb.dot(qb)), iD = TR.equal(0).select(0, TR.inverseSqrt()), NZ = /* @__PURE__ */ zb.mul(iD).toVar("tangentViewFrame"), DZ = /* @__PURE__ */ qb.mul(iD).toVar("bitangentViewFrame"), z2 = /* @__PURE__ */ Jl("tangent", "vec4"), G0 = /* @__PURE__ */ z2.xyz.toVar("tangentLocal"), q2 = /* @__PURE__ */ pe(({ subBuildFn: i, geometry: e, material: t }) => {
  let n;
  return i === "VERTEX" || e.hasAttribute("tangent") ? n = sc.mul(Gt(G0, 0)).xyz.toVarying("v_tangentView").normalize() : n = NZ, t.flatShading !== !0 && (n = hA(n)), n;
}, "vec3").once(["NORMAL", "VERTEX"])().toVar("tangentView"), rD = /* @__PURE__ */ q2.transformDirection(ea).toVarying("v_tangentWorld").normalize().toVar("tangentWorld"), H2 = /* @__PURE__ */ pe(([i, e], { subBuildFn: t, material: n }) => {
  let r = i.mul(z2.w).xyz;
  return t === "NORMAL" && n.flatShading !== !0 && (r = r.toVarying(e)), r;
}).once(["NORMAL"]), LZ = /* @__PURE__ */ H2(V2.cross(z2), "v_bitangentGeometry").normalize().toVar("bitangentGeometry"), IZ = /* @__PURE__ */ H2(oo.cross(G0), "v_bitangentLocal").normalize().toVar("bitangentLocal"), sD = /* @__PURE__ */ pe(({ subBuildFn: i, geometry: e, material: t }) => {
  let n;
  return i === "VERTEX" || e.hasAttribute("tangent") ? n = H2(Gn.cross(q2), "v_bitangentView").normalize() : n = DZ, t.flatShading !== !0 && (n = hA(n)), n;
}, "vec3").once(["NORMAL", "VERTEX"])().toVar("bitangentView"), BZ = /* @__PURE__ */ H2(oc.cross(rD), "v_bitangentWorld").normalize().toVar("bitangentWorld"), rh = /* @__PURE__ */ Kr(q2, sD, Gn).toVar("TBNViewMatrix"), oD = /* @__PURE__ */ gi.mul(rh), FZ = (i, e) => i.sub(oD.mul(e)), aD = /* @__PURE__ */ pe(() => {
  let i = hh.cross(gi);
  return i = i.cross(hh).normalize(), i = Bn(i, Gn, Mu.mul(Ha.oneMinus()).oneMinus().pow2().pow2()).normalize(), i;
}).once()(), lD = (i) => ut(i).mul(0.5).add(0.5), UZ = (i) => ut(i).mul(2).sub(1), Hb = (i) => ce(i, ps(U2(J(1).sub($o(i, i)))));
class OZ extends Hi {
  static get type() {
    return "NormalMapNode";
  }
  /**
   * Constructs a new normal map node.
   *
   * @param {Node<vec3>} node - Represents the normal map data.
   * @param {?Node<vec2>} [scaleNode=null] - Controls the intensity of the effect.
   */
  constructor(e, t = null) {
    super("vec3"), this.node = e, this.scaleNode = t, this.normalMapType = xa, this.unpackNormalMode = $g;
  }
  setup({ material: e }) {
    const { normalMapType: t, scaleNode: n, unpackNormalMode: r } = this;
    let s = this.node.mul(2).sub(1);
    if (t === xa ? r === E3 ? s = Hb(s.xy) : r === C5 ? s = Hb(s.yw) : r !== $g && console.error(`THREE.NodeMaterial: Unexpected unpack normal mode: ${r}`) : r !== $g && console.error(`THREE.NodeMaterial: Normal map type '${t}' is not compatible with unpack normal mode '${r}'`), n !== null) {
      let a = n;
      e.flatShading === !0 && (a = hA(a)), s = ce(s.xy.mul(a), s.z);
    }
    let o = null;
    return t === M3 ? o = ET(s) : t === xa ? o = rh.mul(s).normalize() : (Ie(`NodeMaterial: Unsupported normal map type: ${t}`), o = Gn), o;
  }
}
const Wb = /* @__PURE__ */ on(OZ).setParameterLength(1, 2), kZ = pe(({ textureNode: i, bumpScale: e }) => {
  const t = (r) => i.isolate().context({ getUV: (s) => r(s.uvNode || hi()), forceUVContext: !0 }), n = J(t((r) => r));
  return Xe(
    J(t((r) => r.add(r.dFdx()))).sub(n),
    J(t((r) => r.add(r.dFdy()))).sub(n)
  ).mul(e);
}), VZ = pe((i) => {
  const { surf_pos: e, surf_norm: t, dHdxy: n } = i, r = e.dFdx().normalize(), s = e.dFdy().normalize(), o = t, a = s.cross(o), l = o.cross(r), u = r.dot(a).mul(MT), c = u.sign().mul(n.x.mul(a).add(n.y.mul(l)));
  return u.abs().mul(t).sub(c).normalize();
});
class GZ extends Hi {
  static get type() {
    return "BumpMapNode";
  }
  /**
   * Constructs a new bump map node.
   *
   * @param {Node<float>} textureNode - Represents the bump map data.
   * @param {?Node<float>} [scaleNode=null] - Controls the intensity of the bump effect.
   */
  constructor(e, t = null) {
    super("vec3"), this.textureNode = e, this.scaleNode = t;
  }
  setup() {
    const e = this.scaleNode !== null ? this.scaleNode : 1, t = kZ({ textureNode: this.textureNode, bumpScale: e });
    return VZ({
      surf_pos: tr,
      surf_norm: Gn,
      dHdxy: t
    });
  }
}
const PT = /* @__PURE__ */ on(GZ).setParameterLength(1, 2), wR = /* @__PURE__ */ new Map();
class Ue extends St {
  static get type() {
    return "MaterialNode";
  }
  /**
   * Constructs a new material node.
   *
   * @param {string} scope - The scope defines what kind of material property is referred by the node.
   */
  constructor(e) {
    super(), this.scope = e;
  }
  /**
   * Returns a cached reference node for the given property and type.
   *
   * @param {string} property - The name of the material property.
   * @param {string} type - The uniform type of the property.
   * @return {MaterialReferenceNode} A material reference node representing the property access.
   */
  getCache(e, t) {
    let n = wR.get(e);
    return n === void 0 && (n = wl(e, t), wR.set(e, n)), n;
  }
  /**
   * Returns a float-typed material reference node for the given property name.
   *
   * @param {string} property - The name of the material property.
   * @return {MaterialReferenceNode<float>} A material reference node representing the property access.
   */
  getFloat(e) {
    return this.getCache(e, "float");
  }
  /**
   * Returns a color-typed material reference node for the given property name.
   *
   * @param {string} property - The name of the material property.
   * @return {MaterialReferenceNode<color>} A material reference node representing the property access.
   */
  getColor(e) {
    return this.getCache(e, "color");
  }
  /**
   * Returns a texture-typed material reference node for the given property name.
   *
   * @param {string} property - The name of the material property.
   * @return {MaterialReferenceNode} A material reference node representing the property access.
   */
  getTexture(e) {
    return this.getCache(e === "map" ? "map" : e + "Map", "texture");
  }
  /**
   * The node setup is done depending on the selected scope. Multiple material properties
   * might be grouped into a single node composition if they logically belong together.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node} The node representing the selected scope.
   */
  setup(e) {
    const t = e.context.material, n = this.scope;
    let r = null;
    if (n === Ue.COLOR) {
      const s = t.color !== void 0 ? this.getColor(n) : ce();
      t.map && t.map.isTexture === !0 ? r = s.mul(this.getTexture("map")) : r = s;
    } else if (n === Ue.OPACITY) {
      const s = this.getFloat(n);
      t.alphaMap && t.alphaMap.isTexture === !0 ? r = s.mul(this.getTexture("alpha")) : r = s;
    } else if (n === Ue.SPECULAR_STRENGTH)
      t.specularMap && t.specularMap.isTexture === !0 ? r = this.getTexture("specular").r : r = J(1);
    else if (n === Ue.SPECULAR_INTENSITY) {
      const s = this.getFloat(n);
      t.specularIntensityMap && t.specularIntensityMap.isTexture === !0 ? r = s.mul(this.getTexture(n).a) : r = s;
    } else if (n === Ue.SPECULAR_COLOR) {
      const s = this.getColor(n);
      t.specularColorMap && t.specularColorMap.isTexture === !0 ? r = s.mul(this.getTexture(n).rgb) : r = s;
    } else if (n === Ue.ROUGHNESS) {
      const s = this.getFloat(n);
      t.roughnessMap && t.roughnessMap.isTexture === !0 ? r = s.mul(this.getTexture(n).g) : r = s;
    } else if (n === Ue.METALNESS) {
      const s = this.getFloat(n);
      t.metalnessMap && t.metalnessMap.isTexture === !0 ? r = s.mul(this.getTexture(n).b) : r = s;
    } else if (n === Ue.EMISSIVE) {
      const s = this.getFloat("emissiveIntensity"), o = this.getColor(n).mul(s);
      t.emissiveMap && t.emissiveMap.isTexture === !0 ? r = o.mul(this.getTexture(n)) : r = o;
    } else if (n === Ue.NORMAL)
      t.normalMap ? (r = Wb(this.getTexture("normal"), this.getCache("normalScale", "vec2")), r.normalMapType = t.normalMapType, (t.normalMap.format == fs || t.normalMap.format == Hu || t.normalMap.format == qu) && (r.unpackNormalMode = E3)) : t.bumpMap ? r = PT(this.getTexture("bump").r, this.getFloat("bumpScale")) : r = Gn;
    else if (n === Ue.CLEARCOAT) {
      const s = this.getFloat(n);
      t.clearcoatMap && t.clearcoatMap.isTexture === !0 ? r = s.mul(this.getTexture(n).r) : r = s;
    } else if (n === Ue.CLEARCOAT_ROUGHNESS) {
      const s = this.getFloat(n);
      t.clearcoatRoughnessMap && t.clearcoatRoughnessMap.isTexture === !0 ? r = s.mul(this.getTexture(n).r) : r = s;
    } else if (n === Ue.CLEARCOAT_NORMAL)
      t.clearcoatNormalMap ? r = Wb(this.getTexture(n), this.getCache(n + "Scale", "vec2")) : r = Gn;
    else if (n === Ue.SHEEN) {
      const s = this.getColor("sheenColor").mul(this.getFloat("sheen"));
      t.sheenColorMap && t.sheenColorMap.isTexture === !0 ? r = s.mul(this.getTexture("sheenColor").rgb) : r = s;
    } else if (n === Ue.SHEEN_ROUGHNESS) {
      const s = this.getFloat(n);
      t.sheenRoughnessMap && t.sheenRoughnessMap.isTexture === !0 ? r = s.mul(this.getTexture(n).a) : r = s, r = r.clamp(1e-4, 1);
    } else if (n === Ue.ANISOTROPY)
      if (t.anisotropyMap && t.anisotropyMap.isTexture === !0) {
        const s = this.getTexture(n);
        r = P2(sf.x, sf.y, sf.y.negate(), sf.x).mul(s.rg.mul(2).sub(Xe(1)).normalize().mul(s.b));
      } else
        r = sf;
    else if (n === Ue.IRIDESCENCE_THICKNESS) {
      const s = ui("1", "float", t.iridescenceThicknessRange);
      if (t.iridescenceThicknessMap) {
        const o = ui("0", "float", t.iridescenceThicknessRange);
        r = s.sub(o).mul(this.getTexture(n).g).add(o);
      } else
        r = s;
    } else if (n === Ue.TRANSMISSION) {
      const s = this.getFloat(n);
      t.transmissionMap ? r = s.mul(this.getTexture(n).r) : r = s;
    } else if (n === Ue.THICKNESS) {
      const s = this.getFloat(n);
      t.thicknessMap ? r = s.mul(this.getTexture(n).g) : r = s;
    } else if (n === Ue.IOR)
      r = this.getFloat(n);
    else if (n === Ue.LIGHT_MAP)
      r = this.getTexture(n).rgb.mul(this.getFloat("lightMapIntensity"));
    else if (n === Ue.AO)
      r = this.getTexture(n).r.sub(1).mul(this.getFloat("aoMapIntensity")).add(1);
    else if (n === Ue.LINE_DASH_OFFSET)
      r = t.dashOffset ? this.getFloat(n) : J(0);
    else {
      const s = this.getNodeType(e);
      r = this.getCache(n, s);
    }
    return r;
  }
}
Ue.ALPHA_TEST = "alphaTest";
Ue.COLOR = "color";
Ue.OPACITY = "opacity";
Ue.SHININESS = "shininess";
Ue.SPECULAR = "specular";
Ue.SPECULAR_STRENGTH = "specularStrength";
Ue.SPECULAR_INTENSITY = "specularIntensity";
Ue.SPECULAR_COLOR = "specularColor";
Ue.REFLECTIVITY = "reflectivity";
Ue.ROUGHNESS = "roughness";
Ue.METALNESS = "metalness";
Ue.NORMAL = "normal";
Ue.CLEARCOAT = "clearcoat";
Ue.CLEARCOAT_ROUGHNESS = "clearcoatRoughness";
Ue.CLEARCOAT_NORMAL = "clearcoatNormal";
Ue.EMISSIVE = "emissive";
Ue.ROTATION = "rotation";
Ue.SHEEN = "sheen";
Ue.SHEEN_ROUGHNESS = "sheenRoughness";
Ue.ANISOTROPY = "anisotropy";
Ue.IRIDESCENCE = "iridescence";
Ue.IRIDESCENCE_IOR = "iridescenceIOR";
Ue.IRIDESCENCE_THICKNESS = "iridescenceThickness";
Ue.IOR = "ior";
Ue.TRANSMISSION = "transmission";
Ue.THICKNESS = "thickness";
Ue.ATTENUATION_DISTANCE = "attenuationDistance";
Ue.ATTENUATION_COLOR = "attenuationColor";
Ue.LINE_SCALE = "scale";
Ue.LINE_DASH_SIZE = "dashSize";
Ue.LINE_GAP_SIZE = "gapSize";
Ue.LINE_WIDTH = "linewidth";
Ue.LINE_DASH_OFFSET = "dashOffset";
Ue.POINT_SIZE = "size";
Ue.DISPERSION = "dispersion";
Ue.LIGHT_MAP = "light";
Ue.AO = "ao";
const uD = /* @__PURE__ */ st(Ue, Ue.ALPHA_TEST), cD = /* @__PURE__ */ st(Ue, Ue.COLOR), hD = /* @__PURE__ */ st(Ue, Ue.SHININESS), dD = /* @__PURE__ */ st(Ue, Ue.EMISSIVE), NT = /* @__PURE__ */ st(Ue, Ue.OPACITY), fD = /* @__PURE__ */ st(Ue, Ue.SPECULAR), $b = /* @__PURE__ */ st(Ue, Ue.SPECULAR_INTENSITY), AD = /* @__PURE__ */ st(Ue, Ue.SPECULAR_COLOR), Dp = /* @__PURE__ */ st(Ue, Ue.SPECULAR_STRENGTH), s1 = /* @__PURE__ */ st(Ue, Ue.REFLECTIVITY), pD = /* @__PURE__ */ st(Ue, Ue.ROUGHNESS), mD = /* @__PURE__ */ st(Ue, Ue.METALNESS), gD = /* @__PURE__ */ st(Ue, Ue.NORMAL), _D = /* @__PURE__ */ st(Ue, Ue.CLEARCOAT), xD = /* @__PURE__ */ st(Ue, Ue.CLEARCOAT_ROUGHNESS), yD = /* @__PURE__ */ st(Ue, Ue.CLEARCOAT_NORMAL), vD = /* @__PURE__ */ st(Ue, Ue.ROTATION), bD = /* @__PURE__ */ st(Ue, Ue.SHEEN), SD = /* @__PURE__ */ st(Ue, Ue.SHEEN_ROUGHNESS), TD = /* @__PURE__ */ st(Ue, Ue.ANISOTROPY), wD = /* @__PURE__ */ st(Ue, Ue.IRIDESCENCE), MD = /* @__PURE__ */ st(Ue, Ue.IRIDESCENCE_IOR), ED = /* @__PURE__ */ st(Ue, Ue.IRIDESCENCE_THICKNESS), RD = /* @__PURE__ */ st(Ue, Ue.TRANSMISSION), CD = /* @__PURE__ */ st(Ue, Ue.THICKNESS), PD = /* @__PURE__ */ st(Ue, Ue.IOR), ND = /* @__PURE__ */ st(Ue, Ue.ATTENUATION_DISTANCE), DD = /* @__PURE__ */ st(Ue, Ue.ATTENUATION_COLOR), LD = /* @__PURE__ */ st(Ue, Ue.LINE_SCALE), ID = /* @__PURE__ */ st(Ue, Ue.LINE_DASH_SIZE), BD = /* @__PURE__ */ st(Ue, Ue.LINE_GAP_SIZE), zZ = /* @__PURE__ */ st(Ue, Ue.LINE_WIDTH), FD = /* @__PURE__ */ st(Ue, Ue.LINE_DASH_OFFSET), UD = /* @__PURE__ */ st(Ue, Ue.POINT_SIZE), OD = /* @__PURE__ */ st(Ue, Ue.DISPERSION), DT = /* @__PURE__ */ st(Ue, Ue.LIGHT_MAP), kD = /* @__PURE__ */ st(Ue, Ue.AO), sf = /* @__PURE__ */ It(new Le()).onReference(function(i) {
  return i.material;
}).onRenderUpdate(function({ material: i }) {
  this.value.set(i.anisotropy * Math.cos(i.anisotropyRotation), i.anisotropy * Math.sin(i.anisotropyRotation));
}), VD = /* @__PURE__ */ pe((i) => i.context.setupModelViewProjection(), "vec4").once()().toVarying("v_modelViewProjection");
class qZ extends sd {
  static get type() {
    return "StorageArrayElementNode";
  }
  /**
   * Constructs storage buffer element node.
   *
   * @param {StorageBufferNode} storageBufferNode - The storage buffer node.
   * @param {Node} indexNode - The index node that defines the element access.
   */
  constructor(e, t) {
    super(e, t), this.isStorageArrayElementNode = !0;
  }
  /**
   * The storage buffer node.
   *
   * @param {Node} value
   * @type {StorageBufferNode}
   */
  set storageBufferNode(e) {
    this.node = e;
  }
  get storageBufferNode() {
    return this.node;
  }
  getMemberType(e, t) {
    const n = this.storageBufferNode.structTypeNode;
    return n ? n.getMemberType(e, t) : "void";
  }
  setup(e) {
    return e.isAvailable("storageBuffer") === !1 && this.node.isPBO === !0 && e.setupPBO(this.node), super.setup(e);
  }
  generate(e, t) {
    let n;
    const r = e.context.assign;
    if (e.isAvailable("storageBuffer") === !1 ? this.node.isPBO === !0 && r !== !0 && (this.node.value.isInstancedBufferAttribute || e.shaderStage !== "compute") ? n = e.generatePBO(this) : n = this.node.build(e) : n = super.generate(e), r !== !0) {
      const s = this.getNodeType(e);
      n = e.format(n, s, t);
    }
    return n;
  }
}
const HZ = /* @__PURE__ */ on(qZ).setParameterLength(2);
class WZ extends bT {
  static get type() {
    return "StorageBufferNode";
  }
  /**
   * Constructs a new storage buffer node.
   *
   * @param {StorageBufferAttribute|StorageInstancedBufferAttribute|BufferAttribute} value - The buffer data.
   * @param {?(string|Struct)} [bufferType=null] - The buffer type (e.g. `'vec3'`).
   * @param {number} [bufferCount=0] - The buffer count.
   */
  constructor(e, t = null, n = 0) {
    let r, s = null;
    t && t.isStruct ? (r = "struct", s = t.layout, (e.isStorageBufferAttribute || e.isStorageInstancedBufferAttribute) && (n = e.count)) : t === null && (e.isStorageBufferAttribute || e.isStorageInstancedBufferAttribute) ? (r = QP(e.itemSize), n = e.count) : r = t, super(e, r, n), this.isStorageBufferNode = !0, this.structTypeNode = s, this.access = Xr.READ_WRITE, this.isAtomic = !1, this.isPBO = !1, this._attribute = null, this._varying = null, this.global = !0, e.isStorageBufferAttribute !== !0 && e.isStorageInstancedBufferAttribute !== !0 && (e.isInstancedBufferAttribute ? e.isStorageInstancedBufferAttribute = !0 : e.isStorageBufferAttribute = !0);
  }
  /**
   * This method is overwritten since the buffer data might be shared
   * and thus the hash should be shared as well.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The hash.
   */
  getHash(e) {
    if (this.bufferCount === 0) {
      let t = e.globalCache.getData(this.value);
      return t === void 0 && (t = {
        node: this
      }, e.globalCache.setData(this.value, t)), t.node.uuid;
    }
    return this.uuid;
  }
  /**
   * Overwrites the default implementation to return a fixed value `'indirectStorageBuffer'` or `'storageBuffer'`.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The input type.
   */
  getInputType() {
    return this.value.isIndirectStorageBufferAttribute ? "indirectStorageBuffer" : "storageBuffer";
  }
  /**
   * Enables element access with the given index node.
   *
   * @param {IndexNode} indexNode - The index node.
   * @return {StorageArrayElementNode} A node representing the element access.
   */
  element(e) {
    return HZ(this, e);
  }
  /**
   * Defines whether this node is a PBO or not. Only relevant for WebGL.
   *
   * @param {boolean} value - The value so set.
   * @return {StorageBufferNode} A reference to this node.
   */
  setPBO(e) {
    return this.isPBO = e, this;
  }
  /**
   * Returns the `isPBO` value.
   *
   * @return {boolean} Whether the node represents a PBO or not.
   */
  getPBO() {
    return this.isPBO;
  }
  /**
   * Defines the node access.
   *
   * @param {string} value - The node access.
   * @return {StorageBufferNode} A reference to this node.
   */
  setAccess(e) {
    return this.access = e, this;
  }
  /**
   * Convenience method for configuring a read-only node access.
   *
   * @return {StorageBufferNode} A reference to this node.
   */
  toReadOnly() {
    return this.setAccess(Xr.READ_ONLY);
  }
  /**
   * Defines whether the node is atomic or not.
   *
   * @param {boolean} value - The atomic flag.
   * @return {StorageBufferNode} A reference to this node.
   */
  setAtomic(e) {
    return this.isAtomic = e, this;
  }
  /**
   * Convenience method for making this node atomic.
   *
   * @return {StorageBufferNode} A reference to this node.
   */
  toAtomic() {
    return this.setAtomic(!0);
  }
  /**
   * Returns attribute data for this storage buffer node.
   *
   * @return {{attribute: BufferAttributeNode, varying: VaryingNode}} The attribute data.
   */
  getAttributeData() {
    return this._attribute === null && (this._attribute = _T(this.value), this._varying = cl(this._attribute)), {
      attribute: this._attribute,
      varying: this._varying
    };
  }
  /**
   * This method is overwritten since the node type from the availability of storage buffers
   * and the attribute data.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(e) {
    if (this.structTypeNode !== null)
      return this.structTypeNode.getNodeType(e);
    if (e.isAvailable("storageBuffer") || e.isAvailable("indirectStorageBuffer"))
      return super.getNodeType(e);
    const { attribute: t } = this.getAttributeData();
    return t.getNodeType(e);
  }
  /**
   * Returns the type of a member of the struct.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {string} name - The name of the member.
   * @return {string} The type of the member.
   */
  getMemberType(e, t) {
    return this.structTypeNode !== null ? this.structTypeNode.getMemberType(e, t) : "void";
  }
  /**
   * Generates the code snippet of the storage buffer node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The generated code snippet.
   */
  generate(e) {
    if (this.structTypeNode !== null && this.structTypeNode.build(e), e.isAvailable("storageBuffer") || e.isAvailable("indirectStorageBuffer"))
      return super.generate(e);
    const { attribute: t, varying: n } = this.getAttributeData(), r = n.build(e);
    return e.registerTransform(r, t), r;
  }
}
const kl = (i, e = null, t = 0) => new WZ(i, e, t), $Z = (i, e, t) => (Me('TSL: "storageObject()" is deprecated. Use "storage().setPBO( true )" instead.'), kl(i, e, t).setPBO(!0));
class Di extends St {
  static get type() {
    return "IndexNode";
  }
  /**
   * Constructs a new index node.
   *
   * @param {('vertex'|'instance'|'subgroup'|'invocationLocal'|'invocationGlobal'|'invocationSubgroup'|'draw')} scope - The scope of the index node.
   */
  constructor(e) {
    super("uint"), this.scope = e, this.isIndexNode = !0;
  }
  generate(e) {
    const t = this.getNodeType(e), n = this.scope;
    let r;
    if (n === Di.VERTEX)
      r = e.getVertexIndex();
    else if (n === Di.INSTANCE)
      r = e.getInstanceIndex();
    else if (n === Di.DRAW)
      r = e.getDrawIndex();
    else if (n === Di.INVOCATION_LOCAL)
      r = e.getInvocationLocalIndex();
    else if (n === Di.INVOCATION_SUBGROUP)
      r = e.getInvocationSubgroupIndex();
    else if (n === Di.SUBGROUP)
      r = e.getSubgroupIndex();
    else
      throw new Error("THREE.IndexNode: Unknown scope: " + n);
    let s;
    return e.shaderStage === "vertex" || e.shaderStage === "compute" ? s = r : s = cl(this).build(e, t), s;
  }
}
Di.VERTEX = "vertex";
Di.INSTANCE = "instance";
Di.SUBGROUP = "subgroup";
Di.INVOCATION_LOCAL = "invocationLocal";
Di.INVOCATION_SUBGROUP = "invocationSubgroup";
Di.DRAW = "draw";
const GD = /* @__PURE__ */ st(Di, Di.VERTEX), nl = /* @__PURE__ */ st(Di, Di.INSTANCE), jZ = /* @__PURE__ */ st(Di, Di.SUBGROUP), XZ = /* @__PURE__ */ st(Di, Di.INVOCATION_SUBGROUP), YZ = /* @__PURE__ */ st(Di, Di.INVOCATION_LOCAL), zD = /* @__PURE__ */ st(Di, Di.DRAW);
class qD extends St {
  static get type() {
    return "InstanceNode";
  }
  /**
   * Constructs a new instance node.
   *
   * @param {number} count - The number of instances.
   * @param {InstancedBufferAttribute|StorageInstancedBufferAttribute} instanceMatrix - Instanced buffer attribute representing the instance transformations.
   * @param {?InstancedBufferAttribute|StorageInstancedBufferAttribute} instanceColor - Instanced buffer attribute representing the instance colors.
   */
  constructor(e, t, n = null) {
    super("void"), this.count = e, this.instanceMatrix = t, this.instanceColor = n, this.instanceMatrixNode = null, this.instanceColorNode = null, this.updateType = hn.FRAME, this.buffer = null, this.bufferColor = null;
  }
  /**
   * Tracks whether the matrix data is provided via a storage buffer.
   *
   * @type {boolean}
   */
  get isStorageMatrix() {
    const { instanceMatrix: e } = this;
    return e && e.isStorageInstancedBufferAttribute === !0;
  }
  /**
   * Tracks whether the color data is provided via a storage buffer.
   *
   * @type {boolean}
   */
  get isStorageColor() {
    const { instanceColor: e } = this;
    return e && e.isStorageInstancedBufferAttribute === !0;
  }
  /**
   * Setups the internal buffers and nodes and assigns the transformed vertex data
   * to predefined node variables for accumulation. That follows the same patterns
   * like with morph and skinning nodes.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  setup(e) {
    const { instanceMatrix: t, instanceColor: n, isStorageMatrix: r, isStorageColor: s } = this, { count: o } = t;
    let { instanceMatrixNode: a, instanceColorNode: l } = this;
    if (a === null) {
      if (r)
        a = kl(t, "mat4", Math.max(o, 1)).element(nl);
      else if (o <= 1e3)
        a = k0(t.array, "mat4", Math.max(o, 1)).element(nl);
      else {
        const c = new $p(t.array, 16, 1);
        this.buffer = c;
        const A = t.usage === Du ? Ob : c_, m = [
          A(c, "vec4", 16, 0),
          A(c, "vec4", 16, 4),
          A(c, "vec4", 16, 8),
          A(c, "vec4", 16, 12)
        ];
        a = Vu(...m);
      }
      this.instanceMatrixNode = a;
    }
    if (n && l === null) {
      if (s)
        l = kl(n, "vec3", Math.max(n.count, 1)).element(nl);
      else {
        const c = new to(n.array, 3), A = n.usage === Du ? Ob : c_;
        this.bufferColor = c, l = ce(A(c, "vec3", 3, 0));
      }
      this.instanceColorNode = l;
    }
    const u = a.mul(Vi).xyz;
    if (Vi.assign(u), e.hasGeometryAttribute("normal")) {
      const c = H6(oo, a);
      oo.assign(c);
    }
    this.instanceColorNode !== null && o0("vec3", "vInstanceColor").assign(this.instanceColorNode);
  }
  /**
   * Checks if the internal buffers require an update.
   *
   * @param {NodeFrame} frame - The current node frame.
   */
  update() {
    this.buffer !== null && this.isStorageMatrix !== !0 && (this.buffer.clearUpdateRanges(), this.buffer.updateRanges.push(...this.instanceMatrix.updateRanges), this.instanceMatrix.usage !== Du && this.instanceMatrix.version !== this.buffer.version && (this.buffer.version = this.instanceMatrix.version)), this.instanceColor && this.bufferColor !== null && this.isStorageColor !== !0 && (this.bufferColor.clearUpdateRanges(), this.bufferColor.updateRanges.push(...this.instanceColor.updateRanges), this.instanceColor.usage !== Du && this.instanceColor.version !== this.bufferColor.version && (this.bufferColor.version = this.instanceColor.version));
  }
}
const QZ = /* @__PURE__ */ on(qD).setParameterLength(2, 3);
class KZ extends qD {
  static get type() {
    return "InstancedMeshNode";
  }
  /**
   * Constructs a new instanced mesh node.
   *
   * @param {InstancedMesh} instancedMesh - The instanced mesh.
   */
  constructor(e) {
    const { count: t, instanceMatrix: n, instanceColor: r } = e;
    super(t, n, r), this.instancedMesh = e;
  }
}
const HD = /* @__PURE__ */ on(KZ).setParameterLength(1);
class ZZ extends St {
  static get type() {
    return "BatchNode";
  }
  /**
   * Constructs a new batch node.
   *
   * @param {BatchedMesh} batchMesh - A reference to batched mesh.
   */
  constructor(e) {
    super("void"), this.batchMesh = e, this.batchingIdNode = null;
  }
  /**
   * Setups the internal buffers and nodes and assigns the transformed vertex data
   * to predefined node variables for accumulation. That follows the same patterns
   * like with morph and skinning nodes.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  setup(e) {
    this.batchingIdNode === null && (e.getDrawIndex() === null ? this.batchingIdNode = nl : this.batchingIdNode = zD);
    const n = pe(([y]) => {
      const T = le(Fl($i(this.batchMesh._indirectTexture), 0).x).toConst(), b = le(y).mod(T).toConst(), S = le(y).div(T).toConst();
      return $i(this.batchMesh._indirectTexture, ur(b, S)).x;
    }).setLayout({
      name: "getIndirectIndex",
      type: "uint",
      inputs: [
        { name: "id", type: "int" }
      ]
    })(le(this.batchingIdNode)), r = this.batchMesh._matricesTexture, s = le(Fl($i(r), 0).x).toConst(), o = J(n).mul(4).toInt().toConst(), a = o.mod(s).toConst(), l = o.div(s).toConst(), u = Vu(
      $i(r, ur(a, l)),
      $i(r, ur(a.add(1), l)),
      $i(r, ur(a.add(2), l)),
      $i(r, ur(a.add(3), l))
    ), c = this.batchMesh._colorsTexture;
    if (c !== null) {
      const T = pe(([b]) => {
        const S = le(Fl($i(c), 0).x).toConst(), E = b, R = E.mod(S).toConst(), C = E.div(S).toConst();
        return $i(c, ur(R, C)).rgb;
      }).setLayout({
        name: "getBatchingColor",
        type: "vec3",
        inputs: [
          { name: "id", type: "int" }
        ]
      })(n);
      o0("vec3", "vBatchColor").assign(T);
    }
    const A = Kr(u);
    Vi.assign(u.mul(Vi));
    const m = oo.div(ce(A[0].dot(A[0]), A[1].dot(A[1]), A[2].dot(A[2]))), _ = A.mul(m).xyz;
    oo.assign(_), e.hasGeometryAttribute("tangent") && G0.mulAssign(A);
  }
}
const WD = /* @__PURE__ */ on(ZZ).setParameterLength(1), MR = /* @__PURE__ */ new WeakMap();
class $D extends St {
  static get type() {
    return "SkinningNode";
  }
  /**
   * Constructs a new skinning node.
   *
   * @param {SkinnedMesh} skinnedMesh - The skinned mesh.
   */
  constructor(e) {
    super("void"), this.skinnedMesh = e, this.updateType = hn.OBJECT, this.skinIndexNode = Jl("skinIndex", "uvec4"), this.skinWeightNode = Jl("skinWeight", "vec4"), this.bindMatrixNode = ui("bindMatrix", "mat4"), this.bindMatrixInverseNode = ui("bindMatrixInverse", "mat4"), this.boneMatricesNode = Gb("skeleton.boneMatrices", "mat4", e.skeleton.bones.length), this.positionNode = Vi, this.toPositionNode = Vi, this.previousBoneMatricesNode = null;
  }
  /**
   * Transforms the given vertex position via skinning.
   *
   * @param {Node} [boneMatrices=this.boneMatricesNode] - The bone matrices
   * @param {Node<vec3>} [position=this.positionNode] - The vertex position in local space.
   * @return {Node<vec3>} The transformed vertex position.
   */
  getSkinnedPosition(e = this.boneMatricesNode, t = this.positionNode) {
    const { skinIndexNode: n, skinWeightNode: r, bindMatrixNode: s, bindMatrixInverseNode: o } = this, a = e.element(n.x), l = e.element(n.y), u = e.element(n.z), c = e.element(n.w), A = s.mul(t), m = sr(
      a.mul(r.x).mul(A),
      l.mul(r.y).mul(A),
      u.mul(r.z).mul(A),
      c.mul(r.w).mul(A)
    );
    return o.mul(m).xyz;
  }
  /**
   * Transforms the given vertex normal via skinning.
   *
   * @param {Node} [boneMatrices=this.boneMatricesNode] - The bone matrices
   * @param {Node<vec3>} [normal=normalLocal] - The vertex normal in local space.
   * @return {Node<vec3>} The transformed vertex normal.
   */
  getSkinnedNormal(e = this.boneMatricesNode, t = oo) {
    const { skinIndexNode: n, skinWeightNode: r, bindMatrixNode: s, bindMatrixInverseNode: o } = this, a = e.element(n.x), l = e.element(n.y), u = e.element(n.z), c = e.element(n.w);
    let A = sr(
      r.x.mul(a),
      r.y.mul(l),
      r.z.mul(u),
      r.w.mul(c)
    );
    return A = o.mul(A).mul(s), A.transformDirection(t).xyz;
  }
  /**
   * Computes the transformed/skinned vertex position of the previous frame.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node<vec3>} The skinned position from the previous frame.
   */
  getPreviousSkinnedPosition(e) {
    const t = e.object;
    return this.previousBoneMatricesNode === null && (t.skeleton.previousBoneMatrices = new Float32Array(t.skeleton.boneMatrices), this.previousBoneMatricesNode = Gb("skeleton.previousBoneMatrices", "mat4", t.skeleton.bones.length)), this.getSkinnedPosition(this.previousBoneMatricesNode, h_);
  }
  /**
   * Returns `true` if bone matrices from the previous frame are required. Relevant
   * when computing motion vectors with {@link VelocityNode}.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {boolean} Whether bone matrices from the previous frame are required or not.
   */
  needsPreviousBoneMatrices(e) {
    const t = e.renderer.getMRT();
    return t && t.has("velocity") || ZP(e.object).useVelocity === !0;
  }
  /**
   * Setups the skinning node by assigning the transformed vertex data to predefined node variables.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node<vec3>} The transformed vertex position.
   */
  setup(e) {
    this.needsPreviousBoneMatrices(e) && h_.assign(this.getPreviousSkinnedPosition(e));
    const t = this.getSkinnedPosition();
    if (this.toPositionNode && this.toPositionNode.assign(t), e.hasGeometryAttribute("normal")) {
      const n = this.getSkinnedNormal();
      oo.assign(n), e.hasGeometryAttribute("tangent") && G0.assign(n);
    }
    return t;
  }
  /**
   * Generates the code snippet of the skinning node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {string} output - The current output.
   * @return {string} The generated code snippet.
   */
  generate(e, t) {
    if (t !== "void")
      return super.generate(e, t);
  }
  /**
   * Updates the state of the skinned mesh by updating the skeleton once per frame.
   *
   * @param {NodeFrame} frame - The current node frame.
   */
  update(e) {
    const t = e.object && e.object.skeleton ? e.object.skeleton : this.skinnedMesh.skeleton;
    MR.get(t) !== e.frameId && (MR.set(t, e.frameId), this.previousBoneMatricesNode !== null && (t.previousBoneMatrices === null && (t.previousBoneMatrices = new Float32Array(t.boneMatrices)), t.previousBoneMatrices.set(t.boneMatrices)), t.update());
  }
}
const jD = (i) => new $D(i), JZ = (i, e = null) => {
  const t = new $D(i);
  return t.positionNode = kl(new to(i.geometry.getAttribute("position").array, 3), "vec3").setPBO(!0).toReadOnly().element(nl).toVar(), t.skinIndexNode = kl(new to(new Uint32Array(i.geometry.getAttribute("skinIndex").array), 4), "uvec4").setPBO(!0).toReadOnly().element(nl).toVar(), t.skinWeightNode = kl(new to(i.geometry.getAttribute("skinWeight").array, 4), "vec4").setPBO(!0).toReadOnly().element(nl).toVar(), t.bindMatrixNode = It(i.bindMatrix, "mat4"), t.bindMatrixInverseNode = It(i.bindMatrixInverse, "mat4"), t.boneMatricesNode = k0(i.skeleton.boneMatrices, "mat4", i.skeleton.bones.length), t.toPositionNode = e, ut(t);
};
class eJ extends St {
  static get type() {
    return "LoopNode";
  }
  /**
   * Constructs a new loop node.
   *
   * @param {Array<any>} params - Depending on the loop type, array holds different parameterization values for the loop.
   */
  constructor(e = []) {
    super("void"), this.params = e;
  }
  /**
   * Returns a loop variable name based on an index. The pattern is
   * `0` = `i`, `1`= `j`, `2`= `k` and so on.
   *
   * @param {number} index - The index.
   * @return {string} The loop variable name.
   */
  getVarName(e) {
    return String.fromCharCode(105 + e);
  }
  /**
   * Returns properties about this node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Object} The node properties.
   */
  getProperties(e) {
    const t = e.getNodeProperties(this);
    if (t.stackNode !== void 0) return t;
    const n = {};
    for (let a = 0, l = this.params.length - 1; a < l; a++) {
      const u = this.params[a], c = u.isNode !== !0 && u.name || this.getVarName(a), A = u.isNode !== !0 && u.type || "int";
      n[c] = Zl(c, A);
    }
    const r = e.addStack(), s = this.params[this.params.length - 1](n);
    t.returnsNode = s.context({ nodeLoop: s }), t.stackNode = r;
    const o = this.params[0];
    if (o.isNode !== !0 && typeof o.update == "function") {
      const a = pe(this.params[0].update)(n);
      t.updateNode = a.context({ nodeLoop: a });
    }
    return e.removeStack(), t;
  }
  setup(e) {
    if (this.getProperties(e), e.fnCall) {
      const t = e.getDataFromNode(e.fnCall.shaderNode);
      t.hasLoop = !0;
    }
  }
  generate(e) {
    const t = this.getProperties(e), n = this.params, r = t.stackNode;
    for (let o = 0, a = n.length - 1; o < a; o++) {
      const l = n[o];
      let u = !1, c = null, A = null, m = null, _ = null, y = null, T = null;
      l.isNode ? l.getNodeType(e) === "bool" ? (u = !0, _ = "bool", A = l.build(e, _)) : (_ = "int", m = this.getVarName(o), c = "0", A = l.build(e, _), y = "<") : (_ = l.type || "int", m = l.name || this.getVarName(o), c = l.start, A = l.end, y = l.condition, T = l.update, typeof c == "number" ? c = e.generateConst(_, c) : c && c.isNode && (c = c.build(e, _)), typeof A == "number" ? A = e.generateConst(_, A) : A && A.isNode && (A = A.build(e, _)), c !== void 0 && A === void 0 ? (c = c + " - 1", A = "0", y = ">=") : A !== void 0 && c === void 0 && (c = "0", y = "<"), y === void 0 && (Number(c) > Number(A) ? y = ">=" : y = "<"));
      let b;
      if (u)
        b = `while ( ${A} )`;
      else {
        const S = { start: c, end: A }, E = S.start, R = S.end;
        let C;
        const L = () => y.includes("<") ? "+=" : "-=";
        if (T != null)
          switch (typeof T) {
            case "function":
              C = e.flowStagesNode(t.updateNode, "void").code.replace(/\t|;/g, "");
              break;
            case "number":
              C = m + " " + L() + " " + e.generateConst(_, T);
              break;
            case "string":
              C = m + " " + T;
              break;
            default:
              T.isNode ? C = m + " " + L() + " " + T.build(e) : (Ie("TSL: 'Loop( { update: ... } )' is not a function, string or number."), C = "break /* invalid update */");
          }
        else
          _ === "int" || _ === "uint" ? T = y.includes("<") ? "++" : "--" : T = L() + " 1.", C = m + " " + T;
        const D = e.getVar(_, m) + " = " + E, B = m + " " + y + " " + R;
        b = `for ( ${D}; ${B}; ${C} )`;
      }
      e.addFlowCode((o === 0 ? `
` : "") + e.tab + b + ` {

`).addFlowTab();
    }
    const s = r.build(e, "void");
    t.returnsNode.build(e, "void"), e.removeFlowTab().addFlowCode(`
` + e.tab + s);
    for (let o = 0, a = this.params.length - 1; o < a; o++)
      e.addFlowCode((o === 0 ? "" : e.tab) + `}

`).removeFlowTab();
    e.addFlowTab();
  }
}
const ri = (...i) => new eJ(ch(i, "int")).toStack(), tJ = () => Zl("continue").toStack(), XD = () => Zl("break").toStack(), Wy = /* @__PURE__ */ new WeakMap(), po = /* @__PURE__ */ new Kt(), ER = /* @__PURE__ */ pe(({ bufferMap: i, influence: e, stride: t, width: n, depth: r, offset: s }) => {
  const o = le(GD).mul(t).add(s), a = o.div(n), l = o.sub(a.mul(n));
  return $i(i, ur(l, a)).depth(r).xyz.mul(e);
});
function nJ(i) {
  const e = i.morphAttributes.position !== void 0, t = i.morphAttributes.normal !== void 0, n = i.morphAttributes.color !== void 0, r = i.morphAttributes.position || i.morphAttributes.normal || i.morphAttributes.color, s = r !== void 0 ? r.length : 0;
  let o = Wy.get(i);
  if (o === void 0 || o.count !== s) {
    let S = function() {
      T.dispose(), Wy.delete(i), i.removeEventListener("dispose", S);
    };
    o !== void 0 && o.texture.dispose();
    const a = i.morphAttributes.position || [], l = i.morphAttributes.normal || [], u = i.morphAttributes.color || [];
    let c = 0;
    e === !0 && (c = 1), t === !0 && (c = 2), n === !0 && (c = 3);
    let A = i.attributes.position.count * c, m = 1;
    const _ = 4096;
    A > _ && (m = Math.ceil(A / _), A = _);
    const y = new Float32Array(A * m * 4 * s), T = new y0(y, A, m, s);
    T.type = Ei, T.needsUpdate = !0;
    const b = c * 4;
    for (let E = 0; E < s; E++) {
      const R = a[E], C = l[E], L = u[E], D = A * m * 4 * E;
      for (let B = 0; B < R.count; B++) {
        const U = B * b;
        e === !0 && (po.fromBufferAttribute(R, B), y[D + U + 0] = po.x, y[D + U + 1] = po.y, y[D + U + 2] = po.z, y[D + U + 3] = 0), t === !0 && (po.fromBufferAttribute(C, B), y[D + U + 4] = po.x, y[D + U + 5] = po.y, y[D + U + 6] = po.z, y[D + U + 7] = 0), n === !0 && (po.fromBufferAttribute(L, B), y[D + U + 8] = po.x, y[D + U + 9] = po.y, y[D + U + 10] = po.z, y[D + U + 11] = L.itemSize === 4 ? po.w : 1);
      }
    }
    o = {
      count: s,
      texture: T,
      stride: c,
      size: new Le(A, m)
    }, Wy.set(i, o), i.addEventListener("dispose", S);
  }
  return o;
}
class iJ extends St {
  static get type() {
    return "MorphNode";
  }
  /**
   * Constructs a new morph node.
   *
   * @param {Mesh} mesh - The mesh holding the morph targets.
   */
  constructor(e) {
    super("void"), this.mesh = e, this.morphBaseInfluence = It(1), this.updateType = hn.OBJECT;
  }
  /**
   * Setups the morph node by assigning the transformed vertex data to predefined node variables.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  setup(e) {
    const { geometry: t } = e, n = t.morphAttributes.position !== void 0, r = t.hasAttribute("normal") && t.morphAttributes.normal !== void 0, s = t.morphAttributes.position || t.morphAttributes.normal || t.morphAttributes.color, o = s !== void 0 ? s.length : 0, { texture: a, stride: l, size: u } = nJ(t);
    n === !0 && Vi.mulAssign(this.morphBaseInfluence), r === !0 && oo.mulAssign(this.morphBaseInfluence);
    const c = le(u.width);
    ri(o, ({ i: A }) => {
      const m = J(0).toVar();
      this.mesh.count > 1 && this.mesh.morphTexture !== null && this.mesh.morphTexture !== void 0 ? m.assign($i(this.mesh.morphTexture, ur(le(A).add(1), le(nl))).r) : m.assign(ui("morphTargetInfluences", "float").element(A).toVar()), Ot(m.notEqual(0), () => {
        n === !0 && Vi.addAssign(ER({
          bufferMap: a,
          influence: m,
          stride: l,
          width: c,
          depth: A,
          offset: le(0)
        })), r === !0 && oo.addAssign(ER({
          bufferMap: a,
          influence: m,
          stride: l,
          width: c,
          depth: A,
          offset: le(1)
        }));
      });
    });
  }
  /**
   * Updates the state of the morphed mesh by updating the base influence.
   *
   * @param {NodeFrame} frame - The current node frame.
   */
  update() {
    const e = this.morphBaseInfluence;
    this.mesh.geometry.morphTargetsRelative ? e.value = 1 : e.value = 1 - this.mesh.morphTargetInfluences.reduce((t, n) => t + n, 0);
  }
}
const YD = /* @__PURE__ */ on(iJ).setParameterLength(1);
class dA extends St {
  static get type() {
    return "LightingNode";
  }
  /**
   * Constructs a new lighting node.
   */
  constructor() {
    super("vec3"), this.isLightingNode = !0;
  }
}
class rJ extends dA {
  static get type() {
    return "AONode";
  }
  /**
   * Constructs a new AO node.
   *
   * @param {?Node<float>} [aoNode=null] - The ambient occlusion node.
   */
  constructor(e = null) {
    super(), this.aoNode = e;
  }
  setup(e) {
    e.context.ambientOcclusion.mulAssign(this.aoNode);
  }
}
class sJ extends a6 {
  static get type() {
    return "LightingContextNode";
  }
  /**
   * Constructs a new lighting context node.
   *
   * @param {LightsNode} lightsNode - The lights node.
   * @param {?LightingModel} [lightingModel=null] - The current lighting model.
   * @param {?Node<vec3>} [backdropNode=null] - A backdrop node.
   * @param {?Node<float>} [backdropAlphaNode=null] - A backdrop alpha node.
   */
  constructor(e, t = null, n = null, r = null) {
    super(e), this.lightingModel = t, this.backdropNode = n, this.backdropAlphaNode = r, this._value = null;
  }
  /**
   * Returns a lighting context object.
   *
   * @return {{
   * radiance: Node<vec3>,
   * irradiance: Node<vec3>,
   * iblIrradiance: Node<vec3>,
   * ambientOcclusion: Node<float>,
   * reflectedLight: {directDiffuse: Node<vec3>, directSpecular: Node<vec3>, indirectDiffuse: Node<vec3>, indirectSpecular: Node<vec3>},
   * backdrop: Node<vec3>,
   * backdropAlpha: Node<float>
   * }} The lighting context object.
   */
  getContext() {
    const { backdropNode: e, backdropAlphaNode: t } = this, n = ce().toVar("directDiffuse"), r = ce().toVar("directSpecular"), s = ce().toVar("indirectDiffuse"), o = ce().toVar("indirectSpecular"), a = {
      directDiffuse: n,
      directSpecular: r,
      indirectDiffuse: s,
      indirectSpecular: o
    };
    return {
      radiance: ce().toVar("radiance"),
      irradiance: ce().toVar("irradiance"),
      iblIrradiance: ce().toVar("iblIrradiance"),
      ambientOcclusion: J(1).toVar("ambientOcclusion"),
      reflectedLight: a,
      backdrop: e,
      backdropAlpha: t
    };
  }
  setup(e) {
    return this.value = this._value || (this._value = this.getContext()), this.value.lightingModel = this.lightingModel || e.context.lightingModel, super.setup(e);
  }
}
const QD = /* @__PURE__ */ on(sJ);
class oJ extends dA {
  static get type() {
    return "IrradianceNode";
  }
  /**
   * Constructs a new irradiance node.
   *
   * @param {Node<vec3>} node - A node contributing irradiance.
   */
  constructor(e) {
    super(), this.node = e;
  }
  setup(e) {
    e.context.irradiance.addAssign(this.node);
  }
}
const $d = /* @__PURE__ */ new Le();
class W2 extends sl {
  static get type() {
    return "ViewportTextureNode";
  }
  /**
   * Constructs a new viewport texture node.
   *
   * @param {Node} [uvNode=screenUV] - The uv node.
   * @param {?Node} [levelNode=null] - The level node.
   * @param {?Texture} [framebufferTexture=null] - A framebuffer texture holding the viewport data. If not provided, a framebuffer texture is created automatically.
   */
  constructor(e = Ul, t = null, n = null) {
    let r = null;
    n === null ? (r = new t2(), r.minFilter = $r, n = r) : r = n, super(n, e, t), this.generateMipmaps = !1, this.defaultFramebuffer = r, this.isOutputTextureNode = !0, this.updateBeforeType = hn.FRAME, this._cacheTextures = /* @__PURE__ */ new WeakMap();
  }
  /**
   * This methods returns a texture for the given render target reference.
   *
   * To avoid rendering errors, `ViewportTextureNode` must use unique framebuffer textures
   * for different render contexts.
   *
   * @param {?RenderTarget} [reference=null] - The render target reference.
   * @return {Texture} The framebuffer texture.
   */
  getTextureForReference(e = null) {
    let t, n;
    if (this.referenceNode ? (t = this.referenceNode.defaultFramebuffer, n = this.referenceNode._cacheTextures) : (t = this.defaultFramebuffer, n = this._cacheTextures), e === null)
      return t;
    if (n.has(e) === !1) {
      const r = t.clone();
      n.set(e, r);
    }
    return n.get(e);
  }
  updateReference(e) {
    const t = e.renderer.getRenderTarget();
    return this.value = this.getTextureForReference(t), this.value;
  }
  updateBefore(e) {
    const t = e.renderer, n = t.getRenderTarget();
    n === null ? t.getDrawingBufferSize($d) : $d.set(n.width, n.height);
    const r = this.getTextureForReference(n);
    (r.image.width !== $d.width || r.image.height !== $d.height) && (r.image.width = $d.width, r.image.height = $d.height, r.needsUpdate = !0);
    const s = r.generateMipmaps;
    r.generateMipmaps = this.generateMipmaps, t.copyFramebufferToTexture(r), r.generateMipmaps = s;
  }
  clone() {
    const e = new this.constructor(this.uvNode, this.levelNode, this.value);
    return e.generateMipmaps = this.generateMipmaps, e;
  }
}
const aJ = /* @__PURE__ */ on(W2).setParameterLength(0, 3), LT = /* @__PURE__ */ on(W2, null, null, { generateMipmaps: !0 }).setParameterLength(0, 3);
let ug = null;
class lJ extends W2 {
  static get type() {
    return "ViewportDepthTextureNode";
  }
  /**
   * Constructs a new viewport depth texture node.
   *
   * @param {Node} [uvNode=screenUV] - The uv node.
   * @param {?Node} [levelNode=null] - The level node.
   */
  constructor(e = Ul, t = null) {
    ug === null && (ug = new Qr()), super(e, t, ug);
  }
  /**
   * Overwritten so the method always returns the unique shared
   * depth texture.
   *
   * @return {DepthTexture} The shared depth texture.
   */
  getTextureForReference() {
    return ug;
  }
}
const IT = /* @__PURE__ */ on(lJ).setParameterLength(0, 2);
class Ys extends St {
  static get type() {
    return "ViewportDepthNode";
  }
  /**
   * Constructs a new viewport depth node.
   *
   * @param {('depth'|'depthBase'|'linearDepth')} scope - The node's scope.
   * @param {?Node} [valueNode=null] - The value node.
   */
  constructor(e, t = null) {
    super("float"), this.scope = e, this.valueNode = t, this.isViewportDepthNode = !0;
  }
  generate(e) {
    const { scope: t } = this;
    return t === Ys.DEPTH_BASE ? e.getFragDepth() : super.generate(e);
  }
  setup({ camera: e }) {
    const { scope: t } = this, n = this.valueNode;
    let r = null;
    if (t === Ys.DEPTH_BASE)
      n !== null && (r = ZD().assign(n));
    else if (t === Ys.DEPTH)
      e.isPerspectiveCamera ? r = KD(tr.z, Cu, Pu) : r = Sf(tr.z, Cu, Pu);
    else if (t === Ys.LINEAR_DEPTH)
      if (n !== null)
        if (e.isPerspectiveCamera) {
          const s = BT(n, Cu, Pu);
          r = Sf(s, Cu, Pu);
        } else
          r = n;
      else
        r = Sf(tr.z, Cu, Pu);
    return r;
  }
}
Ys.DEPTH_BASE = "depthBase";
Ys.DEPTH = "depth";
Ys.LINEAR_DEPTH = "linearDepth";
const Sf = (i, e, t) => i.add(e).div(e.sub(t)), uJ = (i, e, t) => e.sub(t).mul(i).sub(e), KD = (i, e, t) => e.add(i).mul(t).div(t.sub(e).mul(i)), BT = (i, e, t) => e.mul(t).div(t.sub(e).mul(i).sub(t)), FT = (i, e, t) => {
  e = e.max(1e-6).toVar();
  const n = Za(i.negate().div(e)), r = Za(t.div(e));
  return n.div(r);
}, cJ = (i, e, t) => {
  const n = i.mul(L2(t.div(e)));
  return J(Math.E).pow(n).mul(e).negate();
}, ZD = /* @__PURE__ */ on(Ys, Ys.DEPTH_BASE), UT = /* @__PURE__ */ st(Ys, Ys.DEPTH), d_ = /* @__PURE__ */ on(Ys, Ys.LINEAR_DEPTH).setParameterLength(0, 1), hJ = /* @__PURE__ */ d_(IT());
UT.assign = (i) => ZD(i);
class zo extends St {
  static get type() {
    return "ClippingNode";
  }
  /**
   * Constructs a new clipping node.
   *
   * @param {('default'|'hardware'|'alphaToCoverage')} [scope='default'] - The node's scope. Similar to other nodes,
   * the selected scope influences the behavior of the node and what type of code is generated.
   */
  constructor(e = zo.DEFAULT) {
    super(), this.scope = e;
  }
  /**
   * Setups the node depending on the selected scope.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node} The result node.
   */
  setup(e) {
    super.setup(e);
    const t = e.clippingContext, { intersectionPlanes: n, unionPlanes: r } = t;
    return this.hardwareClipping = e.material.hardwareClipping, this.scope === zo.ALPHA_TO_COVERAGE ? this.setupAlphaToCoverage(n, r) : this.scope === zo.HARDWARE ? this.setupHardwareClipping(r, e) : this.setupDefault(n, r);
  }
  /**
   * Setups alpha to coverage.
   *
   * @param {Array<Vector4>} intersectionPlanes - The intersection planes.
   * @param {Array<Vector4>} unionPlanes - The union planes.
   * @return {Node} The result node.
   */
  setupAlphaToCoverage(e, t) {
    return pe(() => {
      const n = J().toVar("distanceToPlane"), r = J().toVar("distanceToGradient"), s = J(1).toVar("clipOpacity"), o = t.length;
      if (this.hardwareClipping === !1 && o > 0) {
        const l = hs(t).setGroup(Lt);
        ri(o, ({ i: u }) => {
          const c = l.element(u);
          n.assign(tr.dot(c.xyz).negate().add(c.w)), r.assign(n.fwidth().div(2)), s.mulAssign(Ta(r.negate(), r, n));
        });
      }
      const a = e.length;
      if (a > 0) {
        const l = hs(e).setGroup(Lt), u = J(1).toVar("intersectionClipOpacity");
        ri(a, ({ i: c }) => {
          const A = l.element(c);
          n.assign(tr.dot(A.xyz).negate().add(A.w)), r.assign(n.fwidth().div(2)), u.mulAssign(Ta(r.negate(), r, n).oneMinus());
        }), s.mulAssign(u.oneMinus());
      }
      ni.a.mulAssign(s), ni.a.equal(0).discard();
    })();
  }
  /**
   * Setups the default clipping.
   *
   * @param {Array<Vector4>} intersectionPlanes - The intersection planes.
   * @param {Array<Vector4>} unionPlanes - The union planes.
   * @return {Node} The result node.
   */
  setupDefault(e, t) {
    return pe(() => {
      const n = t.length;
      if (this.hardwareClipping === !1 && n > 0) {
        const s = hs(t).setGroup(Lt);
        ri(n, ({ i: o }) => {
          const a = s.element(o);
          tr.dot(a.xyz).greaterThan(a.w).discard();
        });
      }
      const r = e.length;
      if (r > 0) {
        const s = hs(e).setGroup(Lt), o = Wo(!0).toVar("clipped");
        ri(r, ({ i: a }) => {
          const l = s.element(a);
          o.assign(tr.dot(l.xyz).greaterThan(l.w).and(o));
        }), o.discard();
      }
    })();
  }
  /**
   * Setups hardware clipping.
   *
   * @param {Array<Vector4>} unionPlanes - The union planes.
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node} The result node.
   */
  setupHardwareClipping(e, t) {
    const n = e.length;
    return t.enableHardwareClipping(n), pe(() => {
      const r = hs(e).setGroup(Lt), s = tu(t.getClipDistance());
      ri(n, ({ i: o }) => {
        const a = r.element(o), l = tr.dot(a.xyz).sub(a.w).negate();
        s.element(o).assign(l);
      });
    })();
  }
}
zo.ALPHA_TO_COVERAGE = "alphaToCoverage";
zo.DEFAULT = "default";
zo.HARDWARE = "hardware";
const dJ = () => new zo(), fJ = () => new zo(zo.ALPHA_TO_COVERAGE), AJ = () => new zo(zo.HARDWARE), pJ = 0.05, RR = /* @__PURE__ */ pe(([i]) => ba(sn(1e4, Ns(sn(17, i.x).add(sn(0.1, i.y)))).mul(sr(0.1, vi(Ns(sn(13, i.y).add(i.x))))))), CR = /* @__PURE__ */ pe(([i]) => RR(Xe(RR(i.xy), i.z))), mJ = /* @__PURE__ */ pe(([i]) => {
  const e = qi(
    el(sT(i.xyz)),
    el(oT(i.xyz))
  ), t = J(1).div(J(pJ).mul(e)).toVar("pixScale"), n = Xe(
    Xf(Ja(Za(t))),
    Xf(I2(Za(t)))
  ), r = Xe(
    CR(Ja(n.x.mul(i.xyz))),
    CR(Ja(n.y.mul(i.xyz)))
  ), s = ba(Za(t)), o = sr(sn(s.oneMinus(), r.x), sn(s, r.y)), a = so(s, s.oneMinus()), l = ce(
    o.mul(o).div(sn(2, a).mul(Un(1, a))),
    o.sub(sn(0.5, a)).div(Un(1, a)),
    Un(1, Un(1, o).mul(Un(1, o)).div(sn(2, a).mul(Un(1, a))))
  ), u = o.lessThan(a.oneMinus()).select(o.lessThan(a).select(l.x, l.y), l.z);
  return Sa(u, 1e-6, 1);
}).setLayout({
  name: "getAlphaHashThreshold",
  type: "float",
  inputs: [
    { name: "position", type: "vec3" }
  ]
});
class gJ extends I6 {
  static get type() {
    return "VertexColorNode";
  }
  /**
   * Constructs a new vertex color node.
   *
   * @param {number} index - The attribute index.
   */
  constructor(e) {
    super(null, "vec4"), this.isVertexColorNode = !0, this.index = e;
  }
  /**
   * Overwrites the default implementation by honoring the attribute index.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The attribute name.
   */
  getAttributeName() {
    const e = this.index;
    return "color" + (e > 0 ? e : "");
  }
  generate(e) {
    const t = this.getAttributeName(e), n = e.hasGeometryAttribute(t);
    let r;
    return n === !0 ? r = super.generate(e) : r = e.generateConst(this.nodeType, new Kt(1, 1, 1, 1)), r;
  }
  serialize(e) {
    super.serialize(e), e.index = this.index;
  }
  deserialize(e) {
    super.deserialize(e), this.index = e.index;
  }
}
const JD = (i = 0) => new gJ(i), eL = /* @__PURE__ */ pe(([i, e]) => so(1, i.oneMinus().div(e)).oneMinus()).setLayout({
  name: "blendBurn",
  type: "vec3",
  inputs: [
    { name: "base", type: "vec3" },
    { name: "blend", type: "vec3" }
  ]
}), tL = /* @__PURE__ */ pe(([i, e]) => so(i.div(e.oneMinus()), 1)).setLayout({
  name: "blendDodge",
  type: "vec3",
  inputs: [
    { name: "base", type: "vec3" },
    { name: "blend", type: "vec3" }
  ]
}), nL = /* @__PURE__ */ pe(([i, e]) => i.oneMinus().mul(e.oneMinus()).oneMinus()).setLayout({
  name: "blendScreen",
  type: "vec3",
  inputs: [
    { name: "base", type: "vec3" },
    { name: "blend", type: "vec3" }
  ]
}), iL = /* @__PURE__ */ pe(([i, e]) => Bn(i.mul(2).mul(e), i.oneMinus().mul(2).mul(e.oneMinus()).oneMinus(), F2(0.5, i))).setLayout({
  name: "blendOverlay",
  type: "vec3",
  inputs: [
    { name: "base", type: "vec3" },
    { name: "blend", type: "vec3" }
  ]
}), _J = /* @__PURE__ */ pe(([i, e]) => {
  const t = e.a.add(i.a.mul(e.a.oneMinus()));
  return Gt(e.rgb.mul(e.a).add(i.rgb.mul(i.a).mul(e.a.oneMinus())).div(t), t);
}).setLayout({
  name: "blendColor",
  type: "vec4",
  inputs: [
    { name: "base", type: "vec4" },
    { name: "blend", type: "vec4" }
  ]
}), rL = /* @__PURE__ */ pe(([i]) => Gt(i.rgb.mul(i.a), i.a), { color: "vec4", return: "vec4" }), xJ = /* @__PURE__ */ pe(([i]) => (Ot(i.a.equal(0), () => Gt(0)), Gt(i.rgb.div(i.a), i.a)), { color: "vec4", return: "vec4" }), yJ = (...i) => (Me('TSL: "burn" has been renamed. Use "blendBurn" instead.'), eL(i)), vJ = (...i) => (Me('TSL: "dodge" has been renamed. Use "blendDodge" instead.'), tL(i)), bJ = (...i) => (Me('TSL: "screen" has been renamed. Use "blendScreen" instead.'), nL(i)), SJ = (...i) => (Me('TSL: "overlay" has been renamed. Use "blendOverlay" instead.'), iL(i));
class Yi extends Br {
  static get type() {
    return "NodeMaterial";
  }
  /**
   * Represents the type of the node material.
   *
   * @type {string}
   */
  get type() {
    return this.constructor.type;
  }
  set type(e) {
  }
  /**
   * Constructs a new node material.
   */
  constructor() {
    super(), this.isNodeMaterial = !0, this.fog = !0, this.lights = !1, this.hardwareClipping = !1, this.lightsNode = null, this.envNode = null, this.aoNode = null, this.colorNode = null, this.normalNode = null, this.opacityNode = null, this.backdropNode = null, this.backdropAlphaNode = null, this.alphaTestNode = null, this.maskNode = null, this.positionNode = null, this.geometryNode = null, this.depthNode = null, this.receivedShadowPositionNode = null, this.castShadowPositionNode = null, this.receivedShadowNode = null, this.castShadowNode = null, this.outputNode = null, this.mrtNode = null, this.fragmentNode = null, this.vertexNode = null, this.contextNode = null, Object.defineProperty(this, "shadowPositionNode", {
      // @deprecated, r176
      get: () => this.receivedShadowPositionNode,
      set: (e) => {
        Me('NodeMaterial: ".shadowPositionNode" was renamed to ".receivedShadowPositionNode".'), this.receivedShadowPositionNode = e;
      }
    });
  }
  /**
   * Returns an array of child nodes for this material.
   *
   * @private
   * @returns {Array<{property: string, childNode: Node}>}
   */
  _getNodeChildren() {
    const e = [];
    for (const t of Object.getOwnPropertyNames(this)) {
      if (t.startsWith("_") === !0) continue;
      const n = this[t];
      n && n.isNode === !0 && e.push({ property: t, childNode: n });
    }
    return e;
  }
  /**
   * Allows to define a custom cache key that influence the material key computation
   * for render objects.
   *
   * @return {string} The custom cache key.
   */
  customProgramCacheKey() {
    const e = [];
    for (const { property: t, childNode: n } of this._getNodeChildren())
      e.push(F0(t.slice(0, -4)), n.getCacheKey());
    return this.type + cA(e);
  }
  /**
   * Builds this material with the given node builder.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  build(e) {
    this.setup(e);
  }
  /**
   * Setups a node material observer with the given builder.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {NodeMaterialObserver} The node material observer.
   */
  setupObserver(e) {
    return new qQ(e);
  }
  /**
   * Setups the vertex and fragment stage of this node material.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  setup(e) {
    e.context.setupNormal = () => vf(this.setupNormal(e), "NORMAL", "vec3"), e.context.setupPositionView = () => this.setupPositionView(e), e.context.setupModelViewProjection = () => this.setupModelViewProjection(e);
    const t = e.renderer, n = t.getRenderTarget();
    t.contextNode.isContextNode === !0 ? e.context = { ...e.context, ...t.contextNode.getFlowContextData() } : Ie('NodeMaterial: "renderer.contextNode" must be an instance of `context()`.'), this.contextNode !== null && (this.contextNode.isContextNode === !0 ? e.context = { ...e.context, ...this.contextNode.getFlowContextData() } : Ie('NodeMaterial: "material.contextNode" must be an instance of `context()`.')), e.addStack();
    const r = vf(this.setupVertex(e), "VERTEX"), s = this.vertexNode || r;
    e.stack.outputNode = s, this.setupHardwareClipping(e), this.geometryNode !== null && (e.stack.outputNode = e.stack.outputNode.bypass(this.geometryNode)), e.addFlow("vertex", e.removeStack()), e.addStack();
    let o;
    const a = this.setupClipping(e);
    if ((this.depthWrite === !0 || this.depthTest === !0) && (n !== null ? n.depthBuffer === !0 && this.setupDepth(e) : t.depth === !0 && this.setupDepth(e)), this.fragmentNode === null) {
      this.setupDiffuseColor(e), this.setupVariants(e);
      const l = this.setupLighting(e);
      a !== null && e.stack.addToStack(a);
      const u = Gt(l, ni.a).max(0);
      o = this.setupOutput(e, u), yf.assign(o);
      const c = this.outputNode !== null;
      if (c && (o = this.outputNode), e.context.getOutput && (o = e.context.getOutput(o, e)), n !== null) {
        const A = t.getMRT(), m = this.mrtNode;
        A !== null ? (c && yf.assign(o), o = A, m !== null && (o = A.merge(m))) : m !== null && (o = m);
      }
    } else {
      let l = this.fragmentNode;
      l.isOutputStructNode !== !0 && (l = Gt(l)), o = this.setupOutput(e, l);
    }
    e.stack.outputNode = o, e.addFlow("fragment", e.removeStack()), e.observer = this.setupObserver(e);
  }
  /**
   * Setups the clipping node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {ClippingNode} The clipping node.
   */
  setupClipping(e) {
    if (e.clippingContext === null) return null;
    const { unionPlanes: t, intersectionPlanes: n } = e.clippingContext;
    let r = null;
    if (t.length > 0 || n.length > 0) {
      const s = e.renderer.currentSamples;
      this.alphaToCoverage && s > 1 ? r = fJ() : e.stack.addToStack(dJ());
    }
    return r;
  }
  /**
   * Setups the hardware clipping if available on the current device.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  setupHardwareClipping(e) {
    if (this.hardwareClipping = !1, e.clippingContext === null) return;
    const t = e.clippingContext.unionPlanes.length;
    t > 0 && t <= 8 && e.isAvailable("clipDistance") && (e.stack.addToStack(AJ()), this.hardwareClipping = !0);
  }
  /**
   * Setups the depth of this material.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  setupDepth(e) {
    const { renderer: t, camera: n } = e;
    let r = this.depthNode;
    if (r === null) {
      const s = t.getMRT();
      s && s.has("depth") ? r = s.get("depth") : t.logarithmicDepthBuffer === !0 && (n.isPerspectiveCamera ? r = FT(tr.z, Cu, Pu) : r = Sf(tr.z, Cu, Pu));
    }
    r !== null && UT.assign(r).toStack();
  }
  /**
   * Setups the position node in view space. This method exists
   * so derived node materials can modify the implementation e.g. sprite materials.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node<vec3>} The position in view space.
   */
  setupPositionView() {
    return sc.mul(Vi).xyz;
  }
  /**
   * Setups the position in clip space.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node<vec4>} The position in view space.
   */
  setupModelViewProjection() {
    return Ol.mul(tr);
  }
  /**
   * Setups the logic for the vertex stage.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node<vec4>} The position in clip space.
   */
  setupVertex(e) {
    return e.addStack(), this.setupPosition(e), e.context.vertex = e.removeStack(), VD;
  }
  /**
   * Setups the computation of the position in local space.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node<vec3>} The position in local space.
   */
  setupPosition(e) {
    const { object: t, geometry: n } = e;
    if ((n.morphAttributes.position || n.morphAttributes.normal || n.morphAttributes.color) && YD(t).toStack(), t.isSkinnedMesh === !0 && jD(t).toStack(), this.displacementMap) {
      const r = wl("displacementMap", "texture"), s = wl("displacementScale", "float"), o = wl("displacementBias", "float");
      Vi.addAssign(oo.normalize().mul(r.x.mul(s).add(o)));
    }
    return t.isBatchedMesh && WD(t).toStack(), t.isInstancedMesh && t.instanceMatrix && t.instanceMatrix.isInstancedBufferAttribute === !0 && HD(t).toStack(), this.positionNode !== null && Vi.assign(vf(this.positionNode, "POSITION", "vec3")), Vi;
  }
  /**
   * Setups the computation of the material's diffuse color.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {BufferGeometry} geometry - The geometry.
   */
  setupDiffuseColor(e) {
    const { object: t, geometry: n } = e;
    this.maskNode !== null && Wo(this.maskNode).not().discard();
    let r = this.colorNode ? Gt(this.colorNode) : cD;
    this.vertexColors === !0 && n.hasAttribute("color") && (r = r.mul(JD())), t.instanceColor && (r = o0("vec3", "vInstanceColor").mul(r)), t.isBatchedMesh && t._colorsTexture && (r = o0("vec3", "vBatchColor").mul(r)), ni.assign(r);
    const s = this.opacityNode ? J(this.opacityNode) : NT;
    ni.a.assign(ni.a.mul(s));
    let o = null;
    (this.alphaTestNode !== null || this.alphaTest > 0) && (o = this.alphaTestNode !== null ? J(this.alphaTestNode) : uD, this.alphaToCoverage === !0 ? (ni.a = Ta(o, o.add(lT(ni.a)), ni.a), ni.a.lessThanEqual(0).discard()) : ni.a.lessThanEqual(o).discard()), this.alphaHash === !0 && ni.a.lessThan(mJ(Vi)).discard(), e.isOpaque() && ni.a.assign(1);
  }
  /**
   * Abstract interface method that can be implemented by derived materials
   * to setup material-specific node variables.
   *
   * @abstract
   * @param {NodeBuilder} builder - The current node builder.
   */
  setupVariants() {
  }
  /**
   * Setups the outgoing light node variable
   *
   * @return {Node<vec3>} The outgoing light node.
   */
  setupOutgoingLight() {
    return this.lights === !0 ? ce(0) : ni.rgb;
  }
  /**
   * Setups the normal node from the material.
   *
   * @return {Node<vec3>} The normal node.
   */
  setupNormal() {
    return this.normalNode ? ce(this.normalNode) : gD;
  }
  /**
   * Setups the environment node from the material.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node<vec4>} The environment node.
   */
  setupEnvironment() {
    let e = null;
    return this.envNode ? e = this.envNode : this.envMap && (e = this.envMap.isCubeTexture ? wl("envMap", "cubeTexture") : wl("envMap", "texture")), e;
  }
  /**
   * Setups the light map node from the material.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node<vec3>} The light map node.
   */
  setupLightMap(e) {
    let t = null;
    return e.material.lightMap && (t = new oJ(DT)), t;
  }
  /**
   * Setups the lights node based on the scene, environment and material.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {LightsNode} The lights node.
   */
  setupLights(e) {
    const t = [], n = this.setupEnvironment(e);
    n && n.isLightingNode && t.push(n);
    const r = this.setupLightMap(e);
    r && r.isLightingNode && t.push(r);
    let s = this.aoNode;
    s === null && e.material.aoMap && (s = kD), e.context.getAO && (s = e.context.getAO(s, e)), s && t.push(new rJ(s));
    let o = this.lightsNode || e.lightsNode;
    return t.length > 0 && (o = e.renderer.lighting.createNode([...o.getLights(), ...t])), o;
  }
  /**
   * This method should be implemented by most derived materials
   * since it defines the material's lighting model.
   *
   * @abstract
   * @param {NodeBuilder} builder - The current node builder.
   * @return {LightingModel} The lighting model.
   */
  setupLightingModel() {
  }
  /**
   * Setups the outgoing light node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node<vec3>} The outgoing light node.
   */
  setupLighting(e) {
    const { material: t } = e, { backdropNode: n, backdropAlphaNode: r, emissiveNode: s } = this, a = this.lights === !0 || this.lightsNode !== null ? this.setupLights(e) : null;
    let l = this.setupOutgoingLight(e);
    if (a && a.getScope().hasLights) {
      const u = this.setupLightingModel(e) || null;
      l = QD(a, u, n, r);
    } else n !== null && (l = ce(r !== null ? Bn(l, n, r) : n));
    return (s && s.isNode === !0 || t.emissive && t.emissive.isColor === !0) && (Fb.assign(ce(s || dD)), l = l.add(Fb)), l;
  }
  /**
   * Setup the fog.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {Node<vec4>} outputNode - The existing output node.
   * @return {Node<vec4>} The output node.
   */
  setupFog(e, t) {
    const n = e.fogNode;
    return n && (yf.assign(t), t = Gt(n.toVar())), t;
  }
  /**
   * Setups premultiplied alpha.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {Node<vec4>} outputNode - The existing output node.
   * @return {Node<vec4>} The output node.
   */
  setupPremultipliedAlpha(e, t) {
    return rL(t);
  }
  /**
   * Setups the output node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {Node<vec4>} outputNode - The existing output node.
   * @return {Node<vec4>} The output node.
   */
  setupOutput(e, t) {
    return this.fog === !0 && (t = this.setupFog(e, t)), this.premultipliedAlpha === !0 && (t = this.setupPremultipliedAlpha(e, t)), t;
  }
  /**
   * Most classic material types have a node pendant e.g. for `MeshBasicMaterial`
   * there is `MeshBasicNodeMaterial`. This utility method is intended for
   * defining all material properties of the classic type in the node type.
   *
   * @param {Material} material - The material to copy properties with their values to this node material.
   */
  setDefaultValues(e) {
    for (const n in e) {
      const r = e[n];
      this[n] === void 0 && (this[n] = r, r && r.clone && (this[n] = r.clone()));
    }
    const t = Object.getOwnPropertyDescriptors(e.constructor.prototype);
    for (const n in t)
      Object.getOwnPropertyDescriptor(this.constructor.prototype, n) === void 0 && t[n].get !== void 0 && Object.defineProperty(this.constructor.prototype, n, t[n]);
  }
  /**
   * Serializes this material to JSON.
   *
   * @param {?(Object|string)} meta - The meta information for serialization.
   * @return {Object} The serialized node.
   */
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    t && (e = {
      textures: {},
      images: {},
      nodes: {}
    });
    const n = Br.prototype.toJSON.call(this, e);
    n.inputNodes = {};
    for (const { property: s, childNode: o } of this._getNodeChildren())
      n.inputNodes[s] = o.toJSON(e).uuid;
    function r(s) {
      const o = [];
      for (const a in s) {
        const l = s[a];
        delete l.metadata, o.push(l);
      }
      return o;
    }
    if (t) {
      const s = r(e.textures), o = r(e.images), a = r(e.nodes);
      s.length > 0 && (n.textures = s), o.length > 0 && (n.images = o), a.length > 0 && (n.nodes = a);
    }
    return n;
  }
  /**
   * Copies the properties of the given node material to this instance.
   *
   * @param {NodeMaterial} source - The material to copy.
   * @return {NodeMaterial} A reference to this node material.
   */
  copy(e) {
    return this.lightsNode = e.lightsNode, this.envNode = e.envNode, this.aoNode = e.aoNode, this.colorNode = e.colorNode, this.normalNode = e.normalNode, this.opacityNode = e.opacityNode, this.backdropNode = e.backdropNode, this.backdropAlphaNode = e.backdropAlphaNode, this.alphaTestNode = e.alphaTestNode, this.maskNode = e.maskNode, this.positionNode = e.positionNode, this.geometryNode = e.geometryNode, this.depthNode = e.depthNode, this.receivedShadowPositionNode = e.receivedShadowPositionNode, this.castShadowPositionNode = e.castShadowPositionNode, this.receivedShadowNode = e.receivedShadowNode, this.castShadowNode = e.castShadowNode, this.outputNode = e.outputNode, this.mrtNode = e.mrtNode, this.fragmentNode = e.fragmentNode, this.vertexNode = e.vertexNode, this.contextNode = e.contextNode, super.copy(e);
  }
}
const TJ = /* @__PURE__ */ new br();
class wJ extends Yi {
  static get type() {
    return "LineBasicNodeMaterial";
  }
  /**
   * Constructs a new line basic node material.
   *
   * @param {Object} [parameters] - The configuration parameter.
   */
  constructor(e) {
    super(), this.isLineBasicNodeMaterial = !0, this.setDefaultValues(TJ), this.setValues(e);
  }
}
const MJ = /* @__PURE__ */ new J3();
class EJ extends Yi {
  static get type() {
    return "LineDashedNodeMaterial";
  }
  /**
   * Constructs a new line dashed node material.
   *
   * @param {Object} [parameters] - The configuration parameter.
   */
  constructor(e) {
    super(), this.isLineDashedNodeMaterial = !0, this.setDefaultValues(MJ), this.dashOffset = 0, this.offsetNode = null, this.dashScaleNode = null, this.dashSizeNode = null, this.gapSizeNode = null, this.setValues(e);
  }
  /**
   * Setups the dash specific node variables.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  setupVariants() {
    const e = this.offsetNode ? J(this.offsetNode) : FD, t = this.dashScaleNode ? J(this.dashScaleNode) : LD, n = this.dashSizeNode ? J(this.dashSizeNode) : ID, r = this.gapSizeNode ? J(this.gapSizeNode) : BD;
    t1.assign(n), Ub.assign(r);
    const s = cl(Jl("lineDistance").mul(t));
    (e ? s.add(e) : s).mod(t1.add(Ub)).greaterThan(t1).discard();
  }
}
let cg = null;
class RJ extends W2 {
  static get type() {
    return "ViewportSharedTextureNode";
  }
  /**
   * Constructs a new viewport shared texture node.
   *
   * @param {Node} [uvNode=screenUV] - The uv node.
   * @param {?Node} [levelNode=null] - The level node.
   */
  constructor(e = Ul, t = null) {
    cg === null && (cg = new t2()), super(e, t, cg);
  }
  /**
   * Overwritten so the method always returns the unique shared
   * framebuffer texture.
   *
   * @return {FramebufferTexture} The shared framebuffer texture.
   */
  getTextureForReference() {
    return cg;
  }
  updateReference() {
    return this;
  }
}
const CJ = /* @__PURE__ */ on(RJ).setParameterLength(0, 2), PJ = /* @__PURE__ */ new Y3();
class NJ extends Yi {
  static get type() {
    return "MeshNormalNodeMaterial";
  }
  /**
   * Constructs a new mesh normal node material.
   *
   * @param {Object} [parameters] - The configuration parameter.
   */
  constructor(e) {
    super(), this.isMeshNormalNodeMaterial = !0, this.setDefaultValues(PJ), this.setValues(e);
  }
  /**
   * Overwrites the default implementation by computing the diffuse color
   * based on the normal data.
   */
  setupDiffuseColor() {
    const e = this.opacityNode ? J(this.opacityNode) : NT;
    ni.assign(O2(Gt(lD(Gn), e), gr));
  }
}
const OT = /* @__PURE__ */ pe(([i = wT]) => {
  const e = i.z.atan(i.x).mul(1 / (Math.PI * 2)).add(0.5), t = i.y.clamp(-1, 1).asin().mul(1 / Math.PI).add(0.5);
  return Xe(e, t);
});
class sL extends Q_ {
  /**
   * Constructs a new cube render target.
   *
   * @param {number} [size=1] - The size of the render target.
   * @param {RenderTarget~Options} [options] - The configuration object.
   */
  constructor(e = 1, t = {}) {
    super(e, t), this.isCubeRenderTarget = !0;
  }
  /**
   * Converts the given equirectangular texture to a cube map.
   *
   * @param {Renderer} renderer - The renderer.
   * @param {Texture} texture - The equirectangular texture.
   * @return {CubeRenderTarget} A reference to this cube render target.
   */
  fromEquirectangularTexture(e, t) {
    const n = t.minFilter, r = t.generateMipmaps;
    t.generateMipmaps = !0, this.texture.type = t.type, this.texture.colorSpace = t.colorSpace, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter;
    const s = new ul(5, 5, 5), o = OT(wT), a = new Yi();
    a.colorNode = Wn(t, o, 0), a.side = si, a.blending = ms;
    const l = new Tn(s, a), u = new oA();
    u.add(l), t.minFilter === $r && (t.minFilter = qn);
    const c = new D3(1, 10, this), A = e.getMRT();
    return e.setMRT(null), c.update(e, u), e.setMRT(A), t.minFilter = n, t.currentGenerateMipmaps = r, l.geometry.dispose(), l.material.dispose(), this;
  }
}
const Lp = /* @__PURE__ */ new WeakMap();
class DJ extends Hi {
  static get type() {
    return "CubeMapNode";
  }
  /**
   * Constructs a new cube map node.
   *
   * @param {Node} envNode - The node representing the environment map.
   */
  constructor(e) {
    super("vec3"), this.envNode = e, this._cubeTexture = null, this._cubeTextureNode = Is(null);
    const t = new Ju();
    t.isRenderTargetTexture = !0, this._defaultTexture = t, this.updateBeforeType = hn.RENDER;
  }
  updateBefore(e) {
    const { renderer: t, material: n } = e, r = this.envNode;
    if (r.isTextureNode || r.isMaterialReferenceNode) {
      const s = r.isTextureNode ? r.value : n[r.property];
      if (s && s.isTexture) {
        const o = s.mapping;
        if (o === Gu || o === zu) {
          if (Lp.has(s)) {
            const a = Lp.get(s);
            PR(a, s.mapping), this._cubeTexture = a;
          } else {
            const a = s.image;
            if (LJ(a)) {
              const l = new sL(a.height);
              l.fromEquirectangularTexture(t, s), PR(l.texture, s.mapping), this._cubeTexture = l.texture, Lp.set(s, l.texture), s.addEventListener("dispose", oL);
            } else
              this._cubeTexture = this._defaultTexture;
          }
          this._cubeTextureNode.value = this._cubeTexture;
        } else
          this._cubeTextureNode = this.envNode;
      }
    }
  }
  setup(e) {
    return this.updateBefore(e), this._cubeTextureNode;
  }
}
function LJ(i) {
  return i == null ? !1 : i.height > 0;
}
function oL(i) {
  const e = i.target;
  e.removeEventListener("dispose", oL);
  const t = Lp.get(e);
  t !== void 0 && (Lp.delete(e), t.dispose());
}
function PR(i, e) {
  e === Gu ? i.mapping = no : e === zu && (i.mapping = qo);
}
const aL = /* @__PURE__ */ on(DJ).setParameterLength(1);
class kT extends dA {
  static get type() {
    return "BasicEnvironmentNode";
  }
  /**
   * Constructs a new basic environment node.
   *
   * @param {Node} [envNode=null] - A node representing the environment.
   */
  constructor(e = null) {
    super(), this.envNode = e;
  }
  setup(e) {
    e.context.environment = aL(this.envNode);
  }
}
class IJ extends dA {
  static get type() {
    return "BasicLightMapNode";
  }
  /**
   * Constructs a new basic light map node.
   *
   * @param {?Node<vec3>} [lightMapNode=null] - The light map node.
   */
  constructor(e = null) {
    super(), this.lightMapNode = e;
  }
  setup(e) {
    const t = J(1 / Math.PI);
    e.context.irradianceLightMap = this.lightMapNode.mul(t);
  }
}
class $2 {
  /**
   * This method is intended for setting up lighting model and context data
   * which are later used in the evaluation process.
   *
   * @abstract
   * @param {NodeBuilder} builder - The current node builder.
   */
  start(e) {
    e.lightsNode.setupLights(e, e.lightsNode.getLightNodes(e)), this.indirect(e);
  }
  /**
   * This method is intended for executing final tasks like final updates
   * to the outgoing light.
   *
   * @abstract
   * @param {NodeBuilder} builder - The current node builder.
   */
  finish() {
  }
  /**
   * This method is intended for implementing the direct light term and
   * executed during the build process of directional, point and spot light nodes.
   *
   * @abstract
   * @param {Object} lightData - The light data.
   * @param {NodeBuilder} builder - The current node builder.
   */
  direct() {
  }
  /**
   * This method is intended for implementing the direct light term for
   * rect area light nodes.
   *
   * @abstract
   * @param {Object} lightData - The light data.
   * @param {NodeBuilder} builder - The current node builder.
   */
  directRectArea() {
  }
  /**
   * This method is intended for implementing the indirect light term.
   *
   * @abstract
   * @param {NodeBuilder} builder - The current node builder.
   */
  indirect() {
  }
  /**
   * This method is intended for implementing the ambient occlusion term.
   * Unlike other methods, this method must be called manually by the lighting
   * model in its indirect term.
   *
   * @abstract
   * @param {NodeBuilder} builder - The current node builder.
   */
  ambientOcclusion() {
  }
}
class lL extends $2 {
  /**
   * Constructs a new basic lighting model.
   */
  constructor() {
    super();
  }
  /**
   * Implements the baked indirect lighting with its modulation.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  indirect({ context: e }) {
    const t = e.ambientOcclusion, n = e.reflectedLight, r = e.irradianceLightMap;
    n.indirectDiffuse.assign(Gt(0)), r ? n.indirectDiffuse.addAssign(r) : n.indirectDiffuse.addAssign(Gt(1, 1, 1, 0)), n.indirectDiffuse.mulAssign(t), n.indirectDiffuse.mulAssign(ni.rgb);
  }
  /**
   * Implements the environment mapping.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  finish(e) {
    const { material: t, context: n } = e, r = n.outgoingLight, s = e.context.environment;
    if (s)
      switch (t.combine) {
        case tA:
          r.rgb.assign(Bn(r.rgb, r.rgb.mul(s.rgb), Dp.mul(s1)));
          break;
        case b3:
          r.rgb.assign(Bn(r.rgb, s.rgb, Dp.mul(s1)));
          break;
        case S3:
          r.rgb.addAssign(s.rgb.mul(Dp.mul(s1)));
          break;
        default:
          Me("BasicLightingModel: Unsupported .combine value:", t.combine);
          break;
      }
  }
}
const BJ = /* @__PURE__ */ new Nr();
class FJ extends Yi {
  static get type() {
    return "MeshBasicNodeMaterial";
  }
  /**
   * Constructs a new mesh basic node material.
   *
   * @param {Object} [parameters] - The configuration parameter.
   */
  constructor(e) {
    super(), this.isMeshBasicNodeMaterial = !0, this.lights = !0, this.setDefaultValues(BJ), this.setValues(e);
  }
  /**
   * Basic materials are not affected by normal and bump maps so we
   * return by default {@link normalViewGeometry}.
   *
   * @return {Node<vec3>} The normal node.
   */
  setupNormal() {
    return hA(Yf);
  }
  /**
   * Overwritten since this type of material uses {@link BasicEnvironmentNode}
   * to implement the default environment mapping.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {?BasicEnvironmentNode<vec3>} The environment node.
   */
  setupEnvironment(e) {
    const t = super.setupEnvironment(e);
    return t ? new kT(t) : null;
  }
  /**
   * This method must be overwritten since light maps are evaluated
   * with a special scaling factor for basic materials.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {?BasicLightMapNode<vec3>} The light map node.
   */
  setupLightMap(e) {
    let t = null;
    return e.material.lightMap && (t = new IJ(DT)), t;
  }
  /**
   * The material overwrites this method because `lights` is set to `true` but
   * we still want to return the diffuse color as the outgoing light.
   *
   * @return {Node<vec3>} The outgoing light node.
   */
  setupOutgoingLight() {
    return ni.rgb;
  }
  /**
   * Setups the lighting model.
   *
   * @return {BasicLightingModel} The lighting model.
   */
  setupLightingModel() {
    return new lL();
  }
}
const Qf = /* @__PURE__ */ pe(({ f0: i, f90: e, dotVH: t }) => {
  const n = t.mul(-5.55473).sub(6.98316).mul(t).exp2();
  return i.mul(n.oneMinus()).add(e.mul(n));
}), Xh = /* @__PURE__ */ pe((i) => i.diffuseColor.mul(1 / Math.PI)), UJ = () => J(0.25), OJ = /* @__PURE__ */ pe(({ dotNH: i }) => a_.mul(J(0.5)).add(1).mul(J(1 / Math.PI)).mul(i.pow(a_))), kJ = /* @__PURE__ */ pe(({ lightDirection: i }) => {
  const e = i.add(gi).normalize(), t = Gn.dot(e).clamp(), n = gi.dot(e).clamp(), r = Qf({ f0: Yu, f90: 1, dotVH: n }), s = UJ(), o = OJ({ dotNH: t });
  return r.mul(s).mul(o);
});
class uL extends lL {
  /**
   * Constructs a new phong lighting model.
   *
   * @param {boolean} [specular=true] - Whether specular is supported or not.
   */
  constructor(e = !0) {
    super(), this.specular = e;
  }
  /**
   * Implements the direct lighting. The specular portion is optional an can be controlled
   * with the {@link PhongLightingModel#specular} flag.
   *
   * @param {Object} lightData - The light data.
   */
  direct({ lightDirection: e, lightColor: t, reflectedLight: n }) {
    const s = Gn.dot(e).clamp().mul(t);
    n.directDiffuse.addAssign(s.mul(Xh({ diffuseColor: ni.rgb }))), this.specular === !0 && n.directSpecular.addAssign(s.mul(kJ({ lightDirection: e })).mul(Dp));
  }
  /**
   * Implements the indirect lighting.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  indirect(e) {
    const { ambientOcclusion: t, irradiance: n, reflectedLight: r } = e.context;
    r.indirectDiffuse.addAssign(n.mul(Xh({ diffuseColor: ni }))), r.indirectDiffuse.mulAssign(t);
  }
}
const VJ = /* @__PURE__ */ new Ea();
class GJ extends Yi {
  static get type() {
    return "MeshLambertNodeMaterial";
  }
  /**
   * Constructs a new mesh lambert node material.
   *
   * @param {Object} [parameters] - The configuration parameter.
   */
  constructor(e) {
    super(), this.isMeshLambertNodeMaterial = !0, this.lights = !0, this.setDefaultValues(VJ), this.setValues(e);
  }
  /**
   * Overwritten since this type of material uses {@link BasicEnvironmentNode}
   * to implement the default environment mapping.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {?BasicEnvironmentNode<vec3>} The environment node.
   */
  setupEnvironment(e) {
    const t = super.setupEnvironment(e);
    return t ? new kT(t) : null;
  }
  /**
   * Setups the lighting model.
   *
   * @return {PhongLightingModel} The lighting model.
   */
  setupLightingModel() {
    return new uL(!1);
  }
}
const zJ = /* @__PURE__ */ new A2();
class qJ extends Yi {
  static get type() {
    return "MeshPhongNodeMaterial";
  }
  /**
   * Constructs a new mesh lambert node material.
   *
   * @param {Object} [parameters] - The configuration parameter.
   */
  constructor(e) {
    super(), this.isMeshPhongNodeMaterial = !0, this.lights = !0, this.shininessNode = null, this.specularNode = null, this.setDefaultValues(zJ), this.setValues(e);
  }
  /**
   * Overwritten since this type of material uses {@link BasicEnvironmentNode}
   * to implement the default environment mapping.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {?BasicEnvironmentNode<vec3>} The environment node.
   */
  setupEnvironment(e) {
    const t = super.setupEnvironment(e);
    return t ? new kT(t) : null;
  }
  /**
   * Setups the lighting model.
   *
   * @return {PhongLightingModel} The lighting model.
   */
  setupLightingModel() {
    return new uL();
  }
  /**
   * Setups the phong specific node variables.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  setupVariants() {
    const e = (this.shininessNode ? J(this.shininessNode) : hD).max(1e-4);
    a_.assign(e);
    const t = this.specularNode || fD;
    Yu.assign(t);
  }
  copy(e) {
    return this.shininessNode = e.shininessNode, this.specularNode = e.specularNode, super.copy(e);
  }
}
const cL = /* @__PURE__ */ pe((i) => {
  if (i.geometry.hasAttribute("normal") === !1)
    return J(0);
  const e = Yf.dFdx().abs().max(Yf.dFdy().abs());
  return e.x.max(e.y).max(e.z);
}), VT = /* @__PURE__ */ pe((i) => {
  const { roughness: e } = i, t = cL();
  let n = e.max(0.0525);
  return n = n.add(t), n = n.min(1), n;
}), hL = /* @__PURE__ */ pe(({ alpha: i, dotNL: e, dotNV: t }) => {
  const n = i.pow2(), r = e.mul(n.add(n.oneMinus().mul(t.pow2())).sqrt()), s = t.mul(n.add(n.oneMinus().mul(e.pow2())).sqrt());
  return Ro(0.5, r.add(s).max(JS));
}).setLayout({
  name: "V_GGX_SmithCorrelated",
  type: "float",
  inputs: [
    { name: "alpha", type: "float" },
    { name: "dotNL", type: "float" },
    { name: "dotNV", type: "float" }
  ]
}), HJ = /* @__PURE__ */ pe(({ alphaT: i, alphaB: e, dotTV: t, dotBV: n, dotTL: r, dotBL: s, dotNV: o, dotNL: a }) => {
  const l = a.mul(ce(i.mul(t), e.mul(n), o).length()), u = o.mul(ce(i.mul(r), e.mul(s), a).length());
  return Ro(0.5, l.add(u));
}).setLayout({
  name: "V_GGX_SmithCorrelated_Anisotropic",
  type: "float",
  inputs: [
    { name: "alphaT", type: "float", qualifier: "in" },
    { name: "alphaB", type: "float", qualifier: "in" },
    { name: "dotTV", type: "float", qualifier: "in" },
    { name: "dotBV", type: "float", qualifier: "in" },
    { name: "dotTL", type: "float", qualifier: "in" },
    { name: "dotBL", type: "float", qualifier: "in" },
    { name: "dotNV", type: "float", qualifier: "in" },
    { name: "dotNL", type: "float", qualifier: "in" }
  ]
}), dL = /* @__PURE__ */ pe(({ alpha: i, dotNH: e }) => {
  const t = i.pow2(), n = e.pow2().mul(t.oneMinus()).oneMinus();
  return t.div(n.pow2()).mul(1 / Math.PI);
}).setLayout({
  name: "D_GGX",
  type: "float",
  inputs: [
    { name: "alpha", type: "float" },
    { name: "dotNH", type: "float" }
  ]
}), WJ = /* @__PURE__ */ J(1 / Math.PI), $J = /* @__PURE__ */ pe(({ alphaT: i, alphaB: e, dotNH: t, dotTH: n, dotBH: r }) => {
  const s = i.mul(e), o = ce(e.mul(n), i.mul(r), s.mul(t)), a = o.dot(o), l = s.div(a);
  return WJ.mul(s.mul(l.pow2()));
}).setLayout({
  name: "D_GGX_Anisotropic",
  type: "float",
  inputs: [
    { name: "alphaT", type: "float", qualifier: "in" },
    { name: "alphaB", type: "float", qualifier: "in" },
    { name: "dotNH", type: "float", qualifier: "in" },
    { name: "dotTH", type: "float", qualifier: "in" },
    { name: "dotBH", type: "float", qualifier: "in" }
  ]
}), GT = /* @__PURE__ */ pe(({ lightDirection: i, f0: e, f90: t, roughness: n, f: r, normalView: s = Gn, USE_IRIDESCENCE: o, USE_ANISOTROPY: a }) => {
  const l = n.pow2(), u = i.add(gi).normalize(), c = s.dot(i).clamp(), A = s.dot(gi).clamp(), m = s.dot(u).clamp(), _ = gi.dot(u).clamp();
  let y = Qf({ f0: e, f90: t, dotVH: _ }), T, b;
  if (r0(o) && (y = N2.mix(y, r)), r0(a)) {
    const S = Pp.dot(i), E = Pp.dot(gi), R = Pp.dot(u), C = hh.dot(i), L = hh.dot(gi), D = hh.dot(u);
    T = HJ({ alphaT: o_, alphaB: l, dotTV: E, dotBV: L, dotTL: S, dotBL: C, dotNV: A, dotNL: c }), b = $J({ alphaT: o_, alphaB: l, dotNH: m, dotTH: R, dotBH: D });
  } else
    T = hL({ alpha: l, dotNL: c, dotNV: A }), b = dL({ alpha: l, dotNH: m });
  return y.mul(T).mul(b);
}), jJ = new Uint16Array([
  12469,
  15057,
  12620,
  14925,
  13266,
  14620,
  13807,
  14376,
  14323,
  13990,
  14545,
  13625,
  14713,
  13328,
  14840,
  12882,
  14931,
  12528,
  14996,
  12233,
  15039,
  11829,
  15066,
  11525,
  15080,
  11295,
  15085,
  10976,
  15082,
  10705,
  15073,
  10495,
  13880,
  14564,
  13898,
  14542,
  13977,
  14430,
  14158,
  14124,
  14393,
  13732,
  14556,
  13410,
  14702,
  12996,
  14814,
  12596,
  14891,
  12291,
  14937,
  11834,
  14957,
  11489,
  14958,
  11194,
  14943,
  10803,
  14921,
  10506,
  14893,
  10278,
  14858,
  9960,
  14484,
  14039,
  14487,
  14025,
  14499,
  13941,
  14524,
  13740,
  14574,
  13468,
  14654,
  13106,
  14743,
  12678,
  14818,
  12344,
  14867,
  11893,
  14889,
  11509,
  14893,
  11180,
  14881,
  10751,
  14852,
  10428,
  14812,
  10128,
  14765,
  9754,
  14712,
  9466,
  14764,
  13480,
  14764,
  13475,
  14766,
  13440,
  14766,
  13347,
  14769,
  13070,
  14786,
  12713,
  14816,
  12387,
  14844,
  11957,
  14860,
  11549,
  14868,
  11215,
  14855,
  10751,
  14825,
  10403,
  14782,
  10044,
  14729,
  9651,
  14666,
  9352,
  14599,
  9029,
  14967,
  12835,
  14966,
  12831,
  14963,
  12804,
  14954,
  12723,
  14936,
  12564,
  14917,
  12347,
  14900,
  11958,
  14886,
  11569,
  14878,
  11247,
  14859,
  10765,
  14828,
  10401,
  14784,
  10011,
  14727,
  9600,
  14660,
  9289,
  14586,
  8893,
  14508,
  8533,
  15111,
  12234,
  15110,
  12234,
  15104,
  12216,
  15092,
  12156,
  15067,
  12010,
  15028,
  11776,
  14981,
  11500,
  14942,
  11205,
  14902,
  10752,
  14861,
  10393,
  14812,
  9991,
  14752,
  9570,
  14682,
  9252,
  14603,
  8808,
  14519,
  8445,
  14431,
  8145,
  15209,
  11449,
  15208,
  11451,
  15202,
  11451,
  15190,
  11438,
  15163,
  11384,
  15117,
  11274,
  15055,
  10979,
  14994,
  10648,
  14932,
  10343,
  14871,
  9936,
  14803,
  9532,
  14729,
  9218,
  14645,
  8742,
  14556,
  8381,
  14461,
  8020,
  14365,
  7603,
  15273,
  10603,
  15272,
  10607,
  15267,
  10619,
  15256,
  10631,
  15231,
  10614,
  15182,
  10535,
  15118,
  10389,
  15042,
  10167,
  14963,
  9787,
  14883,
  9447,
  14800,
  9115,
  14710,
  8665,
  14615,
  8318,
  14514,
  7911,
  14411,
  7507,
  14279,
  7198,
  15314,
  9675,
  15313,
  9683,
  15309,
  9712,
  15298,
  9759,
  15277,
  9797,
  15229,
  9773,
  15166,
  9668,
  15084,
  9487,
  14995,
  9274,
  14898,
  8910,
  14800,
  8539,
  14697,
  8234,
  14590,
  7790,
  14479,
  7409,
  14367,
  7067,
  14178,
  6621,
  15337,
  8619,
  15337,
  8631,
  15333,
  8677,
  15325,
  8769,
  15305,
  8871,
  15264,
  8940,
  15202,
  8909,
  15119,
  8775,
  15022,
  8565,
  14916,
  8328,
  14804,
  8009,
  14688,
  7614,
  14569,
  7287,
  14448,
  6888,
  14321,
  6483,
  14088,
  6171,
  15350,
  7402,
  15350,
  7419,
  15347,
  7480,
  15340,
  7613,
  15322,
  7804,
  15287,
  7973,
  15229,
  8057,
  15148,
  8012,
  15046,
  7846,
  14933,
  7611,
  14810,
  7357,
  14682,
  7069,
  14552,
  6656,
  14421,
  6316,
  14251,
  5948,
  14007,
  5528,
  15356,
  5942,
  15356,
  5977,
  15353,
  6119,
  15348,
  6294,
  15332,
  6551,
  15302,
  6824,
  15249,
  7044,
  15171,
  7122,
  15070,
  7050,
  14949,
  6861,
  14818,
  6611,
  14679,
  6349,
  14538,
  6067,
  14398,
  5651,
  14189,
  5311,
  13935,
  4958,
  15359,
  4123,
  15359,
  4153,
  15356,
  4296,
  15353,
  4646,
  15338,
  5160,
  15311,
  5508,
  15263,
  5829,
  15188,
  6042,
  15088,
  6094,
  14966,
  6001,
  14826,
  5796,
  14678,
  5543,
  14527,
  5287,
  14377,
  4985,
  14133,
  4586,
  13869,
  4257,
  15360,
  1563,
  15360,
  1642,
  15358,
  2076,
  15354,
  2636,
  15341,
  3350,
  15317,
  4019,
  15273,
  4429,
  15203,
  4732,
  15105,
  4911,
  14981,
  4932,
  14836,
  4818,
  14679,
  4621,
  14517,
  4386,
  14359,
  4156,
  14083,
  3795,
  13808,
  3437,
  15360,
  122,
  15360,
  137,
  15358,
  285,
  15355,
  636,
  15344,
  1274,
  15322,
  2177,
  15281,
  2765,
  15215,
  3223,
  15120,
  3451,
  14995,
  3569,
  14846,
  3567,
  14681,
  3466,
  14511,
  3305,
  14344,
  3121,
  14037,
  2800,
  13753,
  2467,
  15360,
  0,
  15360,
  1,
  15359,
  21,
  15355,
  89,
  15346,
  253,
  15325,
  479,
  15287,
  796,
  15225,
  1148,
  15133,
  1492,
  15008,
  1749,
  14856,
  1882,
  14685,
  1886,
  14506,
  1783,
  14324,
  1608,
  13996,
  1398,
  13702,
  1183
]);
let Ba = null;
const l0 = /* @__PURE__ */ pe(({ roughness: i, dotNV: e }) => {
  Ba === null && (Ba = new wo(jJ, 16, 16, fs, Ri), Ba.name = "DFG_LUT", Ba.minFilter = qn, Ba.magFilter = qn, Ba.wrapS = xr, Ba.wrapT = xr, Ba.generateMipmaps = !1, Ba.needsUpdate = !0);
  const t = Xe(i, e);
  return Wn(Ba, t).rg;
}), XJ = /* @__PURE__ */ pe(({ lightDirection: i, f0: e, f90: t, roughness: n, f: r, USE_IRIDESCENCE: s, USE_ANISOTROPY: o }) => {
  const a = GT({ lightDirection: i, f0: e, f90: t, roughness: n, f: r, USE_IRIDESCENCE: s, USE_ANISOTROPY: o }), l = Gn.dot(i).clamp(), u = Gn.dot(gi).clamp(), c = l0({ roughness: n, dotNV: u }), A = l0({ roughness: n, dotNV: l }), m = e.mul(c.x).add(t.mul(c.y)), _ = e.mul(A.x).add(t.mul(A.y)), y = c.x.add(c.y), T = A.x.add(A.y), b = J(1).sub(y), S = J(1).sub(T), E = e.add(e.oneMinus().mul(0.047619)), R = m.mul(_).mul(E).div(J(1).sub(b.mul(S).mul(E).mul(E)).add(JS)), C = b.mul(S), L = R.mul(C);
  return a.add(L);
}), fL = /* @__PURE__ */ pe((i) => {
  const { dotNV: e, specularColor: t, specularF90: n, roughness: r } = i, s = l0({ dotNV: e, roughness: r });
  return t.mul(s.x).add(n.mul(s.y));
}), jb = /* @__PURE__ */ pe(({ f: i, f90: e, dotVH: t }) => {
  const n = t.oneMinus().saturate(), r = n.mul(n), s = n.mul(r, r).clamp(0, 0.9999);
  return i.sub(ce(e).mul(s)).div(s.oneMinus());
}).setLayout({
  name: "Schlick_to_F0",
  type: "vec3",
  inputs: [
    { name: "f", type: "vec3" },
    { name: "f90", type: "float" },
    { name: "dotVH", type: "float" }
  ]
}), YJ = /* @__PURE__ */ pe(({ roughness: i, dotNH: e }) => {
  const t = i.pow2(), n = J(1).div(t), s = e.pow2().oneMinus().max(78125e-7);
  return J(2).add(n).mul(s.pow(n.mul(0.5))).div(2 * Math.PI);
}).setLayout({
  name: "D_Charlie",
  type: "float",
  inputs: [
    { name: "roughness", type: "float" },
    { name: "dotNH", type: "float" }
  ]
}), QJ = /* @__PURE__ */ pe(({ dotNV: i, dotNL: e }) => J(1).div(J(4).mul(e.add(i).sub(e.mul(i))))).setLayout({
  name: "V_Neubelt",
  type: "float",
  inputs: [
    { name: "dotNV", type: "float" },
    { name: "dotNL", type: "float" }
  ]
}), KJ = /* @__PURE__ */ pe(({ lightDirection: i }) => {
  const e = i.add(gi).normalize(), t = Gn.dot(i).clamp(), n = Gn.dot(gi).clamp(), r = Gn.dot(e).clamp(), s = YJ({ roughness: Ru, dotNH: r }), o = QJ({ dotNV: n, dotNL: t });
  return go.mul(s).mul(o);
}), ZJ = /* @__PURE__ */ pe(({ N: i, V: e, roughness: t }) => {
  const s = 78125e-7, o = i.dot(e).saturate(), a = Xe(t, o.oneMinus().sqrt());
  return a.assign(a.mul(0.984375).add(s)), a;
}).setLayout({
  name: "LTC_Uv",
  type: "vec2",
  inputs: [
    { name: "N", type: "vec3" },
    { name: "V", type: "vec3" },
    { name: "roughness", type: "float" }
  ]
}), JJ = /* @__PURE__ */ pe(({ f: i }) => {
  const e = i.length();
  return qi(e.mul(e).add(i.z).div(e.add(1)), 0);
}).setLayout({
  name: "LTC_ClippedSphereFormFactor",
  type: "float",
  inputs: [
    { name: "f", type: "vec3" }
  ]
}), hg = /* @__PURE__ */ pe(({ v1: i, v2: e }) => {
  const t = i.dot(e), n = t.abs().toVar(), r = n.mul(0.0145206).add(0.4965155).mul(n).add(0.8543985).toVar(), s = n.add(4.1616724).mul(n).add(3.417594).toVar(), o = r.div(s), a = t.greaterThan(0).select(o, qi(t.mul(t).oneMinus(), 1e-7).inverseSqrt().mul(0.5).sub(o));
  return i.cross(e).mul(a);
}).setLayout({
  name: "LTC_EdgeVectorFormFactor",
  type: "vec3",
  inputs: [
    { name: "v1", type: "vec3" },
    { name: "v2", type: "vec3" }
  ]
}), NR = /* @__PURE__ */ pe(({ N: i, V: e, P: t, mInv: n, p0: r, p1: s, p2: o, p3: a }) => {
  const l = s.sub(r).toVar(), u = a.sub(r).toVar(), c = l.cross(u), A = ce().toVar();
  return Ot(c.dot(t.sub(r)).greaterThanEqual(0), () => {
    const m = e.sub(i.mul(e.dot(i))).normalize(), _ = i.cross(m).negate(), y = n.mul(Kr(m, _, i).transpose()).toVar(), T = y.mul(r.sub(t)).normalize().toVar(), b = y.mul(s.sub(t)).normalize().toVar(), S = y.mul(o.sub(t)).normalize().toVar(), E = y.mul(a.sub(t)).normalize().toVar(), R = ce(0).toVar();
    R.addAssign(hg({ v1: T, v2: b })), R.addAssign(hg({ v1: b, v2: S })), R.addAssign(hg({ v1: S, v2: E })), R.addAssign(hg({ v1: E, v2: T })), A.assign(ce(JJ({ f: R })));
  }), A;
}).setLayout({
  name: "LTC_Evaluate",
  type: "vec3",
  inputs: [
    { name: "N", type: "vec3" },
    { name: "V", type: "vec3" },
    { name: "P", type: "vec3" },
    { name: "mInv", type: "mat3" },
    { name: "p0", type: "vec3" },
    { name: "p1", type: "vec3" },
    { name: "p2", type: "vec3" },
    { name: "p3", type: "vec3" }
  ]
}), j2 = 1 / 6, AL = (i) => sn(j2, sn(i, sn(i, i.negate().add(3)).sub(3)).add(1)), Xb = (i) => sn(j2, sn(i, sn(i, sn(3, i).sub(6))).add(4)), pL = (i) => sn(j2, sn(i, sn(i, sn(-3, i).add(3)).add(3)).add(1)), Yb = (i) => sn(j2, ko(i, 3)), DR = (i) => AL(i).add(Xb(i)), LR = (i) => pL(i).add(Yb(i)), IR = (i) => sr(-1, Xb(i).div(AL(i).add(Xb(i)))), BR = (i) => sr(1, Yb(i).div(pL(i).add(Yb(i)))), FR = (i, e, t) => {
  const n = i.uvNode, r = sn(n, e.zw).add(0.5), s = Ja(r), o = ba(r), a = DR(o.x), l = LR(o.x), u = IR(o.x), c = BR(o.x), A = IR(o.y), m = BR(o.y), _ = Xe(s.x.add(u), s.y.add(A)).sub(0.5).mul(e.xy), y = Xe(s.x.add(c), s.y.add(A)).sub(0.5).mul(e.xy), T = Xe(s.x.add(u), s.y.add(m)).sub(0.5).mul(e.xy), b = Xe(s.x.add(c), s.y.add(m)).sub(0.5).mul(e.xy), S = DR(o.y).mul(sr(a.mul(i.sample(_).level(t)), l.mul(i.sample(y).level(t)))), E = LR(o.y).mul(sr(a.mul(i.sample(T).level(t)), l.mul(i.sample(b).level(t))));
  return S.add(E);
}, zT = /* @__PURE__ */ pe(([i, e]) => {
  const t = Xe(i.size(le(e))), n = Xe(i.size(le(e.add(1)))), r = Ro(1, t), s = Ro(1, n), o = FR(i, Gt(r, t), Ja(e)), a = FR(i, Gt(s, n), I2(e));
  return ba(e).mix(o, a);
}), eee = /* @__PURE__ */ pe(([i, e]) => {
  const t = e.mul(yT(i));
  return zT(i, t);
}), UR = /* @__PURE__ */ pe(([i, e, t, n, r]) => {
  const s = ce(dT(e.negate(), Fs(i), Ro(1, n))), o = ce(
    el(r[0].xyz),
    el(r[1].xyz),
    el(r[2].xyz)
  );
  return Fs(s).mul(t.mul(o));
}).setLayout({
  name: "getVolumeTransmissionRay",
  type: "vec3",
  inputs: [
    { name: "n", type: "vec3" },
    { name: "v", type: "vec3" },
    { name: "thickness", type: "float" },
    { name: "ior", type: "float" },
    { name: "modelMatrix", type: "mat4" }
  ]
}), tee = /* @__PURE__ */ pe(([i, e]) => i.mul(Sa(e.mul(2).sub(2), 0, 1))).setLayout({
  name: "applyIorToRoughness",
  type: "float",
  inputs: [
    { name: "roughness", type: "float" },
    { name: "ior", type: "float" }
  ]
}), nee = /* @__PURE__ */ LT(), iee = /* @__PURE__ */ LT(), OR = /* @__PURE__ */ pe(([i, e, t], { material: n }) => {
  const s = (n.side === si ? nee : iee).sample(i), o = Za(jh.x).mul(tee(e, t));
  return zT(s, o);
}), kR = /* @__PURE__ */ pe(([i, e, t]) => (Ot(t.notEqual(0), () => {
  const n = L2(e).negate().div(t);
  return eT(n.negate().mul(i));
}), ce(1))).setLayout({
  name: "volumeAttenuation",
  type: "vec3",
  inputs: [
    { name: "transmissionDistance", type: "float" },
    { name: "attenuationColor", type: "vec3" },
    { name: "attenuationDistance", type: "float" }
  ]
}), ree = /* @__PURE__ */ pe(([i, e, t, n, r, s, o, a, l, u, c, A, m, _, y]) => {
  let T, b;
  if (y) {
    T = Gt().toVar(), b = ce().toVar();
    const L = c.sub(1).mul(y.mul(0.025)), D = ce(c.sub(L), c, c.add(L));
    ri({ start: 0, end: 3 }, ({ i: B }) => {
      const U = D.element(B), N = UR(i, e, A, U, a), O = o.add(N), G = u.mul(l.mul(Gt(O, 1))), H = Xe(G.xy.div(G.w)).toVar();
      H.addAssign(1), H.divAssign(2), H.assign(Xe(H.x, H.y.oneMinus()));
      const Y = OR(H, t, U);
      T.element(B).assign(Y.element(B)), T.a.addAssign(Y.a), b.element(B).assign(n.element(B).mul(kR(el(N), m, _).element(B)));
    }), T.a.divAssign(3);
  } else {
    const L = UR(i, e, A, c, a), D = o.add(L), B = u.mul(l.mul(Gt(D, 1))), U = Xe(B.xy.div(B.w)).toVar();
    U.addAssign(1), U.divAssign(2), U.assign(Xe(U.x, U.y.oneMinus())), T = OR(U, t, c), b = n.mul(kR(el(L), m, _));
  }
  const S = b.rgb.mul(T.rgb), E = i.dot(e).clamp(), R = ce(fL({
    // n, v, specularColor, specularF90, roughness
    dotNV: E,
    specularColor: r,
    specularF90: s,
    roughness: t
  })), C = b.r.add(b.g, b.b).div(3);
  return Gt(R.oneMinus().mul(S), T.a.oneMinus().mul(C).oneMinus());
}), see = /* @__PURE__ */ Kr(
  3.2404542,
  -0.969266,
  0.0556434,
  -1.5371385,
  1.8760108,
  -0.2040259,
  -0.4985314,
  0.041556,
  1.0572252
), oee = (i) => {
  const e = i.sqrt();
  return ce(1).add(e).div(ce(1).sub(e));
}, VR = (i, e) => i.sub(e).div(i.add(e)).pow2(), aee = (i, e) => {
  const t = i.mul(2 * Math.PI * 1e-9), n = ce(54856e-17, 44201e-17, 52481e-17), r = ce(1681e3, 1795300, 2208400), s = ce(43278e5, 93046e5, 66121e5), o = J(9747e-17 * Math.sqrt(2 * Math.PI * 45282e5)).mul(t.mul(2239900).add(e.x).cos()).mul(t.pow2().mul(-45282e5).exp());
  let a = n.mul(s.mul(2 * Math.PI).sqrt()).mul(r.mul(t).add(e).cos()).mul(t.pow2().negate().mul(s).exp());
  return a = ce(a.x.add(o), a.y, a.z).div(10685e-11), see.mul(a);
}, GR = /* @__PURE__ */ pe(({ outsideIOR: i, eta2: e, cosTheta1: t, thinFilmThickness: n, baseF0: r }) => {
  const s = Bn(i, e, Ta(0, 0.03, n)), a = i.div(s).pow2().mul(t.pow2().oneMinus()).oneMinus();
  Ot(a.lessThan(0), () => ce(1));
  const l = a.sqrt(), u = VR(s, i), c = Qf({ f0: u, f90: 1, dotVH: t }), A = c.oneMinus(), m = s.lessThan(i).select(Math.PI, 0), _ = J(Math.PI).sub(m), y = oee(r.clamp(0, 0.9999)), T = VR(y, s.toVec3()), b = Qf({ f0: T, f90: 1, dotVH: l }), S = ce(
    y.x.lessThan(s).select(Math.PI, 0),
    y.y.lessThan(s).select(Math.PI, 0),
    y.z.lessThan(s).select(Math.PI, 0)
  ), E = s.mul(n, l, 2), R = ce(_).add(S), C = c.mul(b).clamp(1e-5, 0.9999), L = C.sqrt(), D = A.pow2().mul(b).div(ce(1).sub(C)), U = c.add(D).toVar(), N = D.sub(A).toVar();
  return ri({ start: 1, end: 2, condition: "<=", name: "m" }, ({ m: O }) => {
    N.mulAssign(L);
    const G = aee(J(O).mul(E), J(O).mul(R)).mul(2);
    U.addAssign(N.mul(G));
  }), U.max(ce(0));
}).setLayout({
  name: "evalIridescence",
  type: "vec3",
  inputs: [
    { name: "outsideIOR", type: "float" },
    { name: "eta2", type: "float" },
    { name: "cosTheta1", type: "float" },
    { name: "thinFilmThickness", type: "float" },
    { name: "baseF0", type: "vec3" }
  ]
}), WA = /* @__PURE__ */ pe(({ normal: i, viewDir: e, roughness: t }) => {
  const n = i.dot(e).saturate(), r = t.mul(t), s = t.add(0.1).reciprocal(), o = J(-1.9362).add(t.mul(1.0678)).add(r.mul(0.4573)).sub(s.mul(0.8469)), a = J(-0.6014).add(t.mul(0.5538)).sub(r.mul(0.467)).sub(s.mul(0.1255));
  return o.mul(n).add(a).exp().saturate();
}), $y = ce(0.04), jy = J(1);
class mL extends $2 {
  /**
   * Constructs a new physical lighting model.
   *
   * @param {boolean} [clearcoat=false] - Whether clearcoat is supported or not.
   * @param {boolean} [sheen=false] - Whether sheen is supported or not.
   * @param {boolean} [iridescence=false] - Whether iridescence is supported or not.
   * @param {boolean} [anisotropy=false] - Whether anisotropy is supported or not.
   * @param {boolean} [transmission=false] - Whether transmission is supported or not.
   * @param {boolean} [dispersion=false] - Whether dispersion is supported or not.
   */
  constructor(e = !1, t = !1, n = !1, r = !1, s = !1, o = !1) {
    super(), this.clearcoat = e, this.sheen = t, this.iridescence = n, this.anisotropy = r, this.transmission = s, this.dispersion = o, this.clearcoatRadiance = null, this.clearcoatSpecularDirect = null, this.clearcoatSpecularIndirect = null, this.sheenSpecularDirect = null, this.sheenSpecularIndirect = null, this.iridescenceFresnel = null, this.iridescenceF0 = null, this.iridescenceF0Dielectric = null, this.iridescenceF0Metallic = null;
  }
  /**
   * Depending on what features are requested, the method prepares certain node variables
   * which are later used for lighting computations.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  start(e) {
    if (this.clearcoat === !0 && (this.clearcoatRadiance = ce().toVar("clearcoatRadiance"), this.clearcoatSpecularDirect = ce().toVar("clearcoatSpecularDirect"), this.clearcoatSpecularIndirect = ce().toVar("clearcoatSpecularIndirect")), this.sheen === !0 && (this.sheenSpecularDirect = ce().toVar("sheenSpecularDirect"), this.sheenSpecularIndirect = ce().toVar("sheenSpecularIndirect")), this.iridescence === !0) {
      const t = Gn.dot(gi).clamp(), n = GR({
        outsideIOR: J(1),
        eta2: r_,
        cosTheta1: t,
        thinFilmThickness: s_,
        baseF0: Yu
      }), r = GR({
        outsideIOR: J(1),
        eta2: r_,
        cosTheta1: t,
        thinFilmThickness: s_,
        baseF0: ni.rgb
      });
      this.iridescenceFresnel = Bn(n, r, El), this.iridescenceF0Dielectric = jb({ f: n, f90: 1, dotVH: t }), this.iridescenceF0Metallic = jb({ f: r, f90: 1, dotVH: t }), this.iridescenceF0 = Bn(this.iridescenceF0Dielectric, this.iridescenceF0Metallic, El);
    }
    if (this.transmission === !0) {
      const t = tl, n = U6.sub(tl).normalize(), r = oc, s = e.context;
      s.backdrop = ree(
        r,
        n,
        Ha,
        Hc,
        nh,
        xf,
        // specularF90
        t,
        // positionWorld
        Vo,
        // modelMatrix
        ea,
        // viewMatrix
        Ol,
        // projMatrix
        Np,
        $S,
        XS,
        jS,
        this.dispersion ? YS : null
      ), s.backdropAlpha = l_, ni.a.mulAssign(Bn(1, s.backdrop.a, l_));
    }
    super.start(e);
  }
  // Fdez-Agera's "Multiple-Scattering Microfacet Model for Real-Time Image Based Lighting"
  // Approximates multi-scattering in order to preserve energy.
  // http://www.jcgt.org/published/0008/01/03/
  computeMultiscattering(e, t, n, r, s = null) {
    const o = Gn.dot(gi).clamp(), a = l0({ roughness: Ha, dotNV: o }), l = s ? N2.mix(r, s) : r, u = l.mul(a.x).add(n.mul(a.y)), A = a.x.add(a.y).oneMinus(), m = l.add(l.oneMinus().mul(0.047619)), _ = u.mul(m).div(A.mul(m).oneMinus());
    e.addAssign(u), t.addAssign(_.mul(A));
  }
  /**
   * Implements the direct light.
   *
   * @param {Object} lightData - The light data.
   * @param {NodeBuilder} builder - The current node builder.
   */
  direct({ lightDirection: e, lightColor: t, reflectedLight: n }) {
    const s = Gn.dot(e).clamp().mul(t).toVar();
    if (this.sheen === !0) {
      this.sheenSpecularDirect.addAssign(s.mul(KJ({ lightDirection: e })));
      const o = WA({ normal: Gn, viewDir: gi, roughness: Ru }), a = WA({ normal: Gn, viewDir: e, roughness: Ru }), l = go.r.max(go.g).max(go.b).mul(o.max(a)).oneMinus();
      s.mulAssign(l);
    }
    if (this.clearcoat === !0) {
      const a = ih.dot(e).clamp().mul(t);
      this.clearcoatSpecularDirect.addAssign(a.mul(GT({ lightDirection: e, f0: $y, f90: jy, roughness: a0, normalView: ih })));
    }
    n.directDiffuse.addAssign(s.mul(Xh({ diffuseColor: Hc }))), n.directSpecular.addAssign(s.mul(XJ({ lightDirection: e, f0: nh, f90: 1, roughness: Ha, f: this.iridescenceFresnel, USE_IRIDESCENCE: this.iridescence, USE_ANISOTROPY: this.anisotropy })));
  }
  /**
   * This method is intended for implementing the direct light term for
   * rect area light nodes.
   *
   * @param {Object} input - The input data.
   * @param {NodeBuilder} builder - The current node builder.
   */
  directRectArea({ lightColor: e, lightPosition: t, halfWidth: n, halfHeight: r, reflectedLight: s, ltc_1: o, ltc_2: a }) {
    const l = t.add(n).sub(r), u = t.sub(n).sub(r), c = t.sub(n).add(r), A = t.add(n).add(r), m = Gn, _ = gi, y = tr.toVar(), T = ZJ({ N: m, V: _, roughness: Ha }), b = o.sample(T).toVar(), S = a.sample(T).toVar(), E = Kr(
      ce(b.x, 0, b.y),
      ce(0, 1, 0),
      ce(b.z, 0, b.w)
    ).toVar(), R = nh.mul(S.x).add(nh.oneMinus().mul(S.y)).toVar();
    s.directSpecular.addAssign(e.mul(R).mul(NR({ N: m, V: _, P: y, mInv: E, p0: l, p1: u, p2: c, p3: A }))), s.directDiffuse.addAssign(e.mul(Hc).mul(NR({ N: m, V: _, P: y, mInv: Kr(1, 0, 0, 0, 1, 0, 0, 0, 1), p0: l, p1: u, p2: c, p3: A })));
  }
  /**
   * Implements the indirect lighting.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  indirect(e) {
    this.indirectDiffuse(e), this.indirectSpecular(e), this.ambientOcclusion(e);
  }
  /**
   * Implements the indirect diffuse term.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  indirectDiffuse(e) {
    const { irradiance: t, reflectedLight: n } = e.context, r = t.mul(Xh({ diffuseColor: Hc })).toVar();
    if (this.sheen === !0) {
      const s = WA({ normal: Gn, viewDir: gi, roughness: Ru }), o = go.r.max(go.g).max(go.b).mul(s).oneMinus();
      r.mulAssign(o);
    }
    n.indirectDiffuse.addAssign(r);
  }
  /**
   * Implements the indirect specular term.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  indirectSpecular(e) {
    const { radiance: t, iblIrradiance: n, reflectedLight: r } = e.context;
    if (this.sheen === !0 && this.sheenSpecularIndirect.addAssign(n.mul(
      go,
      WA({
        normal: Gn,
        viewDir: gi,
        roughness: Ru
      })
    )), this.clearcoat === !0) {
      const b = ih.dot(gi).clamp(), S = fL({
        dotNV: b,
        specularColor: $y,
        specularF90: jy,
        roughness: a0
      });
      this.clearcoatSpecularIndirect.addAssign(this.clearcoatRadiance.mul(S));
    }
    const s = ce().toVar("singleScatteringDielectric"), o = ce().toVar("multiScatteringDielectric"), a = ce().toVar("singleScatteringMetallic"), l = ce().toVar("multiScatteringMetallic");
    this.computeMultiscattering(s, o, xf, Yu, this.iridescenceF0Dielectric), this.computeMultiscattering(a, l, xf, ni.rgb, this.iridescenceF0Metallic);
    const u = Bn(s, a, El), c = Bn(o, l, El), A = s.add(o), m = Hc.mul(A.oneMinus()), _ = n.mul(1 / Math.PI), y = t.mul(u).add(c.mul(_)).toVar(), T = m.mul(_).toVar();
    if (this.sheen === !0) {
      const b = WA({ normal: Gn, viewDir: gi, roughness: Ru }), S = go.r.max(go.g).max(go.b).mul(b).oneMinus();
      y.mulAssign(S), T.mulAssign(S);
    }
    r.indirectSpecular.addAssign(y), r.indirectDiffuse.addAssign(T);
  }
  /**
   * Implements the ambient occlusion term.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  ambientOcclusion(e) {
    const { ambientOcclusion: t, reflectedLight: n } = e.context, s = Gn.dot(gi).clamp().add(t), o = Ha.mul(-16).oneMinus().negate().exp2(), a = t.sub(s.pow(o).oneMinus()).clamp();
    this.clearcoat === !0 && this.clearcoatSpecularIndirect.mulAssign(t), this.sheen === !0 && this.sheenSpecularIndirect.mulAssign(t), n.indirectDiffuse.mulAssign(t), n.indirectSpecular.mulAssign(a);
  }
  /**
   * Used for final lighting accumulations depending on the requested features.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  finish({ context: e }) {
    const { outgoingLight: t } = e;
    if (this.clearcoat === !0) {
      const n = ih.dot(gi).clamp(), r = Qf({
        dotVH: n,
        f0: $y,
        f90: jy
      }), s = t.mul(i_.mul(r).oneMinus()).add(this.clearcoatSpecularDirect.add(this.clearcoatSpecularIndirect).mul(i_));
      t.assign(s);
    }
    if (this.sheen === !0) {
      const n = t.add(this.sheenSpecularDirect, this.sheenSpecularIndirect.mul(1 / Math.PI));
      t.assign(n);
    }
  }
}
const zR = /* @__PURE__ */ J(1), Qb = /* @__PURE__ */ J(-2), dg = /* @__PURE__ */ J(0.8), Xy = /* @__PURE__ */ J(-1), fg = /* @__PURE__ */ J(0.4), Yy = /* @__PURE__ */ J(2), Ag = /* @__PURE__ */ J(0.305), Qy = /* @__PURE__ */ J(3), qR = /* @__PURE__ */ J(0.21), lee = /* @__PURE__ */ J(4), HR = /* @__PURE__ */ J(4), uee = /* @__PURE__ */ J(16), cee = /* @__PURE__ */ pe(([i]) => {
  const e = ce(vi(i)).toVar(), t = J(-1).toVar();
  return Ot(e.x.greaterThan(e.z), () => {
    Ot(e.x.greaterThan(e.y), () => {
      t.assign(Yr(i.x.greaterThan(0), 0, 3));
    }).Else(() => {
      t.assign(Yr(i.y.greaterThan(0), 1, 4));
    });
  }).Else(() => {
    Ot(e.z.greaterThan(e.y), () => {
      t.assign(Yr(i.z.greaterThan(0), 2, 5));
    }).Else(() => {
      t.assign(Yr(i.y.greaterThan(0), 1, 4));
    });
  }), t;
}).setLayout({
  name: "getFace",
  type: "float",
  inputs: [
    { name: "direction", type: "vec3" }
  ]
}), hee = /* @__PURE__ */ pe(([i, e]) => {
  const t = Xe().toVar();
  return Ot(e.equal(0), () => {
    t.assign(Xe(i.z, i.y).div(vi(i.x)));
  }).ElseIf(e.equal(1), () => {
    t.assign(Xe(i.x.negate(), i.z.negate()).div(vi(i.y)));
  }).ElseIf(e.equal(2), () => {
    t.assign(Xe(i.x.negate(), i.y).div(vi(i.z)));
  }).ElseIf(e.equal(3), () => {
    t.assign(Xe(i.z.negate(), i.y).div(vi(i.x)));
  }).ElseIf(e.equal(4), () => {
    t.assign(Xe(i.x.negate(), i.z).div(vi(i.y)));
  }).Else(() => {
    t.assign(Xe(i.x, i.y).div(vi(i.z)));
  }), sn(0.5, t.add(1));
}).setLayout({
  name: "getUV",
  type: "vec2",
  inputs: [
    { name: "direction", type: "vec3" },
    { name: "face", type: "float" }
  ]
}), dee = /* @__PURE__ */ pe(([i]) => {
  const e = J(0).toVar();
  return Ot(i.greaterThanEqual(dg), () => {
    e.assign(zR.sub(i).mul(Xy.sub(Qb)).div(zR.sub(dg)).add(Qb));
  }).ElseIf(i.greaterThanEqual(fg), () => {
    e.assign(dg.sub(i).mul(Yy.sub(Xy)).div(dg.sub(fg)).add(Xy));
  }).ElseIf(i.greaterThanEqual(Ag), () => {
    e.assign(fg.sub(i).mul(Qy.sub(Yy)).div(fg.sub(Ag)).add(Yy));
  }).ElseIf(i.greaterThanEqual(qR), () => {
    e.assign(Ag.sub(i).mul(lee.sub(Qy)).div(Ag.sub(qR)).add(Qy));
  }).Else(() => {
    e.assign(J(-2).mul(Za(sn(1.16, i))));
  }), e;
}).setLayout({
  name: "roughnessToMip",
  type: "float",
  inputs: [
    { name: "roughness", type: "float" }
  ]
}), gL = /* @__PURE__ */ pe(([i, e]) => {
  const t = i.toVar();
  t.assign(sn(2, t).sub(1));
  const n = ce(t, 1).toVar();
  return Ot(e.equal(0), () => {
    n.assign(n.zyx);
  }).ElseIf(e.equal(1), () => {
    n.assign(n.xzy), n.xz.mulAssign(-1);
  }).ElseIf(e.equal(2), () => {
    n.x.mulAssign(-1);
  }).ElseIf(e.equal(3), () => {
    n.assign(n.zyx), n.xz.mulAssign(-1);
  }).ElseIf(e.equal(4), () => {
    n.assign(n.xzy), n.xy.mulAssign(-1);
  }).ElseIf(e.equal(5), () => {
    n.z.mulAssign(-1);
  }), n;
}).setLayout({
  name: "getDirection",
  type: "vec3",
  inputs: [
    { name: "uv", type: "vec2" },
    { name: "face", type: "float" }
  ]
}), _L = /* @__PURE__ */ pe(([i, e, t, n, r, s]) => {
  const o = J(t), a = ce(e), l = Sa(dee(o), Qb, s), u = ba(l), c = Ja(l), A = ce(u0(i, a, c, n, r, s)).toVar();
  return Ot(u.notEqual(0), () => {
    const m = ce(u0(i, a, c.add(1), n, r, s)).toVar();
    A.assign(Bn(A, m, u));
  }), A;
}), u0 = /* @__PURE__ */ pe(([i, e, t, n, r, s]) => {
  const o = J(t).toVar(), a = ce(e), l = J(cee(a)).toVar(), u = J(qi(HR.sub(o), 0)).toVar();
  o.assign(qi(o, HR));
  const c = J(Xf(o)).toVar(), A = Xe(hee(a, l).mul(c.sub(2)).add(1)).toVar();
  return Ot(l.greaterThan(2), () => {
    A.y.addAssign(c), l.subAssign(3);
  }), A.x.addAssign(l.mul(c)), A.x.addAssign(u.mul(sn(3, uee))), A.y.addAssign(sn(4, Xf(s).sub(c))), A.x.mulAssign(n), A.y.mulAssign(r), i.sample(A).grad(Xe(), Xe());
}), Ky = /* @__PURE__ */ pe(({ envMap: i, mipInt: e, outputDirection: t, theta: n, axis: r, CUBEUV_TEXEL_WIDTH: s, CUBEUV_TEXEL_HEIGHT: o, CUBEUV_MAX_MIP: a }) => {
  const l = ha(n), u = t.mul(l).add(r.cross(t).mul(Ns(n))).add(r.mul(r.dot(t).mul(l.oneMinus())));
  return u0(i, u, e, s, o, a);
}), xL = /* @__PURE__ */ pe(({ n: i, latitudinal: e, poleAxis: t, outputDirection: n, weights: r, samples: s, dTheta: o, mipInt: a, envMap: l, CUBEUV_TEXEL_WIDTH: u, CUBEUV_TEXEL_HEIGHT: c, CUBEUV_MAX_MIP: A }) => {
  const m = ce(Yr(e, t, Kl(t, n))).toVar();
  Ot(m.equal(ce(0)), () => {
    m.assign(ce(n.z, 0, n.x.negate()));
  }), m.assign(Fs(m));
  const _ = ce().toVar();
  return _.addAssign(r.element(0).mul(Ky({ theta: 0, axis: m, outputDirection: n, mipInt: a, envMap: l, CUBEUV_TEXEL_WIDTH: u, CUBEUV_TEXEL_HEIGHT: c, CUBEUV_MAX_MIP: A }))), ri({ start: le(1), end: i }, ({ i: y }) => {
    Ot(y.greaterThanEqual(s), () => {
      XD();
    });
    const T = J(o.mul(J(y))).toVar();
    _.addAssign(r.element(y).mul(Ky({ theta: T.mul(-1), axis: m, outputDirection: n, mipInt: a, envMap: l, CUBEUV_TEXEL_WIDTH: u, CUBEUV_TEXEL_HEIGHT: c, CUBEUV_MAX_MIP: A }))), _.addAssign(r.element(y).mul(Ky({ theta: T, axis: m, outputDirection: n, mipInt: a, envMap: l, CUBEUV_TEXEL_WIDTH: u, CUBEUV_TEXEL_HEIGHT: c, CUBEUV_MAX_MIP: A })));
  }), Gt(_, 1);
}), fee = /* @__PURE__ */ pe(([i]) => {
  const e = Ge(i).toVar();
  return e.assign(e.shiftLeft(Ge(16)).bitOr(e.shiftRight(Ge(16)))), e.assign(e.bitAnd(Ge(1431655765)).shiftLeft(Ge(1)).bitOr(e.bitAnd(Ge(2863311530)).shiftRight(Ge(1)))), e.assign(e.bitAnd(Ge(858993459)).shiftLeft(Ge(2)).bitOr(e.bitAnd(Ge(3435973836)).shiftRight(Ge(2)))), e.assign(e.bitAnd(Ge(252645135)).shiftLeft(Ge(4)).bitOr(e.bitAnd(Ge(4042322160)).shiftRight(Ge(4)))), e.assign(e.bitAnd(Ge(16711935)).shiftLeft(Ge(8)).bitOr(e.bitAnd(Ge(4278255360)).shiftRight(Ge(8)))), J(e).mul(23283064365386963e-26);
}), Aee = /* @__PURE__ */ pe(([i, e]) => Xe(J(i).div(J(e)), fee(i))), pee = /* @__PURE__ */ pe(([i, e, t]) => {
  const n = ce(e).toVar(), r = J(t), s = r.mul(r).toVar(), o = Fs(ce(s.mul(n.x), s.mul(n.y), n.z)).toVar(), a = o.x.mul(o.x).add(o.y.mul(o.y)), l = Yr(a.greaterThan(0), ce(o.y.negate(), o.x, 0).div(ps(a)), ce(1, 0, 0)).toVar(), u = Kl(o, l).toVar(), c = ps(i.x), A = sn(2, 3.14159265359).mul(i.y), m = c.mul(ha(A)).toVar(), _ = c.mul(Ns(A)).toVar(), y = sn(0.5, o.z.add(1));
  _.assign(y.oneMinus().mul(ps(m.mul(m).oneMinus())).add(y.mul(_)));
  const T = l.mul(m).add(u.mul(_)).add(o.mul(ps(qi(0, m.mul(m).add(_.mul(_)).oneMinus()))));
  return Fs(ce(s.mul(T.x), s.mul(T.y), qi(0, T.z)));
}), yL = /* @__PURE__ */ pe(({ roughness: i, mipInt: e, envMap: t, N_immutable: n, GGX_SAMPLES: r, CUBEUV_TEXEL_WIDTH: s, CUBEUV_TEXEL_HEIGHT: o, CUBEUV_MAX_MIP: a }) => {
  const l = ce(n).toVar(), u = ce(0).toVar(), c = J(0).toVar();
  return Ot(i.lessThan(1e-3), () => {
    u.assign(u0(t, l, e, s, o, a));
  }).Else(() => {
    const A = Yr(vi(l.z).lessThan(0.999), ce(0, 0, 1), ce(1, 0, 0)), m = Fs(Kl(A, l)).toVar(), _ = Kl(l, m).toVar();
    ri({ start: Ge(0), end: r }, ({ i: y }) => {
      const T = Aee(y, r), b = pee(T, ce(0, 0, 1), i), S = Fs(m.mul(b.x).add(_.mul(b.y)).add(l.mul(b.z))), E = Fs(S.mul($o(l, S).mul(2)).sub(l)), R = qi($o(l, E), 0);
      Ot(R.greaterThan(0), () => {
        const C = u0(t, E, e, s, o, a);
        u.addAssign(C.mul(R)), c.addAssign(R);
      });
    }), Ot(c.greaterThan(0), () => {
      u.assign(u.div(c));
    });
  }), Gt(u, 1);
}), Fu = 4, WR = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582], Wc = 20, mee = 512, $A = /* @__PURE__ */ new ic(-1, 1, 1, -1, 0, 1), gee = /* @__PURE__ */ new Ji(90, 1), $R = /* @__PURE__ */ new ct();
let Zy = null, Jy = 0, ev = 0;
const _ee = /* @__PURE__ */ new j(), f_ = /* @__PURE__ */ new WeakMap(), xee = [
  3,
  1,
  5,
  0,
  4,
  2
], tv = /* @__PURE__ */ gL(hi(), Jl("faceIndex")).normalize(), X2 = /* @__PURE__ */ ce(tv.x, tv.y, tv.z);
class yee {
  /**
   * Constructs a new PMREM generator.
   *
   * @param {Renderer} renderer - The renderer.
   */
  constructor(e) {
    this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._sizeLods = [], this._sigmas = [], this._lodMeshes = [], this._blurMaterial = null, this._ggxMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._backgroundBox = null;
  }
  get _hasInitialized() {
    return this._renderer.hasInitialized();
  }
  /**
   * Generates a PMREM from a supplied Scene, which can be faster than using an
   * image if networking bandwidth is low. Optional sigma specifies a blur radius
   * in radians to be applied to the scene before PMREM generation. Optional near
   * and far planes ensure the scene is rendered in its entirety.
   *
   * @param {Scene} scene - The scene to be captured.
   * @param {number} [sigma=0] - The blur radius in radians.
   * @param {number} [near=0.1] - The near plane distance.
   * @param {number} [far=100] - The far plane distance.
   * @param {Object} [options={}] - The configuration options.
   * @param {number} [options.size=256] - The texture size of the PMREM.
   * @param {Vector3} [options.renderTarget=origin] - The position of the internal cube camera that renders the scene.
   * @param {?RenderTarget} [options.renderTarget=null] - The render target to use.
   * @return {RenderTarget} The resulting PMREM.
   * @see {@link PMREMGenerator#fromScene}
   */
  fromScene(e, t = 0, n = 0.1, r = 100, s = {}) {
    const {
      size: o = 256,
      position: a = _ee,
      renderTarget: l = null
    } = s;
    if (this._setSize(o), this._hasInitialized === !1) {
      Me('PMREMGenerator: ".fromScene()" called before the backend is initialized. Try using "await renderer.init()" instead.');
      const c = l || this._allocateTarget();
      return s.renderTarget = c, this.fromSceneAsync(e, t, n, r, s), c;
    }
    Zy = this._renderer.getRenderTarget(), Jy = this._renderer.getActiveCubeFace(), ev = this._renderer.getActiveMipmapLevel();
    const u = l || this._allocateTarget();
    return u.depthBuffer = !0, this._init(u), this._sceneToCubeUV(e, n, r, u, a), t > 0 && this._blur(u, 0, 0, t), this._applyPMREM(u), this._cleanup(u), u;
  }
  /**
   * Generates a PMREM from a supplied Scene, which can be faster than using an
   * image if networking bandwidth is low. Optional sigma specifies a blur radius
   * in radians to be applied to the scene before PMREM generation. Optional near
   * and far planes ensure the scene is rendered in its entirety (the cubeCamera
   * is placed at the origin).
   *
   * @deprecated
   * @param {Scene} scene - The scene to be captured.
   * @param {number} [sigma=0] - The blur radius in radians.
   * @param {number} [near=0.1] - The near plane distance.
   * @param {number} [far=100] - The far plane distance.
   * @param {Object} [options={}] - The configuration options.
   * @param {number} [options.size=256] - The texture size of the PMREM.
   * @param {Vector3} [options.position=origin] - The position of the internal cube camera that renders the scene.
   * @param {?RenderTarget} [options.renderTarget=null] - The render target to use.
   * @return {Promise<RenderTarget>} A Promise that resolve with the PMREM when the generation has been finished.
   * @see {@link PMREMGenerator#fromScene}
   */
  async fromSceneAsync(e, t = 0, n = 0.1, r = 100, s = {}) {
    return li('PMREMGenerator: ".fromSceneAsync()" is deprecated. Use "await renderer.init()" instead.'), await this._renderer.init(), this.fromScene(e, t, n, r, s);
  }
  /**
   * Generates a PMREM from an equirectangular texture, which can be either LDR
   * or HDR. The ideal input image size is 1k (1024 x 512),
   * as this matches best with the 256 x 256 cubemap output.
   *
   * @param {Texture} equirectangular - The equirectangular texture to be converted.
   * @param {?RenderTarget} [renderTarget=null] - The render target to use.
   * @return {RenderTarget} The resulting PMREM.
   * @see {@link PMREMGenerator#fromEquirectangularAsync}
   */
  fromEquirectangular(e, t = null) {
    if (this._hasInitialized === !1) {
      Me('PMREMGenerator: .fromEquirectangular() called before the backend is initialized. Try using "await renderer.init()" instead.'), this._setSizeFromTexture(e);
      const n = t || this._allocateTarget();
      return this.fromEquirectangularAsync(e, n), n;
    }
    return this._fromTexture(e, t);
  }
  /**
   * Generates a PMREM from an equirectangular texture, which can be either LDR
   * or HDR. The ideal input image size is 1k (1024 x 512),
   * as this matches best with the 256 x 256 cubemap output.
   *
   * @deprecated
   * @param {Texture} equirectangular - The equirectangular texture to be converted.
   * @param {?RenderTarget} [renderTarget=null] - The render target to use.
   * @return {Promise<RenderTarget>} The resulting PMREM.
   * @see {@link PMREMGenerator#fromEquirectangular}
   */
  async fromEquirectangularAsync(e, t = null) {
    return li('PMREMGenerator: ".fromEquirectangularAsync()" is deprecated. Use "await renderer.init()" instead.'), await this._renderer.init(), this._fromTexture(e, t);
  }
  /**
   * Generates a PMREM from an cubemap texture, which can be either LDR
   * or HDR. The ideal input cube size is 256 x 256,
   * as this matches best with the 256 x 256 cubemap output.
   *
   * @param {Texture} cubemap - The cubemap texture to be converted.
   * @param {?RenderTarget} [renderTarget=null] - The render target to use.
   * @return {RenderTarget} The resulting PMREM.
   * @see {@link PMREMGenerator#fromCubemapAsync}
   */
  fromCubemap(e, t = null) {
    if (this._hasInitialized === !1) {
      Me("PMREMGenerator: .fromCubemap() called before the backend is initialized. Try using .fromCubemapAsync() instead."), this._setSizeFromTexture(e);
      const n = t || this._allocateTarget();
      return this.fromCubemapAsync(e, t), n;
    }
    return this._fromTexture(e, t);
  }
  /**
   * Generates a PMREM from an cubemap texture, which can be either LDR
   * or HDR. The ideal input cube size is 256 x 256,
   * with the 256 x 256 cubemap output.
   *
   * @deprecated
   * @param {Texture} cubemap - The cubemap texture to be converted.
   * @param {?RenderTarget} [renderTarget=null] - The render target to use.
   * @return {Promise<RenderTarget>} The resulting PMREM.
   * @see {@link PMREMGenerator#fromCubemap}
   */
  async fromCubemapAsync(e, t = null) {
    return li('PMREMGenerator: ".fromCubemapAsync()" is deprecated. Use "await renderer.init()" instead.'), await this._renderer.init(), this._fromTexture(e, t);
  }
  /**
   * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   *
   * @returns {Promise}
   */
  async compileCubemapShader() {
    this._cubemapMaterial === null && (this._cubemapMaterial = XR(), await this._compileMaterial(this._cubemapMaterial));
  }
  /**
   * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   *
   * @returns {Promise}
   */
  async compileEquirectangularShader() {
    this._equirectMaterial === null && (this._equirectMaterial = YR(), await this._compileMaterial(this._equirectMaterial));
  }
  /**
   * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
   * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
   * one of them will cause any others to also become unusable.
   */
  dispose() {
    this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose(), this._backgroundBox !== null && (this._backgroundBox.geometry.dispose(), this._backgroundBox.material.dispose());
  }
  // private interface
  _setSizeFromTexture(e) {
    e.mapping === no || e.mapping === qo ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4);
  }
  _setSize(e) {
    this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax);
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(), this._ggxMaterial !== null && this._ggxMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
    for (let e = 0; e < this._lodMeshes.length; e++)
      this._lodMeshes[e].geometry.dispose();
  }
  _cleanup(e) {
    this._renderer.setRenderTarget(Zy, Jy, ev), e.scissorTest = !1, jd(e, 0, 0, e.width, e.height);
  }
  _fromTexture(e, t) {
    this._setSizeFromTexture(e), Zy = this._renderer.getRenderTarget(), Jy = this._renderer.getActiveCubeFace(), ev = this._renderer.getActiveMipmapLevel();
    const n = t || this._allocateTarget();
    return this._init(n), this._textureToCubeUV(e, n), this._applyPMREM(n), this._cleanup(n), n;
  }
  _allocateTarget() {
    const e = 3 * Math.max(this._cubeSize, 112), t = 4 * this._cubeSize;
    return jR(e, t);
  }
  _init(e) {
    if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e.width || this._pingPongRenderTarget.height !== e.height) {
      this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = jR(e.width, e.height);
      const { _lodMax: t } = this;
      ({ lodMeshes: this._lodMeshes, sizeLods: this._sizeLods, sigmas: this._sigmas } = vee(t)), this._blurMaterial = bee(t, e.width, e.height), this._ggxMaterial = See(t, e.width, e.height);
    }
  }
  async _compileMaterial(e) {
    const t = new Tn(new Yt(), e);
    await this._renderer.compile(t, $A);
  }
  _sceneToCubeUV(e, t, n, r, s) {
    const o = gee;
    o.near = t, o.far = n;
    const a = [1, 1, 1, 1, -1, 1], l = [1, -1, 1, -1, 1, -1], u = this._renderer, c = u.autoClear;
    u.getClearColor($R), u.autoClear = !1, this._backgroundBox === null && (this._backgroundBox = new Tn(
      new ul(),
      new Nr({
        name: "PMREM.Background",
        side: si,
        depthWrite: !1,
        depthTest: !1
      })
    ));
    const A = this._backgroundBox, m = A.material;
    let _ = !1;
    const y = e.background;
    y ? y.isColor && (m.color.copy(y), e.background = null, _ = !0) : (m.color.copy($R), _ = !0), u.setRenderTarget(r), u.clear(), _ && u.render(A, o);
    for (let T = 0; T < 6; T++) {
      const b = T % 3;
      b === 0 ? (o.up.set(0, a[T], 0), o.position.set(s.x, s.y, s.z), o.lookAt(s.x + l[T], s.y, s.z)) : b === 1 ? (o.up.set(0, 0, a[T]), o.position.set(s.x, s.y, s.z), o.lookAt(s.x, s.y + l[T], s.z)) : (o.up.set(0, a[T], 0), o.position.set(s.x, s.y, s.z), o.lookAt(s.x, s.y, s.z + l[T]));
      const S = this._cubeSize;
      jd(r, b * S, T > 2 ? S : 0, S, S), u.render(e, o);
    }
    u.autoClear = c, e.background = y;
  }
  _textureToCubeUV(e, t) {
    const n = this._renderer, r = e.mapping === no || e.mapping === qo;
    r ? this._cubemapMaterial === null && (this._cubemapMaterial = XR(e)) : this._equirectMaterial === null && (this._equirectMaterial = YR(e));
    const s = r ? this._cubemapMaterial : this._equirectMaterial;
    s.fragmentNode.value = e;
    const o = this._lodMeshes[0];
    o.material = s;
    const a = this._cubeSize;
    jd(t, 0, 0, 3 * a, 2 * a), n.setRenderTarget(t), n.render(o, $A);
  }
  _applyPMREM(e) {
    const t = this._renderer, n = t.autoClear;
    t.autoClear = !1;
    const r = this._lodMeshes.length;
    for (let s = 1; s < r; s++)
      this._applyGGXFilter(e, s - 1, s);
    t.autoClear = n;
  }
  /**
   * Applies GGX VNDF importance sampling filter to generate a prefiltered environment map.
   * Uses Monte Carlo integration with VNDF importance sampling to accurately represent the
   * GGX BRDF for physically-based rendering. Reads from the previous LOD level and
   * applies incremental roughness filtering to avoid over-blurring.
   *
   * @private
   * @param {RenderTarget} cubeUVRenderTarget
   * @param {number} lodIn - Source LOD level to read from
   * @param {number} lodOut - Target LOD level to write to
   */
  _applyGGXFilter(e, t, n) {
    const r = this._renderer, s = this._pingPongRenderTarget, o = this._ggxMaterial, a = this._lodMeshes[n];
    a.material = o;
    const l = f_.get(o), u = n / (this._lodMeshes.length - 1), c = t / (this._lodMeshes.length - 1), A = Math.sqrt(u * u - c * c), m = 0 + u * 1.25, _ = A * m, { _lodMax: y } = this, T = this._sizeLods[n], b = 3 * T * (n > y - Fu ? n - y + Fu : 0), S = 4 * (this._cubeSize - T);
    e.texture.frame = (e.texture.frame || 0) + 1, l.envMap.value = e.texture, l.roughness.value = _, l.mipInt.value = y - t, jd(s, b, S, 3 * T, 2 * T), r.setRenderTarget(s), r.render(a, $A), s.texture.frame = (s.texture.frame || 0) + 1, l.envMap.value = s.texture, l.roughness.value = 0, l.mipInt.value = y - n, jd(e, b, S, 3 * T, 2 * T), r.setRenderTarget(e), r.render(a, $A);
  }
  /**
   * This is a two-pass Gaussian blur for a cubemap. Normally this is done
   * vertically and horizontally, but this breaks down on a cube. Here we apply
   * the blur latitudinally (around the poles), and then longitudinally (towards
   * the poles) to approximate the orthogonally-separable blur. It is least
   * accurate at the poles, but still does a decent job.
   *
   * Used for initial scene blur in fromScene() method when sigma > 0.
   *
   * @private
   * @param {RenderTarget} cubeUVRenderTarget - The cubemap render target.
   * @param {number} lodIn - The input level-of-detail.
   * @param {number} lodOut - The output level-of-detail.
   * @param {number} sigma - The blur radius in radians.
   * @param {Vector3} [poleAxis] - The pole axis.
   */
  _blur(e, t, n, r, s) {
    const o = this._pingPongRenderTarget;
    this._halfBlur(
      e,
      o,
      t,
      n,
      r,
      "latitudinal",
      s
    ), this._halfBlur(
      o,
      e,
      n,
      n,
      r,
      "longitudinal",
      s
    );
  }
  _halfBlur(e, t, n, r, s, o, a) {
    const l = this._renderer, u = this._blurMaterial;
    o !== "latitudinal" && o !== "longitudinal" && Ie("blur direction must be either latitudinal or longitudinal!");
    const c = 3, A = this._lodMeshes[r];
    A.material = u;
    const m = f_.get(u), _ = this._sizeLods[n] - 1, y = isFinite(s) ? Math.PI / (2 * _) : 2 * Math.PI / (2 * Wc - 1), T = s / y, b = isFinite(s) ? 1 + Math.floor(c * T) : Wc;
    b > Wc && Me(`sigmaRadians, ${s}, is too large and will clip, as it requested ${b} samples when the maximum is set to ${Wc}`);
    const S = [];
    let E = 0;
    for (let B = 0; B < Wc; ++B) {
      const U = B / T, N = Math.exp(-U * U / 2);
      S.push(N), B === 0 ? E += N : B < b && (E += 2 * N);
    }
    for (let B = 0; B < S.length; B++)
      S[B] = S[B] / E;
    e.texture.frame = (e.texture.frame || 0) + 1, m.envMap.value = e.texture, m.samples.value = b, m.weights.array = S, m.latitudinal.value = o === "latitudinal" ? 1 : 0, a && (m.poleAxis.value = a);
    const { _lodMax: R } = this;
    m.dTheta.value = y, m.mipInt.value = R - n;
    const C = this._sizeLods[r], L = 3 * C * (r > R - Fu ? r - R + Fu : 0), D = 4 * (this._cubeSize - C);
    jd(t, L, D, 3 * C, 2 * C), l.setRenderTarget(t), l.render(A, $A);
  }
}
function vee(i) {
  const e = [], t = [], n = [];
  let r = i;
  const s = i - Fu + 1 + WR.length;
  for (let o = 0; o < s; o++) {
    const a = Math.pow(2, r);
    e.push(a);
    let l = 1 / a;
    o > i - Fu ? l = WR[o - i + Fu - 1] : o === 0 && (l = 0), t.push(l);
    const u = 1 / (a - 2), c = -u, A = 1 + u, m = [c, c, A, c, A, A, c, c, A, A, c, A], _ = 6, y = 6, T = 3, b = 2, S = 1, E = new Float32Array(T * y * _), R = new Float32Array(b * y * _), C = new Float32Array(S * y * _);
    for (let D = 0; D < _; D++) {
      const B = D % 3 * 2 / 3 - 1, U = D > 2 ? 0 : -1, N = [
        B,
        U,
        0,
        B + 2 / 3,
        U,
        0,
        B + 2 / 3,
        U + 1,
        0,
        B,
        U,
        0,
        B + 2 / 3,
        U + 1,
        0,
        B,
        U + 1,
        0
      ], O = xee[D];
      E.set(N, T * y * O), R.set(m, b * y * O);
      const G = [O, O, O, O, O, O];
      C.set(G, S * y * O);
    }
    const L = new Yt();
    L.setAttribute("position", new Dn(E, T)), L.setAttribute("uv", new Dn(R, b)), L.setAttribute("faceIndex", new Dn(C, S)), n.push(new Tn(L, null)), r > Fu && r--;
  }
  return { lodMeshes: n, sizeLods: e, sigmas: t };
}
function jR(i, e) {
  const t = {
    magFilter: qn,
    minFilter: qn,
    generateMipmaps: !1,
    type: Ri,
    format: Pi,
    colorSpace: Hl
    //depthBuffer: false
  }, n = new Ma(i, e, t);
  return n.texture.mapping = Gl, n.texture.name = "PMREM.cubeUv", n.texture.isPMREMTexture = !0, n.scissorTest = !0, n;
}
function jd(i, e, t, n, r) {
  i.viewport.set(e, t, n, r), i.scissor.set(e, t, n, r);
}
function Y2(i) {
  const e = new Yi();
  return e.depthTest = !1, e.depthWrite = !1, e.blending = ms, e.name = `PMREM_${i}`, e;
}
function bee(i, e, t) {
  const n = hs(new Array(Wc).fill(0)), r = It(new j(0, 1, 0)), s = It(0), o = J(Wc), a = It(0), l = It(1), u = Wn(), c = It(0), A = J(1 / e), m = J(1 / t), _ = J(i), y = {
    n: o,
    latitudinal: a,
    weights: n,
    poleAxis: r,
    outputDirection: X2,
    dTheta: s,
    samples: l,
    envMap: u,
    mipInt: c,
    CUBEUV_TEXEL_WIDTH: A,
    CUBEUV_TEXEL_HEIGHT: m,
    CUBEUV_MAX_MIP: _
  }, T = Y2("blur");
  return T.fragmentNode = xL({ ...y, latitudinal: a.equal(1) }), f_.set(T, y), T;
}
function See(i, e, t) {
  const n = Wn(), r = It(0), s = It(0), o = J(1 / e), a = J(1 / t), l = J(i), u = {
    envMap: n,
    roughness: r,
    mipInt: s,
    CUBEUV_TEXEL_WIDTH: o,
    CUBEUV_TEXEL_HEIGHT: a,
    CUBEUV_MAX_MIP: l
  }, c = Y2("ggx");
  return c.fragmentNode = yL({
    ...u,
    N_immutable: X2,
    GGX_SAMPLES: Ge(mee)
  }), f_.set(c, u), c;
}
function XR(i) {
  const e = Y2("cubemap");
  return e.fragmentNode = Is(i, X2), e;
}
function YR(i) {
  const e = Y2("equirect");
  return e.fragmentNode = Wn(i, OT(X2), 0), e;
}
const QR = /* @__PURE__ */ new WeakMap();
function Tee(i) {
  const e = Math.log2(i) - 2, t = 1 / i;
  return { texelWidth: 1 / (3 * Math.max(Math.pow(2, e), 112)), texelHeight: t, maxMip: e };
}
function wee(i, e, t) {
  const n = Mee(e);
  let r = n.get(i);
  if ((r !== void 0 ? r.pmremVersion : -1) !== i.pmremVersion) {
    const o = i.image;
    if (i.isCubeTexture)
      if (Ree(o))
        r = t.fromCubemap(i, r);
      else
        return null;
    else if (Cee(o))
      r = t.fromEquirectangular(i, r);
    else
      return null;
    r.pmremVersion = i.pmremVersion, n.set(i, r);
  }
  return r.texture;
}
function Mee(i) {
  let e = QR.get(i);
  return e === void 0 && (e = /* @__PURE__ */ new WeakMap(), QR.set(i, e)), e;
}
class Eee extends Hi {
  static get type() {
    return "PMREMNode";
  }
  /**
   * Constructs a new function overloading node.
   *
   * @param {Texture} value - The input texture.
   * @param {Node<vec2>} [uvNode=null] - The uv node.
   * @param {Node<float>} [levelNode=null] - The level node.
   */
  constructor(e, t = null, n = null) {
    super("vec3"), this._value = e, this._pmrem = null, this.uvNode = t, this.levelNode = n, this._generator = null;
    const r = new Ii();
    r.isRenderTargetTexture = !0, this._texture = Wn(r), this._width = It(0), this._height = It(0), this._maxMip = It(0), this.updateBeforeType = hn.RENDER;
  }
  set value(e) {
    this._value = e, this._pmrem = null;
  }
  /**
   * The node's texture value.
   *
   * @type {Texture}
   */
  get value() {
    return this._value;
  }
  /**
   * Uses the given PMREM texture to update internal values.
   *
   * @param {Texture} texture - The PMREM texture.
   */
  updateFromTexture(e) {
    const t = Tee(e.image.height);
    this._texture.value = e, this._width.value = t.texelWidth, this._height.value = t.texelHeight, this._maxMip.value = t.maxMip;
  }
  updateBefore(e) {
    let t = this._pmrem;
    const n = t ? t.pmremVersion : -1, r = this._value;
    n !== r.pmremVersion && (r.isPMREMTexture === !0 ? t = r : t = wee(r, e.renderer, this._generator), t !== null && (this._pmrem = t, this.updateFromTexture(t)));
  }
  setup(e) {
    this._generator === null && (this._generator = new yee(e.renderer)), this.updateBefore(e);
    let t = this.uvNode;
    t === null && e.context.getUV && (t = e.context.getUV(this, e)), t = RT.mul(ce(t.x, t.y.negate(), t.z));
    let n = this.levelNode;
    return n === null && e.context.getTextureLevel && (n = e.context.getTextureLevel(this)), _L(this._texture, t, n, this._width, this._height, this._maxMip);
  }
  dispose() {
    super.dispose(), this._generator !== null && this._generator.dispose();
  }
}
function Ree(i) {
  if (i == null) return !1;
  let e = 0;
  const t = 6;
  for (let n = 0; n < t; n++)
    i[n] !== void 0 && e++;
  return e === t;
}
function Cee(i) {
  return i == null ? !1 : i.height > 0;
}
const qT = /* @__PURE__ */ on(Eee).setParameterLength(1, 3), KR = /* @__PURE__ */ new WeakMap();
class Pee extends dA {
  static get type() {
    return "EnvironmentNode";
  }
  /**
   * Constructs a new environment node.
   *
   * @param {Node} [envNode=null] - A node representing the environment.
   */
  constructor(e = null) {
    super(), this.envNode = e;
  }
  setup(e) {
    const { material: t } = e;
    let n = this.envNode;
    if (n.isTextureNode || n.isMaterialReferenceNode) {
      const A = n.isTextureNode ? n.value : t[n.property];
      let m = KR.get(A);
      m === void 0 && (m = qT(A), KR.set(A, m)), n = m;
    }
    const s = t.useAnisotropy === !0 || t.anisotropy > 0 ? aD : Gn, o = n.context(ZR(Ha, s)).mul(r1), a = n.context(Nee(oc)).mul(Math.PI).mul(r1), l = bf(o), u = bf(a);
    e.context.radiance.addAssign(l), e.context.iblIrradiance.addAssign(u);
    const c = e.context.lightingModel.clearcoatRadiance;
    if (c) {
      const A = n.context(ZR(a0, ih)).mul(r1), m = bf(A);
      c.addAssign(m);
    }
  }
}
const ZR = (i, e) => {
  let t = null;
  return {
    getUV: () => (t === null && (t = gi.negate().reflect(e), t = cT(i).mix(t, e).normalize(), t = t.transformDirection(ea)), t),
    getTextureLevel: () => i
  };
}, Nee = (i) => ({
  getUV: () => i,
  getTextureLevel: () => J(1)
}), Dee = /* @__PURE__ */ new f2();
class vL extends Yi {
  static get type() {
    return "MeshStandardNodeMaterial";
  }
  /**
   * Constructs a new mesh standard node material.
   *
   * @param {Object} [parameters] - The configuration parameter.
   */
  constructor(e) {
    super(), this.isMeshStandardNodeMaterial = !0, this.lights = !0, this.emissiveNode = null, this.metalnessNode = null, this.roughnessNode = null, this.setDefaultValues(Dee), this.setValues(e);
  }
  /**
   * Overwritten since this type of material uses {@link EnvironmentNode}
   * to implement the PBR (PMREM based) environment mapping. Besides, the
   * method honors `Scene.environment`.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {?EnvironmentNode<vec3>} The environment node.
   */
  setupEnvironment(e) {
    let t = super.setupEnvironment(e);
    return t === null && e.environmentNode && (t = e.environmentNode), t ? new Pee(t) : null;
  }
  /**
   * Setups the lighting model.
   *
   * @return {PhysicalLightingModel} The lighting model.
   */
  setupLightingModel() {
    return new mL();
  }
  /**
   * Setups the specular related node variables.
   */
  setupSpecular() {
    const e = Bn(ce(0.04), ni.rgb, El);
    Yu.assign(ce(0.04)), nh.assign(e), xf.assign(1);
  }
  /**
   * Setups the standard specific node variables.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  setupVariants() {
    const e = this.metalnessNode ? J(this.metalnessNode) : mD;
    El.assign(e);
    let t = this.roughnessNode ? J(this.roughnessNode) : pD;
    t = VT({ roughness: t }), Ha.assign(t), this.setupSpecular(), Hc.assign(ni.rgb.mul(e.oneMinus()));
  }
  copy(e) {
    return this.emissiveNode = e.emissiveNode, this.metalnessNode = e.metalnessNode, this.roughnessNode = e.roughnessNode, super.copy(e);
  }
}
const Lee = /* @__PURE__ */ new j3();
class Iee extends vL {
  static get type() {
    return "MeshPhysicalNodeMaterial";
  }
  /**
   * Constructs a new mesh physical node material.
   *
   * @param {Object} [parameters] - The configuration parameter.
   */
  constructor(e) {
    super(), this.isMeshPhysicalNodeMaterial = !0, this.clearcoatNode = null, this.clearcoatRoughnessNode = null, this.clearcoatNormalNode = null, this.sheenNode = null, this.sheenRoughnessNode = null, this.iridescenceNode = null, this.iridescenceIORNode = null, this.iridescenceThicknessNode = null, this.specularIntensityNode = null, this.specularColorNode = null, this.iorNode = null, this.transmissionNode = null, this.thicknessNode = null, this.attenuationDistanceNode = null, this.attenuationColorNode = null, this.dispersionNode = null, this.anisotropyNode = null, this.setDefaultValues(Lee), this.setValues(e);
  }
  /**
   * Whether the lighting model should use clearcoat or not.
   *
   * @type {boolean}
   * @default true
   */
  get useClearcoat() {
    return this.clearcoat > 0 || this.clearcoatNode !== null;
  }
  /**
   * Whether the lighting model should use iridescence or not.
   *
   * @type {boolean}
   * @default true
   */
  get useIridescence() {
    return this.iridescence > 0 || this.iridescenceNode !== null;
  }
  /**
   * Whether the lighting model should use sheen or not.
   *
   * @type {boolean}
   * @default true
   */
  get useSheen() {
    return this.sheen > 0 || this.sheenNode !== null;
  }
  /**
   * Whether the lighting model should use anisotropy or not.
   *
   * @type {boolean}
   * @default true
   */
  get useAnisotropy() {
    return this.anisotropy > 0 || this.anisotropyNode !== null;
  }
  /**
   * Whether the lighting model should use transmission or not.
   *
   * @type {boolean}
   * @default true
   */
  get useTransmission() {
    return this.transmission > 0 || this.transmissionNode !== null;
  }
  /**
   * Whether the lighting model should use dispersion or not.
   *
   * @type {boolean}
   * @default true
   */
  get useDispersion() {
    return this.dispersion > 0 || this.dispersionNode !== null;
  }
  /**
   * Setups the specular related node variables.
   */
  setupSpecular() {
    const e = this.iorNode ? J(this.iorNode) : PD;
    Np.assign(e), Yu.assign(so(uT(Np.sub(1).div(Np.add(1))).mul(AD), ce(1)).mul($b)), nh.assign(Bn(Yu, ni.rgb, El)), xf.assign(Bn($b, 1, El));
  }
  /**
   * Setups the lighting model.
   *
   * @return {PhysicalLightingModel} The lighting model.
   */
  setupLightingModel() {
    return new mL(this.useClearcoat, this.useSheen, this.useIridescence, this.useAnisotropy, this.useTransmission, this.useDispersion);
  }
  /**
   * Setups the physical specific node variables.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  setupVariants(e) {
    if (super.setupVariants(e), this.useClearcoat) {
      const t = this.clearcoatNode ? J(this.clearcoatNode) : _D, n = this.clearcoatRoughnessNode ? J(this.clearcoatRoughnessNode) : xD;
      i_.assign(t), a0.assign(VT({ roughness: n }));
    }
    if (this.useSheen) {
      const t = this.sheenNode ? ce(this.sheenNode) : bD, n = this.sheenRoughnessNode ? J(this.sheenRoughnessNode) : SD;
      go.assign(t), Ru.assign(n);
    }
    if (this.useIridescence) {
      const t = this.iridescenceNode ? J(this.iridescenceNode) : wD, n = this.iridescenceIORNode ? J(this.iridescenceIORNode) : MD, r = this.iridescenceThicknessNode ? J(this.iridescenceThicknessNode) : ED;
      N2.assign(t), r_.assign(n), s_.assign(r);
    }
    if (this.useAnisotropy) {
      const t = (this.anisotropyNode ? Xe(this.anisotropyNode) : TD).toVar();
      Mu.assign(t.length()), Ot(Mu.equal(0), () => {
        t.assign(Xe(1, 0));
      }).Else(() => {
        t.divAssign(Xe(Mu)), Mu.assign(Mu.saturate());
      }), o_.assign(Mu.pow2().mix(Ha.pow2(), 1)), Pp.assign(rh[0].mul(t.x).add(rh[1].mul(t.y))), hh.assign(rh[1].mul(t.x).sub(rh[0].mul(t.y)));
    }
    if (this.useTransmission) {
      const t = this.transmissionNode ? J(this.transmissionNode) : RD, n = this.thicknessNode ? J(this.thicknessNode) : CD, r = this.attenuationDistanceNode ? J(this.attenuationDistanceNode) : ND, s = this.attenuationColorNode ? ce(this.attenuationColorNode) : DD;
      if (l_.assign(t), $S.assign(n), jS.assign(r), XS.assign(s), this.useDispersion) {
        const o = this.dispersionNode ? J(this.dispersionNode) : OD;
        YS.assign(o);
      }
    }
  }
  /**
   * Setups the clearcoat normal node.
   *
   * @return {Node<vec3>} The clearcoat normal.
   */
  setupClearcoatNormal() {
    return this.clearcoatNormalNode ? ce(this.clearcoatNormalNode) : yD;
  }
  setup(e) {
    e.context.setupClearcoatNormal = () => vf(this.setupClearcoatNormal(e), "NORMAL", "vec3"), super.setup(e);
  }
  copy(e) {
    return this.clearcoatNode = e.clearcoatNode, this.clearcoatRoughnessNode = e.clearcoatRoughnessNode, this.clearcoatNormalNode = e.clearcoatNormalNode, this.sheenNode = e.sheenNode, this.sheenRoughnessNode = e.sheenRoughnessNode, this.iridescenceNode = e.iridescenceNode, this.iridescenceIORNode = e.iridescenceIORNode, this.iridescenceThicknessNode = e.iridescenceThicknessNode, this.specularIntensityNode = e.specularIntensityNode, this.specularColorNode = e.specularColorNode, this.transmissionNode = e.transmissionNode, this.thicknessNode = e.thicknessNode, this.attenuationDistanceNode = e.attenuationDistanceNode, this.attenuationColorNode = e.attenuationColorNode, this.dispersionNode = e.dispersionNode, this.anisotropyNode = e.anisotropyNode, super.copy(e);
  }
}
const Bee = /* @__PURE__ */ pe(({ normal: i, lightDirection: e, builder: t }) => {
  const n = i.dot(e), r = Xe(n.mul(0.5).add(0.5), 0);
  if (t.material.gradientMap) {
    const s = wl("gradientMap", "texture").context({ getUV: () => r });
    return ce(s.r);
  } else {
    const s = r.fwidth().mul(0.5);
    return Bn(ce(0.7), ce(1), Ta(J(0.7).sub(s.x), J(0.7).add(s.x), r.x));
  }
});
class Fee extends $2 {
  /**
   * Implements the direct lighting. Instead of using a conventional smooth irradiance, the irradiance is
   * reduced to a small number of discrete shades to create a comic-like, flat look.
   *
   * @param {Object} lightData - The light data.
   * @param {NodeBuilder} builder - The current node builder.
   */
  direct({ lightDirection: e, lightColor: t, reflectedLight: n }, r) {
    const s = Bee({ normal: V2, lightDirection: e, builder: r }).mul(t);
    n.directDiffuse.addAssign(s.mul(Xh({ diffuseColor: ni.rgb })));
  }
  /**
   * Implements the indirect lighting.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  indirect(e) {
    const { ambientOcclusion: t, irradiance: n, reflectedLight: r } = e.context;
    r.indirectDiffuse.addAssign(n.mul(Xh({ diffuseColor: ni }))), r.indirectDiffuse.mulAssign(t);
  }
}
const Uee = /* @__PURE__ */ new X3();
class Oee extends Yi {
  static get type() {
    return "MeshToonNodeMaterial";
  }
  /**
   * Constructs a new mesh toon node material.
   *
   * @param {Object} [parameters] - The configuration parameter.
   */
  constructor(e) {
    super(), this.isMeshToonNodeMaterial = !0, this.lights = !0, this.setDefaultValues(Uee), this.setValues(e);
  }
  /**
   * Setups the lighting model.
   *
   * @return {ToonLightingModel} The lighting model.
   */
  setupLightingModel() {
    return new Fee();
  }
}
const bL = /* @__PURE__ */ pe(() => {
  const i = ce(gi.z, 0, gi.x.negate()).normalize(), e = gi.cross(i);
  return Xe(i.dot(Gn), e.dot(Gn)).mul(0.495).add(0.5);
}).once(["NORMAL", "VERTEX"])().toVar("matcapUV"), kee = /* @__PURE__ */ new Z3();
class Vee extends Yi {
  static get type() {
    return "MeshMatcapNodeMaterial";
  }
  /**
   * Constructs a new mesh normal node material.
   *
   * @param {Object} [parameters] - The configuration parameter.
   */
  constructor(e) {
    super(), this.isMeshMatcapNodeMaterial = !0, this.setDefaultValues(kee), this.setValues(e);
  }
  /**
   * Setups the matcap specific node variables.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  setupVariants(e) {
    const t = bL;
    let n;
    e.material.matcap ? n = wl("matcap", "texture").context({ getUV: () => t }) : n = ce(Bn(0.2, 0.8, t.y)), ni.rgb.mulAssign(n.rgb);
  }
}
class Gee extends Hi {
  static get type() {
    return "RotateNode";
  }
  /**
   * Constructs a new rotate node.
   *
   * @param {Node} positionNode - The position node.
   * @param {Node} rotationNode - Represents the rotation that is applied to the position node. Depending
   * on whether the position data are 2D or 3D, the rotation is expressed a single float value or an Euler value.
   */
  constructor(e, t) {
    super(), this.positionNode = e, this.rotationNode = t;
  }
  /**
   * The type of the {@link RotateNode#positionNode} defines the node's type.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node's type.
   */
  getNodeType(e) {
    return this.positionNode.getNodeType(e);
  }
  setup(e) {
    const { rotationNode: t, positionNode: n } = this;
    if (this.getNodeType(e) === "vec2") {
      const s = t.cos(), o = t.sin();
      return P2(
        s,
        o,
        o.negate(),
        s
      ).mul(n);
    } else {
      const s = t, o = Vu(Gt(1, 0, 0, 0), Gt(0, ha(s.x), Ns(s.x).negate(), 0), Gt(0, Ns(s.x), ha(s.x), 0), Gt(0, 0, 0, 1)), a = Vu(Gt(ha(s.y), 0, Ns(s.y), 0), Gt(0, 1, 0, 0), Gt(Ns(s.y).negate(), 0, ha(s.y), 0), Gt(0, 0, 0, 1)), l = Vu(Gt(ha(s.z), Ns(s.z).negate(), 0, 0), Gt(Ns(s.z), ha(s.z), 0, 0), Gt(0, 0, 1, 0), Gt(0, 0, 0, 1));
      return o.mul(a).mul(l).mul(Gt(n, 1)).xyz;
    }
  }
}
const z0 = /* @__PURE__ */ on(Gee).setParameterLength(2), zee = /* @__PURE__ */ new J_();
class SL extends Yi {
  static get type() {
    return "SpriteNodeMaterial";
  }
  /**
   * Constructs a new sprite node material.
   *
   * @param {Object} [parameters] - The configuration parameter.
   */
  constructor(e) {
    super(), this.isSpriteNodeMaterial = !0, this._useSizeAttenuation = !0, this.positionNode = null, this.rotationNode = null, this.scaleNode = null, this.transparent = !0, this.setDefaultValues(zee), this.setValues(e);
  }
  /**
   * Setups the position node in view space. This method implements
   * the sprite specific vertex shader.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node<vec3>} The position in view space.
   */
  setupPositionView(e) {
    const { object: t, camera: n } = e, { positionNode: r, rotationNode: s, scaleNode: o, sizeAttenuation: a } = this, l = sc.mul(ce(r || 0));
    let u = Xe(Vo[0].xyz.length(), Vo[1].xyz.length());
    o !== null && (u = u.mul(Xe(o))), n.isPerspectiveCamera && a === !1 && (u = u.mul(l.z.negate()));
    let c = V0.xy;
    if (t.center && t.center.isVector2 === !0) {
      const _ = FK("center", "vec2", t);
      c = c.sub(_.sub(0.5));
    }
    c = c.mul(u);
    const A = J(s || vD), m = z0(c, A);
    return Gt(l.xy.add(m), l.zw);
  }
  copy(e) {
    return this.positionNode = e.positionNode, this.rotationNode = e.rotationNode, this.scaleNode = e.scaleNode, super.copy(e);
  }
  /**
   * Whether to use size attenuation or not.
   *
   * @type {boolean}
   * @default true
   */
  get sizeAttenuation() {
    return this._useSizeAttenuation;
  }
  set sizeAttenuation(e) {
    this._useSizeAttenuation !== e && (this._useSizeAttenuation = e, this.needsUpdate = !0);
  }
}
const qee = /* @__PURE__ */ new S0(), Hee = /* @__PURE__ */ new Le();
class Wee extends SL {
  static get type() {
    return "PointsNodeMaterial";
  }
  /**
   * Constructs a new points node material.
   *
   * @param {Object} [parameters] - The configuration parameter.
   */
  constructor(e) {
    super(), this.sizeNode = null, this.isPointsNodeMaterial = !0, this.setDefaultValues(qee), this.setValues(e);
  }
  setupPositionView() {
    const { positionNode: e } = this;
    return sc.mul(ce(e || Vi)).xyz;
  }
  setupVertexSprite(e) {
    const { material: t, camera: n } = e, { rotationNode: r, scaleNode: s, sizeNode: o, sizeAttenuation: a } = this;
    let l = super.setupVertex(e);
    if (t.isNodeMaterial !== !0)
      return l;
    let u = o !== null ? Xe(o) : UD;
    u = u.mul(B6), n.isPerspectiveCamera && a === !0 && (u = u.mul($ee.div(tr.z.negate()))), s && s.isNode && (u = u.mul(Xe(s)));
    let c = V0.xy;
    if (r && r.isNode) {
      const A = J(r);
      c = z0(c, A);
    }
    return c = c.mul(u), c = c.div(TT.div(2)), c = c.mul(l.w), l = l.add(Gt(c, 0, 0)), l;
  }
  setupVertex(e) {
    return e.object.isPoints ? super.setupVertex(e) : this.setupVertexSprite(e);
  }
  /**
   * Whether alpha to coverage should be used or not.
   *
   * @type {boolean}
   * @default true
   */
  get alphaToCoverage() {
    return this._useAlphaToCoverage;
  }
  set alphaToCoverage(e) {
    this._useAlphaToCoverage !== e && (this._useAlphaToCoverage = e, this.needsUpdate = !0);
  }
}
const $ee = /* @__PURE__ */ It(1).onFrameUpdate(function({ renderer: i }) {
  const e = i.getSize(Hee);
  this.value = 0.5 * e.y;
});
class jee extends $2 {
  /**
   * Constructs a new shadow mask model.
   */
  constructor() {
    super(), this.shadowNode = J(1).toVar("shadowMask");
  }
  /**
   * Only used to save the shadow mask.
   *
   * @param {Object} input - The input data.
   */
  direct({ lightNode: e }) {
    e.shadowNode !== null && this.shadowNode.mulAssign(e.shadowNode);
  }
  /**
   * Uses the shadow mask to produce the final color.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  finish({ context: e }) {
    ni.a.mulAssign(this.shadowNode.oneMinus()), e.outgoingLight.rgb.assign(ni.rgb);
  }
}
const Xee = /* @__PURE__ */ new W3();
class Yee extends Yi {
  static get type() {
    return "ShadowNodeMaterial";
  }
  /**
   * Constructs a new shadow node material.
   *
   * @param {Object} [parameters] - The configuration parameter.
   */
  constructor(e) {
    super(), this.isShadowNodeMaterial = !0, this.lights = !0, this.transparent = !0, this.setDefaultValues(Xee), this.setValues(e);
  }
  /**
   * Setups the lighting model.
   *
   * @return {ShadowMaskModel} The lighting model.
   */
  setupLightingModel() {
    return new jee();
  }
}
Bl("vec3");
Bl("vec3");
Bl("vec3");
class Qee {
  /**
   * Constructs a new animation loop management component.
   *
   * @param {Renderer} renderer - A reference to the main renderer.
   * @param {Nodes} nodes - Renderer component for managing nodes related logic.
   * @param {Info} info - Renderer component for managing metrics and monitoring data.
   */
  constructor(e, t, n) {
    this.renderer = e, this.nodes = t, this.info = n, this._context = typeof self < "u" ? self : null, this._animationLoop = null, this._requestId = null;
  }
  /**
   * Starts the internal animation loop.
   */
  start() {
    const e = (t, n) => {
      this._requestId = this._context.requestAnimationFrame(e), this.info.autoReset === !0 && this.info.reset(), this.nodes.nodeFrame.update(), this.info.frame = this.nodes.nodeFrame.frameId, this.renderer._inspector.begin(), this._animationLoop !== null && this._animationLoop(t, n), this.renderer._inspector.finish();
    };
    e();
  }
  /**
   * Stops the internal animation loop.
   */
  stop() {
    this._context.cancelAnimationFrame(this._requestId), this._requestId = null;
  }
  /**
   * Returns the user-level animation loop.
   *
   * @return {?Function} The animation loop.
   */
  getAnimationLoop() {
    return this._animationLoop;
  }
  /**
   * Defines the user-level animation loop.
   *
   * @param {?Function} callback - The animation loop.
   */
  setAnimationLoop(e) {
    this._animationLoop = e;
  }
  /**
   * Returns the animation context.
   *
   * @return {Window|XRSession} The animation context.
   */
  getContext() {
    return this._context;
  }
  /**
   * Defines the context in which `requestAnimationFrame()` is executed.
   *
   * @param {Window|XRSession} context - The context to set.
   */
  setContext(e) {
    this._context = e;
  }
  /**
   * Frees all internal resources and stops the animation loop.
   */
  dispose() {
    this.stop();
  }
}
class wa {
  /**
   * Constructs a new Chain Map.
   */
  constructor() {
    this.weakMaps = {};
  }
  /**
   * Returns the Weak Map for the given keys.
   *
   * @param {Array<Object>} keys - List of keys.
   * @return {WeakMap} The weak map.
   */
  _getWeakMap(e) {
    const t = e.length;
    let n = this.weakMaps[t];
    return n === void 0 && (n = /* @__PURE__ */ new WeakMap(), this.weakMaps[t] = n), n;
  }
  /**
   * Returns the value for the given array of keys.
   *
   * @param {Array<Object>} keys - List of keys.
   * @return {any} The value. Returns `undefined` if no value was found.
   */
  get(e) {
    let t = this._getWeakMap(e);
    for (let n = 0; n < e.length - 1; n++)
      if (t = t.get(e[n]), t === void 0) return;
    return t.get(e[e.length - 1]);
  }
  /**
   * Sets the value for the given keys.
   *
   * @param {Array<Object>} keys - List of keys.
   * @param {any} value - The value to set.
   * @return {ChainMap} A reference to this Chain Map.
   */
  set(e, t) {
    let n = this._getWeakMap(e);
    for (let r = 0; r < e.length - 1; r++) {
      const s = e[r];
      n.has(s) === !1 && n.set(s, /* @__PURE__ */ new WeakMap()), n = n.get(s);
    }
    return n.set(e[e.length - 1], t), this;
  }
  /**
   * Deletes a value for the given keys.
   *
   * @param {Array<Object>} keys - The keys.
   * @return {boolean} Returns `true` if the value has been removed successfully and `false` if the value has not be found.
   */
  delete(e) {
    let t = this._getWeakMap(e);
    for (let n = 0; n < e.length - 1; n++)
      if (t = t.get(e[n]), t === void 0) return !1;
    return t.delete(e[e.length - 1]);
  }
}
let Kee = 0;
function Zee(i) {
  const e = Object.keys(i);
  let t = Object.getPrototypeOf(i);
  for (; t; ) {
    const n = Object.getOwnPropertyDescriptors(t);
    for (const r in n)
      if (n[r] !== void 0) {
        const s = n[r];
        s && typeof s.get == "function" && e.push(r);
      }
    t = Object.getPrototypeOf(t);
  }
  return e;
}
class Jee {
  /**
   * Constructs a new render object.
   *
   * @param {Nodes} nodes - Renderer component for managing nodes related logic.
   * @param {Geometries} geometries - Renderer component for managing geometries.
   * @param {Renderer} renderer - The renderer.
   * @param {Object3D} object - The 3D object.
   * @param {Material} material - The 3D object's material.
   * @param {Scene} scene - The scene the 3D object belongs to.
   * @param {Camera} camera - The camera the object should be rendered with.
   * @param {LightsNode} lightsNode - The lights node.
   * @param {RenderContext} renderContext - The render context.
   * @param {ClippingContext} clippingContext - The clipping context.
   */
  constructor(e, t, n, r, s, o, a, l, u, c) {
    this.id = Kee++, this._nodes = e, this._geometries = t, this.renderer = n, this.object = r, this.material = s, this.scene = o, this.camera = a, this.lightsNode = l, this.context = u, this.geometry = r.geometry, this.version = s.version, this.drawRange = null, this.attributes = null, this.attributesId = null, this.pipeline = null, this.group = null, this.vertexBuffers = null, this.drawParams = null, this.bundle = null, this.clippingContext = c, this.clippingContextCacheKey = c !== null ? c.cacheKey : "", this.initialNodesCacheKey = this.getDynamicCacheKey(), this.initialCacheKey = this.getCacheKey(), this._nodeBuilderState = null, this._bindings = null, this._monitor = null, this.onDispose = null, this.isRenderObject = !0, this.onMaterialDispose = () => {
      this.dispose();
    }, this.onGeometryDispose = () => {
      this.attributes = null, this.attributesId = null;
    }, this.material.addEventListener("dispose", this.onMaterialDispose), this.geometry.addEventListener("dispose", this.onGeometryDispose);
  }
  /**
   * Updates the clipping context.
   *
   * @param {ClippingContext} context - The clipping context to set.
   */
  updateClipping(e) {
    this.clippingContext = e;
  }
  /**
   * Whether the clipping requires an update or not.
   *
   * @type {boolean}
   * @readonly
   */
  get clippingNeedsUpdate() {
    return this.clippingContext === null || this.clippingContext.cacheKey === this.clippingContextCacheKey ? !1 : (this.clippingContextCacheKey = this.clippingContext.cacheKey, !0);
  }
  /**
   * The number of clipping planes defined in context of hardware clipping.
   *
   * @type {number}
   * @readonly
   */
  get hardwareClippingPlanes() {
    return this.material.hardwareClipping === !0 ? this.clippingContext.unionClippingCount : 0;
  }
  /**
   * Returns the node builder state of this render object.
   *
   * @return {NodeBuilderState} The node builder state.
   */
  getNodeBuilderState() {
    return this._nodeBuilderState || (this._nodeBuilderState = this._nodes.getForRender(this));
  }
  /**
   * Returns the node material observer of this render object.
   *
   * @return {NodeMaterialObserver} The node material observer.
   */
  getMonitor() {
    return this._monitor || (this._monitor = this.getNodeBuilderState().observer);
  }
  /**
   * Returns an array of bind groups of this render object.
   *
   * @return {Array<BindGroup>} The bindings.
   */
  getBindings() {
    return this._bindings || (this._bindings = this.getNodeBuilderState().createBindings());
  }
  /**
   * Returns a binding group by group name of this render object.
   *
   * @param {string} name - The name of the binding group.
   * @return {?BindGroup} The bindings.
   */
  getBindingGroup(e) {
    for (const t of this.getBindings())
      if (t.name === e)
        return t;
  }
  /**
   * Returns the index of the render object's geometry.
   *
   * @return {?BufferAttribute} The index. Returns `null` for non-indexed geometries.
   */
  getIndex() {
    return this._geometries.getIndex(this);
  }
  /**
   * Returns the indirect buffer attribute.
   *
   * @return {?BufferAttribute} The indirect attribute. `null` if no indirect drawing is used.
   */
  getIndirect() {
    return this._geometries.getIndirect(this);
  }
  /**
   * Returns the byte offset into the indirect attribute buffer.
   *
   * @return {number|Array<number>} The byte offset into the indirect attribute buffer.
   */
  getIndirectOffset() {
    return this._geometries.getIndirectOffset(this);
  }
  /**
   * Returns an array that acts as a key for identifying the render object in a chain map.
   *
   * @return {Array<Object>} An array with object references.
   */
  getChainArray() {
    return [this.object, this.material, this.context, this.lightsNode];
  }
  /**
   * This method is used when the geometry of a 3D object has been exchanged and the
   * respective render object now requires an update.
   *
   * @param {BufferGeometry} geometry - The geometry to set.
   */
  setGeometry(e) {
    this.geometry = e, this.attributes = null, this.attributesId = null;
  }
  /**
   * Returns the buffer attributes of the render object. The returned array holds
   * attribute definitions on geometry and node level.
   *
   * @return {Array<BufferAttribute>} An array with buffer attributes.
   */
  getAttributes() {
    if (this.attributes !== null) return this.attributes;
    const e = this.getNodeBuilderState().nodeAttributes, t = this.geometry, n = [], r = /* @__PURE__ */ new Set(), s = {};
    for (const o of e) {
      let a;
      if (o.node && o.node.attribute ? a = o.node.attribute : (a = t.getAttribute(o.name), s[o.name] = a.version), a === void 0) continue;
      n.push(a);
      const l = a.isInterleavedBufferAttribute ? a.data : a;
      r.add(l);
    }
    return this.attributes = n, this.attributesId = s, this.vertexBuffers = Array.from(r.values()), n;
  }
  /**
   * Returns the vertex buffers of the render object.
   *
   * @return {Array<BufferAttribute|InterleavedBuffer>} An array with buffer attribute or interleaved buffers.
   */
  getVertexBuffers() {
    return this.vertexBuffers === null && this.getAttributes(), this.vertexBuffers;
  }
  /**
   * Returns the draw parameters for the render object.
   *
   * @return {?{vertexCount: number, firstVertex: number, instanceCount: number, firstInstance: number}} The draw parameters.
   */
  getDrawParameters() {
    const { object: e, material: t, geometry: n, group: r, drawRange: s } = this, o = this.drawParams || (this.drawParams = {
      vertexCount: 0,
      firstVertex: 0,
      instanceCount: 0,
      firstInstance: 0
    }), a = this.getIndex(), l = a !== null;
    let u = 1;
    if (n.isInstancedBufferGeometry === !0 ? u = n.instanceCount : e.count !== void 0 && (u = Math.max(0, e.count)), u === 0) return null;
    if (o.instanceCount = u, e.isBatchedMesh === !0) return o;
    let c = 1;
    t.wireframe === !0 && !e.isPoints && !e.isLineSegments && !e.isLine && !e.isLineLoop && (c = 2);
    let A = s.start * c, m = (s.start + s.count) * c;
    r !== null && (A = Math.max(A, r.start * c), m = Math.min(m, (r.start + r.count) * c));
    const _ = n.attributes.position;
    let y = 1 / 0;
    l ? y = a.count : _ != null && (y = _.count), A = Math.max(A, 0), m = Math.min(m, y);
    const T = m - A;
    return T < 0 || T === 1 / 0 ? null : (o.vertexCount = T, o.firstVertex = A, o);
  }
  /**
   * Returns the render object's geometry cache key.
   *
   * The geometry cache key is part of the material cache key.
   *
   * @return {string} The geometry cache key.
   */
  getGeometryCacheKey() {
    const { geometry: e } = this;
    let t = "";
    for (const n of Object.keys(e.attributes).sort()) {
      const r = e.attributes[n];
      t += n + ",", r.data && (t += r.data.stride + ","), r.offset && (t += r.offset + ","), r.itemSize && (t += r.itemSize + ","), r.normalized && (t += "n,");
    }
    for (const n of Object.keys(e.morphAttributes).sort()) {
      const r = e.morphAttributes[n];
      t += "morph-" + n + ",";
      for (let s = 0, o = r.length; s < o; s++) {
        const a = r[s];
        t += a.id + ",";
      }
    }
    return e.index && (t += "index,"), t;
  }
  /**
   * Returns the render object's material cache key.
   *
   * The material cache key is part of the render object cache key.
   *
   * @return {number} The material cache key.
   */
  getMaterialCacheKey() {
    const { object: e, material: t, renderer: n } = this;
    let r = t.customProgramCacheKey();
    for (const s of Zee(t)) {
      if (/^(is[A-Z]|_)|^(visible|version|uuid|name|opacity|userData)$/.test(s)) continue;
      const o = t[s];
      let a;
      if (o !== null) {
        const l = typeof o;
        l === "number" ? a = o !== 0 ? "1" : "0" : l === "object" ? (a = "{", o.isTexture && (a += o.mapping, n.backend.isWebGPUBackend === !0 && (a += o.magFilter, a += o.minFilter, a += o.wrapS, a += o.wrapT, a += o.wrapR)), a += "}") : a = String(o);
      } else
        a = String(o);
      r += /*property + ':' +*/
      a + ",";
    }
    return r += this.clippingContextCacheKey + ",", e.geometry && (r += this.getGeometryCacheKey()), e.skeleton && (r += e.skeleton.bones.length + ","), e.isBatchedMesh && (r += e._matricesTexture.uuid + ",", e._colorsTexture !== null && (r += e._colorsTexture.uuid + ",")), (e.isInstancedMesh || e.count > 1 || Array.isArray(e.morphTargetInfluences)) && (r += e.uuid + ","), r += this.context.id + ",", r += e.receiveShadow + ",", F0(r);
  }
  /**
   * Whether the geometry requires an update or not.
   *
   * @type {boolean}
   * @readonly
   */
  get needsGeometryUpdate() {
    if (this.geometry.id !== this.object.geometry.id) return !0;
    if (this.attributes !== null) {
      const e = this.attributesId;
      for (const t in e) {
        const n = this.geometry.getAttribute(t);
        if (n === void 0 || e[t] !== n.id)
          return !0;
      }
    }
    return !1;
  }
  /**
   * Whether the render object requires an update or not.
   *
   * Note: There are two distinct places where render objects are checked for an update.
   *
   * 1. In `RenderObjects.get()` which is executed when the render object is request. This
   * method checks the `needsUpdate` flag and recreates the render object if necessary.
   * 2. In `Renderer._renderObjectDirect()` right after getting the render object via
   * `RenderObjects.get()`. The render object's NodeMaterialObserver is then used to detect
   * a need for a refresh due to material, geometry or object related value changes.
   *
   * TODO: Investigate if it's possible to merge both steps so there is only a single place
   * that performs the 'needsUpdate' check.
   *
   * @type {boolean}
   * @readonly
   */
  get needsUpdate() {
    return (
      /*this.object.static !== true &&*/
      this.initialNodesCacheKey !== this.getDynamicCacheKey() || this.clippingNeedsUpdate
    );
  }
  /**
   * Returns the dynamic cache key which represents a key that is computed per draw command.
   *
   * @return {number} The cache key.
   */
  getDynamicCacheKey() {
    let e = 0;
    return this.material.isShadowPassMaterial !== !0 && (e = this._nodes.getCacheKey(this.scene, this.lightsNode)), this.camera.isArrayCamera && (e = Rp(e, this.camera.cameras.length)), this.object.receiveShadow && (e = Rp(e, 1)), e = Rp(e, this.camera.id, this.renderer.contextNode.id, this.renderer.contextNode.version), e;
  }
  /**
   * Returns the render object's cache key.
   *
   * @return {number} The cache key.
   */
  getCacheKey() {
    return this.getMaterialCacheKey() + this.getDynamicCacheKey();
  }
  /**
   * Frees internal resources.
   */
  dispose() {
    this.material.removeEventListener("dispose", this.onMaterialDispose), this.geometry.removeEventListener("dispose", this.onGeometryDispose), this.onDispose();
  }
}
const Lc = [];
class ete {
  /**
   * Constructs a new render object management component.
   *
   * @param {Renderer} renderer - The renderer.
   * @param {Nodes} nodes - Renderer component for managing nodes related logic.
   * @param {Geometries} geometries - Renderer component for managing geometries.
   * @param {Pipelines} pipelines - Renderer component for managing pipelines.
   * @param {Bindings} bindings - Renderer component for managing bindings.
   * @param {Info} info - Renderer component for managing metrics and monitoring data.
   */
  constructor(e, t, n, r, s, o) {
    this.renderer = e, this.nodes = t, this.geometries = n, this.pipelines = r, this.bindings = s, this.info = o, this.chainMaps = {};
  }
  /**
   * Returns a render object for the given object and state data.
   *
   * @param {Object3D} object - The 3D object.
   * @param {Material} material - The 3D object's material.
   * @param {Scene} scene - The scene the 3D object belongs to.
   * @param {Camera} camera - The camera the 3D object should be rendered with.
   * @param {LightsNode} lightsNode - The lights node.
   * @param {RenderContext} renderContext - The render context.
   * @param {ClippingContext} clippingContext - The clipping context.
   * @param {string} [passId] - An optional ID for identifying the pass.
   * @return {RenderObject} The render object.
   */
  get(e, t, n, r, s, o, a, l) {
    const u = this.getChainMap(l);
    Lc[0] = e, Lc[1] = t, Lc[2] = o, Lc[3] = s;
    let c = u.get(Lc);
    return c === void 0 ? (c = this.createRenderObject(this.nodes, this.geometries, this.renderer, e, t, n, r, s, o, a, l), u.set(Lc, c)) : (c.updateClipping(a), c.needsGeometryUpdate && c.setGeometry(e.geometry), (c.version !== t.version || c.needsUpdate) && (c.initialCacheKey !== c.getCacheKey() ? (c.dispose(), c = this.get(e, t, n, r, s, o, a, l)) : c.version = t.version)), Lc.length = 0, c;
  }
  /**
   * Returns a chain map for the given pass ID.
   *
   * @param {string} [passId='default'] - The pass ID.
   * @return {ChainMap} The chain map.
   */
  getChainMap(e = "default") {
    return this.chainMaps[e] || (this.chainMaps[e] = new wa());
  }
  /**
   * Frees internal resources.
   */
  dispose() {
    this.chainMaps = {};
  }
  /**
   * Factory method for creating render objects with the given list of parameters.
   *
   * @param {Nodes} nodes - Renderer component for managing nodes related logic.
   * @param {Geometries} geometries - Renderer component for managing geometries.
   * @param {Renderer} renderer - The renderer.
   * @param {Object3D} object - The 3D object.
   * @param {Material} material - The object's material.
   * @param {Scene} scene - The scene the 3D object belongs to.
   * @param {Camera} camera - The camera the object should be rendered with.
   * @param {LightsNode} lightsNode - The lights node.
   * @param {RenderContext} renderContext - The render context.
   * @param {ClippingContext} clippingContext - The clipping context.
   * @param {string} [passId] - An optional ID for identifying the pass.
   * @return {RenderObject} The render object.
   */
  createRenderObject(e, t, n, r, s, o, a, l, u, c, A) {
    const m = this.getChainMap(A), _ = new Jee(e, t, n, r, s, o, a, l, u, c);
    return _.onDispose = () => {
      this.pipelines.delete(_), this.bindings.deleteForRender(_), this.nodes.delete(_), m.delete(_.getChainArray());
    }, _;
  }
}
class ac {
  /**
   * Constructs a new data map.
   */
  constructor() {
    this.data = /* @__PURE__ */ new WeakMap();
  }
  /**
   * Returns the dictionary for the given object.
   *
   * @param {Object} object - The object.
   * @return {Object} The dictionary.
   */
  get(e) {
    let t = this.data.get(e);
    return t === void 0 && (t = {}, this.data.set(e, t)), t;
  }
  /**
   * Deletes the dictionary for the given object.
   *
   * @param {Object} object - The object.
   * @return {?Object} The deleted dictionary.
   */
  delete(e) {
    let t = null;
    return this.data.has(e) && (t = this.data.get(e), this.data.delete(e)), t;
  }
  /**
   * Returns `true` if the given object has a dictionary defined.
   *
   * @param {Object} object - The object to test.
   * @return {boolean} Whether a dictionary is defined or not.
   */
  has(e) {
    return this.data.has(e);
  }
  /**
   * Frees internal resources.
   */
  dispose() {
    this.data = /* @__PURE__ */ new WeakMap();
  }
}
const Go = {
  VERTEX: 1,
  INDEX: 2,
  STORAGE: 3,
  INDIRECT: 4
}, Nu = 16, tte = 211, nte = 212;
class ite extends ac {
  /**
   * Constructs a new attribute management component.
   *
   * @param {Backend} backend - The renderer's backend.
   */
  constructor(e) {
    super(), this.backend = e;
  }
  /**
   * Deletes the data for the given attribute.
   *
   * @param {BufferAttribute} attribute - The attribute.
   * @return {?Object} The deleted attribute data.
   */
  delete(e) {
    const t = super.delete(e);
    return t !== null && this.backend.destroyAttribute(e), t;
  }
  /**
   * Updates the given attribute. This method creates attribute buffers
   * for new attributes and updates data for existing ones.
   *
   * @param {BufferAttribute} attribute - The attribute to update.
   * @param {number} type - The attribute type.
   */
  update(e, t) {
    const n = this.get(e);
    if (n.version === void 0)
      t === Go.VERTEX ? this.backend.createAttribute(e) : t === Go.INDEX ? this.backend.createIndexAttribute(e) : t === Go.STORAGE ? this.backend.createStorageAttribute(e) : t === Go.INDIRECT && this.backend.createIndirectStorageAttribute(e), n.version = this._getBufferAttribute(e).version;
    else {
      const r = this._getBufferAttribute(e);
      (n.version < r.version || r.usage === Du) && (this.backend.updateAttribute(e), n.version = r.version);
    }
  }
  /**
   * Utility method for handling interleaved buffer attributes correctly.
   * To process them, their `InterleavedBuffer` is returned.
   *
   * @param {BufferAttribute} attribute - The attribute.
   * @return {BufferAttribute|InterleavedBuffer}
   */
  _getBufferAttribute(e) {
    return e.isInterleavedBufferAttribute && (e = e.data), e;
  }
}
function TL(i) {
  return i.index !== null ? i.index.version : i.attributes.position.version;
}
function JR(i) {
  const e = [], t = i.index, n = i.attributes.position;
  if (t !== null) {
    const s = t.array;
    for (let o = 0, a = s.length; o < a; o += 3) {
      const l = s[o + 0], u = s[o + 1], c = s[o + 2];
      e.push(l, u, u, c, c, l);
    }
  } else {
    const s = n.array;
    for (let o = 0, a = s.length / 3 - 1; o < a; o += 3) {
      const l = o + 0, u = o + 1, c = o + 2;
      e.push(l, u, u, c, c, l);
    }
  }
  const r = new (R3(e) ? Y_ : X_)(e, 1);
  return r.version = TL(i), r;
}
class rte extends ac {
  /**
   * Constructs a new geometry management component.
   *
   * @param {Attributes} attributes - Renderer component for managing attributes.
   * @param {Info} info - Renderer component for managing metrics and monitoring data.
   */
  constructor(e, t) {
    super(), this.attributes = e, this.info = t, this.wireframes = /* @__PURE__ */ new WeakMap(), this.attributeCall = /* @__PURE__ */ new WeakMap(), this._geometryDisposeListeners = /* @__PURE__ */ new Map();
  }
  /**
   * Returns `true` if the given render object has an initialized geometry.
   *
   * @param {RenderObject} renderObject - The render object.
   * @return {boolean} Whether if the given render object has an initialized geometry or not.
   */
  has(e) {
    const t = e.geometry;
    return super.has(t) && this.get(t).initialized === !0;
  }
  /**
   * Prepares the geometry of the given render object for rendering.
   *
   * @param {RenderObject} renderObject - The render object.
   */
  updateForRender(e) {
    this.has(e) === !1 && this.initGeometry(e), this.updateAttributes(e);
  }
  /**
   * Initializes the geometry of the given render object.
   *
   * @param {RenderObject} renderObject - The render object.
   */
  initGeometry(e) {
    const t = e.geometry, n = this.get(t);
    n.initialized = !0, this.info.memory.geometries++;
    const r = () => {
      this.info.memory.geometries--;
      const s = t.index, o = e.getAttributes();
      s !== null && this.attributes.delete(s);
      for (const l of o)
        this.attributes.delete(l);
      const a = this.wireframes.get(t);
      a !== void 0 && this.attributes.delete(a), t.removeEventListener("dispose", r), this._geometryDisposeListeners.delete(t);
    };
    t.addEventListener("dispose", r), this._geometryDisposeListeners.set(t, r);
  }
  /**
   * Updates the geometry attributes of the given render object.
   *
   * @param {RenderObject} renderObject - The render object.
   */
  updateAttributes(e) {
    const t = e.getAttributes();
    for (const s of t)
      s.isStorageBufferAttribute || s.isStorageInstancedBufferAttribute ? this.updateAttribute(s, Go.STORAGE) : this.updateAttribute(s, Go.VERTEX);
    const n = this.getIndex(e);
    n !== null && this.updateAttribute(n, Go.INDEX);
    const r = e.geometry.indirect;
    r !== null && this.updateAttribute(r, Go.INDIRECT);
  }
  /**
   * Updates the given attribute.
   *
   * @param {BufferAttribute} attribute - The attribute to update.
   * @param {number} type - The attribute type.
   */
  updateAttribute(e, t) {
    const n = this.info.render.calls;
    e.isInterleavedBufferAttribute ? this.attributeCall.get(e) === void 0 ? (this.attributes.update(e, t), this.attributeCall.set(e, n)) : this.attributeCall.get(e.data) !== n && (this.attributes.update(e, t), this.attributeCall.set(e.data, n), this.attributeCall.set(e, n)) : this.attributeCall.get(e) !== n && (this.attributes.update(e, t), this.attributeCall.set(e, n));
  }
  /**
   * Returns the indirect buffer attribute of the given render object.
   *
   * @param {RenderObject} renderObject - The render object.
   * @return {?BufferAttribute} The indirect attribute. `null` if no indirect drawing is used.
   */
  getIndirect(e) {
    return e.geometry.indirect;
  }
  /**
   * Returns the byte offset into the indirect attribute buffer of the given render object.
   *
   * @param {RenderObject} renderObject - The render object.
   * @return {number} The byte offset into the indirect attribute buffer.
   */
  getIndirectOffset(e) {
    return e.geometry.indirectOffset;
  }
  /**
   * Returns the index of the given render object's geometry. This is implemented
   * in a method to return a wireframe index if necessary.
   *
   * @param {RenderObject} renderObject - The render object.
   * @return {?BufferAttribute} The index. Returns `null` for non-indexed geometries.
   */
  getIndex(e) {
    const { geometry: t, material: n } = e;
    let r = t.index;
    if (n.wireframe === !0) {
      const s = this.wireframes;
      let o = s.get(t);
      o === void 0 ? (o = JR(t), s.set(t, o)) : o.version !== TL(t) && (this.attributes.delete(o), o = JR(t), s.set(t, o)), r = o;
    }
    return r;
  }
  dispose() {
    for (const [e, t] of this._geometryDisposeListeners.entries())
      e.removeEventListener("dispose", t);
    this._geometryDisposeListeners.clear();
  }
}
class ste {
  /**
   * Constructs a new info component.
   */
  constructor() {
    this.autoReset = !0, this.frame = 0, this.calls = 0, this.render = {
      calls: 0,
      frameCalls: 0,
      drawCalls: 0,
      triangles: 0,
      points: 0,
      lines: 0,
      timestamp: 0
    }, this.compute = {
      calls: 0,
      frameCalls: 0,
      timestamp: 0
    }, this.memory = {
      geometries: 0,
      textures: 0
    };
  }
  /**
   * This method should be executed per draw call and updates the corresponding metrics.
   *
   * @param {Object3D} object - The 3D object that is going to be rendered.
   * @param {number} count - The vertex or index count.
   * @param {number} instanceCount - The instance count.
   */
  update(e, t, n) {
    this.render.drawCalls++, e.isMesh || e.isSprite ? this.render.triangles += n * (t / 3) : e.isPoints ? this.render.points += n * t : e.isLineSegments ? this.render.lines += n * (t / 2) : e.isLine ? this.render.lines += n * (t - 1) : Ie("WebGPUInfo: Unknown object type.");
  }
  /**
   * Resets frame related metrics.
   */
  reset() {
    this.render.drawCalls = 0, this.render.frameCalls = 0, this.compute.frameCalls = 0, this.render.triangles = 0, this.render.points = 0, this.render.lines = 0;
  }
  /**
   * Performs a complete reset of the object.
   */
  dispose() {
    this.reset(), this.calls = 0, this.render.calls = 0, this.compute.calls = 0, this.render.timestamp = 0, this.compute.timestamp = 0, this.memory.geometries = 0, this.memory.textures = 0;
  }
}
class wL {
  /**
   * Constructs a new pipeline.
   *
   * @param {string} cacheKey - The pipeline's cache key.
   */
  constructor(e) {
    this.cacheKey = e, this.usedTimes = 0;
  }
}
class ote extends wL {
  /**
   * Constructs a new render pipeline.
   *
   * @param {string} cacheKey - The pipeline's cache key.
   * @param {ProgrammableStage} vertexProgram - The pipeline's vertex shader.
   * @param {ProgrammableStage} fragmentProgram - The pipeline's fragment shader.
   */
  constructor(e, t, n) {
    super(e), this.vertexProgram = t, this.fragmentProgram = n;
  }
}
class ate extends wL {
  /**
   * Constructs a new render pipeline.
   *
   * @param {string} cacheKey - The pipeline's cache key.
   * @param {ProgrammableStage} computeProgram - The pipeline's compute shader.
   */
  constructor(e, t) {
    super(e), this.computeProgram = t, this.isComputePipeline = !0;
  }
}
let lte = 0;
class nv {
  /**
   * Constructs a new programmable stage.
   *
   * @param {string} code - The shader code.
   * @param {('vertex'|'fragment'|'compute')} stage - The type of stage.
   * @param {string} name - The name of the shader.
   * @param {?Array<Object>} [transforms=null] - The transforms (only relevant for compute stages with WebGL 2 which uses Transform Feedback).
   * @param {?Array<Object>} [attributes=null] - The attributes (only relevant for compute stages with WebGL 2 which uses Transform Feedback).
   */
  constructor(e, t, n, r = null, s = null) {
    this.id = lte++, this.code = e, this.stage = t, this.name = n, this.transforms = r, this.attributes = s, this.usedTimes = 0;
  }
}
class ute extends ac {
  /**
   * Constructs a new pipeline management component.
   *
   * @param {Backend} backend - The renderer's backend.
   * @param {Nodes} nodes - Renderer component for managing nodes related logic.
   */
  constructor(e, t) {
    super(), this.backend = e, this.nodes = t, this.bindings = null, this.caches = /* @__PURE__ */ new Map(), this.programs = {
      vertex: /* @__PURE__ */ new Map(),
      fragment: /* @__PURE__ */ new Map(),
      compute: /* @__PURE__ */ new Map()
    };
  }
  /**
   * Returns a compute pipeline for the given compute node.
   *
   * @param {Node} computeNode - The compute node.
   * @param {Array<BindGroup>} bindings - The bindings.
   * @return {ComputePipeline} The compute pipeline.
   */
  getForCompute(e, t) {
    const { backend: n } = this, r = this.get(e);
    if (this._needsComputeUpdate(e)) {
      const s = r.pipeline;
      s && (s.usedTimes--, s.computeProgram.usedTimes--);
      const o = this.nodes.getForCompute(e);
      let a = this.programs.compute.get(o.computeShader);
      a === void 0 && (s && s.computeProgram.usedTimes === 0 && this._releaseProgram(s.computeProgram), a = new nv(o.computeShader, "compute", e.name, o.transforms, o.nodeAttributes), this.programs.compute.set(o.computeShader, a), n.createProgram(a));
      const l = this._getComputeCacheKey(e, a);
      let u = this.caches.get(l);
      u === void 0 && (s && s.usedTimes === 0 && this._releasePipeline(s), u = this._getComputePipeline(e, a, l, t)), u.usedTimes++, a.usedTimes++, r.version = e.version, r.pipeline = u;
    }
    return r.pipeline;
  }
  /**
   * Returns a render pipeline for the given render object.
   *
   * @param {RenderObject} renderObject - The render object.
   * @param {?Array<Promise>} [promises=null] - An array of compilation promises which is only relevant in context of `Renderer.compileAsync()`.
   * @return {RenderPipeline} The render pipeline.
   */
  getForRender(e, t = null) {
    const { backend: n } = this, r = this.get(e);
    if (this._needsRenderUpdate(e)) {
      const s = r.pipeline;
      s && (s.usedTimes--, s.vertexProgram.usedTimes--, s.fragmentProgram.usedTimes--);
      const o = e.getNodeBuilderState(), a = e.material ? e.material.name : "";
      let l = this.programs.vertex.get(o.vertexShader);
      l === void 0 && (s && s.vertexProgram.usedTimes === 0 && this._releaseProgram(s.vertexProgram), l = new nv(o.vertexShader, "vertex", a), this.programs.vertex.set(o.vertexShader, l), n.createProgram(l));
      let u = this.programs.fragment.get(o.fragmentShader);
      u === void 0 && (s && s.fragmentProgram.usedTimes === 0 && this._releaseProgram(s.fragmentProgram), u = new nv(o.fragmentShader, "fragment", a), this.programs.fragment.set(o.fragmentShader, u), n.createProgram(u));
      const c = this._getRenderCacheKey(e, l, u);
      let A = this.caches.get(c);
      A === void 0 ? (s && s.usedTimes === 0 && this._releasePipeline(s), A = this._getRenderPipeline(e, l, u, c, t)) : e.pipeline = A, A.usedTimes++, l.usedTimes++, u.usedTimes++, r.pipeline = A;
    }
    return r.pipeline;
  }
  /**
   * Deletes the pipeline for the given render object.
   *
   * @param {RenderObject} object - The render object.
   * @return {?Object} The deleted dictionary.
   */
  delete(e) {
    const t = this.get(e).pipeline;
    return t && (t.usedTimes--, t.usedTimes === 0 && this._releasePipeline(t), t.isComputePipeline ? (t.computeProgram.usedTimes--, t.computeProgram.usedTimes === 0 && this._releaseProgram(t.computeProgram)) : (t.fragmentProgram.usedTimes--, t.vertexProgram.usedTimes--, t.vertexProgram.usedTimes === 0 && this._releaseProgram(t.vertexProgram), t.fragmentProgram.usedTimes === 0 && this._releaseProgram(t.fragmentProgram))), super.delete(e);
  }
  /**
   * Frees internal resources.
   */
  dispose() {
    super.dispose(), this.caches = /* @__PURE__ */ new Map(), this.programs = {
      vertex: /* @__PURE__ */ new Map(),
      fragment: /* @__PURE__ */ new Map(),
      compute: /* @__PURE__ */ new Map()
    };
  }
  /**
   * Updates the pipeline for the given render object.
   *
   * @param {RenderObject} renderObject - The render object.
   */
  updateForRender(e) {
    this.getForRender(e);
  }
  /**
   * Returns a compute pipeline for the given parameters.
   *
   * @private
   * @param {Node} computeNode - The compute node.
   * @param {ProgrammableStage} stageCompute - The programmable stage representing the compute shader.
   * @param {string} cacheKey - The cache key.
   * @param {Array<BindGroup>} bindings - The bindings.
   * @return {ComputePipeline} The compute pipeline.
   */
  _getComputePipeline(e, t, n, r) {
    n = n || this._getComputeCacheKey(e, t);
    let s = this.caches.get(n);
    return s === void 0 && (s = new ate(n, t), this.caches.set(n, s), this.backend.createComputePipeline(s, r)), s;
  }
  /**
   * Returns a render pipeline for the given parameters.
   *
   * @private
   * @param {RenderObject} renderObject - The render object.
   * @param {ProgrammableStage} stageVertex - The programmable stage representing the vertex shader.
   * @param {ProgrammableStage} stageFragment - The programmable stage representing the fragment shader.
   * @param {string} cacheKey - The cache key.
   * @param {?Array<Promise>} promises - An array of compilation promises which is only relevant in context of `Renderer.compileAsync()`.
   * @return {ComputePipeline} The compute pipeline.
   */
  _getRenderPipeline(e, t, n, r, s) {
    r = r || this._getRenderCacheKey(e, t, n);
    let o = this.caches.get(r);
    return o === void 0 && (o = new ote(r, t, n), this.caches.set(r, o), e.pipeline = o, this.backend.createRenderPipeline(e, s)), o;
  }
  /**
   * Computes a cache key representing a compute pipeline.
   *
   * @private
   * @param {Node} computeNode - The compute node.
   * @param {ProgrammableStage} stageCompute - The programmable stage representing the compute shader.
   * @return {string} The cache key.
   */
  _getComputeCacheKey(e, t) {
    return e.id + "," + t.id;
  }
  /**
   * Computes a cache key representing a render pipeline.
   *
   * @private
   * @param {RenderObject} renderObject - The render object.
   * @param {ProgrammableStage} stageVertex - The programmable stage representing the vertex shader.
   * @param {ProgrammableStage} stageFragment - The programmable stage representing the fragment shader.
   * @return {string} The cache key.
   */
  _getRenderCacheKey(e, t, n) {
    return t.id + "," + n.id + "," + this.backend.getRenderCacheKey(e);
  }
  /**
   * Releases the given pipeline.
   *
   * @private
   * @param {Pipeline} pipeline - The pipeline to release.
   */
  _releasePipeline(e) {
    this.caches.delete(e.cacheKey);
  }
  /**
   * Releases the shader program.
   *
   * @private
   * @param {Object} program - The shader program to release.
   */
  _releaseProgram(e) {
    const t = e.code, n = e.stage;
    this.programs[n].delete(t);
  }
  /**
   * Returns `true` if the compute pipeline for the given compute node requires an update.
   *
   * @private
   * @param {Node} computeNode - The compute node.
   * @return {boolean} Whether the compute pipeline for the given compute node requires an update or not.
   */
  _needsComputeUpdate(e) {
    const t = this.get(e);
    return t.pipeline === void 0 || t.version !== e.version;
  }
  /**
   * Returns `true` if the render pipeline for the given render object requires an update.
   *
   * @private
   * @param {RenderObject} renderObject - The render object.
   * @return {boolean} Whether the render object for the given render object requires an update or not.
   */
  _needsRenderUpdate(e) {
    return this.get(e).pipeline === void 0 || this.backend.needsRenderUpdate(e);
  }
}
class cte extends ac {
  /**
   * Constructs a new bindings management component.
   *
   * @param {Backend} backend - The renderer's backend.
   * @param {Nodes} nodes - Renderer component for managing nodes related logic.
   * @param {Textures} textures - Renderer component for managing textures.
   * @param {Attributes} attributes - Renderer component for managing attributes.
   * @param {Pipelines} pipelines - Renderer component for managing pipelines.
   * @param {Info} info - Renderer component for managing metrics and monitoring data.
   */
  constructor(e, t, n, r, s, o) {
    super(), this.backend = e, this.textures = n, this.pipelines = s, this.attributes = r, this.nodes = t, this.info = o, this.pipelines.bindings = this;
  }
  /**
   * Returns the bind groups for the given render object.
   *
   * @param {RenderObject} renderObject - The render object.
   * @return {Array<BindGroup>} The bind groups.
   */
  getForRender(e) {
    const t = e.getBindings();
    for (const n of t) {
      const r = this.get(n);
      r.bindGroup === void 0 && (this._init(n), this.backend.createBindings(n, t, 0), r.bindGroup = n);
    }
    return t;
  }
  /**
   * Returns the bind groups for the given compute node.
   *
   * @param {Node} computeNode - The compute node.
   * @return {Array<BindGroup>} The bind groups.
   */
  getForCompute(e) {
    const t = this.nodes.getForCompute(e).bindings;
    for (const n of t) {
      const r = this.get(n);
      r.bindGroup === void 0 && (this._init(n), this.backend.createBindings(n, t, 0), r.bindGroup = n);
    }
    return t;
  }
  /**
   * Updates the bindings for the given compute node.
   *
   * @param {Node} computeNode - The compute node.
   */
  updateForCompute(e) {
    this._updateBindings(this.getForCompute(e));
  }
  /**
   * Updates the bindings for the given render object.
   *
   * @param {RenderObject} renderObject - The render object.
   */
  updateForRender(e) {
    this._updateBindings(this.getForRender(e));
  }
  /**
   * Deletes the bindings for the given compute node.
   *
   * @param {Node} computeNode - The compute node.
   */
  deleteForCompute(e) {
    const t = this.nodes.getForCompute(e).bindings;
    for (const n of t)
      this.backend.deleteBindGroupData(n), this.delete(n);
  }
  /**
   * Deletes the bindings for the given renderObject node.
   *
   * @param {RenderObject} renderObject - The renderObject.
   */
  deleteForRender(e) {
    const t = e.getBindings();
    for (const n of t)
      this.backend.deleteBindGroupData(n), this.delete(n);
  }
  /**
   * Updates the given array of bindings.
   *
   * @param {Array<BindGroup>} bindings - The bind groups.
   */
  _updateBindings(e) {
    for (const t of e)
      this._update(t, e);
  }
  /**
   * Initializes the given bind group.
   *
   * @param {BindGroup} bindGroup - The bind group to initialize.
   */
  _init(e) {
    for (const t of e.bindings)
      if (t.isSampledTexture)
        this.textures.updateTexture(t.texture);
      else if (t.isSampler)
        this.textures.updateSampler(t.texture);
      else if (t.isStorageBuffer) {
        const n = t.attribute, r = n.isIndirectStorageBufferAttribute ? Go.INDIRECT : Go.STORAGE;
        this.attributes.update(n, r);
      }
  }
  /**
   * Updates the given bind group.
   *
   * @param {BindGroup} bindGroup - The bind group to update.
   * @param {Array<BindGroup>} bindings - The bind groups.
   */
  _update(e, t) {
    const { backend: n } = this;
    let r = !1, s = !0, o = 0, a = 0;
    for (const l of e.bindings)
      if (this.nodes.updateGroup(l) !== !1) {
        if (l.isStorageBuffer) {
          const c = l.attribute, A = c.isIndirectStorageBufferAttribute ? Go.INDIRECT : Go.STORAGE;
          this.attributes.update(c, A);
        }
        if (l.isUniformBuffer)
          l.update() && n.updateBinding(l);
        else if (l.isSampledTexture) {
          const c = l.update(), A = l.texture, m = this.textures.get(A);
          if (c && (this.textures.updateTexture(A), l.generation !== m.generation && (l.generation = m.generation, r = !0, s = !1)), n.get(A).externalTexture !== void 0 || m.isDefaultTexture ? s = !1 : (o = o * 10 + A.id, a += A.version), A.isStorageTexture === !0 && A.mipmapsAutoUpdate === !0) {
            const y = this.get(A);
            l.store === !0 ? y.needsMipmap = !0 : this.textures.needsMipmaps(A) && y.needsMipmap === !0 && (this.backend.generateMipmaps(A), y.needsMipmap = !1);
          }
        } else if (l.isSampler && l.update()) {
          const A = this.textures.updateSampler(l.texture);
          l.samplerKey !== A && (l.samplerKey = A, r = !0, s = !1);
        }
      }
    r === !0 && this.backend.updateBindings(e, t, s ? o : 0, a);
  }
}
function hte(i, e) {
  return i.groupOrder !== e.groupOrder ? i.groupOrder - e.groupOrder : i.renderOrder !== e.renderOrder ? i.renderOrder - e.renderOrder : i.z !== e.z ? i.z - e.z : i.id - e.id;
}
function eC(i, e) {
  return i.groupOrder !== e.groupOrder ? i.groupOrder - e.groupOrder : i.renderOrder !== e.renderOrder ? i.renderOrder - e.renderOrder : i.z !== e.z ? e.z - i.z : i.id - e.id;
}
function tC(i) {
  return (i.transmission > 0 || i.transmissionNode && i.transmissionNode.isNode) && i.side === er && i.forceSinglePass === !1;
}
class dte {
  /**
   * Constructs a render list.
   *
   * @param {Lighting} lighting - The lighting management component.
   * @param {Scene} scene - The scene.
   * @param {Camera} camera - The camera the scene is rendered with.
   */
  constructor(e, t, n) {
    this.renderItems = [], this.renderItemsIndex = 0, this.opaque = [], this.transparentDoublePass = [], this.transparent = [], this.bundles = [], this.lightsNode = e.getNode(t, n), this.lightsArray = [], this.scene = t, this.camera = n, this.occlusionQueryCount = 0;
  }
  /**
   * This method is called right at the beginning of a render call
   * before the scene is analyzed. It prepares the internal data
   * structures for the upcoming render lists generation.
   *
   * @return {RenderList} A reference to this render list.
   */
  begin() {
    return this.renderItemsIndex = 0, this.opaque.length = 0, this.transparentDoublePass.length = 0, this.transparent.length = 0, this.bundles.length = 0, this.lightsArray.length = 0, this.occlusionQueryCount = 0, this;
  }
  /**
   * Returns a render item for the giving render item state. The state is defined
   * by a series of object-related parameters.
   *
   * The method avoids object creation by holding render items and reusing them in
   * subsequent render calls (just with different property values).
   *
   * @param {Object3D} object - The 3D object.
   * @param {BufferGeometry} geometry - The 3D object's geometry.
   * @param {Material} material - The 3D object's material.
   * @param {number} groupOrder - The current group order.
   * @param {number} z - Th 3D object's depth value (z value in clip space).
   * @param {?number} group - {?Object} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.
   * @param {ClippingContext} clippingContext - The current clipping context.
   * @return {Object} The render item.
   */
  getNextRenderItem(e, t, n, r, s, o, a) {
    let l = this.renderItems[this.renderItemsIndex];
    return l === void 0 ? (l = {
      id: e.id,
      object: e,
      geometry: t,
      material: n,
      groupOrder: r,
      renderOrder: e.renderOrder,
      z: s,
      group: o,
      clippingContext: a
    }, this.renderItems[this.renderItemsIndex] = l) : (l.id = e.id, l.object = e, l.geometry = t, l.material = n, l.groupOrder = r, l.renderOrder = e.renderOrder, l.z = s, l.group = o, l.clippingContext = a), this.renderItemsIndex++, l;
  }
  /**
   * Pushes the given object as a render item to the internal render lists.
   * The selected lists depend on the object properties.
   *
   * @param {Object3D} object - The 3D object.
   * @param {BufferGeometry} geometry - The 3D object's geometry.
   * @param {Material} material - The 3D object's material.
   * @param {number} groupOrder - The current group order.
   * @param {number} z - Th 3D object's depth value (z value in clip space).
   * @param {?number} group - {?Object} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.
   * @param {ClippingContext} clippingContext - The current clipping context.
   */
  push(e, t, n, r, s, o, a) {
    const l = this.getNextRenderItem(e, t, n, r, s, o, a);
    e.occlusionTest === !0 && this.occlusionQueryCount++, n.transparent === !0 || n.transmission > 0 || n.transmissionNode && n.transmissionNode.isNode || n.backdropNode && n.backdropNode.isNode ? (tC(n) && this.transparentDoublePass.push(l), this.transparent.push(l)) : this.opaque.push(l);
  }
  /**
   * Inserts the given object as a render item at the start of the internal render lists.
   * The selected lists depend on the object properties.
   *
   * @param {Object3D} object - The 3D object.
   * @param {BufferGeometry} geometry - The 3D object's geometry.
   * @param {Material} material - The 3D object's material.
   * @param {number} groupOrder - The current group order.
   * @param {number} z - Th 3D object's depth value (z value in clip space).
   * @param {?number} group - {?Object} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.
   * @param {ClippingContext} clippingContext - The current clipping context.
   */
  unshift(e, t, n, r, s, o, a) {
    const l = this.getNextRenderItem(e, t, n, r, s, o, a);
    n.transparent === !0 || n.transmission > 0 || n.transmissionNode && n.transmissionNode.isNode || n.backdropNode && n.backdropNode.isNode ? (tC(n) && this.transparentDoublePass.unshift(l), this.transparent.unshift(l)) : this.opaque.unshift(l);
  }
  /**
   * Pushes render bundle group data into the render list.
   *
   * @param {Object} group - Bundle group data.
   */
  pushBundle(e) {
    this.bundles.push(e);
  }
  /**
   * Pushes a light into the render list.
   *
   * @param {Light} light - The light.
   */
  pushLight(e) {
    this.lightsArray.push(e);
  }
  /**
   * Sorts the internal render lists.
   *
   * @param {?function(any, any): number} customOpaqueSort - A custom sort function for opaque objects.
   * @param {?function(any, any): number} customTransparentSort -  A custom sort function for transparent objects.
   */
  sort(e, t) {
    this.opaque.length > 1 && this.opaque.sort(e || hte), this.transparentDoublePass.length > 1 && this.transparentDoublePass.sort(t || eC), this.transparent.length > 1 && this.transparent.sort(t || eC);
  }
  /**
   * This method performs finalizing tasks right after the render lists
   * have been generated.
   */
  finish() {
    this.lightsNode.setLights(this.lightsArray);
    for (let e = this.renderItemsIndex, t = this.renderItems.length; e < t; e++) {
      const n = this.renderItems[e];
      if (n.id === null) break;
      n.id = null, n.object = null, n.geometry = null, n.material = null, n.groupOrder = null, n.renderOrder = null, n.z = null, n.group = null, n.clippingContext = null;
    }
  }
}
const jA = [];
class fte {
  /**
   * Constructs a render lists management component.
   *
   * @param {Lighting} lighting - The lighting management component.
   */
  constructor(e) {
    this.lighting = e, this.lists = new wa();
  }
  /**
   * Returns a render list for the given scene and camera.
   *
   * @param {Scene} scene - The scene.
   * @param {Camera} camera - The camera.
   * @return {RenderList} The render list.
   */
  get(e, t) {
    const n = this.lists;
    jA[0] = e, jA[1] = t;
    let r = n.get(jA);
    return r === void 0 && (r = new dte(this.lighting, e, t), n.set(jA, r)), jA.length = 0, r;
  }
  /**
   * Frees all internal resources.
   */
  dispose() {
    this.lists = new wa();
  }
}
let Ate = 0;
class pte {
  /**
   * Constructs a new render context.
   */
  constructor() {
    this.id = Ate++, this.color = !0, this.clearColor = !0, this.clearColorValue = { r: 0, g: 0, b: 0, a: 1 }, this.depth = !0, this.clearDepth = !0, this.clearDepthValue = 1, this.stencil = !1, this.clearStencil = !0, this.clearStencilValue = 1, this.viewport = !1, this.viewportValue = new Kt(), this.scissor = !1, this.scissorValue = new Kt(), this.renderTarget = null, this.textures = null, this.depthTexture = null, this.activeCubeFace = 0, this.activeMipmapLevel = 0, this.sampleCount = 1, this.width = 0, this.height = 0, this.occlusionQueryCount = 0, this.clippingContext = null, this.isRenderContext = !0;
  }
  /**
   * Returns the cache key of this render context.
   *
   * @return {number} The cache key.
   */
  getCacheKey() {
    return ML(this);
  }
}
function ML(i) {
  const { textures: e, activeCubeFace: t, activeMipmapLevel: n } = i, r = [t, n];
  for (const s of e)
    r.push(s.id);
  return cA(r);
}
const Xd = [], mte = /* @__PURE__ */ new oA(), gte = /* @__PURE__ */ new Jh();
class _te {
  /**
   * Constructs a new render context management component.
   */
  constructor() {
    this.chainMaps = {};
  }
  /**
   * Returns a render context for the given scene, camera and render target.
   *
   * @param {Scene} scene - The scene.
   * @param {Camera} camera - The camera that is used to render the scene.
   * @param {?RenderTarget} [renderTarget=null] - The active render target.
   * @param {?MRT} [mrt=null] - The active multiple render target.
   * @return {RenderContext} The render context.
   */
  get(e, t, n = null, r = null) {
    Xd[0] = e, Xd[1] = t, r !== null && (Xd[2] = r);
    let s;
    if (n === null)
      s = "default";
    else {
      const l = n.texture.format;
      s = `${n.textures.length}:${l}:${n.samples}:${n.depthBuffer}:${n.stencilBuffer}`;
    }
    const o = this._getChainMap(s);
    let a = o.get(Xd);
    return a === void 0 && (a = new pte(), o.set(Xd, a)), Xd.length = 0, n !== null && (a.sampleCount = n.samples === 0 ? 1 : n.samples), a;
  }
  /**
   * Returns a render context intended for clear operations.
   *
   * @param {?RenderTarget} [renderTarget=null] - The active render target.
   * @return {RenderContext} The render context.
   */
  getForClear(e = null) {
    return this.get(mte, gte, e);
  }
  /**
   * Returns a chain map for the given attachment state.
   *
   * @private
   * @param {string} attachmentState - The attachment state.
   * @return {ChainMap} The chain map.
   */
  _getChainMap(e) {
    return this.chainMaps[e] || (this.chainMaps[e] = new wa());
  }
  /**
   * Frees internal resources.
   */
  dispose() {
    this.chainMaps = {};
  }
}
const xte = /* @__PURE__ */ new j();
class yte extends ac {
  /**
   * Constructs a new texture management component.
   *
   * @param {Renderer} renderer - The renderer.
   * @param {Backend} backend - The renderer's backend.
   * @param {Info} info - Renderer component for managing metrics and monitoring data.
   */
  constructor(e, t, n) {
    super(), this.renderer = e, this.backend = t, this.info = n;
  }
  /**
   * Updates the given render target. Based on the given render target configuration,
   * it updates the texture states representing the attachments of the framebuffer.
   *
   * @param {RenderTarget} renderTarget - The render target to update.
   * @param {number} [activeMipmapLevel=0] - The active mipmap level.
   */
  updateRenderTarget(e, t = 0) {
    const n = this.get(e), r = e.samples === 0 ? 1 : e.samples, s = n.depthTextureMips || (n.depthTextureMips = {}), o = e.textures, a = this.getSize(o[0]), l = a.width >> t, u = a.height >> t;
    let c = e.depthTexture || s[t];
    const A = e.depthBuffer === !0 || e.stencilBuffer === !0;
    let m = !1;
    c === void 0 && A && (c = new Qr(), c.format = e.stencilBuffer ? ds : Lr, c.type = e.stencilBuffer ? Js : Jn, c.image.width = l, c.image.height = u, c.image.depth = a.depth, c.renderTarget = e, c.isArrayTexture = e.multiview === !0 && a.depth > 1, s[t] = c), (n.width !== a.width || a.height !== n.height) && (m = !0, c && (c.needsUpdate = !0, c.image.width = l, c.image.height = u, c.image.depth = c.isArrayTexture ? c.image.depth : 1)), n.width = a.width, n.height = a.height, n.textures = o, n.depthTexture = c || null, n.depth = e.depthBuffer, n.stencil = e.stencilBuffer, n.renderTarget = e, n.sampleCount !== r && (m = !0, c && (c.needsUpdate = !0), n.sampleCount = r);
    const _ = { sampleCount: r };
    if (e.isXRRenderTarget !== !0) {
      for (let y = 0; y < o.length; y++) {
        const T = o[y];
        m && (T.needsUpdate = !0), this.updateTexture(T, _);
      }
      c && this.updateTexture(c, _);
    }
    n.initialized !== !0 && (n.initialized = !0, n.onDispose = () => {
      this._destroyRenderTarget(e);
    }, e.addEventListener("dispose", n.onDispose));
  }
  /**
   * Updates the given texture. Depending on the texture state, this method
   * triggers the upload of texture data to the GPU memory. If the texture data are
   * not yet ready for the upload, it uses default texture data for as a placeholder.
   *
   * @param {Texture} texture - The texture to update.
   * @param {Object} [options={}] - The options.
   */
  updateTexture(e, t = {}) {
    const n = this.get(e);
    if (n.initialized === !0 && n.version === e.version) return;
    const r = e.isRenderTargetTexture || e.isDepthTexture || e.isFramebufferTexture, s = this.backend;
    if (r && n.initialized === !0 && s.destroyTexture(e), e.isFramebufferTexture) {
      const u = this.renderer.getRenderTarget();
      u ? e.type = u.texture.type : e.type = Mi;
    }
    const { width: o, height: a, depth: l } = this.getSize(e);
    if (t.width = o, t.height = a, t.depth = l, t.needsMipmaps = this.needsMipmaps(e), t.levels = t.needsMipmaps ? this.getMipLevels(e, o, a) : 1, e.isCubeTexture && e.mipmaps.length > 0 && t.levels++, r || e.isStorageTexture === !0 || e.isExternalTexture === !0)
      s.createTexture(e, t), n.generation = e.version;
    else if (e.version > 0) {
      const u = e.image;
      if (u === void 0)
        Me("Renderer: Texture marked for update but image is undefined.");
      else if (u.complete === !1)
        Me("Renderer: Texture marked for update but image is incomplete.");
      else {
        if (e.images) {
          const A = [];
          for (const m of e.images)
            A.push(m);
          t.images = A;
        } else
          t.image = u;
        (n.isDefaultTexture === void 0 || n.isDefaultTexture === !0) && (s.createTexture(e, t), n.isDefaultTexture = !1, n.generation = e.version), e.source.dataReady === !0 && s.updateTexture(e, t);
        const c = e.isStorageTexture === !0 && e.mipmapsAutoUpdate === !1;
        t.needsMipmaps && e.mipmaps.length === 0 && !c && s.generateMipmaps(e), e.onUpdate && e.onUpdate(e);
      }
    } else
      s.createDefaultTexture(e), n.isDefaultTexture = !0, n.generation = e.version;
    n.initialized !== !0 && (n.initialized = !0, n.generation = e.version, this.info.memory.textures++, e.isVideoTexture && Xt.enabled === !0 && Xt.getTransfer(e.colorSpace) !== vt && Me("WebGPURenderer: Video textures must use a color space with a sRGB transfer function, e.g. SRGBColorSpace."), n.onDispose = () => {
      this._destroyTexture(e);
    }, e.addEventListener("dispose", n.onDispose)), n.version = e.version;
  }
  /**
   * Updates the sampler for the given texture. This method has no effect
   * for the WebGL backend since it has no concept of samplers. Texture
   * parameters are configured with the `texParameter()` command for each
   * texture.
   *
   * In WebGPU, samplers are objects like textures and it's possible to share
   * them when the texture parameters match.
   *
   * @param {Texture} texture - The texture to update the sampler for.
   * @return {string} The current sampler key.
   */
  updateSampler(e) {
    return this.backend.updateSampler(e);
  }
  /**
   * Computes the size of the given texture and writes the result
   * into the target vector. This vector is also returned by the
   * method.
   *
   * If no texture data are available for the compute yet, the method
   * returns default size values.
   *
   * @param {Texture} texture - The texture to compute the size for.
   * @param {Vector3} target - The target vector.
   * @return {Vector3} The target vector.
   */
  getSize(e, t = xte) {
    let n = e.images ? e.images[0] : e.image;
    return n ? (n.image !== void 0 && (n = n.image), typeof HTMLVideoElement < "u" && n instanceof HTMLVideoElement ? (t.width = n.videoWidth || 1, t.height = n.videoHeight || 1, t.depth = 1) : typeof VideoFrame < "u" && n instanceof VideoFrame ? (t.width = n.displayWidth || 1, t.height = n.displayHeight || 1, t.depth = 1) : (t.width = n.width || 1, t.height = n.height || 1, t.depth = e.isCubeTexture ? 6 : n.depth || 1)) : t.width = t.height = t.depth = 1, t;
  }
  /**
   * Computes the number of mipmap levels for the given texture.
   *
   * @param {Texture} texture - The texture.
   * @param {number} width - The texture's width.
   * @param {number} height - The texture's height.
   * @return {number} The number of mipmap levels.
   */
  getMipLevels(e, t, n) {
    let r;
    return e.mipmaps.length > 0 ? r = e.mipmaps.length : e.isCompressedTexture === !0 ? r = 1 : r = Math.floor(Math.log2(Math.max(t, n))) + 1, r;
  }
  /**
   * Returns `true` if the given texture makes use of mipmapping.
   *
   * @param {Texture} texture - The texture.
   * @return {boolean} Whether mipmaps are required or not.
   */
  needsMipmaps(e) {
    return e.generateMipmaps === !0 || e.mipmaps.length > 0;
  }
  /**
   * Frees internal resources when the given render target isn't
   * required anymore.
   *
   * @param {RenderTarget} renderTarget - The render target to destroy.
   */
  _destroyRenderTarget(e) {
    if (this.has(e) === !0) {
      const t = this.get(e), n = t.textures, r = t.depthTexture;
      e.removeEventListener("dispose", t.onDispose);
      for (let s = 0; s < n.length; s++)
        this._destroyTexture(n[s]);
      r && this._destroyTexture(r), this.delete(e), this.backend.delete(e);
    }
  }
  /**
   * Frees internal resource when the given texture isn't
   * required anymore.
   *
   * @param {Texture} texture - The texture to destroy.
   */
  _destroyTexture(e) {
    if (this.has(e) === !0) {
      const t = this.get(e);
      e.removeEventListener("dispose", t.onDispose);
      const n = t.isDefaultTexture;
      this.backend.destroyTexture(e, n), this.delete(e), this.info.memory.textures--;
    }
  }
}
class HT extends ct {
  /**
   * Constructs a new four-component color.
   * You can also pass a single THREE.Color, hex or
   * string argument to this constructor.
   *
   * @param {number|string} [r=1] - The red value.
   * @param {number} [g=1] - The green value.
   * @param {number} [b=1] - The blue value.
   * @param {number} [a=1] - The alpha value.
   */
  constructor(e, t, n, r = 1) {
    super(e, t, n), this.a = r;
  }
  /**
   * Overwrites the default to honor alpha.
   * You can also pass a single THREE.Color, hex or
   * string argument to this method.
   *
   * @param {number|string|Color} r - The red value.
   * @param {number} [g] - The green value.
   * @param {number} [b] - The blue value.
   * @param {number} [a=1] - The alpha value.
   * @return {Color4} A reference to this object.
   */
  set(e, t, n, r = 1) {
    return this.a = r, super.set(e, t, n);
  }
  /**
   * Overwrites the default to honor alpha.
   *
   * @param {Color4} color - The color to copy.
   * @return {Color4} A reference to this object.
   */
  copy(e) {
    return e.a !== void 0 && (this.a = e.a), super.copy(e);
  }
  /**
   * Overwrites the default to honor alpha.
   *
   * @return {Color4} The cloned color.
   */
  clone() {
    return new this.constructor(this.r, this.g, this.b, this.a);
  }
}
class EL extends Qn {
  static get type() {
    return "ParameterNode";
  }
  /**
   * Constructs a new parameter node.
   *
   * @param {string} nodeType - The type of the node.
   * @param {?string} [name=null] - The name of the parameter in the shader.
   */
  constructor(e, t = null) {
    super(e, t), this.isParameterNode = !0;
  }
  /**
   * Gets the type of a member variable in the parameter node.
   *
   * @param {NodeBuilder} builder - The node builder.
   * @param {string} name - The name of the member variable.
   * @returns {string}
   */
  getMemberType(e, t) {
    const n = this.getNodeType(e), r = e.getStructTypeNode(n);
    let s;
    return r !== null ? s = r.getMemberType(e, t) : (Ie(`TSL: Member "${t}" not found in struct "${n}".`), s = "float"), s;
  }
  getHash() {
    return this.uuid;
  }
  generate() {
    return this.name;
  }
}
const vte = (i, e) => new EL(i, e);
class bte extends St {
  static get type() {
    return "StackNode";
  }
  /**
   * Constructs a new stack node.
   *
   * @param {?StackNode} [parent=null] - The parent stack node.
   */
  constructor(e = null) {
    super(), this.nodes = [], this.outputNode = null, this.parent = e, this._currentCond = null, this._expressionNode = null, this._currentNode = null, this.isStackNode = !0;
  }
  getElementType(e) {
    return this.hasOutput ? this.outputNode.getElementType(e) : "void";
  }
  getNodeType(e) {
    return this.hasOutput ? this.outputNode.getNodeType(e) : "void";
  }
  getMemberType(e, t) {
    return this.hasOutput ? this.outputNode.getMemberType(e, t) : "void";
  }
  /**
   * Adds a node to this stack.
   *
   * @param {Node} node - The node to add.
   * @param {number} [index=this.nodes.length] - The index where the node should be added.
   * @return {StackNode} A reference to this stack node.
   */
  addToStack(e, t = this.nodes.length) {
    return e.isNode !== !0 ? (Ie("TSL: Invalid node added to stack."), this) : (this.nodes.splice(t, 0, e), this);
  }
  /**
   * Adds a node to the stack before the current node.
   *
   * @param {Node} node - The node to add.
   * @return {StackNode} A reference to this stack node.
   */
  addToStackBefore(e) {
    const t = this._currentNode ? this.nodes.indexOf(this._currentNode) : 0;
    return this.addToStack(e, t);
  }
  /**
   * Represent an `if` statement in TSL.
   *
   * @param {Node} boolNode - Represents the condition.
   * @param {Function} method - TSL code which is executed if the condition evaluates to `true`.
   * @return {StackNode} A reference to this stack node.
   */
  If(e, t) {
    const n = new df(t);
    return this._currentCond = Yr(e, n), this.addToStack(this._currentCond);
  }
  /**
   * Represent an `elseif` statement in TSL.
   *
   * @param {Node} boolNode - Represents the condition.
   * @param {Function} method - TSL code which is executed if the condition evaluates to `true`.
   * @return {StackNode} A reference to this stack node.
   */
  ElseIf(e, t) {
    const n = new df(t), r = Yr(e, n);
    return this._currentCond.elseNode = r, this._currentCond = r, this;
  }
  /**
   * Represent an `else` statement in TSL.
   *
   * @param {Function} method - TSL code which is executed in the `else` case.
   * @return {StackNode} A reference to this stack node.
   */
  Else(e) {
    return this._currentCond.elseNode = new df(e), this;
  }
  /**
   * Represents a `switch` statement in TSL.
   *
   * @param {any} expression - Represents the expression.
   * @param {Function} method - TSL code which is executed if the condition evaluates to `true`.
   * @return {StackNode} A reference to this stack node.
   */
  Switch(e) {
    return this._expressionNode = ut(e), this;
  }
  /**
   * Represents a `case` statement in TSL. The TSL version accepts an arbitrary numbers of values.
   * The last parameter must be the callback method that should be executed in the `true` case.
   *
   * @param {...any} params - The values of the `Case()` statement as well as the callback method.
   * @return {StackNode} A reference to this stack node.
   */
  Case(...e) {
    const t = [];
    if (e.length >= 2)
      for (let a = 0; a < e.length - 1; a++)
        t.push(this._expressionNode.equal(ut(e[a])));
    else
      Ie("TSL: Invalid parameter length. Case() requires at least two parameters.");
    const n = e[e.length - 1], r = new df(n);
    let s = t[0];
    for (let a = 1; a < t.length; a++)
      s = s.or(t[a]);
    const o = Yr(s, r);
    return this._currentCond === null ? (this._currentCond = o, this.addToStack(this._currentCond)) : (this._currentCond.elseNode = o, this._currentCond = o, this);
  }
  /**
   * Represents the default code block of a Switch/Case statement.
   *
   * @param {Function} method - TSL code which is executed in the `else` case.
   * @return {StackNode} A reference to this stack node.
   */
  Default(e) {
    return this.Else(e), this;
  }
  setup(e) {
    const t = e.getNodeProperties(this);
    let n = 0;
    for (const r of this.getChildren())
      r.isVarNode && r.isIntent(e) && r.isAssign(e) !== !0 || (t["node" + n++] = r);
    return t.outputNode || null;
  }
  get hasOutput() {
    return this.outputNode && this.outputNode.isNode;
  }
  build(e, ...t) {
    const n = VS(), r = e.buildStage;
    s0(this), e.setActiveStack(this);
    const s = (u) => {
      if (this._currentNode = u, !(u.isVarNode && u.isIntent(e) && u.isAssign(e) !== !0)) {
        if (r === "setup")
          u.build(e);
        else if (r === "analyze")
          u.build(e, this);
        else if (r === "generate") {
          const c = e.getDataFromNode(u, "any").stages, A = c && c[e.shaderStage];
          if (u.isVarNode && A && A.length === 1 && A[0] && A[0].isStackNode)
            return;
          u.build(e, "void");
        }
      }
    }, o = [...this.nodes];
    for (const u of o)
      s(u);
    this._currentNode = null;
    const a = this.nodes.filter((u) => o.indexOf(u) === -1);
    for (const u of a)
      s(u);
    let l;
    return this.hasOutput ? l = this.outputNode.build(e, ...t) : l = super.build(e, ...t), s0(n), e.removeActiveStack(this), l;
  }
}
const o1 = /* @__PURE__ */ on(bte).setParameterLength(0, 1);
function Ste(i) {
  return Object.entries(i).map(([e, t]) => typeof t == "string" ? { name: e, type: t, atomic: !1 } : { name: e, type: t.type, atomic: t.atomic || !1 });
}
class Tte extends St {
  static get type() {
    return "StructTypeNode";
  }
  /**
   * Creates an instance of StructTypeNode.
   *
   * @param {Object} membersLayout - The layout of the members for the struct.
   * @param {?string} [name=null] - The optional name of the struct.
   */
  constructor(e, t = null) {
    super("struct"), this.membersLayout = Ste(e), this.name = t, this.isStructLayoutNode = !0;
  }
  /**
   * Returns the length of the struct.
   * The length is calculated by summing the lengths of the struct's members.
   *
   * @returns {number} The length of the struct.
   */
  getLength() {
    const e = Float32Array.BYTES_PER_ELEMENT;
    let t = 1, n = 0;
    for (const r of this.membersLayout) {
      const s = r.type, o = WQ(s), a = $Q(s) / e;
      t = Math.max(t, a);
      const u = n % t % a;
      u !== 0 && (n += a - u), n += o;
    }
    return Math.ceil(n / t) * t;
  }
  getMemberType(e, t) {
    const n = this.membersLayout.find((r) => r.name === t);
    return n ? n.type : "void";
  }
  getNodeType(e) {
    return e.getStructTypeFromNode(this, this.membersLayout, this.name).name;
  }
  setup(e) {
    e.getStructTypeFromNode(this, this.membersLayout, this.name), e.addInclude(this);
  }
  generate(e) {
    return this.getNodeType(e);
  }
}
class wte extends St {
  static get type() {
    return "StructNode";
  }
  constructor(e, t) {
    super("vec3"), this.structTypeNode = e, this.values = t, this.isStructNode = !0;
  }
  getNodeType(e) {
    return this.structTypeNode.getNodeType(e);
  }
  getMemberType(e, t) {
    return this.structTypeNode.getMemberType(e, t);
  }
  generate(e) {
    const t = e.getVarFromNode(this), n = t.type, r = e.getPropertyName(t);
    return e.addLineFlowCode(`${r} = ${e.generateStruct(n, this.structTypeNode.membersLayout, this.values)}`, this), t.name;
  }
}
const Mte = (i, e = null) => {
  const t = new Tte(i, e), n = (...r) => {
    let s = null;
    if (r.length > 0)
      if (r[0].isNode) {
        s = {};
        const o = Object.keys(i);
        for (let a = 0; a < r.length; a++)
          s[o[a]] = r[a];
      } else
        s = r[0];
    return new wte(t, s);
  };
  return n.layout = t, n.isStruct = !0, n;
};
class RL extends St {
  static get type() {
    return "OutputStructNode";
  }
  /**
   * Constructs a new output struct node. The constructor can be invoked with an
   * arbitrary number of nodes representing the members.
   *
   * @param {...Node} members - A parameter list of nodes.
   */
  constructor(...e) {
    super(), this.members = e, this.isOutputStructNode = !0;
  }
  getNodeType(e) {
    const t = e.getNodeProperties(this);
    if (t.membersLayout === void 0) {
      const n = this.members, r = [];
      for (let s = 0; s < n.length; s++) {
        const o = "m" + s, a = n[s].getNodeType(e);
        r.push({ name: o, type: a, index: s });
      }
      t.membersLayout = r, t.structType = e.getOutputStructTypeFromNode(this, t.membersLayout);
    }
    return t.structType.name;
  }
  generate(e) {
    const t = e.getOutputStructName(), n = this.members, r = t !== "" ? t + "." : "";
    for (let s = 0; s < n.length; s++) {
      const o = n[s].build(e);
      e.addLineFlowCode(`${r}m${s} = ${o}`, this);
    }
    return t;
  }
}
const Ete = /* @__PURE__ */ on(RL);
function CL(i, e) {
  for (let t = 0; t < i.length; t++)
    if (i[t].name === e)
      return t;
  return -1;
}
class Rte extends RL {
  static get type() {
    return "MRTNode";
  }
  /**
   * Constructs a new output struct node.
   *
   * @param {Object<string, Node>} outputNodes - The MRT outputs.
   */
  constructor(e) {
    super(), this.outputNodes = e, this.isMRTNode = !0;
  }
  /**
   * Returns `true` if the MRT node has an output with the given name.
   *
   * @param {string} name - The name of the output.
   * @return {NodeBuilder} Whether the MRT node has an output for the given name or not.
   */
  has(e) {
    return this.outputNodes[e] !== void 0;
  }
  /**
   * Returns the output node for the given name.
   *
   * @param {string} name - The name of the output.
   * @return {Node} The output node.
   */
  get(e) {
    return this.outputNodes[e];
  }
  /**
   * Merges the outputs of the given MRT node with the outputs of this node.
   *
   * @param {MRTNode} mrtNode - The MRT to merge.
   * @return {MRTNode} A new MRT node with merged outputs..
   */
  merge(e) {
    const t = { ...this.outputNodes, ...e.outputNodes };
    return PL(t);
  }
  setup(e) {
    const t = this.outputNodes, n = e.renderer.getRenderTarget(), r = [], s = n.textures;
    for (const o in t) {
      const a = CL(s, o);
      r[a] = Gt(t[o]);
    }
    return this.members = r, super.setup(e);
  }
}
const PL = /* @__PURE__ */ on(Rte);
class q0 extends Hi {
  static get type() {
    return "BitcastNode";
  }
  /**
   * Constructs a new bitcast node.
   *
   * @param {Node} valueNode - The value to convert.
   * @param {string} conversionType - The type to convert to.
   * @param {?string} [inputType = null] - The expected input data type of the bitcast operation.
   */
  constructor(e, t, n = null) {
    super(), this.valueNode = e, this.conversionType = t, this.inputType = n, this.isBitcastNode = !0;
  }
  getNodeType(e) {
    if (this.inputType !== null) {
      const t = this.valueNode.getNodeType(e), n = e.getTypeLength(t);
      return e.getTypeFromLength(n, this.conversionType);
    }
    return this.conversionType;
  }
  generate(e) {
    const t = this.getNodeType(e);
    let n = "";
    if (this.inputType !== null) {
      const r = this.valueNode.getNodeType(e);
      n = e.getTypeLength(r) === 1 ? this.inputType : e.changeComponentType(r, this.inputType);
    } else
      n = this.valueNode.getNodeType(e);
    return `${e.getBitcastMethod(t, n)}( ${this.valueNode.build(e, n)} )`;
  }
}
const NL = /* @__PURE__ */ Ke(q0).setParameterLength(2), Cte = (i) => new q0(i, "int", "float"), DL = (i) => new q0(i, "uint", "float"), Pte = (i) => new q0(i, "float", "int"), Nte = (i) => new q0(i, "float", "uint"), pg = {};
class Mo extends Se {
  static get type() {
    return "BitcountNode";
  }
  /**
   * Constructs a new math node.
   *
   * @param {'countTrailingZeros'|'countLeadingZeros'|'countOneBits'} method - The method name.
   * @param {Node} aNode - The first input.
   */
  constructor(e, t) {
    super(e, t), this.isBitcountNode = !0;
  }
  /**
   * Casts the input value of the function to an integer if necessary.
   *
   * @private
   * @param {Node<uint>|Node<int>} inputNode - The input value.
   * @param {Node<uint>} outputNode - The output value.
   * @param {string} elementType - The type of the input value.
   */
  _resolveElementType(e, t, n) {
    n === "int" ? t.assign(NL(e, "uint")) : t.assign(e);
  }
  _returnDataNode(e) {
    switch (e) {
      case "uint":
        return Ge;
      case "int":
        return le;
      case "uvec2":
        return GS;
      case "uvec3":
        return od;
      case "uvec4":
        return WS;
      case "ivec2":
        return ur;
      case "ivec3":
        return zS;
      case "ivec4":
        return HS;
    }
  }
  /**
   * Creates and registers a reusable GLSL function that emulates the behavior of countTrailingZeros.
   *
   * @private
   * @param {string} method - The name of the function to create.
   * @param {string} elementType - The type of the input value.
   * @returns {Function} - The generated function
   */
  _createTrailingZerosBaseLayout(e, t) {
    const n = this._returnDataNode(t);
    return pe(([s]) => {
      const o = Ge(0);
      this._resolveElementType(s, o, t);
      const a = J(o.bitAnd(rT(o))), u = DL(a).shiftRight(23).sub(127);
      return n(u);
    }).setLayout({
      name: e,
      type: t,
      inputs: [
        { name: "value", type: t }
      ]
    });
  }
  /**
   * Creates and registers a reusable GLSL function that emulates the behavior of countLeadingZeros.
   *
   * @private
   * @param {string} method - The name of the function to create.
   * @param {string} elementType - The type of the input value.
   * @returns {Function} - The generated function
   */
  _createLeadingZerosBaseLayout(e, t) {
    const n = this._returnDataNode(t);
    return pe(([s]) => {
      Ot(s.equal(Ge(0)), () => Ge(32));
      const o = Ge(0), a = Ge(0);
      return this._resolveElementType(s, o, t), Ot(o.shiftRight(16).equal(0), () => {
        a.addAssign(16), o.shiftLeftAssign(16);
      }), Ot(o.shiftRight(24).equal(0), () => {
        a.addAssign(8), o.shiftLeftAssign(8);
      }), Ot(o.shiftRight(28).equal(0), () => {
        a.addAssign(4), o.shiftLeftAssign(4);
      }), Ot(o.shiftRight(30).equal(0), () => {
        a.addAssign(2), o.shiftLeftAssign(2);
      }), Ot(o.shiftRight(31).equal(0), () => {
        a.addAssign(1);
      }), n(a);
    }).setLayout({
      name: e,
      type: t,
      inputs: [
        { name: "value", type: t }
      ]
    });
  }
  /**
   * Creates and registers a reusable GLSL function that emulates the behavior of countOneBits.
   *
   * @private
   * @param {string} method - The name of the function to create.
   * @param {string} elementType - The type of the input value.
   * @returns {Function} - The generated function
   */
  _createOneBitsBaseLayout(e, t) {
    const n = this._returnDataNode(t);
    return pe(([s]) => {
      const o = Ge(0);
      this._resolveElementType(s, o, t), o.assign(o.sub(o.shiftRight(Ge(1)).bitAnd(Ge(1431655765)))), o.assign(o.bitAnd(Ge(858993459)).add(o.shiftRight(Ge(2)).bitAnd(Ge(858993459))));
      const a = o.add(o.shiftRight(Ge(4))).bitAnd(Ge(252645135)).mul(Ge(16843009)).shiftRight(Ge(24));
      return n(a);
    }).setLayout({
      name: e,
      type: t,
      inputs: [
        { name: "value", type: t }
      ]
    });
  }
  /**
   * Creates and registers a reusable GLSL function that emulates the behavior of the specified bitcount function.
   * including considerations for component-wise bitcounts on vector type inputs.
   *
   * @private
   * @param {string} method - The name of the function to create.
   * @param {string} inputType - The type of the input value.
   * @param {number} typeLength - The vec length of the input value.
   * @param {Function} baseFn - The base function that operates on an individual component of the vector.
   * @returns {Function} - The alias function for the specified bitcount method.
   */
  _createMainLayout(e, t, n, r) {
    const s = this._returnDataNode(t);
    return pe(([a]) => {
      if (n === 1)
        return s(r(a));
      {
        const l = s(0), u = ["x", "y", "z", "w"];
        for (let c = 0; c < n; c++) {
          const A = u[c];
          l[A].assign(r(a[A]));
        }
        return l;
      }
    }).setLayout({
      name: e,
      type: t,
      inputs: [
        { name: "value", type: t }
      ]
    });
  }
  setup(e) {
    const { method: t, aNode: n } = this, { renderer: r } = e;
    if (r.backend.isWebGPUBackend)
      return super.setup(e);
    const s = this.getInputType(e), o = e.getElementType(s), a = e.getTypeLength(s), l = `${t}_base_${o}`, u = `${t}_${s}`;
    let c = pg[l];
    if (c === void 0) {
      switch (t) {
        case Mo.COUNT_LEADING_ZEROS: {
          c = this._createLeadingZerosBaseLayout(l, o);
          break;
        }
        case Mo.COUNT_TRAILING_ZEROS: {
          c = this._createTrailingZerosBaseLayout(l, o);
          break;
        }
        case Mo.COUNT_ONE_BITS: {
          c = this._createOneBitsBaseLayout(l, o);
          break;
        }
      }
      pg[l] = c;
    }
    let A = pg[u];
    return A === void 0 && (A = this._createMainLayout(u, s, a, c), pg[u] = A), pe(() => A(
      n
    ))();
  }
}
Mo.COUNT_TRAILING_ZEROS = "countTrailingZeros";
Mo.COUNT_LEADING_ZEROS = "countLeadingZeros";
Mo.COUNT_ONE_BITS = "countOneBits";
const Dte = /* @__PURE__ */ Ke(Mo, Mo.COUNT_TRAILING_ZEROS).setParameterLength(1), Lte = /* @__PURE__ */ Ke(Mo, Mo.COUNT_LEADING_ZEROS).setParameterLength(1), Ite = /* @__PURE__ */ Ke(Mo, Mo.COUNT_ONE_BITS).setParameterLength(1), Bte = /* @__PURE__ */ pe(([i]) => {
  const e = i.toUint().mul(747796405).add(2891336453), t = e.shiftRight(e.shiftRight(28).add(4)).bitXor(e).mul(277803737);
  return t.shiftRight(22).bitXor(t).toFloat().mul(1 / 2 ** 32);
}), Kb = (i, e) => ko(sn(4, i.mul(Un(1, i))), e), Fte = (i, e) => i.lessThan(0.5) ? Kb(i.mul(2), e).div(2) : Un(1, Kb(sn(Un(1, i), 2), e).div(2)), Ute = (i, e, t) => ko(Ro(ko(i, e), sr(ko(i, e), ko(Un(1, i), t))), 1 / e), Ote = (i, e) => Ns(u_.mul(e.mul(i).sub(1))).div(u_.mul(e.mul(i).sub(1)));
class WT extends Hi {
  static get type() {
    return "PackFloatNode";
  }
  /**
   *
   * @param {'snorm' | 'unorm' | 'float16'} encoding - The numeric encoding that describes how the float values are mapped to the integer range.
   * @param {Node} vectorNode - The vector node to be packed
   */
  constructor(e, t) {
    super(), this.vectorNode = t, this.encoding = e, this.isPackFloatNode = !0;
  }
  getNodeType() {
    return "uint";
  }
  generate(e) {
    const t = this.vectorNode.getNodeType(e);
    return `${e.getFloatPackingMethod(this.encoding)}(${this.vectorNode.build(e, t)})`;
  }
}
const kte = /* @__PURE__ */ Ke(WT, "snorm").setParameterLength(1), Vte = /* @__PURE__ */ Ke(WT, "unorm").setParameterLength(1), Gte = /* @__PURE__ */ Ke(WT, "float16").setParameterLength(1);
class $T extends Hi {
  static get type() {
    return "UnpackFloatNode";
  }
  /**
   *
   * @param {'snorm' | 'unorm' | 'float16'} encoding - The numeric encoding that describes how the integer values are mapped to the float range
   * @param {Node} uintNode - The uint node to be unpacked
   */
  constructor(e, t) {
    super(), this.uintNode = t, this.encoding = e, this.isUnpackFloatNode = !0;
  }
  getNodeType() {
    return "vec2";
  }
  generate(e) {
    const t = this.uintNode.getNodeType(e);
    return `${e.getFloatUnpackingMethod(this.encoding)}(${this.uintNode.build(e, t)})`;
  }
}
const zte = /* @__PURE__ */ Ke($T, "snorm").setParameterLength(1), qte = /* @__PURE__ */ Ke($T, "unorm").setParameterLength(1), Hte = /* @__PURE__ */ Ke($T, "float16").setParameterLength(1), Sl = /* @__PURE__ */ pe(([i]) => i.fract().sub(0.5).abs()).setLayout({
  name: "tri",
  type: "float",
  inputs: [
    { name: "x", type: "float" }
  ]
}), Wte = /* @__PURE__ */ pe(([i]) => ce(Sl(i.z.add(Sl(i.y.mul(1)))), Sl(i.z.add(Sl(i.x.mul(1)))), Sl(i.y.add(Sl(i.x.mul(1)))))).setLayout({
  name: "tri3",
  type: "vec3",
  inputs: [
    { name: "p", type: "vec3" }
  ]
}), $te = /* @__PURE__ */ pe(([i, e, t]) => {
  const n = ce(i).toVar(), r = J(1.4).toVar(), s = J(0).toVar(), o = ce(n).toVar();
  return ri({ start: J(0), end: J(3), type: "float", condition: "<=" }, () => {
    const a = ce(Wte(o.mul(2))).toVar();
    n.addAssign(a.add(t.mul(J(0.1).mul(e)))), o.mulAssign(1.8), r.mulAssign(1.5), n.mulAssign(1.2);
    const l = J(Sl(n.z.add(Sl(n.x.add(Sl(n.y)))))).toVar();
    s.addAssign(l.div(r)), o.addAssign(0.14);
  }), s;
}).setLayout({
  name: "triNoise3D",
  type: "float",
  inputs: [
    { name: "position", type: "vec3" },
    { name: "speed", type: "float" },
    { name: "time", type: "float" }
  ]
});
class jte extends St {
  static get type() {
    return "FunctionOverloadingNode";
  }
  /**
   * Constructs a new function overloading node.
   *
   * @param {Array<Function>} functionNodes - Array of `Fn` function definitions.
   * @param {...Node} parametersNodes - A list of parameter nodes.
   */
  constructor(e = [], ...t) {
    super(), this.functionNodes = e, this.parametersNodes = t, this._candidateFn = null, this.global = !0;
  }
  /**
   * This method is overwritten since the node type is inferred from
   * the function's return type.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(e) {
    return this.getCandidateFn(e).shaderNode.layout.type;
  }
  /**
   * Returns the candidate function for the current parameters.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {FunctionNode} The candidate function.
   */
  getCandidateFn(e) {
    const t = this.parametersNodes;
    let n = this._candidateFn;
    if (n === null) {
      let r = null, s = -1;
      for (const o of this.functionNodes) {
        const l = o.shaderNode.layout;
        if (l === null)
          throw new Error("FunctionOverloadingNode: FunctionNode must be a layout.");
        const u = l.inputs;
        if (t.length === u.length) {
          let c = 0;
          for (let A = 0; A < t.length; A++) {
            const m = t[A], _ = u[A];
            m.getNodeType(e) === _.type && c++;
          }
          c > s && (r = o, s = c);
        }
      }
      this._candidateFn = n = r;
    }
    return n;
  }
  /**
   * Sets up the node for the current parameters.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node} The setup node.
   */
  setup(e) {
    return this.getCandidateFn(e)(...this.parametersNodes);
  }
}
const Xte = /* @__PURE__ */ on(jte), Jr = (i) => (...e) => Xte(i, ...e), fA = /* @__PURE__ */ It(0).setGroup(Lt).onRenderUpdate((i) => i.time), Yte = /* @__PURE__ */ It(0).setGroup(Lt).onRenderUpdate((i) => i.deltaTime), LL = /* @__PURE__ */ It(0, "uint").setGroup(Lt).onRenderUpdate((i) => i.frameId), Qte = (i = fA) => i.add(0.75).mul(Math.PI * 2).sin().mul(0.5).add(0.5), Kte = (i = fA) => i.fract().round(), Zte = (i = fA) => i.add(0.5).fract().mul(2).sub(1).abs(), Jte = (i = fA) => i.fract();
function ene(i, e = null) {
  return eu(e, { getUV: i });
}
const tne = /* @__PURE__ */ pe(([i, e, t = Xe(0.5)]) => z0(i.sub(t), e).add(t)), nne = /* @__PURE__ */ pe(([i, e, t = Xe(0.5)]) => {
  const n = i.sub(t), r = n.dot(n), o = r.mul(r).mul(e);
  return i.add(n.mul(o));
}), ine = /* @__PURE__ */ pe(({ position: i = null, horizontal: e = !0, vertical: t = !1 }) => {
  let n;
  i !== null ? (n = Vo.toVar(), n[3][0] = i.x, n[3][1] = i.y, n[3][2] = i.z) : n = Vo;
  const r = ea.mul(n);
  return r0(e) && (r[0][0] = Vo[0].length(), r[0][1] = 0, r[0][2] = 0), r0(t) && (r[1][0] = 0, r[1][1] = Vo[1].length(), r[1][2] = 0), r[2][0] = 0, r[2][1] = 0, r[2][2] = 1, Ol.mul(r).mul(Vi);
}), rne = /* @__PURE__ */ pe(([i = null]) => {
  const e = d_();
  return d_(IT(i)).sub(e).lessThan(0).select(Ul, i);
});
class sne extends St {
  static get type() {
    return "SpriteSheetUVNode";
  }
  /**
   * Constructs a new sprite sheet uv node.
   *
   * @param {Node<vec2>} countNode - The node that defines the number of sprites in the x and y direction (e.g 6x6).
   * @param {Node<vec2>} [uvNode=uv()] - The uv node.
   * @param {Node<float>} [frameNode=float()] - The node that defines the current frame/sprite.
   */
  constructor(e, t = hi(), n = J(0)) {
    super("vec2"), this.countNode = e, this.uvNode = t, this.frameNode = n;
  }
  setup() {
    const { frameNode: e, uvNode: t, countNode: n } = this, { width: r, height: s } = n, o = e.mod(r.mul(s)).floor(), a = o.mod(r), l = s.sub(o.add(1).div(r).ceil()), u = n.reciprocal(), c = Xe(a, l);
    return t.add(c).mul(u);
  }
}
const one = /* @__PURE__ */ on(sne).setParameterLength(3), IL = /* @__PURE__ */ pe(([i, e = null, t = null, n = J(1), r = Vi, s = oo]) => {
  let o = s.abs().normalize();
  o = o.div(o.dot(ce(1)));
  const a = r.yz.mul(n), l = r.zx.mul(n), u = r.xy.mul(n), c = i.value, A = e !== null ? e.value : c, m = t !== null ? t.value : c, _ = Wn(c, a).mul(o.x), y = Wn(A, l).mul(o.y), T = Wn(m, u).mul(o.z);
  return sr(_, y, T);
}), ane = (...i) => IL(...i), Yd = new ca(), Ic = new j(), Qd = new j(), iv = new j(), XA = new Mt(), mg = new j(0, 0, -1), Fa = new Kt(), YA = new j(), gg = new j(), QA = new Kt(), _g = new Le(), A_ = new Ma(), lne = Ul.flipX();
A_.depthTexture = new Qr(1, 1);
let xg = !1;
class jT extends sl {
  static get type() {
    return "ReflectorNode";
  }
  /**
   * Constructs a new reflector node.
   *
   * @param {Object} [parameters={}] - An object holding configuration parameters.
   * @param {Object3D} [parameters.target=new Object3D()] - The 3D object the reflector is linked to.
   * @param {number} [parameters.resolutionScale=1] - The resolution scale.
   * @param {boolean} [parameters.generateMipmaps=false] - Whether mipmaps should be generated or not.
   * @param {boolean} [parameters.bounces=true] - Whether reflectors can render other reflector nodes or not.
   * @param {boolean} [parameters.depth=false] - Whether depth data should be generated or not.
   * @param {number} [parameters.samples] - Anti-Aliasing samples of the internal render-target.
   * @param {TextureNode} [parameters.defaultTexture] - The default texture node.
   * @param {ReflectorBaseNode} [parameters.reflector] - The reflector base node.
   */
  constructor(e = {}) {
    super(e.defaultTexture || A_.texture, lne), this._reflectorBaseNode = e.reflector || new une(this, e), this._depthNode = null, this.setUpdateMatrix(!1);
  }
  /**
   * A reference to the internal reflector node.
   *
   * @type {ReflectorBaseNode}
   */
  get reflector() {
    return this._reflectorBaseNode;
  }
  /**
   * A reference to 3D object the reflector is linked to.
   *
   * @type {Object3D}
   */
  get target() {
    return this._reflectorBaseNode.target;
  }
  /**
   * Returns a node representing the mirror's depth. That can be used
   * to implement more advanced reflection effects like distance attenuation.
   *
   * @return {Node} The depth node.
   */
  getDepthNode() {
    if (this._depthNode === null) {
      if (this._reflectorBaseNode.depth !== !0)
        throw new Error("THREE.ReflectorNode: Depth node can only be requested when the reflector is created with { depth: true }. ");
      this._depthNode = ut(new jT({
        defaultTexture: A_.depthTexture,
        reflector: this._reflectorBaseNode
      }));
    }
    return this._depthNode;
  }
  setup(e) {
    return e.object.isQuadMesh || this._reflectorBaseNode.build(e), super.setup(e);
  }
  clone() {
    const e = new this.constructor(this.reflectorNode);
    return e.uvNode = this.uvNode, e.levelNode = this.levelNode, e.biasNode = this.biasNode, e.sampler = this.sampler, e.depthNode = this.depthNode, e.compareNode = this.compareNode, e.gradNode = this.gradNode, e.offsetNode = this.offsetNode, e._reflectorBaseNode = this._reflectorBaseNode, e;
  }
  /**
   * Frees internal resources. Should be called when the node is no longer in use.
   */
  dispose() {
    super.dispose(), this._reflectorBaseNode.dispose();
  }
}
class une extends St {
  static get type() {
    return "ReflectorBaseNode";
  }
  /**
   * Constructs a new reflector base node.
   *
   * @param {TextureNode} textureNode - Represents the rendered reflections as a texture node.
   * @param {Object} [parameters={}] - An object holding configuration parameters.
   * @param {Object3D} [parameters.target=new Object3D()] - The 3D object the reflector is linked to.
   * @param {number} [parameters.resolutionScale=1] - The resolution scale.
   * @param {boolean} [parameters.generateMipmaps=false] - Whether mipmaps should be generated or not.
   * @param {boolean} [parameters.bounces=true] - Whether reflectors can render other reflector nodes or not.
   * @param {boolean} [parameters.depth=false] - Whether depth data should be generated or not.
   * @param {number} [parameters.samples] - Anti-Aliasing samples of the internal render-target.
   */
  constructor(e, t = {}) {
    super();
    const {
      target: n = new Vn(),
      resolutionScale: r = 1,
      generateMipmaps: s = !1,
      bounces: o = !0,
      depth: a = !1,
      samples: l = 0
    } = t;
    this.textureNode = e, this.target = n, this.resolutionScale = r, t.resolution !== void 0 && (li('ReflectorNode: The "resolution" parameter has been renamed to "resolutionScale".'), this.resolutionScale = t.resolution), this.generateMipmaps = s, this.bounces = o, this.depth = a, this.samples = l, this.updateBeforeType = o ? hn.RENDER : hn.FRAME, this.virtualCameras = /* @__PURE__ */ new WeakMap(), this.renderTargets = /* @__PURE__ */ new Map(), this.forceUpdate = !1, this.hasOutput = !1;
  }
  /**
   * Updates the resolution of the internal render target.
   *
   * @private
   * @param {RenderTarget} renderTarget - The render target to resize.
   * @param {Renderer} renderer - The renderer that is used to determine the new size.
   */
  _updateResolution(e, t) {
    const n = this.resolutionScale;
    t.getDrawingBufferSize(_g), e.setSize(Math.round(_g.width * n), Math.round(_g.height * n));
  }
  setup(e) {
    return this._updateResolution(A_, e.renderer), super.setup(e);
  }
  /**
   * Frees internal resources. Should be called when the node is no longer in use.
   */
  dispose() {
    super.dispose();
    for (const e of this.renderTargets.values())
      e.dispose();
  }
  /**
   * Returns a virtual camera for the given camera. The virtual camera is used to
   * render the scene from the reflector's view so correct reflections can be produced.
   *
   * @param {Camera} camera - The scene's camera.
   * @return {Camera} The corresponding virtual camera.
   */
  getVirtualCamera(e) {
    let t = this.virtualCameras.get(e);
    return t === void 0 && (t = e.clone(), this.virtualCameras.set(e, t)), t;
  }
  /**
   * Returns a render target for the given camera. The reflections are rendered
   * into this render target.
   *
   * @param {Camera} camera - The scene's camera.
   * @return {RenderTarget} The render target.
   */
  getRenderTarget(e) {
    let t = this.renderTargets.get(e);
    return t === void 0 && (t = new Ma(0, 0, { type: Ri, samples: this.samples }), this.generateMipmaps === !0 && (t.texture.minFilter = v5, t.texture.generateMipmaps = !0), this.depth === !0 && (t.depthTexture = new Qr()), this.renderTargets.set(e, t)), t;
  }
  updateBefore(e) {
    if (this.bounces === !1 && xg) return !1;
    xg = !0;
    const { scene: t, camera: n, renderer: r, material: s } = e, { target: o } = this, a = this.getVirtualCamera(n), l = this.getRenderTarget(a);
    r.getDrawingBufferSize(_g), this._updateResolution(l, r), Qd.setFromMatrixPosition(o.matrixWorld), iv.setFromMatrixPosition(n.matrixWorld), XA.extractRotation(o.matrixWorld), Ic.set(0, 0, 1), Ic.applyMatrix4(XA), YA.subVectors(Qd, iv);
    const u = YA.dot(Ic) > 0;
    let c = !1;
    if (u === !0 && this.forceUpdate === !1) {
      if (this.hasOutput === !1) {
        xg = !1;
        return;
      }
      c = !0;
    }
    YA.reflect(Ic).negate(), YA.add(Qd), XA.extractRotation(n.matrixWorld), mg.set(0, 0, -1), mg.applyMatrix4(XA), mg.add(iv), gg.subVectors(Qd, mg), gg.reflect(Ic).negate(), gg.add(Qd), a.coordinateSystem = n.coordinateSystem, a.position.copy(YA), a.up.set(0, 1, 0), a.up.applyMatrix4(XA), a.up.reflect(Ic), a.lookAt(gg), a.near = n.near, a.far = n.far, a.updateMatrixWorld(), a.projectionMatrix.copy(n.projectionMatrix), Yd.setFromNormalAndCoplanarPoint(Ic, Qd), Yd.applyMatrix4(a.matrixWorldInverse), Fa.set(Yd.normal.x, Yd.normal.y, Yd.normal.z, Yd.constant);
    const A = a.projectionMatrix;
    QA.x = (Math.sign(Fa.x) + A.elements[8]) / A.elements[0], QA.y = (Math.sign(Fa.y) + A.elements[9]) / A.elements[5], QA.z = -1, QA.w = (1 + A.elements[10]) / A.elements[14], Fa.multiplyScalar(1 / Fa.dot(QA));
    const m = 0;
    A.elements[2] = Fa.x, A.elements[6] = Fa.y, A.elements[10] = r.coordinateSystem === io ? Fa.z - m : Fa.z + 1 - m, A.elements[14] = Fa.w, this.textureNode.value = l.texture, this.depth === !0 && (this.textureNode.getDepthNode().value = l.depthTexture), s.visible = !1;
    const _ = r.getRenderTarget(), y = r.getMRT(), T = r.autoClear;
    r.setMRT(null), r.setRenderTarget(l), r.autoClear = !0;
    const b = t.name;
    t.name = (t.name || "Scene") + " [ Reflector ]", c ? (r.clear(), this.hasOutput = !1) : (r.render(t, a), this.hasOutput = !0), t.name = b, r.setMRT(y), r.setRenderTarget(_), r.autoClear = T, s.visible = !0, xg = !1, this.forceUpdate = !1;
  }
  /**
   * The resolution scale.
   *
   * @deprecated
   * @type {number}
   * @default {1}
   */
  get resolution() {
    return li('ReflectorNode: The "resolution" property has been renamed to "resolutionScale".'), this.resolutionScale;
  }
  set resolution(e) {
    li('ReflectorNode: The "resolution" property has been renamed to "resolutionScale".'), this.resolutionScale = e;
  }
}
const cne = (i) => new jT(i), rv = /* @__PURE__ */ new ic(-1, 1, 1, -1, 0, 1);
class hne extends Yt {
  /**
   * Constructs a new quad geometry.
   *
   * @param {boolean} [flipY=false] - Whether the uv coordinates should be flipped along the vertical axis or not.
   */
  constructor(e = !1) {
    super();
    const t = e === !1 ? [0, -1, 0, 1, 2, 1] : [0, 2, 0, 0, 2, 0];
    this.setAttribute("position", new xt([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)), this.setAttribute("uv", new xt(t, 2));
  }
}
const dne = /* @__PURE__ */ new hne();
class Q2 extends Tn {
  /**
   * Constructs a new quad mesh.
   *
   * @param {?Material} [material=null] - The material to render the quad mesh with.
   */
  constructor(e = null) {
    super(dne, e), this.camera = rv, this.isQuadMesh = !0;
  }
  /**
   * Async version of `render()`.
   *
   * @async
   * @deprecated
   * @param {Renderer} renderer - The renderer.
   * @return {Promise} A Promise that resolves when the render has been finished.
   */
  async renderAsync(e) {
    li('QuadMesh: "renderAsync()" has been deprecated. Use "render()" and "await renderer.init();" when creating the renderer.'), await e.init(), e.render(this, rv);
  }
  /**
   * Renders the quad mesh
   *
   * @param {Renderer} renderer - The renderer.
   */
  render(e) {
    e.render(this, rv);
  }
}
const fne = /* @__PURE__ */ new Le();
class Ane extends sl {
  static get type() {
    return "RTTNode";
  }
  /**
   * Constructs a new RTT node.
   *
   * @param {Node} node - The node to render a texture with.
   * @param {?number} [width=null] - The width of the internal render target. If not width is applied, the render target is automatically resized.
   * @param {?number} [height=null] - The height of the internal render target.
   * @param {Object} [options={type:HalfFloatType}] - The options for the internal render target.
   */
  constructor(e, t = null, n = null, r = { type: Ri }) {
    const s = new Ma(t, n, r);
    super(s.texture, hi()), this.isRTTNode = !0, this.node = e, this.width = t, this.height = n, this.pixelRatio = 1, this.renderTarget = s, this.textureNeedsUpdate = !0, this.autoUpdate = !0, this._rttNode = null, this._quadMesh = new Q2(new Yi()), this.updateBeforeType = hn.RENDER;
  }
  /**
   * Whether the internal render target should automatically be resized or not.
   *
   * @type {boolean}
   * @readonly
   * @default true
   */
  get autoResize() {
    return this.width === null;
  }
  setup(e) {
    return this._rttNode = this.node.context(e.getSharedContext()), this._quadMesh.material.name = "RTT", this._quadMesh.material.needsUpdate = !0, super.setup(e);
  }
  /**
   * Sets the size of the internal render target
   *
   * @param {number} width - The width to set.
   * @param {number} height - The width to set.
   */
  setSize(e, t) {
    this.width = e, this.height = t;
    const n = e * this.pixelRatio, r = t * this.pixelRatio;
    this.renderTarget.setSize(n, r), this.textureNeedsUpdate = !0;
  }
  /**
   * Sets the pixel ratio. This will also resize the render target.
   *
   * @param {number} pixelRatio - The pixel ratio to set.
   */
  setPixelRatio(e) {
    this.pixelRatio = e, this.setSize(this.width, this.height);
  }
  updateBefore({ renderer: e }) {
    if (this.textureNeedsUpdate === !1 && this.autoUpdate === !1) return;
    if (this.textureNeedsUpdate = !1, this.autoResize === !0) {
      const r = e.getPixelRatio(), s = e.getSize(fne), o = Math.floor(s.width * r), a = Math.floor(s.height * r);
      (o !== this.renderTarget.width || a !== this.renderTarget.height) && (this.renderTarget.setSize(o, a), this.textureNeedsUpdate = !0);
    }
    let t = "RTT";
    this.node.name && (t = this.node.name + " [ " + t + " ]"), this._quadMesh.material.fragmentNode = this._rttNode, this._quadMesh.name = t;
    const n = e.getRenderTarget();
    e.setRenderTarget(this.renderTarget), this._quadMesh.render(e), e.setRenderTarget(n);
  }
  clone() {
    const e = new sl(this.value, this.uvNode, this.levelNode);
    return e.sampler = this.sampler, e.referenceNode = this, e;
  }
}
const BL = (i, ...e) => ut(new Ane(ut(i), ...e)), pne = (i, ...e) => i.isSampleNode || i.isTextureNode ? i : i.isPassNode ? i.getTextureNode() : BL(i, ...e), of = /* @__PURE__ */ pe(([i, e, t], n) => {
  let r;
  n.renderer.coordinateSystem === io ? (i = Xe(i.x, i.y.oneMinus()).mul(2).sub(1), r = Gt(ce(i, e), 1)) : r = Gt(ce(i.x, i.y.oneMinus(), e).mul(2).sub(1), 1);
  const s = Gt(t.mul(r));
  return s.xyz.div(s.w);
}), mne = /* @__PURE__ */ pe(([i, e]) => {
  const t = e.mul(Gt(i, 1)), n = t.xy.div(t.w).mul(0.5).add(0.5).toVar();
  return Xe(n.x, n.y.oneMinus());
}), gne = /* @__PURE__ */ pe(([i, e, t]) => {
  const n = Fl($i(e)), r = ur(i.mul(n)).toVar(), s = $i(e, r).toVar(), o = $i(e, r.sub(ur(2, 0))).toVar(), a = $i(e, r.sub(ur(1, 0))).toVar(), l = $i(e, r.add(ur(1, 0))).toVar(), u = $i(e, r.add(ur(2, 0))).toVar(), c = $i(e, r.add(ur(0, 2))).toVar(), A = $i(e, r.add(ur(0, 1))).toVar(), m = $i(e, r.sub(ur(0, 1))).toVar(), _ = $i(e, r.sub(ur(0, 2))).toVar(), y = vi(Un(J(2).mul(a).sub(o), s)).toVar(), T = vi(Un(J(2).mul(l).sub(u), s)).toVar(), b = vi(Un(J(2).mul(A).sub(c), s)).toVar(), S = vi(Un(J(2).mul(m).sub(_), s)).toVar(), E = of(i, s, t).toVar(), R = y.lessThan(T).select(E.sub(of(i.sub(Xe(J(1).div(n.x), 0)), a, t)), E.negate().add(of(i.add(Xe(J(1).div(n.x), 0)), l, t))), C = b.lessThan(S).select(E.sub(of(i.add(Xe(0, J(1).div(n.y))), A, t)), E.negate().add(of(i.sub(Xe(0, J(1).div(n.y))), m, t)));
  return Fs(Kl(R, C));
}), XT = pe(([i]) => ba(J(52.9829189).mul(ba($o(i, Xe(0.06711056, 583715e-8)))))).setLayout({
  name: "interleavedGradientNoise",
  type: "float",
  inputs: [
    { name: "position", type: "vec2" }
  ]
}), fa = pe(([i, e, t]) => {
  const n = J(2.399963229728653), r = ps(J(i).add(0.5).div(J(e))), s = J(i).mul(n).add(t);
  return Xe(ha(s), Ns(s)).mul(r);
}).setLayout({
  name: "vogelDiskSample",
  type: "vec2",
  inputs: [
    { name: "sampleIndex", type: "int" },
    { name: "samplesCount", type: "int" },
    { name: "phi", type: "float" }
  ]
});
class _ne extends St {
  /**
   * Returns the type of the node.
   *
   * @type {string}
   * @readonly
   * @static
   */
  static get type() {
    return "SampleNode";
  }
  /**
   * Creates an instance of SampleNode.
   *
   * @param {Function} callback - The function to be called when sampling. Should accept a UV node and return a value.
   * @param {?Node<vec2>} [uvNode=null] - The UV node to be used in the texture sampling.
   */
  constructor(e, t = null) {
    super(), this.callback = e, this.uvNode = t, this.isSampleNode = !0;
  }
  /**
   * Sets up the node by sampling with the default UV accessor.
   *
   * @returns {Node} The result of the callback function when called with the UV node.
   */
  setup() {
    return this.sample(hi());
  }
  /**
   * Calls the callback function with the provided UV node.
   *
   * @param {Node<vec2>} uv - The UV node or value to be passed to the callback.
   * @returns {Node} The result of the callback function.
   */
  sample(e) {
    return this.callback(e);
  }
}
const xne = (i, e = null) => new _ne(i, ut(e));
class Qs extends St {
  static get type() {
    return "EventNode";
  }
  /**
   * Creates an EventNode.
   *
   * @param {string} eventType - The type of event
   * @param {Function} callback - The callback to execute on update.
   */
  constructor(e, t) {
    super("void"), this.eventType = e, this.callback = t, e === Qs.OBJECT ? this.updateType = hn.OBJECT : e === Qs.MATERIAL ? this.updateType = hn.RENDER : e === Qs.BEFORE_OBJECT ? this.updateBeforeType = hn.OBJECT : e === Qs.BEFORE_MATERIAL && (this.updateBeforeType = hn.RENDER);
  }
  update(e) {
    this.callback(e);
  }
  updateBefore(e) {
    this.callback(e);
  }
}
Qs.OBJECT = "object";
Qs.MATERIAL = "material";
Qs.BEFORE_OBJECT = "beforeObject";
Qs.BEFORE_MATERIAL = "beforeMaterial";
const K2 = (i, e) => new Qs(i, e).toStack(), yne = (i) => K2(Qs.OBJECT, i), vne = (i) => K2(Qs.MATERIAL, i), bne = (i) => K2(Qs.BEFORE_OBJECT, i), Sne = (i) => K2(Qs.BEFORE_MATERIAL, i);
class a1 extends to {
  /**
   * Constructs a new storage instanced buffer attribute.
   *
   * @param {number|TypedArray} count - The item count. It is also valid to pass a typed array as an argument.
   * The subsequent parameters are then obsolete.
   * @param {number} itemSize - The item size.
   * @param {TypedArray.constructor} [typeClass=Float32Array] - A typed array constructor.
   */
  constructor(e, t, n = Float32Array) {
    const r = ArrayBuffer.isView(e) ? e : new n(e * t);
    super(r, t), this.isStorageInstancedBufferAttribute = !0;
  }
}
class Tne extends Dn {
  /**
   * Constructs a new storage buffer attribute.
   *
   * @param {number|TypedArray} count - The item count. It is also valid to pass a typed array as an argument.
   * The subsequent parameters are then obsolete.
   * @param {number} itemSize - The item size.
   * @param {TypedArray.constructor} [typeClass=Float32Array] - A typed array constructor.
   */
  constructor(e, t, n = Float32Array) {
    const r = ArrayBuffer.isView(e) ? e : new n(e * t);
    super(r, t), this.isStorageBufferAttribute = !0;
  }
}
const wne = (i, e = "float") => {
  let t, n;
  e.isStruct === !0 ? (t = e.layout.getLength(), n = n_("float")) : (t = KP(e), n = n_(e));
  const r = new Tne(i, t, n);
  return kl(r, e, i);
}, Mne = (i, e = "float") => {
  let t, n;
  e.isStruct === !0 ? (t = e.layout.getLength(), n = n_("float")) : (t = KP(e), n = n_(e));
  const r = new a1(i, t, n);
  return kl(r, e, i);
};
class Ene extends St {
  static get type() {
    return "PointUVNode";
  }
  /**
   * Constructs a new point uv node.
   */
  constructor() {
    super("vec2"), this.isPointUVNode = !0;
  }
  generate() {
    return "vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y )";
  }
}
const Rne = /* @__PURE__ */ st(Ene), KA = /* @__PURE__ */ new Ir(), sv = /* @__PURE__ */ new Mt();
class Ks extends St {
  static get type() {
    return "SceneNode";
  }
  /**
   * Constructs a new scene node.
   *
   * @param {('backgroundBlurriness'|'backgroundIntensity'|'backgroundRotation')} scope - The scope defines the type of scene property that is accessed.
   * @param {?Scene} [scene=null] - A reference to the scene.
   */
  constructor(e = Ks.BACKGROUND_BLURRINESS, t = null) {
    super(), this.scope = e, this.scene = t;
  }
  /**
   * Depending on the scope, the method returns a different type of node that represents
   * the respective scene property.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node} The output node.
   */
  setup(e) {
    const t = this.scope, n = this.scene !== null ? this.scene : e.scene;
    let r;
    return t === Ks.BACKGROUND_BLURRINESS ? r = ui("backgroundBlurriness", "float", n) : t === Ks.BACKGROUND_INTENSITY ? r = ui("backgroundIntensity", "float", n) : t === Ks.BACKGROUND_ROTATION ? r = It("mat4").setName("backgroundRotation").setGroup(Lt).onRenderUpdate(() => {
      const s = n.background;
      return s !== null && s.isTexture && s.mapping !== A0 ? (KA.copy(n.backgroundRotation), KA.x *= -1, KA.y *= -1, KA.z *= -1, sv.makeRotationFromEuler(KA)) : sv.identity(), sv;
    }) : Ie("SceneNode: Unknown scope:", t), r;
  }
}
Ks.BACKGROUND_BLURRINESS = "backgroundBlurriness";
Ks.BACKGROUND_INTENSITY = "backgroundIntensity";
Ks.BACKGROUND_ROTATION = "backgroundRotation";
const FL = /* @__PURE__ */ st(Ks, Ks.BACKGROUND_BLURRINESS), Zb = /* @__PURE__ */ st(Ks, Ks.BACKGROUND_INTENSITY), UL = /* @__PURE__ */ st(Ks, Ks.BACKGROUND_ROTATION);
class Cne extends sl {
  static get type() {
    return "StorageTextureNode";
  }
  /**
   * Constructs a new storage texture node.
   *
   * @param {StorageTexture} value - The storage texture.
   * @param {Node<vec2|vec3>} uvNode - The uv node.
   * @param {?Node} [storeNode=null] - The value node that should be stored in the texture.
   */
  constructor(e, t, n = null) {
    super(e, t), this.storeNode = n, this.mipLevel = 0, this.isStorageTextureNode = !0, this.access = Xr.WRITE_ONLY;
  }
  /**
   * Overwrites the default implementation to return a fixed value `'storageTexture'`.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The input type.
   */
  getInputType() {
    return "storageTexture";
  }
  setup(e) {
    super.setup(e);
    const t = e.getNodeProperties(this);
    return t.storeNode = this.storeNode, t;
  }
  /**
   * Defines the node access.
   *
   * @param {string} value - The node access.
   * @return {StorageTextureNode} A reference to this node.
   */
  setAccess(e) {
    return this.access = e, this;
  }
  /**
   * Sets the mip level to write to.
   *
   * @param {number} level - The mip level.
   * @return {StorageTextureNode} A reference to this node.
   */
  setMipLevel(e) {
    return this.mipLevel = e, this;
  }
  /**
   * Generates the code snippet of the storage node. If no `storeNode`
   * is defined, the texture node is generated as normal texture.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {string} output - The current output.
   * @return {string} The generated code snippet.
   */
  generate(e, t) {
    let n;
    return this.storeNode !== null ? n = this.generateStore(e) : n = super.generate(e, t), n;
  }
  /**
   * Convenience method for configuring a read/write node access.
   *
   * @return {StorageTextureNode} A reference to this node.
   */
  toReadWrite() {
    return this.setAccess(Xr.READ_WRITE);
  }
  /**
   * Convenience method for configuring a read-only node access.
   *
   * @return {StorageTextureNode} A reference to this node.
   */
  toReadOnly() {
    return this.setAccess(Xr.READ_ONLY);
  }
  /**
   * Convenience method for configuring a write-only node access.
   *
   * @return {StorageTextureNode} A reference to this node.
   */
  toWriteOnly() {
    return this.setAccess(Xr.WRITE_ONLY);
  }
  /**
   * Generates the code snippet of the storage texture node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  generateStore(e) {
    const t = e.getNodeProperties(this), { uvNode: n, storeNode: r, depthNode: s } = t, o = super.generate(e, "property"), a = n.build(e, this.value.is3DTexture === !0 ? "uvec3" : "uvec2"), l = r.build(e, "vec4"), u = s ? s.build(e, "int") : null, c = e.generateTextureStore(e, o, a, u, l);
    e.addLineFlowCode(c, this);
  }
  clone() {
    const e = super.clone();
    return e.storeNode = this.storeNode, e.mipLevel = this.mipLevel, e;
  }
}
const OL = /* @__PURE__ */ on(Cne).setParameterLength(1, 3), Pne = (i, e, t) => {
  const n = OL(i, e, t);
  return t !== null && n.toStack(), n;
}, Nne = pe(({ texture: i, uv: e }) => {
  const n = ce().toVar();
  return Ot(e.x.lessThan(1e-4), () => {
    n.assign(ce(1, 0, 0));
  }).ElseIf(e.y.lessThan(1e-4), () => {
    n.assign(ce(0, 1, 0));
  }).ElseIf(e.z.lessThan(1e-4), () => {
    n.assign(ce(0, 0, 1));
  }).ElseIf(e.x.greaterThan(1 - 1e-4), () => {
    n.assign(ce(-1, 0, 0));
  }).ElseIf(e.y.greaterThan(1 - 1e-4), () => {
    n.assign(ce(0, -1, 0));
  }).ElseIf(e.z.greaterThan(1 - 1e-4), () => {
    n.assign(ce(0, 0, -1));
  }).Else(() => {
    const s = i.sample(e.add(ce(-0.01, 0, 0))).r.sub(i.sample(e.add(ce(0.01, 0, 0))).r), o = i.sample(e.add(ce(0, -0.01, 0))).r.sub(i.sample(e.add(ce(0, 0.01, 0))).r), a = i.sample(e.add(ce(0, 0, -0.01))).r.sub(i.sample(e.add(ce(0, 0, 0.01))).r);
    n.assign(ce(s, o, a));
  }), n.normalize();
});
class Dne extends sl {
  static get type() {
    return "Texture3DNode";
  }
  /**
   * Constructs a new 3D texture node.
   *
   * @param {Data3DTexture} value - The 3D texture.
   * @param {?Node<vec2|vec3>} [uvNode=null] - The uv node.
   * @param {?Node<int>} [levelNode=null] - The level node.
   */
  constructor(e, t = null, n = null) {
    super(e, t, n), this.isTexture3DNode = !0;
  }
  /**
   * Overwrites the default implementation to return a fixed value `'texture3D'`.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The input type.
   */
  getInputType() {
    return "texture3D";
  }
  /**
   * Returns a default uv node which is in context of 3D textures a three-dimensional
   * uv node.
   *
   * @return {Node<vec3>} The default uv node.
   */
  getDefaultUV() {
    return ce(0.5, 0.5, 0.5);
  }
  /**
   * Overwritten with an empty implementation since the `updateMatrix` flag is ignored
   * for 3D textures. The uv transformation matrix is not applied to 3D textures.
   *
   * @param {boolean} value - The update toggle.
   */
  setUpdateMatrix() {
  }
  // Ignore .updateMatrix for 3d TextureNode
  /**
   * Overwrites the default implementation to return the unmodified uv node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {Node} uvNode - The uv node to setup.
   * @return {Node} The unmodified uv node.
   */
  setupUV(e, t) {
    const n = this.value;
    return e.isFlipY() && (n.isRenderTargetTexture === !0 || n.isFramebufferTexture === !0) && (this.sampler ? t = t.flipY() : t = t.setY(le(Fl(this, this.levelNode).y).sub(t.y).sub(1))), t;
  }
  /**
   * Generates the uv code snippet.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {Node} uvNode - The uv node to generate code for.
   * @return {string} The generated code snippet.
   */
  generateUV(e, t) {
    return t.build(e, this.sampler === !0 ? "vec3" : "ivec3");
  }
  /**
   * Generates the offset code snippet.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {Node} offsetNode - The offset node to generate code for.
   * @return {string} The generated code snippet.
   */
  generateOffset(e, t) {
    return t.build(e, "ivec3");
  }
  /**
   * TODO.
   *
   * @param {Node<vec3>} uvNode - The uv node .
   * @return {Node<vec3>} TODO.
   */
  normal(e) {
    return Nne({ texture: this, uv: e });
  }
}
const Z2 = /* @__PURE__ */ on(Dne).setParameterLength(1, 3), Lne = (...i) => Z2(...i).setSampler(!1), Ine = (i, e, t) => Z2(i, e).level(t);
class Bne extends G2 {
  static get type() {
    return "UserDataNode";
  }
  /**
   * Constructs a new user data node.
   *
   * @param {string} property - The property name that should be referenced by the node.
   * @param {string} inputType - The node data type of the reference.
   * @param {?Object} [userData=null] - A reference to the `userData` object. If not provided, the `userData` property of the 3D object that uses the node material is evaluated.
   */
  constructor(e, t, n = null) {
    super(e, t, n), this.userData = n;
  }
  /**
   * Overwritten to make sure {@link ReferenceNode#reference} points to the correct
   * `userData` field.
   *
   * @param {(NodeFrame|NodeBuilder)} state - The current state to evaluate.
   * @return {Object} A reference to the `userData` field.
   */
  updateReference(e) {
    return this.reference = this.userData !== null ? this.userData : e.object.userData, this.reference;
  }
}
const Fne = (i, e, t) => new Bne(i, e, t), nC = /* @__PURE__ */ new WeakMap();
class Une extends Hi {
  static get type() {
    return "VelocityNode";
  }
  /**
   * Constructs a new vertex color node.
   */
  constructor() {
    super("vec2"), this.projectionMatrix = null, this.updateType = hn.OBJECT, this.updateAfterType = hn.OBJECT, this.previousModelWorldMatrix = It(new Mt()), this.previousProjectionMatrix = It(new Mt()).setGroup(Lt), this.previousCameraViewMatrix = It(new Mt());
  }
  /**
   * Sets the given projection matrix.
   *
   * @param {Matrix4} projectionMatrix - The projection matrix to set.
   */
  setProjectionMatrix(e) {
    this.projectionMatrix = e;
  }
  /**
   * Updates velocity specific uniforms.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  update({ frameId: e, camera: t, object: n }) {
    const r = iC(n);
    this.previousModelWorldMatrix.value.copy(r);
    const s = kL(t);
    s.frameId !== e && (s.frameId = e, s.previousProjectionMatrix === void 0 ? (s.previousProjectionMatrix = new Mt(), s.previousCameraViewMatrix = new Mt(), s.currentProjectionMatrix = new Mt(), s.currentCameraViewMatrix = new Mt(), s.previousProjectionMatrix.copy(this.projectionMatrix || t.projectionMatrix), s.previousCameraViewMatrix.copy(t.matrixWorldInverse)) : (s.previousProjectionMatrix.copy(s.currentProjectionMatrix), s.previousCameraViewMatrix.copy(s.currentCameraViewMatrix)), s.currentProjectionMatrix.copy(this.projectionMatrix || t.projectionMatrix), s.currentCameraViewMatrix.copy(t.matrixWorldInverse), this.previousProjectionMatrix.value.copy(s.previousProjectionMatrix), this.previousCameraViewMatrix.value.copy(s.previousCameraViewMatrix));
  }
  /**
   * Overwritten to updated velocity specific uniforms.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  updateAfter({ object: e }) {
    iC(e).copy(e.matrixWorld);
  }
  /**
   * Implements the velocity computation based on the previous and current vertex data.
   *
   * @param {NodeBuilder} builder - A reference to the current node builder.
   * @return {Node<vec2>} The motion vector.
   */
  setup() {
    const e = this.projectionMatrix === null ? Ol : It(this.projectionMatrix), t = this.previousCameraViewMatrix.mul(this.previousModelWorldMatrix), n = e.mul(sc).mul(Vi), r = this.previousProjectionMatrix.mul(t).mul(h_), s = n.xy.div(n.w), o = r.xy.div(r.w);
    return Un(s, o);
  }
}
function kL(i) {
  let e = nC.get(i);
  return e === void 0 && (e = {}, nC.set(i, e)), e;
}
function iC(i, e = 0) {
  const t = kL(i);
  let n = t[e];
  return n === void 0 && (t[e] = n = new Mt(), t[e].copy(i.matrixWorld)), n;
}
const One = /* @__PURE__ */ st(Une), kne = /* @__PURE__ */ pe(([i]) => YT(i.rgb)), Vne = /* @__PURE__ */ pe(([i, e = J(1)]) => e.mix(YT(i.rgb), i.rgb)), Gne = /* @__PURE__ */ pe(([i, e = J(1)]) => {
  const t = sr(i.r, i.g, i.b).div(3), n = i.r.max(i.g.max(i.b)), r = n.sub(t).mul(e).mul(-3);
  return Bn(i.rgb, n, r);
}), zne = /* @__PURE__ */ pe(([i, e = J(1)]) => {
  const t = ce(0.57735, 0.57735, 0.57735), n = e.cos();
  return ce(i.rgb.mul(n).add(t.cross(i.rgb).mul(e.sin()).add(t.mul($o(t, i.rgb).mul(n.oneMinus())))));
}), YT = (i, e = ce(Xt.getLuminanceCoefficients(new j()))) => $o(i, e), qne = /* @__PURE__ */ pe(([
  i,
  e = ce(1),
  t = ce(0),
  n = ce(1),
  r = J(1),
  // ASC CDL v1.2 explicitly requires Rec. 709 luminance coefficients.
  s = ce(Xt.getLuminanceCoefficients(new j(), Hl))
]) => {
  const o = i.rgb.dot(ce(s)), a = qi(i.rgb.mul(e).add(t), 0).toVar(), l = a.pow(n).toVar();
  return Ot(a.r.greaterThan(0), () => {
    a.r.assign(l.r);
  }), Ot(a.g.greaterThan(0), () => {
    a.g.assign(l.g);
  }), Ot(a.b.greaterThan(0), () => {
    a.b.assign(l.b);
  }), a.assign(o.add(a.sub(o).mul(r))), Gt(a.rgb, i.a);
});
class Hne extends Hi {
  static get type() {
    return "PosterizeNode";
  }
  /**
   * Constructs a new posterize node.
   *
   * @param {Node} sourceNode - The input color.
   * @param {Node} stepsNode - Controls the intensity of the posterization effect. A lower number results in a more blocky appearance.
   */
  constructor(e, t) {
    super(), this.sourceNode = e, this.stepsNode = t;
  }
  setup() {
    const { sourceNode: e, stepsNode: t } = this;
    return e.mul(t).floor().div(t);
  }
}
const Wne = /* @__PURE__ */ on(Hne).setParameterLength(2), yg = /* @__PURE__ */ new Le();
class VL extends sl {
  static get type() {
    return "PassTextureNode";
  }
  /**
   * Constructs a new pass texture node.
   *
   * @param {PassNode} passNode - The pass node.
   * @param {Texture} texture - The output texture.
   */
  constructor(e, t) {
    super(t), this.passNode = e, this.setUpdateMatrix(!1);
  }
  setup(e) {
    return this.passNode.build(e), super.setup(e);
  }
  clone() {
    return new this.constructor(this.passNode, this.value);
  }
}
class rC extends VL {
  static get type() {
    return "PassMultipleTextureNode";
  }
  /**
   * Constructs a new pass texture node.
   *
   * @param {PassNode} passNode - The pass node.
   * @param {string} textureName - The output texture name.
   * @param {boolean} [previousTexture=false] - Whether previous frame data should be used or not.
   */
  constructor(e, t, n = !1) {
    super(e, null), this.textureName = t, this.previousTexture = n;
  }
  /**
   * Updates the texture reference of this node.
   */
  updateTexture() {
    this.value = this.previousTexture ? this.passNode.getPreviousTexture(this.textureName) : this.passNode.getTexture(this.textureName);
  }
  setup(e) {
    return this.updateTexture(), super.setup(e);
  }
  clone() {
    const e = new this.constructor(this.passNode, this.textureName, this.previousTexture);
    return e.uvNode = this.uvNode, e.levelNode = this.levelNode, e.biasNode = this.biasNode, e.sampler = this.sampler, e.depthNode = this.depthNode, e.compareNode = this.compareNode, e.gradNode = this.gradNode, e.offsetNode = this.offsetNode, e;
  }
}
class ol extends Hi {
  static get type() {
    return "PassNode";
  }
  /**
   * Constructs a new pass node.
   *
   * @param {('color'|'depth')} scope - The scope of the pass. The scope determines whether the node outputs color or depth.
   * @param {Scene} scene - A reference to the scene.
   * @param {Camera} camera - A reference to the camera.
   * @param {Object} options - Options for the internal render target.
   */
  constructor(e, t, n, r = {}) {
    super("vec4"), this.scope = e, this.scene = t, this.camera = n, this.options = r, this._pixelRatio = 1, this._width = 1, this._height = 1;
    const s = new Qr();
    s.isRenderTargetTexture = !0, s.name = "depth";
    const o = new Ma(this._width * this._pixelRatio, this._height * this._pixelRatio, { type: Ri, ...r });
    o.texture.name = "output", o.depthTexture = s, this.renderTarget = o, this.overrideMaterial = null, this.transparent = !0, this.opaque = !0, this.contextNode = null, this._contextNodeCache = null, this._textures = {
      output: o.texture,
      depth: s
    }, this._textureNodes = {}, this._linearDepthNodes = {}, this._viewZNodes = {}, this._previousTextures = {}, this._previousTextureNodes = {}, this._cameraNear = It(0), this._cameraFar = It(0), this._mrt = null, this._layers = null, this._resolutionScale = 1, this._viewport = null, this._scissor = null, this.isPassNode = !0, this.updateBeforeType = hn.FRAME, this.global = !0;
  }
  /**
   * Sets the resolution scale for the pass.
   * The resolution scale is a factor that is multiplied with the renderer's width and height.
   *
   * @param {number} resolutionScale - The resolution scale to set. A value of `1` means full resolution.
   * @return {PassNode} A reference to this pass.
   */
  setResolutionScale(e) {
    return this._resolutionScale = e, this;
  }
  /**
   * Gets the current resolution scale of the pass.
   *
   * @return {number} The current resolution scale. A value of `1` means full resolution.
   */
  getResolutionScale() {
    return this._resolutionScale;
  }
  /**
   * Sets the resolution for the pass.
   * The resolution is a factor that is multiplied with the renderer's width and height.
   *
   * @param {number} resolution - The resolution to set. A value of `1` means full resolution.
   * @return {PassNode} A reference to this pass.
   * @deprecated since r181. Use {@link PassNode#setResolutionScale `setResolutionScale()`} instead.
   */
  setResolution(e) {
    return Me("PassNode: .setResolution() is deprecated. Use .setResolutionScale() instead."), this.setResolutionScale(e);
  }
  /**
   * Gets the current resolution of the pass.
   *
   * @return {number} The current resolution. A value of `1` means full resolution.
   * @deprecated since r181. Use {@link PassNode#getResolutionScale `getResolutionScale()`} instead.
   */
  getResolution() {
    return Me("PassNode: .getResolution() is deprecated. Use .getResolutionScale() instead."), this.getResolutionScale();
  }
  /**
   * Sets the layer configuration that should be used when rendering the pass.
   *
   * @param {Layers} layers - The layers object to set.
   * @return {PassNode} A reference to this pass.
   */
  setLayers(e) {
    return this._layers = e, this;
  }
  /**
   * Gets the current layer configuration of the pass.
   *
   * @return {?Layers} .
   */
  getLayers() {
    return this._layers;
  }
  /**
   * Sets the given MRT node to setup MRT for this pass.
   *
   * @param {MRTNode} mrt - The MRT object.
   * @return {PassNode} A reference to this pass.
   */
  setMRT(e) {
    return this._mrt = e, this;
  }
  /**
   * Returns the current MRT node.
   *
   * @return {MRTNode} The current MRT node.
   */
  getMRT() {
    return this._mrt;
  }
  /**
   * Returns the texture for the given output name.
   *
   * @param {string} name - The output name to get the texture for.
   * @return {Texture} The texture.
   */
  getTexture(e) {
    let t = this._textures[e];
    return t === void 0 && (t = this.renderTarget.texture.clone(), t.name = e, this._textures[e] = t, this.renderTarget.textures.push(t)), t;
  }
  /**
   * Returns the texture holding the data of the previous frame for the given output name.
   *
   * @param {string} name - The output name to get the texture for.
   * @return {Texture} The texture holding the data of the previous frame.
   */
  getPreviousTexture(e) {
    let t = this._previousTextures[e];
    return t === void 0 && (t = this.getTexture(e).clone(), this._previousTextures[e] = t), t;
  }
  /**
   * Switches current and previous textures for the given output name.
   *
   * @param {string} name - The output name.
   */
  toggleTexture(e) {
    const t = this._previousTextures[e];
    if (t !== void 0) {
      const n = this._textures[e], r = this.renderTarget.textures.indexOf(n);
      this.renderTarget.textures[r] = t, this._textures[e] = t, this._previousTextures[e] = n, this._textureNodes[e].updateTexture(), this._previousTextureNodes[e].updateTexture();
    }
  }
  /**
   * Returns the texture node for the given output name.
   *
   * @param {string} [name='output'] - The output name to get the texture node for.
   * @return {TextureNode} The texture node.
   */
  getTextureNode(e = "output") {
    let t = this._textureNodes[e];
    return t === void 0 && (t = new rC(this, e), t.updateTexture(), this._textureNodes[e] = t), t;
  }
  /**
   * Returns the previous texture node for the given output name.
   *
   * @param {string} [name='output'] - The output name to get the previous texture node for.
   * @return {TextureNode} The previous texture node.
   */
  getPreviousTextureNode(e = "output") {
    let t = this._previousTextureNodes[e];
    return t === void 0 && (this._textureNodes[e] === void 0 && this.getTextureNode(e), t = new rC(this, e, !0), t.updateTexture(), this._previousTextureNodes[e] = t), t;
  }
  /**
   * Returns a viewZ node of this pass.
   *
   * @param {string} [name='depth'] - The output name to get the viewZ node for. In most cases the default `'depth'` can be used however the parameter exists for custom depth outputs.
   * @return {Node} The viewZ node.
   */
  getViewZNode(e = "depth") {
    let t = this._viewZNodes[e];
    if (t === void 0) {
      const n = this._cameraNear, r = this._cameraFar;
      this._viewZNodes[e] = t = BT(this.getTextureNode(e), n, r);
    }
    return t;
  }
  /**
   * Returns a linear depth node of this pass.
   *
   * @param {string} [name='depth'] - The output name to get the linear depth node for. In most cases the default `'depth'` can be used however the parameter exists for custom depth outputs.
   * @return {Node} The linear depth node.
   */
  getLinearDepthNode(e = "depth") {
    let t = this._linearDepthNodes[e];
    if (t === void 0) {
      const n = this._cameraNear, r = this._cameraFar, s = this.getViewZNode(e);
      this._linearDepthNodes[e] = t = Sf(s, n, r);
    }
    return t;
  }
  /**
   * Precompiles the pass.
   *
   * Note that this method must be called after the pass configuration is complete.
   * So calls like `setMRT()` and `getTextureNode()` must proceed the precompilation.
   *
   * @async
   * @param {Renderer} renderer - The renderer.
   * @return {Promise} A Promise that resolves when the compile has been finished.
   * @see {@link Renderer#compileAsync}
   */
  async compileAsync(e) {
    const t = e.getRenderTarget(), n = e.getMRT();
    e.setRenderTarget(this.renderTarget), e.setMRT(this._mrt), await e.compileAsync(this.scene, this.camera), e.setRenderTarget(t), e.setMRT(n);
  }
  setup({ renderer: e }) {
    return this.renderTarget.samples = this.options.samples === void 0 ? e.samples : this.options.samples, this.renderTarget.texture.type = e.getOutputBufferType(), this.scope === ol.COLOR ? this.getTextureNode() : this.getLinearDepthNode();
  }
  updateBefore(e) {
    const { renderer: t } = e, { scene: n } = this;
    let r, s;
    const o = t.getOutputRenderTarget();
    o && o.isXRRenderTarget === !0 ? (s = 1, r = t.xr.getCamera(), t.xr.updateCamera(r), yg.set(o.width, o.height)) : (r = this.camera, s = t.getPixelRatio(), t.getSize(yg)), this._pixelRatio = s, this.setSize(yg.width, yg.height);
    const a = t.getRenderTarget(), l = t.getMRT(), u = t.autoClear, c = t.transparent, A = t.opaque, m = r.layers.mask, _ = t.contextNode, y = n.overrideMaterial;
    this._cameraNear.value = r.near, this._cameraFar.value = r.far, this._layers !== null && (r.layers.mask = this._layers.mask);
    for (const b in this._previousTextures)
      this.toggleTexture(b);
    this.overrideMaterial !== null && (n.overrideMaterial = this.overrideMaterial), t.setRenderTarget(this.renderTarget), t.setMRT(this._mrt), t.autoClear = !0, t.transparent = this.transparent, t.opaque = this.opaque, this.contextNode !== null && ((this._contextNodeCache === null || this._contextNodeCache.version !== this.version) && (this._contextNodeCache = {
      version: this.version,
      context: eu({ ...t.contextNode.getFlowContextData(), ...this.contextNode.getFlowContextData() })
    }), t.contextNode = this._contextNodeCache.context);
    const T = n.name;
    n.name = this.name ? this.name : n.name, t.render(n, r), n.name = T, n.overrideMaterial = y, t.setRenderTarget(a), t.setMRT(l), t.autoClear = u, t.transparent = c, t.opaque = A, t.contextNode = _, r.layers.mask = m;
  }
  /**
   * Sets the size of the pass's render target. Honors the pixel ratio.
   *
   * @param {number} width - The width to set.
   * @param {number} height - The height to set.
   */
  setSize(e, t) {
    this._width = e, this._height = t;
    const n = Math.floor(this._width * this._pixelRatio * this._resolutionScale), r = Math.floor(this._height * this._pixelRatio * this._resolutionScale);
    this.renderTarget.setSize(n, r), this._scissor !== null && this.renderTarget.scissor.copy(this._scissor), this._viewport !== null && this.renderTarget.viewport.copy(this._viewport);
  }
  /**
   * This method allows to define the pass's scissor rectangle. By default, the scissor rectangle is kept
   * in sync with the pass's dimensions. To reverse the process and use auto-sizing again, call the method
   * with `null` as the single argument.
   *
   * @param {?(number | Vector4)} x - The horizontal coordinate for the lower left corner of the box in logical pixel unit.
   * Instead of passing four arguments, the method also works with a single four-dimensional vector.
   * @param {number} y - The vertical coordinate for the lower left corner of the box in logical pixel unit.
   * @param {number} width - The width of the scissor box in logical pixel unit.
   * @param {number} height - The height of the scissor box in logical pixel unit.
   */
  setScissor(e, t, n, r) {
    e === null ? this._scissor = null : (this._scissor === null && (this._scissor = new Kt()), e.isVector4 ? this._scissor.copy(e) : this._scissor.set(e, t, n, r), this._scissor.multiplyScalar(this._pixelRatio * this._resolutionScale).floor());
  }
  /**
   * This method allows to define the pass's viewport. By default, the viewport is kept in sync
   * with the pass's dimensions. To reverse the process and use auto-sizing again, call the method
   * with `null` as the single argument.
   *
   * @param {number | Vector4} x - The horizontal coordinate for the lower left corner of the viewport origin in logical pixel unit.
   * @param {number} y - The vertical coordinate for the lower left corner of the viewport origin  in logical pixel unit.
   * @param {number} width - The width of the viewport in logical pixel unit.
   * @param {number} height - The height of the viewport in logical pixel unit.
   */
  setViewport(e, t, n, r) {
    e === null ? this._viewport = null : (this._viewport === null && (this._viewport = new Kt()), e.isVector4 ? this._viewport.copy(e) : this._viewport.set(e, t, n, r), this._viewport.multiplyScalar(this._pixelRatio * this._resolutionScale).floor());
  }
  /**
   * Sets the pixel ratio the pass's render target and updates the size.
   *
   * @param {number} pixelRatio - The pixel ratio to set.
   */
  setPixelRatio(e) {
    this._pixelRatio = e, this.setSize(this._width, this._height);
  }
  /**
   * Frees internal resources. Should be called when the node is no longer in use.
   */
  dispose() {
    this.renderTarget.dispose();
  }
}
ol.COLOR = "color";
ol.DEPTH = "depth";
const $ne = (i, e, t) => new ol(ol.COLOR, i, e, t), jne = (i, e) => new VL(i, e), Xne = (i, e, t) => new ol(ol.DEPTH, i, e, t);
class Yne extends ol {
  static get type() {
    return "ToonOutlinePassNode";
  }
  /**
   * Constructs a new outline pass node.
   *
   * @param {Scene} scene - A reference to the scene.
   * @param {Camera} camera - A reference to the camera.
   * @param {Node} colorNode - Defines the outline's color.
   * @param {Node} thicknessNode - Defines the outline's thickness.
   * @param {Node} alphaNode - Defines the outline's alpha.
   */
  constructor(e, t, n, r, s) {
    super(ol.COLOR, e, t), this.colorNode = n, this.thicknessNode = r, this.alphaNode = s, this._materialCache = /* @__PURE__ */ new WeakMap(), this.name = "Outline Pass";
  }
  updateBefore(e) {
    const { renderer: t } = e, n = t.getRenderObjectFunction();
    t.setRenderObjectFunction((r, s, o, a, l, u, c, A) => {
      if ((l.isMeshToonMaterial || l.isMeshToonNodeMaterial) && l.wireframe === !1) {
        const m = this._getOutlineMaterial(l);
        t.renderObject(r, s, o, a, m, u, c, A);
      }
      t.renderObject(r, s, o, a, l, u, c, A);
    }), super.updateBefore(e), t.setRenderObjectFunction(n);
  }
  /**
   * Creates the material used for outline rendering.
   *
   * @private
   * @return {NodeMaterial} The outline material.
   */
  _createMaterial() {
    const e = new Yi();
    e.isMeshToonOutlineMaterial = !0, e.name = "Toon_Outline", e.side = si;
    const t = oo.negate(), n = Ol.mul(sc), r = J(1), s = n.mul(Gt(Vi, 1)), o = n.mul(Gt(Vi.add(t), 1)), a = Fs(s.sub(o));
    return e.vertexNode = s.add(a.mul(this.thicknessNode).mul(s.w).mul(r)), e.colorNode = Gt(this.colorNode, this.alphaNode), e;
  }
  /**
   * For the given toon material, this method returns a corresponding
   * outline material.
   *
   * @private
   * @param {(MeshToonMaterial|MeshToonNodeMaterial)} originalMaterial - The toon material.
   * @return {NodeMaterial} The outline material.
   */
  _getOutlineMaterial(e) {
    let t = this._materialCache.get(e);
    return t === void 0 && (t = this._createMaterial(), this._materialCache.set(e, t)), t;
  }
}
const Qne = (i, e, t = new ct(0, 0, 0), n = 3e-3, r = 1) => ut(new Yne(i, e, ut(t), ut(n), ut(r))), GL = /* @__PURE__ */ pe(([i, e]) => i.mul(e).clamp()).setLayout({
  name: "linearToneMapping",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" },
    { name: "exposure", type: "float" }
  ]
}), zL = /* @__PURE__ */ pe(([i, e]) => (i = i.mul(e), i.div(i.add(1)).clamp())).setLayout({
  name: "reinhardToneMapping",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" },
    { name: "exposure", type: "float" }
  ]
}), qL = /* @__PURE__ */ pe(([i, e]) => {
  i = i.mul(e), i = i.sub(4e-3).max(0);
  const t = i.mul(i.mul(6.2).add(0.5)), n = i.mul(i.mul(6.2).add(1.7)).add(0.06);
  return t.div(n).pow(2.2);
}).setLayout({
  name: "cineonToneMapping",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" },
    { name: "exposure", type: "float" }
  ]
}), Kne = /* @__PURE__ */ pe(([i]) => {
  const e = i.mul(i.add(0.0245786)).sub(90537e-9), t = i.mul(i.add(0.432951).mul(0.983729)).add(0.238081);
  return e.div(t);
}), HL = /* @__PURE__ */ pe(([i, e]) => {
  const t = Kr(
    0.59719,
    0.35458,
    0.04823,
    0.076,
    0.90834,
    0.01566,
    0.0284,
    0.13383,
    0.83777
  ), n = Kr(
    1.60475,
    -0.53108,
    -0.07367,
    -0.10208,
    1.10813,
    -605e-5,
    -327e-5,
    -0.07276,
    1.07602
  );
  return i = i.mul(e).div(0.6), i = t.mul(i), i = Kne(i), i = n.mul(i), i.clamp();
}).setLayout({
  name: "acesFilmicToneMapping",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" },
    { name: "exposure", type: "float" }
  ]
}), Zne = /* @__PURE__ */ Kr(ce(1.6605, -0.1246, -0.0182), ce(-0.5876, 1.1329, -0.1006), ce(-0.0728, -83e-4, 1.1187)), Jne = /* @__PURE__ */ Kr(ce(0.6274, 0.0691, 0.0164), ce(0.3293, 0.9195, 0.088), ce(0.0433, 0.0113, 0.8956)), eie = /* @__PURE__ */ pe(([i]) => {
  const e = ce(i).toVar(), t = ce(e.mul(e)).toVar(), n = ce(t.mul(t)).toVar();
  return J(15.5).mul(n.mul(t)).sub(sn(40.14, n.mul(e))).add(sn(31.96, n).sub(sn(6.868, t.mul(e))).add(sn(0.4298, t).add(sn(0.1191, e).sub(232e-5))));
}), WL = /* @__PURE__ */ pe(([i, e]) => {
  const t = ce(i).toVar(), n = Kr(ce(0.856627153315983, 0.137318972929847, 0.11189821299995), ce(0.0951212405381588, 0.761241990602591, 0.0767994186031903), ce(0.0482516061458583, 0.101439036467562, 0.811302368396859)), r = Kr(ce(1.1271005818144368, -0.1413297634984383, -0.14132976349843826), ce(-0.11060664309660323, 1.157823702216272, -0.11060664309660294), ce(-0.016493938717834573, -0.016493938717834257, 1.2519364065950405)), s = J(-12.47393), o = J(4.026069);
  return t.mulAssign(e), t.assign(Jne.mul(t)), t.assign(n.mul(t)), t.assign(qi(t, 1e-10)), t.assign(Za(t)), t.assign(t.sub(s).div(o.sub(s))), t.assign(Sa(t, 0, 1)), t.assign(eie(t)), t.assign(r.mul(t)), t.assign(ko(qi(ce(0), t), ce(2.2))), t.assign(Zne.mul(t)), t.assign(Sa(t, 0, 1)), t;
}).setLayout({
  name: "agxToneMapping",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" },
    { name: "exposure", type: "float" }
  ]
}), $L = /* @__PURE__ */ pe(([i, e]) => {
  const t = J(0.76), n = J(0.15);
  i = i.mul(e);
  const r = so(i.r, so(i.g, i.b)), s = Yr(r.lessThan(0.08), r.sub(sn(6.25, r.mul(r))), 0.04);
  i.subAssign(s);
  const o = qi(i.r, qi(i.g, i.b));
  Ot(o.lessThan(t), () => i);
  const a = Un(1, t), l = Un(1, a.mul(a).div(o.add(a.sub(t))));
  i.mulAssign(l.div(o));
  const u = Un(1, Ro(1, n.mul(o.sub(l)).add(1)));
  return Bn(i, ce(l), u);
}).setLayout({
  name: "neutralToneMapping",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" },
    { name: "exposure", type: "float" }
  ]
});
class Cr extends St {
  static get type() {
    return "CodeNode";
  }
  /**
   * Constructs a new code node.
   *
   * @param {string} [code=''] - The native code.
   * @param {Array<Node>} [includes=[]] - An array of includes.
   * @param {('js'|'wgsl'|'glsl')} [language=''] - The used language.
   */
  constructor(e = "", t = [], n = "") {
    super("code"), this.isCodeNode = !0, this.global = !0, this.code = e, this.includes = t, this.language = n;
  }
  /**
   * Sets the includes of this code node.
   *
   * @param {Array<Node>} includes - The includes to set.
   * @return {CodeNode} A reference to this node.
   */
  setIncludes(e) {
    return this.includes = e, this;
  }
  /**
   * Returns the includes of this code node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Array<Node>} The includes.
   */
  getIncludes() {
    return this.includes;
  }
  generate(e) {
    const t = this.getIncludes(e);
    for (const r of t)
      r.build(e);
    const n = e.getCodeFromNode(this, this.getNodeType(e));
    return n.code = this.code, n.code;
  }
  serialize(e) {
    super.serialize(e), e.code = this.code, e.language = this.language;
  }
  deserialize(e) {
    super.deserialize(e), this.code = e.code, this.language = e.language;
  }
}
const J2 = /* @__PURE__ */ on(Cr).setParameterLength(1, 3), tie = (i, e) => J2(i, e, "js"), nie = (i, e) => J2(i, e, "wgsl"), iie = (i, e) => J2(i, e, "glsl");
class jL extends Cr {
  static get type() {
    return "FunctionNode";
  }
  /**
   * Constructs a new function node.
   *
   * @param {string} [code=''] - The native code.
   * @param {Array<Node>} [includes=[]] - An array of includes.
   * @param {('js'|'wgsl'|'glsl')} [language=''] - The used language.
   */
  constructor(e = "", t = [], n = "") {
    super(e, t, n);
  }
  /**
   * Returns the type of this function node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The type.
   */
  getNodeType(e) {
    return this.getNodeFunction(e).type;
  }
  /**
   * Returns the type of a member of this function node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {string} name - The name of the member.
   * @return {string} The type of the member.
   */
  getMemberType(e, t) {
    const n = this.getNodeType(e);
    return e.getStructTypeNode(n).getMemberType(e, t);
  }
  /**
   * Returns the inputs of this function node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Array<NodeFunctionInput>} The inputs.
   */
  getInputs(e) {
    return this.getNodeFunction(e).inputs;
  }
  /**
   * Returns the node function for this function node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {NodeFunction} The node function.
   */
  getNodeFunction(e) {
    const t = e.getDataFromNode(this);
    let n = t.nodeFunction;
    return n === void 0 && (n = e.parser.parseFunction(this.code), t.nodeFunction = n), n;
  }
  generate(e, t) {
    super.generate(e);
    const n = this.getNodeFunction(e), r = n.name, s = n.type, o = e.getCodeFromNode(this, s);
    r !== "" && (o.name = r);
    const a = e.getPropertyName(o), l = this.getNodeFunction(e).getCode(a);
    return o.code = l + `
`, t === "property" ? a : e.format(`${a}()`, s, t);
  }
}
const XL = (i, e = [], t = "") => {
  for (let s = 0; s < e.length; s++) {
    const o = e[s];
    typeof o == "function" && (e[s] = o.functionNode);
  }
  const n = new jL(i, e, t), r = (...s) => n.call(...s);
  return r.functionNode = n, r;
}, rie = (i, e) => XL(i, e, "glsl"), sie = (i, e) => XL(i, e, "wgsl");
class oie extends St {
  static get type() {
    return "ScriptableValueNode";
  }
  /**
   * Constructs a new scriptable node.
   *
   * @param {any} [value=null] - The value.
   */
  constructor(e = null) {
    super(), this._value = e, this._cache = null, this.inputType = null, this.outputType = null, this.events = new lo(), this.isScriptableValueNode = !0;
  }
  /**
   * Whether this node represents an output or not.
   *
   * @type {boolean}
   * @readonly
   * @default true
   */
  get isScriptableOutputNode() {
    return this.outputType !== null;
  }
  set value(e) {
    this._value !== e && (this._cache && this.inputType === "URL" && this.value.value instanceof ArrayBuffer && (URL.revokeObjectURL(this._cache), this._cache = null), this._value = e, this.events.dispatchEvent({ type: "change" }), this.refresh());
  }
  /**
   * The node's value.
   *
   * @type {any}
   */
  get value() {
    return this._value;
  }
  /**
   * Dispatches the `refresh` event.
   */
  refresh() {
    this.events.dispatchEvent({ type: "refresh" });
  }
  /**
   * The `value` property usually represents a node or even binary data in form of array buffers.
   * In this case, this method tries to return the actual value behind the complex type.
   *
   * @return {any} The value.
   */
  getValue() {
    const e = this.value;
    if (e && this._cache === null && this.inputType === "URL" && e.value instanceof ArrayBuffer)
      this._cache = URL.createObjectURL(new Blob([e.value]));
    else if (e && e.value !== null && e.value !== void 0 && ((this.inputType === "URL" || this.inputType === "String") && typeof e.value == "string" || this.inputType === "Number" && typeof e.value == "number" || this.inputType === "Vector2" && e.value.isVector2 || this.inputType === "Vector3" && e.value.isVector3 || this.inputType === "Vector4" && e.value.isVector4 || this.inputType === "Color" && e.value.isColor || this.inputType === "Matrix3" && e.value.isMatrix3 || this.inputType === "Matrix4" && e.value.isMatrix4))
      return e.value;
    return this._cache || e;
  }
  /**
   * Overwritten since the node type is inferred from the value.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(e) {
    return this.value && this.value.isNode ? this.value.getNodeType(e) : "float";
  }
  setup() {
    return this.value && this.value.isNode ? this.value : J();
  }
  serialize(e) {
    super.serialize(e), this.value !== null ? this.inputType === "ArrayBuffer" ? e.value = JP(this.value) : e.value = this.value ? this.value.toJSON(e.meta).uuid : null : e.value = null, e.inputType = this.inputType, e.outputType = this.outputType;
  }
  deserialize(e) {
    super.deserialize(e);
    let t = null;
    e.value !== null && (e.inputType === "ArrayBuffer" ? t = eN(e.value) : e.inputType === "Texture" ? t = e.meta.textures[e.value] : t = e.meta.nodes[e.value] || null), this.value = t, this.inputType = e.inputType, this.outputType = e.outputType;
  }
}
const l1 = /* @__PURE__ */ on(oie).setParameterLength(1);
class YL extends Map {
  get(e, t = null, ...n) {
    if (this.has(e)) return super.get(e);
    if (t !== null) {
      const r = t(...n);
      return this.set(e, r), r;
    }
  }
}
class aie {
  constructor(e) {
    this.scriptableNode = e;
  }
  get parameters() {
    return this.scriptableNode.parameters;
  }
  get layout() {
    return this.scriptableNode.getLayout();
  }
  getInputLayout(e) {
    return this.scriptableNode.getInputLayout(e);
  }
  get(e) {
    const t = this.parameters[e];
    return t ? t.getValue() : null;
  }
}
const u1 = new YL();
class lie extends St {
  static get type() {
    return "ScriptableNode";
  }
  /**
   * Constructs a new scriptable node.
   *
   * @param {?CodeNode} [codeNode=null] - The code node.
   * @param {Object} [parameters={}] - The parameters definition.
   */
  constructor(e = null, t = {}) {
    super(), this.codeNode = e, this.parameters = t, this._local = new YL(), this._output = l1(null), this._outputs = {}, this._source = this.source, this._method = null, this._object = null, this._value = null, this._needsOutputUpdate = !0, this.onRefresh = this.onRefresh.bind(this), this.isScriptableNode = !0;
  }
  /**
   * The source code of the scriptable node.
   *
   * @type {string}
   */
  get source() {
    return this.codeNode ? this.codeNode.code : "";
  }
  /**
   * Sets the reference of a local script variable.
   *
   * @param {string} name - The variable name.
   * @param {Object} value - The reference to set.
   * @return {Resources} The resource map
   */
  setLocal(e, t) {
    return this._local.set(e, t);
  }
  /**
   * Gets the value of a local script variable.
   *
   * @param {string} name - The variable name.
   * @return {Object} The value.
   */
  getLocal(e) {
    return this._local.get(e);
  }
  /**
   * Event listener for the `refresh` event.
   */
  onRefresh() {
    this._refresh();
  }
  /**
   * Returns an input from the layout with the given id/name.
   *
   * @param {string} id - The id/name of the input.
   * @return {Object} The element entry.
   */
  getInputLayout(e) {
    for (const t of this.getLayout())
      if (t.inputType && (t.id === e || t.name === e))
        return t;
  }
  /**
   * Returns an output from the layout with the given id/name.
   *
   * @param {string} id - The id/name of the output.
   * @return {Object} The element entry.
   */
  getOutputLayout(e) {
    for (const t of this.getLayout())
      if (t.outputType && (t.id === e || t.name === e))
        return t;
  }
  /**
   * Defines a script output for the given name and value.
   *
   * @param {string} name - The name of the output.
   * @param {Node} value - The node value.
   * @return {ScriptableNode} A reference to this node.
   */
  setOutput(e, t) {
    const n = this._outputs;
    return n[e] === void 0 ? n[e] = l1(t) : n[e].value = t, this;
  }
  /**
   * Returns a script output for the given name.
   *
   * @param {string} name - The name of the output.
   * @return {ScriptableValueNode} The node value.
   */
  getOutput(e) {
    return this._outputs[e];
  }
  /**
   * Returns a parameter for the given name
   *
   * @param {string} name - The name of the parameter.
   * @return {ScriptableValueNode} The node value.
   */
  getParameter(e) {
    return this.parameters[e];
  }
  /**
   * Sets a value for the given parameter name.
   *
   * @param {string} name - The parameter name.
   * @param {any} value - The parameter value.
   * @return {ScriptableNode} A reference to this node.
   */
  setParameter(e, t) {
    const n = this.parameters;
    return t && t.isScriptableNode ? (this.deleteParameter(e), n[e] = t, n[e].getDefaultOutput().events.addEventListener("refresh", this.onRefresh)) : t && t.isScriptableValueNode ? (this.deleteParameter(e), n[e] = t, n[e].events.addEventListener("refresh", this.onRefresh)) : n[e] === void 0 ? (n[e] = l1(t), n[e].events.addEventListener("refresh", this.onRefresh)) : n[e].value = t, this;
  }
  /**
   * Returns the value of this node which is the value of
   * the default output.
   *
   * @return {Node} The value.
   */
  getValue() {
    return this.getDefaultOutput().getValue();
  }
  /**
   * Deletes a parameter from the script.
   *
   * @param {string} name - The parameter to remove.
   * @return {ScriptableNode} A reference to this node.
   */
  deleteParameter(e) {
    let t = this.parameters[e];
    return t && (t.isScriptableNode && (t = t.getDefaultOutput()), t.events.removeEventListener("refresh", this.onRefresh)), this;
  }
  /**
   * Deletes all parameters from the script.
   *
   * @return {ScriptableNode} A reference to this node.
   */
  clearParameters() {
    for (const e of Object.keys(this.parameters))
      this.deleteParameter(e);
    return this.needsUpdate = !0, this;
  }
  /**
   * Calls a function from the script.
   *
   * @param {string} name - The function name.
   * @param {...any} params - A list of parameters.
   * @return {any} The result of the function call.
   */
  call(e, ...t) {
    const r = this.getObject()[e];
    if (typeof r == "function")
      return r(...t);
  }
  /**
   * Asynchronously calls a function from the script.
   *
   * @param {string} name - The function name.
   * @param {...any} params - A list of parameters.
   * @return {Promise<any>} The result of the function call.
   */
  async callAsync(e, ...t) {
    const r = this.getObject()[e];
    if (typeof r == "function")
      return r.constructor.name === "AsyncFunction" ? await r(...t) : r(...t);
  }
  /**
   * Overwritten since the node types is inferred from the script's output.
   *
   * @param {NodeBuilder} builder - The current node builder
   * @return {string} The node type.
   */
  getNodeType(e) {
    return this.getDefaultOutputNode().getNodeType(e);
  }
  /**
   * Refreshes the script node.
   *
   * @param {?string} [output=null] - An optional output.
   */
  refresh(e = null) {
    e !== null ? this.getOutput(e).refresh() : this._refresh();
  }
  /**
   * Returns an object representation of the script.
   *
   * @return {Object} The result object.
   */
  getObject() {
    if (this.needsUpdate && this.dispose(), this._object !== null) return this._object;
    const e = () => this.refresh(), t = (u, c) => this.setOutput(u, c), n = new aie(this), r = u1.get("THREE"), s = u1.get("TSL"), o = this.getMethod(), a = [n, this._local, u1, e, t, r, s];
    this._object = o(...a);
    const l = this._object.layout;
    if (l && (l.cache === !1 && this._local.clear(), this._output.outputType = l.outputType || null, Array.isArray(l.elements)))
      for (const u of l.elements) {
        const c = u.id || u.name;
        u.inputType && (this.getParameter(c) === void 0 && this.setParameter(c, null), this.getParameter(c).inputType = u.inputType), u.outputType && (this.getOutput(c) === void 0 && this.setOutput(c, null), this.getOutput(c).outputType = u.outputType);
      }
    return this._object;
  }
  deserialize(e) {
    super.deserialize(e);
    for (const t in this.parameters) {
      let n = this.parameters[t];
      n.isScriptableNode && (n = n.getDefaultOutput()), n.events.addEventListener("refresh", this.onRefresh);
    }
  }
  /**
   * Returns the layout of the script.
   *
   * @return {Object} The script's layout.
   */
  getLayout() {
    return this.getObject().layout;
  }
  /**
   * Returns default node output of the script.
   *
   * @return {Node} The default node output.
   */
  getDefaultOutputNode() {
    const e = this.getDefaultOutput().value;
    return e && e.isNode ? e : J();
  }
  /**
   * Returns default output of the script.
   *
   * @return {ScriptableValueNode} The default output.
   */
  getDefaultOutput() {
    return this._exec()._output;
  }
  /**
   * Returns a function created from the node's script.
   *
   * @return {Function} The function representing the node's code.
   */
  getMethod() {
    if (this.needsUpdate && this.dispose(), this._method !== null) return this._method;
    const e = ["parameters", "local", "global", "refresh", "setOutput", "THREE", "TSL"], n = ["layout", "init", "main", "dispose"].join(", "), r = "var " + n + `; var output = {};
`, s = `
return { ...output, ` + n + " };", o = r + this.codeNode.code + s;
    return this._method = new Function(...e, o), this._method;
  }
  /**
   * Frees all internal resources.
   */
  dispose() {
    this._method !== null && (this._object && typeof this._object.dispose == "function" && this._object.dispose(), this._method = null, this._object = null, this._source = null, this._value = null, this._needsOutputUpdate = !0, this._output.value = null, this._outputs = {});
  }
  setup() {
    return this.getDefaultOutputNode();
  }
  getCacheKey(e) {
    const t = [F0(this.source), this.getDefaultOutputNode().getCacheKey(e)];
    for (const n in this.parameters)
      t.push(this.parameters[n].getCacheKey(e));
    return cA(t);
  }
  set needsUpdate(e) {
    e === !0 && this.dispose();
  }
  get needsUpdate() {
    return this.source !== this._source;
  }
  /**
   * Executes the `main` function of the script.
   *
   * @private
   * @return {ScriptableNode} A reference to this node.
   */
  _exec() {
    return this.codeNode === null ? this : (this._needsOutputUpdate === !0 && (this._value = this.call("main"), this._needsOutputUpdate = !1), this._output.value = this._value, this);
  }
  /**
   * Executes the refresh.
   *
   * @private
   */
  _refresh() {
    this.needsUpdate = !0, this._exec(), this._output.refresh();
  }
}
const uie = /* @__PURE__ */ on(lie).setParameterLength(1, 2);
function QL(i) {
  let e;
  const t = i.context.getViewZ;
  return t !== void 0 && (e = t(this)), (e || tr.z).negate();
}
const QT = pe(([i, e], t) => {
  const n = QL(t);
  return Ta(i, e, n);
}), KT = pe(([i], e) => {
  const t = QL(e);
  return i.mul(i, t, t).negate().exp().oneMinus();
}), c0 = pe(([i, e]) => Gt(e.toFloat().mix(yf.rgb, i.toVec3()), yf.a));
function cie(i, e, t) {
  return Me('TSL: "rangeFog( color, near, far )" is deprecated. Use "fog( color, rangeFogFactor( near, far ) )" instead.'), c0(i, QT(e, t));
}
function hie(i, e) {
  return Me('TSL: "densityFog( color, density )" is deprecated. Use "fog( color, densityFogFactor( density ) )" instead.'), c0(i, KT(e));
}
let Bc = null, Fc = null;
class die extends St {
  static get type() {
    return "RangeNode";
  }
  /**
   * Constructs a new range node.
   *
   * @param {Node<any>} [minNode=float()] - A node defining the lower bound of the range.
   * @param {Node<any>} [maxNode=float()] - A node defining the upper bound of the range.
   */
  constructor(e = J(), t = J()) {
    super(), this.minNode = e, this.maxNode = t;
  }
  /**
   * Returns the vector length which is computed based on the range definition.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {number} The vector length.
   */
  getVectorLength(e) {
    const t = this.getConstNode(this.minNode), n = this.getConstNode(this.maxNode), r = e.getTypeLength(Bu(t.value)), s = e.getTypeLength(Bu(n.value));
    return r > s ? r : s;
  }
  /**
   * This method is overwritten since the node type is inferred from range definition.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(e) {
    return e.object.count > 1 ? e.getTypeFromLength(this.getVectorLength(e)) : "float";
  }
  /**
   * Returns a constant node from the given node by traversing it.
   *
   * @param {Node} node - The node to traverse.
   * @returns {Node} The constant node, if found.
   */
  getConstNode(e) {
    let t = null;
    if (e.traverse((n) => {
      n.isConstNode === !0 && (t = n);
    }), t === null)
      throw new Error('THREE.TSL: No "ConstNode" found in node graph.');
    return t;
  }
  setup(e) {
    const t = e.object;
    let n = null;
    if (t.count > 1) {
      const r = this.getConstNode(this.minNode), s = this.getConstNode(this.maxNode), o = r.value, a = s.value, l = e.getTypeLength(Bu(o)), u = e.getTypeLength(Bu(a));
      Bc = Bc || new Kt(), Fc = Fc || new Kt(), Bc.setScalar(0), Fc.setScalar(0), l === 1 ? Bc.setScalar(o) : o.isColor ? Bc.set(o.r, o.g, o.b, 1) : Bc.set(o.x, o.y, o.z || 0, o.w || 0), u === 1 ? Fc.setScalar(a) : a.isColor ? Fc.set(a.r, a.g, a.b, 1) : Fc.set(a.x, a.y, a.z || 0, a.w || 0);
      const c = 4, A = c * t.count, m = new Float32Array(A);
      for (let y = 0; y < A; y++) {
        const T = y % c, b = Bc.getComponent(T), S = Fc.getComponent(T);
        m[y] = zh.lerp(b, S, Math.random());
      }
      const _ = this.getNodeType(e);
      if (t.count <= 4096)
        n = k0(m, "vec4", t.count).element(nl).convert(_);
      else {
        const y = new to(m, 4);
        e.geometry.setAttribute("__range" + this.id, y), n = c_(y).convert(_);
      }
    } else
      n = J(0);
    return n;
  }
}
const fie = /* @__PURE__ */ on(die).setParameterLength(2);
class Aie extends St {
  static get type() {
    return "ComputeBuiltinNode";
  }
  /**
   * Constructs a new compute builtin node.
   *
   * @param {string} builtinName - The built-in name.
   * @param {string} nodeType - The node type.
   */
  constructor(e, t) {
    super(t), this._builtinName = e;
  }
  /**
   * This method is overwritten since hash is derived from the built-in name.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The hash.
   */
  getHash(e) {
    return this.getBuiltinName(e);
  }
  /**
   * This method is overwritten since the node type is simply derived from `nodeType`..
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType() {
    return this.nodeType;
  }
  /**
   * Sets the builtin name.
   *
   * @param {string} builtinName - The built-in name.
   * @return {ComputeBuiltinNode} A reference to this node.
   */
  setBuiltinName(e) {
    return this._builtinName = e, this;
  }
  /**
   * Returns the builtin name.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The builtin name.
   */
  getBuiltinName() {
    return this._builtinName;
  }
  /**
   * Whether the current node builder has the builtin or not.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {boolean} Whether the builder has the builtin or not.
   */
  hasBuiltin(e) {
    return e.hasBuiltin(this._builtinName);
  }
  generate(e, t) {
    const n = this.getBuiltinName(e), r = this.getNodeType(e);
    return e.shaderStage === "compute" ? e.format(n, r, t) : (Me(`ComputeBuiltinNode: Compute built-in value ${n} can not be accessed in the ${e.shaderStage} stage`), e.generateConst(r));
  }
  serialize(e) {
    super.serialize(e), e.global = this.global, e._builtinName = this._builtinName;
  }
  deserialize(e) {
    super.deserialize(e), this.global = e.global, this._builtinName = e._builtinName;
  }
}
const H0 = (i, e) => new Aie(i, e), pie = /* @__PURE__ */ H0("numWorkgroups", "uvec3"), mie = /* @__PURE__ */ H0("workgroupId", "uvec3"), gie = /* @__PURE__ */ H0("globalId", "uvec3"), _ie = /* @__PURE__ */ H0("localId", "uvec3"), xie = /* @__PURE__ */ H0("subgroupSize", "uint");
class yie extends St {
  /**
   * Constructs a new barrier node.
   *
   * @param {string} scope - The scope defines the behavior of the node.
   */
  constructor(e) {
    super(), this.scope = e;
  }
  generate(e) {
    const { scope: t } = this, { renderer: n } = e;
    n.backend.isWebGLBackend === !0 ? e.addFlowCode(`	// ${t}Barrier
`) : e.addLineFlowCode(`${t}Barrier()`, this);
  }
}
const ZT = on(yie), vie = () => ZT("workgroup").toStack(), bie = () => ZT("storage").toStack(), Sie = () => ZT("texture").toStack();
class Tie extends sd {
  /**
   * Constructs a new workgroup info element node.
   *
   * @param {Node} workgroupInfoNode - The workgroup info node.
   * @param {Node} indexNode - The index node that defines the element access.
   */
  constructor(e, t) {
    super(e, t), this.isWorkgroupInfoElementNode = !0;
  }
  generate(e, t) {
    let n;
    const r = e.context.assign;
    if (n = super.generate(e), r !== !0) {
      const s = this.getNodeType(e);
      n = e.format(n, s, t);
    }
    return n;
  }
}
class wie extends St {
  /**
   * Constructs a new buffer scoped to type scope.
   *
   * @param {string} scope - TODO.
   * @param {string} bufferType - The data type of a 'workgroup' scoped buffer element.
   * @param {number} [bufferCount=0] - The number of elements in the buffer.
   */
  constructor(e, t, n = 0) {
    super(t), this.bufferType = t, this.bufferCount = n, this.isWorkgroupInfoNode = !0, this.elementType = t, this.scope = e, this.name = "";
  }
  /**
   * Sets the name of this node.
   *
   * @param {string} name - The name to set.
   * @return {WorkgroupInfoNode} A reference to this node.
   */
  setName(e) {
    return this.name = e, this;
  }
  /**
   * Sets the name/label of this node.
   *
   * @deprecated
   * @param {string} name - The name to set.
   * @return {WorkgroupInfoNode} A reference to this node.
   */
  label(e) {
    return Me('TSL: "label()" has been deprecated. Use "setName()" instead.'), this.setName(e);
  }
  /**
   * Sets the scope of this node.
   *
   * @param {string} scope - The scope to set.
   * @return {WorkgroupInfoNode} A reference to this node.
   */
  setScope(e) {
    return this.scope = e, this;
  }
  /**
   * The data type of the array buffer.
   *
   * @return {string} The element type.
   */
  getElementType() {
    return this.elementType;
  }
  /**
   * Overwrites the default implementation since the input type
   * is inferred from the scope.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The input type.
   */
  getInputType() {
    return `${this.scope}Array`;
  }
  /**
   * This method can be used to access elements via an index node.
   *
   * @param {IndexNode} indexNode - indexNode.
   * @return {WorkgroupInfoElementNode} A reference to an element.
   */
  element(e) {
    return new Tie(this, e);
  }
  generate(e) {
    const t = this.name !== "" ? this.name : `${this.scope}Array_${this.id}`;
    return e.getScopedArray(t, this.scope.toLowerCase(), this.bufferType, this.bufferCount);
  }
}
const Mie = (i, e) => new wie("Workgroup", i, e);
class Tr extends St {
  static get type() {
    return "AtomicFunctionNode";
  }
  /**
   * Constructs a new atomic function node.
   *
   * @param {string} method - The signature of the atomic function to construct.
   * @param {Node} pointerNode - An atomic variable or element of an atomic buffer.
   * @param {Node} valueNode - The value that mutates the atomic variable.
   */
  constructor(e, t, n) {
    super("uint"), this.method = e, this.pointerNode = t, this.valueNode = n, this.parents = !0;
  }
  /**
   * Overwrites the default implementation to return the type of
   * the pointer node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The input type.
   */
  getInputType(e) {
    return this.pointerNode.getNodeType(e);
  }
  /**
   * Overwritten since the node type is inferred from the input type.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(e) {
    return this.getInputType(e);
  }
  generate(e) {
    const t = e.getNodeProperties(this), n = t.parents, r = this.method, s = this.getNodeType(e), o = this.getInputType(e), a = this.pointerNode, l = this.valueNode, u = [];
    u.push(`&${a.build(e, o)}`), l !== null && u.push(l.build(e, o));
    const c = `${e.getMethod(r, s)}( ${u.join(", ")} )`;
    if (n ? n.length === 1 && n[0].isStackNode === !0 : !1)
      e.addLineFlowCode(c, this);
    else
      return t.constNode === void 0 && (t.constNode = Zl(c, s).toConst()), t.constNode.build(e);
  }
}
Tr.ATOMIC_LOAD = "atomicLoad";
Tr.ATOMIC_STORE = "atomicStore";
Tr.ATOMIC_ADD = "atomicAdd";
Tr.ATOMIC_SUB = "atomicSub";
Tr.ATOMIC_MAX = "atomicMax";
Tr.ATOMIC_MIN = "atomicMin";
Tr.ATOMIC_AND = "atomicAnd";
Tr.ATOMIC_OR = "atomicOr";
Tr.ATOMIC_XOR = "atomicXor";
const Eie = on(Tr), hl = (i, e, t) => Eie(i, e, t).toStack(), Rie = (i) => hl(Tr.ATOMIC_LOAD, i, null), Cie = (i, e) => hl(Tr.ATOMIC_STORE, i, e), Pie = (i, e) => hl(Tr.ATOMIC_ADD, i, e), Nie = (i, e) => hl(Tr.ATOMIC_SUB, i, e), Die = (i, e) => hl(Tr.ATOMIC_MAX, i, e), Lie = (i, e) => hl(Tr.ATOMIC_MIN, i, e), Iie = (i, e) => hl(Tr.ATOMIC_AND, i, e), Bie = (i, e) => hl(Tr.ATOMIC_OR, i, e), Fie = (i, e) => hl(Tr.ATOMIC_XOR, i, e);
class ht extends Hi {
  static get type() {
    return "SubgroupFunctionNode";
  }
  /**
   * Constructs a new function node.
   *
   * @param {string} method - The subgroup/wave intrinsic method to construct.
   * @param {Node} [aNode=null] - The method's first argument.
   * @param {Node} [bNode=null] - The method's second argument.
   */
  constructor(e, t = null, n = null) {
    super(), this.method = e, this.aNode = t, this.bNode = n;
  }
  getInputType(e) {
    const t = this.aNode ? this.aNode.getNodeType(e) : null, n = this.bNode ? this.bNode.getNodeType(e) : null, r = e.isMatrix(t) ? 0 : e.getTypeLength(t), s = e.isMatrix(n) ? 0 : e.getTypeLength(n);
    return r > s ? t : n;
  }
  getNodeType(e) {
    const t = this.method;
    return t === ht.SUBGROUP_ELECT ? "bool" : t === ht.SUBGROUP_BALLOT ? "uvec4" : this.getInputType(e);
  }
  generate(e, t) {
    const n = this.method, r = this.getNodeType(e), s = this.getInputType(e), o = this.aNode, a = this.bNode, l = [];
    if (n === ht.SUBGROUP_BROADCAST || n === ht.SUBGROUP_SHUFFLE || n === ht.QUAD_BROADCAST) {
      const c = a.getNodeType(e);
      l.push(
        o.build(e, r),
        a.build(e, c === "float" ? "int" : r)
      );
    } else n === ht.SUBGROUP_SHUFFLE_XOR || n === ht.SUBGROUP_SHUFFLE_DOWN || n === ht.SUBGROUP_SHUFFLE_UP ? l.push(
      o.build(e, r),
      a.build(e, "uint")
    ) : (o !== null && l.push(o.build(e, s)), a !== null && l.push(a.build(e, s)));
    const u = l.length === 0 ? "()" : `( ${l.join(", ")} )`;
    return e.format(`${e.getMethod(n, r)}${u}`, r, t);
  }
  serialize(e) {
    super.serialize(e), e.method = this.method;
  }
  deserialize(e) {
    super.deserialize(e), this.method = e.method;
  }
}
ht.SUBGROUP_ELECT = "subgroupElect";
ht.SUBGROUP_BALLOT = "subgroupBallot";
ht.SUBGROUP_ADD = "subgroupAdd";
ht.SUBGROUP_INCLUSIVE_ADD = "subgroupInclusiveAdd";
ht.SUBGROUP_EXCLUSIVE_AND = "subgroupExclusiveAdd";
ht.SUBGROUP_MUL = "subgroupMul";
ht.SUBGROUP_INCLUSIVE_MUL = "subgroupInclusiveMul";
ht.SUBGROUP_EXCLUSIVE_MUL = "subgroupExclusiveMul";
ht.SUBGROUP_AND = "subgroupAnd";
ht.SUBGROUP_OR = "subgroupOr";
ht.SUBGROUP_XOR = "subgroupXor";
ht.SUBGROUP_MIN = "subgroupMin";
ht.SUBGROUP_MAX = "subgroupMax";
ht.SUBGROUP_ALL = "subgroupAll";
ht.SUBGROUP_ANY = "subgroupAny";
ht.SUBGROUP_BROADCAST_FIRST = "subgroupBroadcastFirst";
ht.QUAD_SWAP_X = "quadSwapX";
ht.QUAD_SWAP_Y = "quadSwapY";
ht.QUAD_SWAP_DIAGONAL = "quadSwapDiagonal";
ht.SUBGROUP_BROADCAST = "subgroupBroadcast";
ht.SUBGROUP_SHUFFLE = "subgroupShuffle";
ht.SUBGROUP_SHUFFLE_XOR = "subgroupShuffleXor";
ht.SUBGROUP_SHUFFLE_UP = "subgroupShuffleUp";
ht.SUBGROUP_SHUFFLE_DOWN = "subgroupShuffleDown";
ht.QUAD_BROADCAST = "quadBroadcast";
const Uie = /* @__PURE__ */ Ke(ht, ht.SUBGROUP_ELECT).setParameterLength(0), Oie = /* @__PURE__ */ Ke(ht, ht.SUBGROUP_BALLOT).setParameterLength(1), kie = /* @__PURE__ */ Ke(ht, ht.SUBGROUP_ADD).setParameterLength(1), Vie = /* @__PURE__ */ Ke(ht, ht.SUBGROUP_INCLUSIVE_ADD).setParameterLength(1), Gie = /* @__PURE__ */ Ke(ht, ht.SUBGROUP_EXCLUSIVE_AND).setParameterLength(1), zie = /* @__PURE__ */ Ke(ht, ht.SUBGROUP_MUL).setParameterLength(1), qie = /* @__PURE__ */ Ke(ht, ht.SUBGROUP_INCLUSIVE_MUL).setParameterLength(1), Hie = /* @__PURE__ */ Ke(ht, ht.SUBGROUP_EXCLUSIVE_MUL).setParameterLength(1), Wie = /* @__PURE__ */ Ke(ht, ht.SUBGROUP_AND).setParameterLength(1), $ie = /* @__PURE__ */ Ke(ht, ht.SUBGROUP_OR).setParameterLength(1), jie = /* @__PURE__ */ Ke(ht, ht.SUBGROUP_XOR).setParameterLength(1), Xie = /* @__PURE__ */ Ke(ht, ht.SUBGROUP_MIN).setParameterLength(1), Yie = /* @__PURE__ */ Ke(ht, ht.SUBGROUP_MAX).setParameterLength(1), Qie = /* @__PURE__ */ Ke(ht, ht.SUBGROUP_ALL).setParameterLength(0), Kie = /* @__PURE__ */ Ke(ht, ht.SUBGROUP_ANY).setParameterLength(0), Zie = /* @__PURE__ */ Ke(ht, ht.SUBGROUP_BROADCAST_FIRST).setParameterLength(2), Jie = /* @__PURE__ */ Ke(ht, ht.QUAD_SWAP_X).setParameterLength(1), ere = /* @__PURE__ */ Ke(ht, ht.QUAD_SWAP_Y).setParameterLength(1), tre = /* @__PURE__ */ Ke(ht, ht.QUAD_SWAP_DIAGONAL).setParameterLength(1), nre = /* @__PURE__ */ Ke(ht, ht.SUBGROUP_BROADCAST).setParameterLength(2), ire = /* @__PURE__ */ Ke(ht, ht.SUBGROUP_SHUFFLE).setParameterLength(2), rre = /* @__PURE__ */ Ke(ht, ht.SUBGROUP_SHUFFLE_XOR).setParameterLength(2), sre = /* @__PURE__ */ Ke(ht, ht.SUBGROUP_SHUFFLE_UP).setParameterLength(2), ore = /* @__PURE__ */ Ke(ht, ht.SUBGROUP_SHUFFLE_DOWN).setParameterLength(2), are = /* @__PURE__ */ Ke(ht, ht.QUAD_BROADCAST).setParameterLength(1);
let vg;
function ex(i) {
  vg = vg || /* @__PURE__ */ new WeakMap();
  let e = vg.get(i);
  return e === void 0 && vg.set(i, e = {}), e;
}
function tx(i) {
  const e = ex(i);
  return e.shadowMatrix || (e.shadowMatrix = It("mat4").setGroup(Lt).onRenderUpdate((t) => ((i.castShadow !== !0 || t.renderer.shadowMap.enabled === !1) && (i.shadow.camera.coordinateSystem !== t.camera.coordinateSystem && (i.shadow.camera.coordinateSystem = t.camera.coordinateSystem, i.shadow.camera.updateProjectionMatrix()), i.shadow.updateMatrices(i)), i.shadow.matrix)));
}
function KL(i, e = tl) {
  const t = tx(i).mul(e);
  return t.xyz.div(t.w);
}
function JT(i) {
  const e = ex(i);
  return e.position || (e.position = It(new j()).setGroup(Lt).onRenderUpdate((t, n) => n.value.setFromMatrixPosition(i.matrixWorld)));
}
function ZL(i) {
  const e = ex(i);
  return e.targetPosition || (e.targetPosition = It(new j()).setGroup(Lt).onRenderUpdate((t, n) => n.value.setFromMatrixPosition(i.target.matrixWorld)));
}
function ew(i) {
  const e = ex(i);
  return e.viewPosition || (e.viewPosition = It(new j()).setGroup(Lt).onRenderUpdate(({ camera: t }, n) => {
    n.value = n.value || new j(), n.value.setFromMatrixPosition(i.matrixWorld), n.value.applyMatrix4(t.matrixWorldInverse);
  }));
}
const tw = (i) => ea.transformDirection(JT(i).sub(ZL(i))), lre = (i) => i.sort((e, t) => e.id - t.id), ure = (i, e) => {
  for (const t of e)
    if (t.isAnalyticLightNode && t.light.id === i)
      return t;
  return null;
}, ov = /* @__PURE__ */ new WeakMap(), ZA = [];
class nw extends St {
  static get type() {
    return "LightsNode";
  }
  /**
   * Constructs a new lights node.
   */
  constructor() {
    super("vec3"), this.totalDiffuseNode = Bl("vec3", "totalDiffuse"), this.totalSpecularNode = Bl("vec3", "totalSpecular"), this.outgoingLightNode = Bl("vec3", "outgoingLight"), this._lights = [], this._lightNodes = null, this._lightNodesHash = null, this.global = !0;
  }
  /**
   * Overwrites the default {@link Node#customCacheKey} implementation by including
   * light data into the cache key.
   *
   * @return {number} The custom cache key.
   */
  customCacheKey() {
    const e = this._lights;
    for (let n = 0; n < e.length; n++) {
      const r = e[n];
      if (ZA.push(r.id), ZA.push(r.castShadow ? 1 : 0), r.isSpotLight === !0) {
        const s = r.map !== null ? r.map.id : -1, o = r.colorNode ? r.colorNode.getCacheKey() : -1;
        ZA.push(s, o);
      }
    }
    const t = cA(ZA);
    return ZA.length = 0, t;
  }
  /**
   * Computes a hash value for identifying the current light nodes setup.
   *
   * @param {NodeBuilder} builder - A reference to the current node builder.
   * @return {string} The computed hash.
   */
  getHash(e) {
    if (this._lightNodesHash === null) {
      this._lightNodes === null && this.setupLightsNode(e);
      const t = [];
      for (const n of this._lightNodes)
        t.push(n.getHash());
      this._lightNodesHash = "lights-" + t.join(",");
    }
    return this._lightNodesHash;
  }
  analyze(e) {
    const t = e.getNodeProperties(this);
    for (const n of t.nodes)
      n.build(e);
    t.outputNode.build(e);
  }
  /**
   * Creates lighting nodes for each scene light. This makes it possible to further
   * process lights in the node system.
   *
   * @param {NodeBuilder} builder - A reference to the current node builder.
   */
  setupLightsNode(e) {
    const t = [], n = this._lightNodes, r = lre(this._lights), s = e.renderer.library;
    for (const o of r)
      if (o.isNode)
        t.push(ut(o));
      else {
        let a = null;
        if (n !== null && (a = ure(o.id, n)), a === null) {
          const l = s.getLightNodeClass(o.constructor);
          if (l === null) {
            Me(`LightsNode.setupNodeLights: Light node not found for ${o.constructor.name}`);
            continue;
          }
          let u = null;
          ov.has(o) ? u = ov.get(o) : (u = new l(o), ov.set(o, u)), t.push(u);
        }
      }
    this._lightNodes = t;
  }
  /**
   * Sets up a direct light in the lighting model.
   *
   * @param {Object} builder - The builder object containing the context and stack.
   * @param {Object} lightNode - The light node.
   * @param {Object} lightData - The light object containing color and direction properties.
   */
  setupDirectLight(e, t, n) {
    const { lightingModel: r, reflectedLight: s } = e.context;
    r.direct({
      ...n,
      lightNode: t,
      reflectedLight: s
    }, e);
  }
  setupDirectRectAreaLight(e, t, n) {
    const { lightingModel: r, reflectedLight: s } = e.context;
    r.directRectArea({
      ...n,
      lightNode: t,
      reflectedLight: s
    }, e);
  }
  /**
   * Setups the internal lights by building all respective
   * light nodes.
   *
   * @param {NodeBuilder} builder - A reference to the current node builder.
   * @param {Array<LightingNode>} lightNodes - An array of lighting nodes.
   */
  setupLights(e, t) {
    for (const n of t)
      n.build(e);
  }
  getLightNodes(e) {
    return this._lightNodes === null && this.setupLightsNode(e), this._lightNodes;
  }
  /**
   * The implementation makes sure that for each light in the scene
   * there is a corresponding light node. By building the light nodes
   * and evaluating the lighting model the outgoing light is computed.
   *
   * @param {NodeBuilder} builder - A reference to the current node builder.
   * @return {Node<vec3>} A node representing the outgoing light.
   */
  setup(e) {
    const t = e.lightsNode;
    e.lightsNode = this;
    let n = this.outgoingLightNode;
    const r = e.context, s = r.lightingModel, o = e.getNodeProperties(this);
    if (s) {
      const { totalDiffuseNode: a, totalSpecularNode: l } = this;
      r.outgoingLight = n;
      const u = e.addStack();
      o.nodes = u.nodes, s.start(e);
      const { backdrop: c, backdropAlpha: A } = r, { directDiffuse: m, directSpecular: _, indirectDiffuse: y, indirectSpecular: T } = r.reflectedLight;
      let b = m.add(y);
      c !== null && (A !== null ? b = ce(A.mix(b, c)) : b = ce(c)), a.assign(b), l.assign(_.add(T)), n.assign(a.add(l)), s.finish(e), n = n.bypass(e.removeStack());
    } else
      o.nodes = [];
    return e.lightsNode = t, n;
  }
  /**
   * Configures this node with an array of lights.
   *
   * @param {Array<Light>} lights - An array of lights.
   * @return {LightsNode} A reference to this node.
   */
  setLights(e) {
    return this._lights = e, this._lightNodes = null, this._lightNodesHash = null, this;
  }
  /**
   * Returns an array of the scene's lights.
   *
   * @return {Array<Light>} The scene's lights.
   */
  getLights() {
    return this._lights;
  }
  /**
   * Whether the scene has lights or not.
   *
   * @type {boolean}
   */
  get hasLights() {
    return this._lights.length > 0;
  }
}
const cre = (i = []) => new nw().setLights(i);
class hre extends St {
  static get type() {
    return "ShadowBaseNode";
  }
  /**
   * Constructs a new shadow base node.
   *
   * @param {Light} light - The shadow casting light.
   */
  constructor(e) {
    super(), this.light = e, this.updateBeforeType = hn.RENDER, this.isShadowBaseNode = !0;
  }
  /**
   * Setups the shadow position node which is by default the predefined TSL node object `shadowPositionWorld`.
   *
   * @param {NodeBuilder} object - A configuration object that must at least hold a material reference.
   */
  setupShadowPosition({ context: e, material: t }) {
    iw.assign(t.receivedShadowPositionNode || e.shadowPositionWorld || tl);
  }
}
const iw = /* @__PURE__ */ Bl("vec3", "shadowPositionWorld");
function dre(i, e = {}) {
  return e.toneMapping = i.toneMapping, e.toneMappingExposure = i.toneMappingExposure, e.outputColorSpace = i.outputColorSpace, e.renderTarget = i.getRenderTarget(), e.activeCubeFace = i.getActiveCubeFace(), e.activeMipmapLevel = i.getActiveMipmapLevel(), e.renderObjectFunction = i.getRenderObjectFunction(), e.pixelRatio = i.getPixelRatio(), e.mrt = i.getMRT(), e.clearColor = i.getClearColor(e.clearColor || new ct()), e.clearAlpha = i.getClearAlpha(), e.autoClear = i.autoClear, e.scissorTest = i.getScissorTest(), e;
}
function fre(i, e) {
  return e = dre(i, e), i.setMRT(null), i.setRenderObjectFunction(null), i.setClearColor(0, 1), i.autoClear = !0, e;
}
function Are(i, e) {
  i.toneMapping = e.toneMapping, i.toneMappingExposure = e.toneMappingExposure, i.outputColorSpace = e.outputColorSpace, i.setRenderTarget(e.renderTarget, e.activeCubeFace, e.activeMipmapLevel), i.setRenderObjectFunction(e.renderObjectFunction), i.setPixelRatio(e.pixelRatio), i.setMRT(e.mrt), i.setClearColor(e.clearColor, e.clearAlpha), i.autoClear = e.autoClear, i.setScissorTest(e.scissorTest);
}
function pre(i, e = {}) {
  return e.background = i.background, e.backgroundNode = i.backgroundNode, e.overrideMaterial = i.overrideMaterial, e;
}
function mre(i, e) {
  return e = pre(i, e), i.background = null, i.backgroundNode = null, i.overrideMaterial = null, e;
}
function gre(i, e) {
  i.background = e.background, i.backgroundNode = e.backgroundNode, i.overrideMaterial = e.overrideMaterial;
}
function _re(i, e, t) {
  return t = fre(i, t), t = mre(e, t), t;
}
function xre(i, e, t) {
  Are(i, t), gre(e, t);
}
const p_ = /* @__PURE__ */ new WeakMap(), JL = /* @__PURE__ */ pe(({ depthTexture: i, shadowCoord: e, depthLayer: t }) => {
  let n = Wn(i, e.xy).setName("t_basic");
  return i.isArrayTexture && (n = n.depth(t)), n.compare(e.z);
}), eI = /* @__PURE__ */ pe(({ depthTexture: i, shadowCoord: e, shadow: t, depthLayer: n }) => {
  const r = (c, A) => {
    let m = Wn(i, c);
    return i.isArrayTexture && (m = m.depth(n)), m.compare(A);
  }, s = ui("mapSize", "vec2", t).setGroup(Lt), o = ui("radius", "float", t).setGroup(Lt), a = Xe(1).div(s), l = o.mul(a.x), u = XT(ad.xy).mul(6.28318530718);
  return sr(
    r(e.xy.add(fa(0, 5, u).mul(l)), e.z),
    r(e.xy.add(fa(1, 5, u).mul(l)), e.z),
    r(e.xy.add(fa(2, 5, u).mul(l)), e.z),
    r(e.xy.add(fa(3, 5, u).mul(l)), e.z),
    r(e.xy.add(fa(4, 5, u).mul(l)), e.z)
  ).mul(1 / 5);
}), tI = /* @__PURE__ */ pe(({ depthTexture: i, shadowCoord: e, shadow: t, depthLayer: n }) => {
  const r = (A, m) => {
    let _ = Wn(i, A);
    return i.isArrayTexture && (_ = _.depth(n)), _.compare(m);
  }, s = ui("mapSize", "vec2", t).setGroup(Lt), o = Xe(1).div(s), a = o.x, l = o.y, u = e.xy, c = ba(u.mul(s).add(0.5));
  return u.subAssign(c.mul(o)), sr(
    r(u, e.z),
    r(u.add(Xe(a, 0)), e.z),
    r(u.add(Xe(0, l)), e.z),
    r(u.add(o), e.z),
    Bn(
      r(u.add(Xe(a.negate(), 0)), e.z),
      r(u.add(Xe(a.mul(2), 0)), e.z),
      c.x
    ),
    Bn(
      r(u.add(Xe(a.negate(), l)), e.z),
      r(u.add(Xe(a.mul(2), l)), e.z),
      c.x
    ),
    Bn(
      r(u.add(Xe(0, l.negate())), e.z),
      r(u.add(Xe(0, l.mul(2))), e.z),
      c.y
    ),
    Bn(
      r(u.add(Xe(a, l.negate())), e.z),
      r(u.add(Xe(a, l.mul(2))), e.z),
      c.y
    ),
    Bn(
      Bn(
        r(u.add(Xe(a.negate(), l.negate())), e.z),
        r(u.add(Xe(a.mul(2), l.negate())), e.z),
        c.x
      ),
      Bn(
        r(u.add(Xe(a.negate(), l.mul(2))), e.z),
        r(u.add(Xe(a.mul(2), l.mul(2))), e.z),
        c.x
      ),
      c.y
    )
  ).mul(1 / 9);
}), nI = /* @__PURE__ */ pe(({ depthTexture: i, shadowCoord: e, depthLayer: t }) => {
  let n = Wn(i).sample(e.xy);
  i.isArrayTexture && (n = n.depth(t)), n = n.rg;
  const r = n.x, s = qi(1e-7, n.y.mul(n.y)), o = F2(e.z, r);
  Ot(o.equal(1), () => J(1));
  const a = e.z.sub(r);
  let l = s.div(s.add(a.mul(a)));
  return l = Sa(Un(l, 0.3).div(0.65)), qi(o, l);
}), yre = /* @__PURE__ */ pe(([i, e, t]) => {
  let n = tl.sub(i).length();
  return n = n.sub(e).div(t.sub(e)), n = n.saturate(), n;
}), vre = (i) => {
  const e = i.shadow.camera, t = ui("near", "float", e).setGroup(Lt), n = ui("far", "float", e).setGroup(Lt), r = O6(i);
  return yre(r, t, n);
}, iI = (i) => {
  let e = p_.get(i);
  if (e === void 0) {
    const t = i.isPointLight ? vre(i) : null;
    e = new Yi(), e.colorNode = Gt(0, 0, 0, 1), e.depthNode = t, e.isShadowPassMaterial = !0, e.name = "ShadowMaterial", e.fog = !1, p_.set(i, e);
  }
  return e;
}, rI = (i) => {
  const e = p_.get(i);
  e !== void 0 && (e.dispose(), p_.delete(i));
}, sC = /* @__PURE__ */ new wa(), Kd = [], sI = (i, e, t, n) => {
  Kd[0] = i, Kd[1] = e;
  let r = sC.get(Kd);
  return (r === void 0 || r.shadowType !== t || r.useVelocity !== n) && (r = (s, o, a, l, u, c, ...A) => {
    (s.castShadow === !0 || s.receiveShadow && t === $a) && (n && (ZP(s).useVelocity = !0), s.onBeforeShadow(i, s, a, e.camera, l, o.overrideMaterial, c), i.renderObject(s, o, a, l, u, c, ...A), s.onAfterShadow(i, s, a, e.camera, l, o.overrideMaterial, c));
  }, r.shadowType = t, r.useVelocity = n, sC.set(Kd, r)), Kd[0] = null, Kd[1] = null, r;
}, bre = /* @__PURE__ */ pe(({ samples: i, radius: e, size: t, shadowPass: n, depthLayer: r }) => {
  const s = J(0).toVar("meanVertical"), o = J(0).toVar("squareMeanVertical"), a = i.lessThanEqual(J(1)).select(J(0), J(2).div(i.sub(1))), l = i.lessThanEqual(J(1)).select(J(0), J(-1));
  ri({ start: le(0), end: le(i), type: "int", condition: "<" }, ({ i: c }) => {
    const A = l.add(J(c).mul(a));
    let m = n.sample(sr(ad.xy, Xe(0, A).mul(e)).div(t));
    n.value.isArrayTexture && (m = m.depth(r)), m = m.x, s.addAssign(m), o.addAssign(m.mul(m));
  }), s.divAssign(i), o.divAssign(i);
  const u = ps(o.sub(s.mul(s)).max(0));
  return Xe(s, u);
}), Sre = /* @__PURE__ */ pe(({ samples: i, radius: e, size: t, shadowPass: n, depthLayer: r }) => {
  const s = J(0).toVar("meanHorizontal"), o = J(0).toVar("squareMeanHorizontal"), a = i.lessThanEqual(J(1)).select(J(0), J(2).div(i.sub(1))), l = i.lessThanEqual(J(1)).select(J(0), J(-1));
  ri({ start: le(0), end: le(i), type: "int", condition: "<" }, ({ i: c }) => {
    const A = l.add(J(c).mul(a));
    let m = n.sample(sr(ad.xy, Xe(A, 0).mul(e)).div(t));
    n.value.isArrayTexture && (m = m.depth(r)), s.addAssign(m.x), o.addAssign(sr(m.y.mul(m.y), m.x.mul(m.x)));
  }), s.divAssign(i), o.divAssign(i);
  const u = ps(o.sub(s.mul(s)).max(0));
  return Xe(s, u);
}), Tre = [JL, eI, tI, nI];
let av;
const bg = /* @__PURE__ */ new Q2();
class oI extends hre {
  static get type() {
    return "ShadowNode";
  }
  /**
   * Constructs a new shadow node.
   *
   * @param {Light} light - The shadow casting light.
   * @param {?LightShadow} [shadow=null] - An optional light shadow.
   */
  constructor(e, t = null) {
    super(e), this.shadow = t || e.shadow, this.shadowMap = null, this.vsmShadowMapVertical = null, this.vsmShadowMapHorizontal = null, this.vsmMaterialVertical = null, this.vsmMaterialHorizontal = null, this._node = null, this._currentShadowType = null, this._cameraFrameId = /* @__PURE__ */ new WeakMap(), this.isShadowNode = !0, this.depthLayer = 0;
  }
  /**
   * Setups the shadow filtering.
   *
   * @param {NodeBuilder} builder - A reference to the current node builder.
   * @param {Object} inputs - A configuration object that defines the shadow filtering.
   * @param {Function} inputs.filterFn - This function defines the filtering type of the shadow map e.g. PCF.
   * @param {DepthTexture} inputs.depthTexture - A reference to the shadow map's texture data.
   * @param {Node<vec3>} inputs.shadowCoord - Shadow coordinates which are used to sample from the shadow map.
   * @param {LightShadow} inputs.shadow - The light shadow.
   * @return {Node<float>} The result node of the shadow filtering.
   */
  setupShadowFilter(e, { filterFn: t, depthTexture: n, shadowCoord: r, shadow: s, depthLayer: o }) {
    const a = r.x.greaterThanEqual(0).and(r.x.lessThanEqual(1)).and(r.y.greaterThanEqual(0)).and(r.y.lessThanEqual(1)).and(r.z.lessThanEqual(1)), l = t({ depthTexture: n, shadowCoord: r, shadow: s, depthLayer: o });
    return a.select(l, J(1));
  }
  /**
   * Setups the shadow coordinates.
   *
   * @param {NodeBuilder} builder - A reference to the current node builder.
   * @param {Node<vec3>} shadowPosition - A node representing the shadow position.
   * @return {Node<vec3>} The shadow coordinates.
   */
  setupShadowCoord(e, t) {
    const { shadow: n } = this, { renderer: r } = e, s = ui("bias", "float", n).setGroup(Lt);
    let o = t, a;
    if (n.camera.isOrthographicCamera || r.logarithmicDepthBuffer !== !0)
      o = o.xyz.div(o.w), a = o.z, r.coordinateSystem === io && (a = a.mul(2).sub(1));
    else {
      const l = o.w;
      o = o.xy.div(l);
      const u = ui("near", "float", n.camera).setGroup(Lt), c = ui("far", "float", n.camera).setGroup(Lt);
      a = FT(l.negate(), u, c);
    }
    return o = ce(
      o.x,
      o.y.oneMinus(),
      // follow webgpu standards
      a.add(s)
    ), o;
  }
  /**
   * Returns the shadow filtering function for the given shadow type.
   *
   * @param {number} type - The shadow type.
   * @return {Function} The filtering function.
   */
  getShadowFilterFn(e) {
    return Tre[e];
  }
  setupRenderTarget(e, t) {
    const n = new Qr(e.mapSize.width, e.mapSize.height);
    n.name = "ShadowDepthTexture", n.compareFunction = iA;
    const r = t.createRenderTarget(e.mapSize.width, e.mapSize.height);
    return r.texture.name = "ShadowMap", r.texture.type = e.mapType, r.depthTexture = n, { shadowMap: r, depthTexture: n };
  }
  /**
   * Setups the shadow output node.
   *
   * @param {NodeBuilder} builder - A reference to the current node builder.
   * @return {Node<vec3>} The shadow output node.
   */
  setupShadow(e) {
    const { renderer: t, camera: n } = e, { light: r, shadow: s } = this, o = t.shadowMap.type, { depthTexture: a, shadowMap: l } = this.setupRenderTarget(s, e);
    if (s.camera.coordinateSystem = n.coordinateSystem, s.camera.updateProjectionMatrix(), o === $a && s.isPointLightShadow !== !0) {
      a.compareFunction = null, l.depth > 1 ? (l._vsmShadowMapVertical || (l._vsmShadowMapVertical = e.createRenderTarget(s.mapSize.width, s.mapSize.height, { format: fs, type: Ri, depth: l.depth, depthBuffer: !1 }), l._vsmShadowMapVertical.texture.name = "VSMVertical"), this.vsmShadowMapVertical = l._vsmShadowMapVertical, l._vsmShadowMapHorizontal || (l._vsmShadowMapHorizontal = e.createRenderTarget(s.mapSize.width, s.mapSize.height, { format: fs, type: Ri, depth: l.depth, depthBuffer: !1 }), l._vsmShadowMapHorizontal.texture.name = "VSMHorizontal"), this.vsmShadowMapHorizontal = l._vsmShadowMapHorizontal) : (this.vsmShadowMapVertical = e.createRenderTarget(s.mapSize.width, s.mapSize.height, { format: fs, type: Ri, depthBuffer: !1 }), this.vsmShadowMapHorizontal = e.createRenderTarget(s.mapSize.width, s.mapSize.height, { format: fs, type: Ri, depthBuffer: !1 }));
      let R = Wn(a);
      a.isArrayTexture && (R = R.depth(this.depthLayer));
      let C = Wn(this.vsmShadowMapVertical.texture);
      a.isArrayTexture && (C = C.depth(this.depthLayer));
      const L = ui("blurSamples", "float", s).setGroup(Lt), D = ui("radius", "float", s).setGroup(Lt), B = ui("mapSize", "vec2", s).setGroup(Lt);
      let U = this.vsmMaterialVertical || (this.vsmMaterialVertical = new Yi());
      U.fragmentNode = bre({ samples: L, radius: D, size: B, shadowPass: R, depthLayer: this.depthLayer }).context(e.getSharedContext()), U.name = "VSMVertical", U = this.vsmMaterialHorizontal || (this.vsmMaterialHorizontal = new Yi()), U.fragmentNode = Sre({ samples: L, radius: D, size: B, shadowPass: C, depthLayer: this.depthLayer }).context(e.getSharedContext()), U.name = "VSMHorizontal";
    }
    const u = ui("intensity", "float", s).setGroup(Lt), c = ui("normalBias", "float", s).setGroup(Lt), A = tx(r).mul(iw.add(oc.mul(c))), m = this.setupShadowCoord(e, A), _ = s.filterNode || this.getShadowFilterFn(t.shadowMap.type) || null;
    if (_ === null)
      throw new Error("THREE.WebGPURenderer: Shadow map type not supported yet.");
    const y = o === $a && s.isPointLightShadow !== !0 ? this.vsmShadowMapHorizontal.texture : a, T = this.setupShadowFilter(e, { filterFn: _, shadowTexture: l.texture, depthTexture: y, shadowCoord: m, shadow: s, depthLayer: this.depthLayer });
    let b;
    l.texture.isCubeTexture ? b = Is(l.texture, m.xyz) : (b = Wn(l.texture, m), a.isArrayTexture && (b = b.depth(this.depthLayer)));
    const S = Bn(1, T.rgb.mix(b, 1), u.mul(b.a)).toVar();
    this.shadowMap = l, this.shadow.map = l;
    const E = `${this.light.type} Shadow [ ${this.light.name || "ID: " + this.light.id} ]`;
    return S.toInspector(`${E} / Color`, () => this.shadowMap.texture.isCubeTexture ? Is(this.shadowMap.texture) : Wn(this.shadowMap.texture)).toInspector(`${E} / Depth`, () => this.shadowMap.texture.isCubeTexture ? Is(this.shadowMap.texture).r.oneMinus() : $i(this.shadowMap.depthTexture, hi().mul(Fl(Wn(this.shadowMap.depthTexture)))).r.oneMinus());
  }
  /**
   * The implementation performs the setup of the output node. An output is only
   * produces if shadow mapping is globally enabled in the renderer.
   *
   * @param {NodeBuilder} builder - A reference to the current node builder.
   * @return {ShaderCallNodeInternal} The output node.
   */
  setup(e) {
    if (e.renderer.shadowMap.enabled !== !1)
      return pe(() => {
        const t = e.renderer.shadowMap.type;
        this._currentShadowType !== t && (this._reset(), this._node = null);
        let n = this._node;
        return this.setupShadowPosition(e), n === null && (this._node = n = this.setupShadow(e), this._currentShadowType = t), e.material.shadowNode && Me('NodeMaterial: ".shadowNode" is deprecated. Use ".castShadowNode" instead.'), e.material.receivedShadowNode && (n = e.material.receivedShadowNode(n)), n;
      })();
  }
  /**
   * Renders the shadow. The logic of this function could be included
   * into {@link ShadowNode#updateShadow} however more specialized shadow
   * nodes might require a custom shadow map rendering. By having a
   * dedicated method, it's easier to overwrite the default behavior.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  renderShadow(e) {
    const { shadow: t, shadowMap: n, light: r } = this, { renderer: s, scene: o } = e;
    t.updateMatrices(r), n.setSize(t.mapSize.width, t.mapSize.height, n.depth);
    const a = o.name;
    o.name = `Shadow Map [ ${r.name || "ID: " + r.id} ]`, s.render(o, t.camera), o.name = a;
  }
  /**
   * Updates the shadow.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  updateShadow(e) {
    const { shadowMap: t, light: n, shadow: r } = this, { renderer: s, scene: o, camera: a } = e, l = s.shadowMap.type, u = t.depthTexture.version;
    this._depthVersionCached = u;
    const c = r.camera.layers.mask;
    (r.camera.layers.mask & 4294967294) === 0 && (r.camera.layers.mask = a.layers.mask);
    const A = s.getRenderObjectFunction(), m = s.getMRT(), _ = m ? m.has("velocity") : !1;
    av = _re(s, o, av), o.overrideMaterial = iI(n), s.setRenderObjectFunction(sI(s, r, l, _)), s.setClearColor(0, 0), s.setRenderTarget(t), this.renderShadow(e), s.setRenderObjectFunction(A), l === $a && r.isPointLightShadow !== !0 && this.vsmPass(s), r.camera.layers.mask = c, xre(s, o, av);
  }
  /**
   * For VSM additional render passes are required.
   *
   * @param {Renderer} renderer - A reference to the current renderer.
   */
  vsmPass(e) {
    const { shadow: t } = this, n = this.shadowMap.depth;
    this.vsmShadowMapVertical.setSize(t.mapSize.width, t.mapSize.height, n), this.vsmShadowMapHorizontal.setSize(t.mapSize.width, t.mapSize.height, n), e.setRenderTarget(this.vsmShadowMapVertical), bg.material = this.vsmMaterialVertical, bg.render(e), e.setRenderTarget(this.vsmShadowMapHorizontal), bg.material = this.vsmMaterialHorizontal, bg.render(e);
  }
  /**
   * Frees the internal resources of this shadow node.
   */
  dispose() {
    this._reset(), super.dispose();
  }
  /**
   * Resets the resouce state of this shadow node.
   *
   * @private
   */
  _reset() {
    this._currentShadowType = null, rI(this.light), this.shadowMap && (this.shadowMap.dispose(), this.shadowMap = null), this.vsmShadowMapVertical !== null && (this.vsmShadowMapVertical.dispose(), this.vsmShadowMapVertical = null, this.vsmMaterialVertical.dispose(), this.vsmMaterialVertical = null), this.vsmShadowMapHorizontal !== null && (this.vsmShadowMapHorizontal.dispose(), this.vsmShadowMapHorizontal = null, this.vsmMaterialHorizontal.dispose(), this.vsmMaterialHorizontal = null);
  }
  /**
   * The implementation performs the update of the shadow map if necessary.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  updateBefore(e) {
    const { shadow: t } = this;
    let n = t.needsUpdate || t.autoUpdate;
    n && (this._cameraFrameId[e.camera] === e.frameId && (n = !1), this._cameraFrameId[e.camera] = e.frameId), n && (this.updateShadow(e), this.shadowMap.depthTexture.version === this._depthVersionCached && (t.needsUpdate = !1));
  }
}
const aI = (i, e) => new oI(i, e), wre = /* @__PURE__ */ new ct(), oC = /* @__PURE__ */ new Mt(), JA = /* @__PURE__ */ new j(), lv = /* @__PURE__ */ new j(), Mre = [
  /* @__PURE__ */ new j(1, 0, 0),
  /* @__PURE__ */ new j(-1, 0, 0),
  /* @__PURE__ */ new j(0, -1, 0),
  /* @__PURE__ */ new j(0, 1, 0),
  /* @__PURE__ */ new j(0, 0, 1),
  /* @__PURE__ */ new j(0, 0, -1)
], Ere = [
  /* @__PURE__ */ new j(0, -1, 0),
  /* @__PURE__ */ new j(0, -1, 0),
  /* @__PURE__ */ new j(0, 0, -1),
  /* @__PURE__ */ new j(0, 0, 1),
  /* @__PURE__ */ new j(0, -1, 0),
  /* @__PURE__ */ new j(0, -1, 0)
], Rre = [
  /* @__PURE__ */ new j(1, 0, 0),
  /* @__PURE__ */ new j(-1, 0, 0),
  /* @__PURE__ */ new j(0, 1, 0),
  /* @__PURE__ */ new j(0, -1, 0),
  /* @__PURE__ */ new j(0, 0, 1),
  /* @__PURE__ */ new j(0, 0, -1)
], Cre = [
  /* @__PURE__ */ new j(0, -1, 0),
  /* @__PURE__ */ new j(0, -1, 0),
  /* @__PURE__ */ new j(0, 0, 1),
  /* @__PURE__ */ new j(0, 0, -1),
  /* @__PURE__ */ new j(0, -1, 0),
  /* @__PURE__ */ new j(0, -1, 0)
], lI = /* @__PURE__ */ pe(({ depthTexture: i, bd3D: e, dp: t }) => Is(i, e).compare(t)), uI = /* @__PURE__ */ pe(({ depthTexture: i, bd3D: e, dp: t, shadow: n }) => {
  const r = ui("radius", "float", n).setGroup(Lt), s = ui("mapSize", "vec2", n).setGroup(Lt), o = r.div(s.x), a = vi(e), l = Fs(Kl(e, a.x.greaterThan(a.z).select(ce(0, 1, 0), ce(1, 0, 0)))), u = Kl(e, l), c = XT(ad.xy).mul(6.28318530718), A = fa(0, 5, c), m = fa(1, 5, c), _ = fa(2, 5, c), y = fa(3, 5, c), T = fa(4, 5, c);
  return Is(i, e.add(l.mul(A.x).add(u.mul(A.y)).mul(o))).compare(t).add(Is(i, e.add(l.mul(m.x).add(u.mul(m.y)).mul(o))).compare(t)).add(Is(i, e.add(l.mul(_.x).add(u.mul(_.y)).mul(o))).compare(t)).add(Is(i, e.add(l.mul(y.x).add(u.mul(y.y)).mul(o))).compare(t)).add(Is(i, e.add(l.mul(T.x).add(u.mul(T.y)).mul(o))).compare(t)).mul(1 / 5);
}), Pre = /* @__PURE__ */ pe(({ filterFn: i, depthTexture: e, shadowCoord: t, shadow: n }) => {
  const r = t.xyz.toVar(), s = r.length(), o = It("float").setGroup(Lt).onRenderUpdate(() => n.camera.near), a = It("float").setGroup(Lt).onRenderUpdate(() => n.camera.far), l = ui("bias", "float", n).setGroup(Lt), u = J(1).toVar();
  return Ot(s.sub(a).lessThanEqual(0).and(s.sub(o).greaterThanEqual(0)), () => {
    const c = s.sub(o).div(a.sub(o)).toVar();
    c.addAssign(l);
    const A = r.normalize();
    u.assign(i({ depthTexture: e, bd3D: A, dp: c, shadow: n }));
  }), u;
});
class Nre extends oI {
  static get type() {
    return "PointShadowNode";
  }
  /**
   * Constructs a new point shadow node.
   *
   * @param {PointLight} light - The shadow casting point light.
   * @param {?PointLightShadow} [shadow=null] - An optional point light shadow.
   */
  constructor(e, t = null) {
    super(e, t);
  }
  /**
   * Overwrites the default implementation to return point light shadow specific
   * filtering functions.
   *
   * @param {number} type - The shadow type.
   * @return {Function} The filtering function.
   */
  getShadowFilterFn(e) {
    return e === A5 ? lI : uI;
  }
  /**
   * Overwrites the default implementation so the unaltered shadow position is used.
   *
   * @param {NodeBuilder} builder - A reference to the current node builder.
   * @param {Node<vec3>} shadowPosition - A node representing the shadow position.
   * @return {Node<vec3>} The shadow coordinates.
   */
  setupShadowCoord(e, t) {
    return t;
  }
  /**
   * Overwrites the default implementation to only use point light specific
   * shadow filter functions.
   *
   * @param {NodeBuilder} builder - A reference to the current node builder.
   * @param {Object} inputs - A configuration object that defines the shadow filtering.
   * @param {Function} inputs.filterFn - This function defines the filtering type of the shadow map e.g. PCF.
   * @param {DepthTexture} inputs.depthTexture - A reference to the shadow map's depth texture.
   * @param {Node<vec3>} inputs.shadowCoord - Shadow coordinates which are used to sample from the shadow map.
   * @param {LightShadow} inputs.shadow - The light shadow.
   * @return {Node<float>} The result node of the shadow filtering.
   */
  setupShadowFilter(e, { filterFn: t, depthTexture: n, shadowCoord: r, shadow: s }) {
    return Pre({ filterFn: t, depthTexture: n, shadowCoord: r, shadow: s });
  }
  /**
   * Overwrites the default implementation to create a CubeRenderTarget with CubeDepthTexture.
   *
   * @param {LightShadow} shadow - The light shadow object.
   * @param {NodeBuilder} builder - A reference to the current node builder.
   * @return {Object} An object containing the shadow map and depth texture.
   */
  setupRenderTarget(e, t) {
    const n = new B3(e.mapSize.width);
    n.name = "PointShadowDepthTexture", n.compareFunction = iA;
    const r = t.createCubeRenderTarget(e.mapSize.width);
    return r.texture.name = "PointShadowMap", r.depthTexture = n, { shadowMap: r, depthTexture: n };
  }
  /**
   * Overwrites the default implementation with point light specific
   * rendering code.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  renderShadow(e) {
    const { shadow: t, shadowMap: n, light: r } = this, { renderer: s, scene: o } = e, a = t.camera, l = t.matrix, u = s.coordinateSystem === io, c = u ? Mre : Rre, A = u ? Ere : Cre;
    n.setSize(t.mapSize.width, t.mapSize.width);
    const m = s.autoClear, _ = s.getClearColor(wre), y = s.getClearAlpha();
    s.autoClear = !1, s.setClearColor(t.clearColor, t.clearAlpha);
    for (let T = 0; T < 6; T++) {
      s.setRenderTarget(n, T), s.clear();
      const b = r.distance || a.far;
      b !== a.far && (a.far = b, a.updateProjectionMatrix()), JA.setFromMatrixPosition(r.matrixWorld), a.position.copy(JA), lv.copy(a.position), lv.add(c[T]), a.up.copy(A[T]), a.lookAt(lv), a.updateMatrixWorld(), l.makeTranslation(-JA.x, -JA.y, -JA.z), oC.multiplyMatrices(a.projectionMatrix, a.matrixWorldInverse), t._frustum.setFromProjectionMatrix(oC, a.coordinateSystem, a.reversedDepth);
      const S = o.name;
      o.name = `Point Light Shadow [ ${r.name || "ID: " + r.id} ] - Face ${T + 1}`, s.render(o, a), o.name = S;
    }
    s.autoClear = m, s.setClearColor(_, y);
  }
}
const cI = (i, e) => new Nre(i, e);
class ld extends dA {
  static get type() {
    return "AnalyticLightNode";
  }
  /**
   * Constructs a new analytic light node.
   *
   * @param {?Light} [light=null] - The light source.
   */
  constructor(e = null) {
    super(), this.light = e, this.color = new ct(), this.colorNode = e && e.colorNode || It(this.color).setGroup(Lt), this.baseColorNode = null, this.shadowNode = null, this.shadowColorNode = null, this.isAnalyticLightNode = !0, this.updateType = hn.FRAME, e && e.shadow && (this._shadowDisposeListener = () => {
      this.disposeShadow();
    }, e.addEventListener("dispose", this._shadowDisposeListener));
  }
  dispose() {
    this._shadowDisposeListener && this.light.removeEventListener("dispose", this._shadowDisposeListener), super.dispose();
  }
  /**
   * Frees internal resources related to shadows.
   */
  disposeShadow() {
    this.shadowNode !== null && (this.shadowNode.dispose(), this.shadowNode = null), this.shadowColorNode = null, this.baseColorNode !== null && (this.colorNode = this.baseColorNode, this.baseColorNode = null);
  }
  getHash() {
    return this.light.uuid;
  }
  /**
   * Returns a node representing a direction vector which points from the current
   * position in view space to the light's position in view space.
   *
   * @param {NodeBuilder} builder - The builder object used for setting up the light.
   * @return {Node<vec3>} The light vector node.
   */
  getLightVector(e) {
    return ew(this.light).sub(e.context.positionView || tr);
  }
  /**
   * Sets up the direct lighting for the analytic light node.
   *
   * @abstract
   * @param {NodeBuilder} builder - The builder object used for setting up the light.
   * @return {Object|undefined} The direct light data (color and direction).
   */
  setupDirect() {
  }
  /**
   * Sets up the direct rect area lighting for the analytic light node.
   *
   * @abstract
   * @param {NodeBuilder} builder - The builder object used for setting up the light.
   * @return {Object|undefined} The direct rect area light data.
   */
  setupDirectRectArea() {
  }
  /**
   * Setups the shadow node for this light. The method exists so concrete light classes
   * can setup different types of shadow nodes.
   *
   * @return {ShadowNode} The created shadow node.
   */
  setupShadowNode() {
    return aI(this.light);
  }
  /**
   * Setups the shadow for this light. This method is only executed if the light
   * cast shadows and the current build object receives shadows. It incorporates
   * shadows into the lighting computation.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  setupShadow(e) {
    const { renderer: t } = e;
    if (t.shadowMap.enabled === !1) return;
    let n = this.shadowColorNode;
    if (n === null) {
      const r = this.light.shadow.shadowNode;
      let s;
      r !== void 0 ? s = ut(r) : s = this.setupShadowNode(), this.shadowNode = s, this.shadowColorNode = n = this.colorNode.mul(s), this.baseColorNode = this.colorNode;
    }
    e.context.getShadow && (n = e.context.getShadow(this, e)), this.colorNode = n;
  }
  /**
   * Unlike most other nodes, lighting nodes do not return a output node in {@link Node#setup}.
   * The main purpose of lighting nodes is to configure the current {@link LightingModel} and/or
   * invocate the respective interface methods.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  setup(e) {
    this.colorNode = this.baseColorNode || this.colorNode, this.light.castShadow ? e.object.receiveShadow && this.setupShadow(e) : this.shadowNode !== null && (this.shadowNode.dispose(), this.shadowNode = null, this.shadowColorNode = null);
    const t = this.setupDirect(e), n = this.setupDirectRectArea(e);
    t && e.lightsNode.setupDirectLight(e, this, t), n && e.lightsNode.setupDirectRectAreaLight(e, this, n);
  }
  /**
   * The update method is used to update light uniforms per frame.
   * Potentially overwritten in concrete light nodes to update light
   * specific uniforms.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  update() {
    const { light: e } = this;
    this.color.copy(e.color).multiplyScalar(e.intensity);
  }
}
const rw = /* @__PURE__ */ pe(({ lightDistance: i, cutoffDistance: e, decayExponent: t }) => {
  const n = i.pow(t).max(0.01).reciprocal();
  return e.greaterThan(0).select(
    n.mul(i.div(e).pow4().oneMinus().clamp().pow2()),
    n
  );
}), hI = ({ color: i, lightVector: e, cutoffDistance: t, decayExponent: n }) => {
  const r = e.normalize(), s = e.length(), o = rw({
    lightDistance: s,
    cutoffDistance: t,
    decayExponent: n
  }), a = i.mul(o);
  return { lightDirection: r, lightColor: a };
};
class Dre extends ld {
  static get type() {
    return "PointLightNode";
  }
  /**
   * Constructs a new point light node.
   *
   * @param {?PointLight} [light=null] - The point light source.
   */
  constructor(e = null) {
    super(e), this.cutoffDistanceNode = It(0).setGroup(Lt), this.decayExponentNode = It(2).setGroup(Lt);
  }
  /**
   * Overwritten to updated point light specific uniforms.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  update(e) {
    const { light: t } = this;
    super.update(e), this.cutoffDistanceNode.value = t.distance, this.decayExponentNode.value = t.decay;
  }
  /**
   * Overwritten to setup point light specific shadow.
   *
   * @return {PointShadowNode}
   */
  setupShadowNode() {
    return cI(this.light);
  }
  setupDirect(e) {
    return hI({
      color: this.colorNode,
      lightVector: this.getLightVector(e),
      cutoffDistance: this.cutoffDistanceNode,
      decayExponent: this.decayExponentNode
    });
  }
}
const Lre = /* @__PURE__ */ pe(([i = hi()]) => {
  const e = i.mul(2), t = e.x.floor(), n = e.y.floor();
  return t.add(n).mod(2).sign();
}), Ire = pe(([i = hi()], { renderer: e, material: t }) => {
  const n = hT(i.mul(2).sub(1));
  let r;
  if (t.alphaToCoverage && e.currentSamples > 0) {
    const s = J(n.fwidth()).toVar();
    r = Ta(s.oneMinus(), s.add(1), n).oneMinus();
  } else
    r = Yr(n.greaterThan(1), 0, 1);
  return r;
}), Ip = /* @__PURE__ */ pe(([i, e, t]) => {
  const n = J(t).toVar(), r = J(e).toVar(), s = Wo(i).toVar();
  return Yr(s, r, n);
}).setLayout({
  name: "mx_select",
  type: "float",
  inputs: [
    { name: "b", type: "bool" },
    { name: "t", type: "float" },
    { name: "f", type: "float" }
  ]
}), m_ = /* @__PURE__ */ pe(([i, e]) => {
  const t = Wo(e).toVar(), n = J(i).toVar();
  return Yr(t, n.negate(), n);
}).setLayout({
  name: "mx_negate_if",
  type: "float",
  inputs: [
    { name: "val", type: "float" },
    { name: "b", type: "bool" }
  ]
}), rr = /* @__PURE__ */ pe(([i]) => {
  const e = J(i).toVar();
  return le(Ja(e));
}).setLayout({
  name: "mx_floor",
  type: "int",
  inputs: [
    { name: "x", type: "float" }
  ]
}), Bi = /* @__PURE__ */ pe(([i, e]) => {
  const t = J(i).toVar();
  return e.assign(rr(t)), t.sub(J(e));
}), Bre = /* @__PURE__ */ pe(([i, e, t, n, r, s]) => {
  const o = J(s).toVar(), a = J(r).toVar(), l = J(n).toVar(), u = J(t).toVar(), c = J(e).toVar(), A = J(i).toVar(), m = J(Un(1, a)).toVar();
  return Un(1, o).mul(A.mul(m).add(c.mul(a))).add(o.mul(u.mul(m).add(l.mul(a))));
}).setLayout({
  name: "mx_bilerp_0",
  type: "float",
  inputs: [
    { name: "v0", type: "float" },
    { name: "v1", type: "float" },
    { name: "v2", type: "float" },
    { name: "v3", type: "float" },
    { name: "s", type: "float" },
    { name: "t", type: "float" }
  ]
}), Fre = /* @__PURE__ */ pe(([i, e, t, n, r, s]) => {
  const o = J(s).toVar(), a = J(r).toVar(), l = ce(n).toVar(), u = ce(t).toVar(), c = ce(e).toVar(), A = ce(i).toVar(), m = J(Un(1, a)).toVar();
  return Un(1, o).mul(A.mul(m).add(c.mul(a))).add(o.mul(u.mul(m).add(l.mul(a))));
}).setLayout({
  name: "mx_bilerp_1",
  type: "vec3",
  inputs: [
    { name: "v0", type: "vec3" },
    { name: "v1", type: "vec3" },
    { name: "v2", type: "vec3" },
    { name: "v3", type: "vec3" },
    { name: "s", type: "float" },
    { name: "t", type: "float" }
  ]
}), dI = /* @__PURE__ */ Jr([Bre, Fre]), Ure = /* @__PURE__ */ pe(([i, e, t, n, r, s, o, a, l, u, c]) => {
  const A = J(c).toVar(), m = J(u).toVar(), _ = J(l).toVar(), y = J(a).toVar(), T = J(o).toVar(), b = J(s).toVar(), S = J(r).toVar(), E = J(n).toVar(), R = J(t).toVar(), C = J(e).toVar(), L = J(i).toVar(), D = J(Un(1, _)).toVar(), B = J(Un(1, m)).toVar();
  return J(Un(1, A)).toVar().mul(B.mul(L.mul(D).add(C.mul(_))).add(m.mul(R.mul(D).add(E.mul(_))))).add(A.mul(B.mul(S.mul(D).add(b.mul(_))).add(m.mul(T.mul(D).add(y.mul(_))))));
}).setLayout({
  name: "mx_trilerp_0",
  type: "float",
  inputs: [
    { name: "v0", type: "float" },
    { name: "v1", type: "float" },
    { name: "v2", type: "float" },
    { name: "v3", type: "float" },
    { name: "v4", type: "float" },
    { name: "v5", type: "float" },
    { name: "v6", type: "float" },
    { name: "v7", type: "float" },
    { name: "s", type: "float" },
    { name: "t", type: "float" },
    { name: "r", type: "float" }
  ]
}), Ore = /* @__PURE__ */ pe(([i, e, t, n, r, s, o, a, l, u, c]) => {
  const A = J(c).toVar(), m = J(u).toVar(), _ = J(l).toVar(), y = ce(a).toVar(), T = ce(o).toVar(), b = ce(s).toVar(), S = ce(r).toVar(), E = ce(n).toVar(), R = ce(t).toVar(), C = ce(e).toVar(), L = ce(i).toVar(), D = J(Un(1, _)).toVar(), B = J(Un(1, m)).toVar();
  return J(Un(1, A)).toVar().mul(B.mul(L.mul(D).add(C.mul(_))).add(m.mul(R.mul(D).add(E.mul(_))))).add(A.mul(B.mul(S.mul(D).add(b.mul(_))).add(m.mul(T.mul(D).add(y.mul(_))))));
}).setLayout({
  name: "mx_trilerp_1",
  type: "vec3",
  inputs: [
    { name: "v0", type: "vec3" },
    { name: "v1", type: "vec3" },
    { name: "v2", type: "vec3" },
    { name: "v3", type: "vec3" },
    { name: "v4", type: "vec3" },
    { name: "v5", type: "vec3" },
    { name: "v6", type: "vec3" },
    { name: "v7", type: "vec3" },
    { name: "s", type: "float" },
    { name: "t", type: "float" },
    { name: "r", type: "float" }
  ]
}), fI = /* @__PURE__ */ Jr([Ure, Ore]), kre = /* @__PURE__ */ pe(([i, e, t]) => {
  const n = J(t).toVar(), r = J(e).toVar(), s = Ge(i).toVar(), o = Ge(s.bitAnd(Ge(7))).toVar(), a = J(Ip(o.lessThan(Ge(4)), r, n)).toVar(), l = J(sn(2, Ip(o.lessThan(Ge(4)), n, r))).toVar();
  return m_(a, Wo(o.bitAnd(Ge(1)))).add(m_(l, Wo(o.bitAnd(Ge(2)))));
}).setLayout({
  name: "mx_gradient_float_0",
  type: "float",
  inputs: [
    { name: "hash", type: "uint" },
    { name: "x", type: "float" },
    { name: "y", type: "float" }
  ]
}), Vre = /* @__PURE__ */ pe(([i, e, t, n]) => {
  const r = J(n).toVar(), s = J(t).toVar(), o = J(e).toVar(), a = Ge(i).toVar(), l = Ge(a.bitAnd(Ge(15))).toVar(), u = J(Ip(l.lessThan(Ge(8)), o, s)).toVar(), c = J(Ip(l.lessThan(Ge(4)), s, Ip(l.equal(Ge(12)).or(l.equal(Ge(14))), o, r))).toVar();
  return m_(u, Wo(l.bitAnd(Ge(1)))).add(m_(c, Wo(l.bitAnd(Ge(2)))));
}).setLayout({
  name: "mx_gradient_float_1",
  type: "float",
  inputs: [
    { name: "hash", type: "uint" },
    { name: "x", type: "float" },
    { name: "y", type: "float" },
    { name: "z", type: "float" }
  ]
}), Pr = /* @__PURE__ */ Jr([kre, Vre]), Gre = /* @__PURE__ */ pe(([i, e, t]) => {
  const n = J(t).toVar(), r = J(e).toVar(), s = od(i).toVar();
  return ce(Pr(s.x, r, n), Pr(s.y, r, n), Pr(s.z, r, n));
}).setLayout({
  name: "mx_gradient_vec3_0",
  type: "vec3",
  inputs: [
    { name: "hash", type: "uvec3" },
    { name: "x", type: "float" },
    { name: "y", type: "float" }
  ]
}), zre = /* @__PURE__ */ pe(([i, e, t, n]) => {
  const r = J(n).toVar(), s = J(t).toVar(), o = J(e).toVar(), a = od(i).toVar();
  return ce(Pr(a.x, o, s, r), Pr(a.y, o, s, r), Pr(a.z, o, s, r));
}).setLayout({
  name: "mx_gradient_vec3_1",
  type: "vec3",
  inputs: [
    { name: "hash", type: "uvec3" },
    { name: "x", type: "float" },
    { name: "y", type: "float" },
    { name: "z", type: "float" }
  ]
}), Fo = /* @__PURE__ */ Jr([Gre, zre]), qre = /* @__PURE__ */ pe(([i]) => {
  const e = J(i).toVar();
  return sn(0.6616, e);
}).setLayout({
  name: "mx_gradient_scale2d_0",
  type: "float",
  inputs: [
    { name: "v", type: "float" }
  ]
}), Hre = /* @__PURE__ */ pe(([i]) => {
  const e = J(i).toVar();
  return sn(0.982, e);
}).setLayout({
  name: "mx_gradient_scale3d_0",
  type: "float",
  inputs: [
    { name: "v", type: "float" }
  ]
}), Wre = /* @__PURE__ */ pe(([i]) => {
  const e = ce(i).toVar();
  return sn(0.6616, e);
}).setLayout({
  name: "mx_gradient_scale2d_1",
  type: "vec3",
  inputs: [
    { name: "v", type: "vec3" }
  ]
}), AI = /* @__PURE__ */ Jr([qre, Wre]), $re = /* @__PURE__ */ pe(([i]) => {
  const e = ce(i).toVar();
  return sn(0.982, e);
}).setLayout({
  name: "mx_gradient_scale3d_1",
  type: "vec3",
  inputs: [
    { name: "v", type: "vec3" }
  ]
}), pI = /* @__PURE__ */ Jr([Hre, $re]), vo = /* @__PURE__ */ pe(([i, e]) => {
  const t = le(e).toVar(), n = Ge(i).toVar();
  return n.shiftLeft(t).bitOr(n.shiftRight(le(32).sub(t)));
}).setLayout({
  name: "mx_rotl32",
  type: "uint",
  inputs: [
    { name: "x", type: "uint" },
    { name: "k", type: "int" }
  ]
}), mI = /* @__PURE__ */ pe(([i, e, t]) => {
  i.subAssign(t), i.bitXorAssign(vo(t, le(4))), t.addAssign(e), e.subAssign(i), e.bitXorAssign(vo(i, le(6))), i.addAssign(t), t.subAssign(e), t.bitXorAssign(vo(e, le(8))), e.addAssign(i), i.subAssign(t), i.bitXorAssign(vo(t, le(16))), t.addAssign(e), e.subAssign(i), e.bitXorAssign(vo(i, le(19))), i.addAssign(t), t.subAssign(e), t.bitXorAssign(vo(e, le(4))), e.addAssign(i);
}), W0 = /* @__PURE__ */ pe(([i, e, t]) => {
  const n = Ge(t).toVar(), r = Ge(e).toVar(), s = Ge(i).toVar();
  return n.bitXorAssign(r), n.subAssign(vo(r, le(14))), s.bitXorAssign(n), s.subAssign(vo(n, le(11))), r.bitXorAssign(s), r.subAssign(vo(s, le(25))), n.bitXorAssign(r), n.subAssign(vo(r, le(16))), s.bitXorAssign(n), s.subAssign(vo(n, le(4))), r.bitXorAssign(s), r.subAssign(vo(s, le(14))), n.bitXorAssign(r), n.subAssign(vo(r, le(24))), n;
}).setLayout({
  name: "mx_bjfinal",
  type: "uint",
  inputs: [
    { name: "a", type: "uint" },
    { name: "b", type: "uint" },
    { name: "c", type: "uint" }
  ]
}), _s = /* @__PURE__ */ pe(([i]) => {
  const e = Ge(i).toVar();
  return J(e).div(J(Ge(le(4294967295))));
}).setLayout({
  name: "mx_bits_to_01",
  type: "float",
  inputs: [
    { name: "bits", type: "uint" }
  ]
}), il = /* @__PURE__ */ pe(([i]) => {
  const e = J(i).toVar();
  return e.mul(e).mul(e).mul(e.mul(e.mul(6).sub(15)).add(10));
}).setLayout({
  name: "mx_fade",
  type: "float",
  inputs: [
    { name: "t", type: "float" }
  ]
}), jre = /* @__PURE__ */ pe(([i]) => {
  const e = le(i).toVar(), t = Ge(Ge(1)).toVar(), n = Ge(Ge(le(3735928559)).add(t.shiftLeft(Ge(2))).add(Ge(13))).toVar();
  return W0(n.add(Ge(e)), n, n);
}).setLayout({
  name: "mx_hash_int_0",
  type: "uint",
  inputs: [
    { name: "x", type: "int" }
  ]
}), Xre = /* @__PURE__ */ pe(([i, e]) => {
  const t = le(e).toVar(), n = le(i).toVar(), r = Ge(Ge(2)).toVar(), s = Ge().toVar(), o = Ge().toVar(), a = Ge().toVar();
  return s.assign(o.assign(a.assign(Ge(le(3735928559)).add(r.shiftLeft(Ge(2))).add(Ge(13))))), s.addAssign(Ge(n)), o.addAssign(Ge(t)), W0(s, o, a);
}).setLayout({
  name: "mx_hash_int_1",
  type: "uint",
  inputs: [
    { name: "x", type: "int" },
    { name: "y", type: "int" }
  ]
}), Yre = /* @__PURE__ */ pe(([i, e, t]) => {
  const n = le(t).toVar(), r = le(e).toVar(), s = le(i).toVar(), o = Ge(Ge(3)).toVar(), a = Ge().toVar(), l = Ge().toVar(), u = Ge().toVar();
  return a.assign(l.assign(u.assign(Ge(le(3735928559)).add(o.shiftLeft(Ge(2))).add(Ge(13))))), a.addAssign(Ge(s)), l.addAssign(Ge(r)), u.addAssign(Ge(n)), W0(a, l, u);
}).setLayout({
  name: "mx_hash_int_2",
  type: "uint",
  inputs: [
    { name: "x", type: "int" },
    { name: "y", type: "int" },
    { name: "z", type: "int" }
  ]
}), Qre = /* @__PURE__ */ pe(([i, e, t, n]) => {
  const r = le(n).toVar(), s = le(t).toVar(), o = le(e).toVar(), a = le(i).toVar(), l = Ge(Ge(4)).toVar(), u = Ge().toVar(), c = Ge().toVar(), A = Ge().toVar();
  return u.assign(c.assign(A.assign(Ge(le(3735928559)).add(l.shiftLeft(Ge(2))).add(Ge(13))))), u.addAssign(Ge(a)), c.addAssign(Ge(o)), A.addAssign(Ge(s)), mI(u, c, A), u.addAssign(Ge(r)), W0(u, c, A);
}).setLayout({
  name: "mx_hash_int_3",
  type: "uint",
  inputs: [
    { name: "x", type: "int" },
    { name: "y", type: "int" },
    { name: "z", type: "int" },
    { name: "xx", type: "int" }
  ]
}), Kre = /* @__PURE__ */ pe(([i, e, t, n, r]) => {
  const s = le(r).toVar(), o = le(n).toVar(), a = le(t).toVar(), l = le(e).toVar(), u = le(i).toVar(), c = Ge(Ge(5)).toVar(), A = Ge().toVar(), m = Ge().toVar(), _ = Ge().toVar();
  return A.assign(m.assign(_.assign(Ge(le(3735928559)).add(c.shiftLeft(Ge(2))).add(Ge(13))))), A.addAssign(Ge(u)), m.addAssign(Ge(l)), _.addAssign(Ge(a)), mI(A, m, _), A.addAssign(Ge(o)), m.addAssign(Ge(s)), W0(A, m, _);
}).setLayout({
  name: "mx_hash_int_4",
  type: "uint",
  inputs: [
    { name: "x", type: "int" },
    { name: "y", type: "int" },
    { name: "z", type: "int" },
    { name: "xx", type: "int" },
    { name: "yy", type: "int" }
  ]
}), ci = /* @__PURE__ */ Jr([jre, Xre, Yre, Qre, Kre]), Zre = /* @__PURE__ */ pe(([i, e]) => {
  const t = le(e).toVar(), n = le(i).toVar(), r = Ge(ci(n, t)).toVar(), s = od().toVar();
  return s.x.assign(r.bitAnd(le(255))), s.y.assign(r.shiftRight(le(8)).bitAnd(le(255))), s.z.assign(r.shiftRight(le(16)).bitAnd(le(255))), s;
}).setLayout({
  name: "mx_hash_vec3_0",
  type: "uvec3",
  inputs: [
    { name: "x", type: "int" },
    { name: "y", type: "int" }
  ]
}), Jre = /* @__PURE__ */ pe(([i, e, t]) => {
  const n = le(t).toVar(), r = le(e).toVar(), s = le(i).toVar(), o = Ge(ci(s, r, n)).toVar(), a = od().toVar();
  return a.x.assign(o.bitAnd(le(255))), a.y.assign(o.shiftRight(le(8)).bitAnd(le(255))), a.z.assign(o.shiftRight(le(16)).bitAnd(le(255))), a;
}).setLayout({
  name: "mx_hash_vec3_1",
  type: "uvec3",
  inputs: [
    { name: "x", type: "int" },
    { name: "y", type: "int" },
    { name: "z", type: "int" }
  ]
}), Uo = /* @__PURE__ */ Jr([Zre, Jre]), ese = /* @__PURE__ */ pe(([i]) => {
  const e = Xe(i).toVar(), t = le().toVar(), n = le().toVar(), r = J(Bi(e.x, t)).toVar(), s = J(Bi(e.y, n)).toVar(), o = J(il(r)).toVar(), a = J(il(s)).toVar(), l = J(dI(Pr(ci(t, n), r, s), Pr(ci(t.add(le(1)), n), r.sub(1), s), Pr(ci(t, n.add(le(1))), r, s.sub(1)), Pr(ci(t.add(le(1)), n.add(le(1))), r.sub(1), s.sub(1)), o, a)).toVar();
  return AI(l);
}).setLayout({
  name: "mx_perlin_noise_float_0",
  type: "float",
  inputs: [
    { name: "p", type: "vec2" }
  ]
}), tse = /* @__PURE__ */ pe(([i]) => {
  const e = ce(i).toVar(), t = le().toVar(), n = le().toVar(), r = le().toVar(), s = J(Bi(e.x, t)).toVar(), o = J(Bi(e.y, n)).toVar(), a = J(Bi(e.z, r)).toVar(), l = J(il(s)).toVar(), u = J(il(o)).toVar(), c = J(il(a)).toVar(), A = J(fI(Pr(ci(t, n, r), s, o, a), Pr(ci(t.add(le(1)), n, r), s.sub(1), o, a), Pr(ci(t, n.add(le(1)), r), s, o.sub(1), a), Pr(ci(t.add(le(1)), n.add(le(1)), r), s.sub(1), o.sub(1), a), Pr(ci(t, n, r.add(le(1))), s, o, a.sub(1)), Pr(ci(t.add(le(1)), n, r.add(le(1))), s.sub(1), o, a.sub(1)), Pr(ci(t, n.add(le(1)), r.add(le(1))), s, o.sub(1), a.sub(1)), Pr(ci(t.add(le(1)), n.add(le(1)), r.add(le(1))), s.sub(1), o.sub(1), a.sub(1)), l, u, c)).toVar();
  return pI(A);
}).setLayout({
  name: "mx_perlin_noise_float_1",
  type: "float",
  inputs: [
    { name: "p", type: "vec3" }
  ]
}), sw = /* @__PURE__ */ Jr([ese, tse]), nse = /* @__PURE__ */ pe(([i]) => {
  const e = Xe(i).toVar(), t = le().toVar(), n = le().toVar(), r = J(Bi(e.x, t)).toVar(), s = J(Bi(e.y, n)).toVar(), o = J(il(r)).toVar(), a = J(il(s)).toVar(), l = ce(dI(Fo(Uo(t, n), r, s), Fo(Uo(t.add(le(1)), n), r.sub(1), s), Fo(Uo(t, n.add(le(1))), r, s.sub(1)), Fo(Uo(t.add(le(1)), n.add(le(1))), r.sub(1), s.sub(1)), o, a)).toVar();
  return AI(l);
}).setLayout({
  name: "mx_perlin_noise_vec3_0",
  type: "vec3",
  inputs: [
    { name: "p", type: "vec2" }
  ]
}), ise = /* @__PURE__ */ pe(([i]) => {
  const e = ce(i).toVar(), t = le().toVar(), n = le().toVar(), r = le().toVar(), s = J(Bi(e.x, t)).toVar(), o = J(Bi(e.y, n)).toVar(), a = J(Bi(e.z, r)).toVar(), l = J(il(s)).toVar(), u = J(il(o)).toVar(), c = J(il(a)).toVar(), A = ce(fI(Fo(Uo(t, n, r), s, o, a), Fo(Uo(t.add(le(1)), n, r), s.sub(1), o, a), Fo(Uo(t, n.add(le(1)), r), s, o.sub(1), a), Fo(Uo(t.add(le(1)), n.add(le(1)), r), s.sub(1), o.sub(1), a), Fo(Uo(t, n, r.add(le(1))), s, o, a.sub(1)), Fo(Uo(t.add(le(1)), n, r.add(le(1))), s.sub(1), o, a.sub(1)), Fo(Uo(t, n.add(le(1)), r.add(le(1))), s, o.sub(1), a.sub(1)), Fo(Uo(t.add(le(1)), n.add(le(1)), r.add(le(1))), s.sub(1), o.sub(1), a.sub(1)), l, u, c)).toVar();
  return pI(A);
}).setLayout({
  name: "mx_perlin_noise_vec3_1",
  type: "vec3",
  inputs: [
    { name: "p", type: "vec3" }
  ]
}), $0 = /* @__PURE__ */ Jr([nse, ise]), rse = /* @__PURE__ */ pe(([i]) => {
  const e = J(i).toVar(), t = le(rr(e)).toVar();
  return _s(ci(t));
}).setLayout({
  name: "mx_cell_noise_float_0",
  type: "float",
  inputs: [
    { name: "p", type: "float" }
  ]
}), sse = /* @__PURE__ */ pe(([i]) => {
  const e = Xe(i).toVar(), t = le(rr(e.x)).toVar(), n = le(rr(e.y)).toVar();
  return _s(ci(t, n));
}).setLayout({
  name: "mx_cell_noise_float_1",
  type: "float",
  inputs: [
    { name: "p", type: "vec2" }
  ]
}), ose = /* @__PURE__ */ pe(([i]) => {
  const e = ce(i).toVar(), t = le(rr(e.x)).toVar(), n = le(rr(e.y)).toVar(), r = le(rr(e.z)).toVar();
  return _s(ci(t, n, r));
}).setLayout({
  name: "mx_cell_noise_float_2",
  type: "float",
  inputs: [
    { name: "p", type: "vec3" }
  ]
}), ase = /* @__PURE__ */ pe(([i]) => {
  const e = Gt(i).toVar(), t = le(rr(e.x)).toVar(), n = le(rr(e.y)).toVar(), r = le(rr(e.z)).toVar(), s = le(rr(e.w)).toVar();
  return _s(ci(t, n, r, s));
}).setLayout({
  name: "mx_cell_noise_float_3",
  type: "float",
  inputs: [
    { name: "p", type: "vec4" }
  ]
}), lse = /* @__PURE__ */ Jr([rse, sse, ose, ase]), use = /* @__PURE__ */ pe(([i]) => {
  const e = J(i).toVar(), t = le(rr(e)).toVar();
  return ce(_s(ci(t, le(0))), _s(ci(t, le(1))), _s(ci(t, le(2))));
}).setLayout({
  name: "mx_cell_noise_vec3_0",
  type: "vec3",
  inputs: [
    { name: "p", type: "float" }
  ]
}), cse = /* @__PURE__ */ pe(([i]) => {
  const e = Xe(i).toVar(), t = le(rr(e.x)).toVar(), n = le(rr(e.y)).toVar();
  return ce(_s(ci(t, n, le(0))), _s(ci(t, n, le(1))), _s(ci(t, n, le(2))));
}).setLayout({
  name: "mx_cell_noise_vec3_1",
  type: "vec3",
  inputs: [
    { name: "p", type: "vec2" }
  ]
}), hse = /* @__PURE__ */ pe(([i]) => {
  const e = ce(i).toVar(), t = le(rr(e.x)).toVar(), n = le(rr(e.y)).toVar(), r = le(rr(e.z)).toVar();
  return ce(_s(ci(t, n, r, le(0))), _s(ci(t, n, r, le(1))), _s(ci(t, n, r, le(2))));
}).setLayout({
  name: "mx_cell_noise_vec3_2",
  type: "vec3",
  inputs: [
    { name: "p", type: "vec3" }
  ]
}), dse = /* @__PURE__ */ pe(([i]) => {
  const e = Gt(i).toVar(), t = le(rr(e.x)).toVar(), n = le(rr(e.y)).toVar(), r = le(rr(e.z)).toVar(), s = le(rr(e.w)).toVar();
  return ce(_s(ci(t, n, r, s, le(0))), _s(ci(t, n, r, s, le(1))), _s(ci(t, n, r, s, le(2))));
}).setLayout({
  name: "mx_cell_noise_vec3_3",
  type: "vec3",
  inputs: [
    { name: "p", type: "vec4" }
  ]
}), nx = /* @__PURE__ */ Jr([use, cse, hse, dse]), g_ = /* @__PURE__ */ pe(([i, e, t, n]) => {
  const r = J(n).toVar(), s = J(t).toVar(), o = le(e).toVar(), a = ce(i).toVar(), l = J(0).toVar(), u = J(1).toVar();
  return ri(o, () => {
    l.addAssign(u.mul(sw(a))), u.mulAssign(r), a.mulAssign(s);
  }), l;
}).setLayout({
  name: "mx_fractal_noise_float",
  type: "float",
  inputs: [
    { name: "p", type: "vec3" },
    { name: "octaves", type: "int" },
    { name: "lacunarity", type: "float" },
    { name: "diminish", type: "float" }
  ]
}), ix = /* @__PURE__ */ pe(([i, e, t, n]) => {
  const r = J(n).toVar(), s = J(t).toVar(), o = le(e).toVar(), a = ce(i).toVar(), l = ce(0).toVar(), u = J(1).toVar();
  return ri(o, () => {
    l.addAssign(u.mul($0(a))), u.mulAssign(r), a.mulAssign(s);
  }), l;
}).setLayout({
  name: "mx_fractal_noise_vec3",
  type: "vec3",
  inputs: [
    { name: "p", type: "vec3" },
    { name: "octaves", type: "int" },
    { name: "lacunarity", type: "float" },
    { name: "diminish", type: "float" }
  ]
}), fse = /* @__PURE__ */ pe(([i, e, t, n]) => {
  const r = J(n).toVar(), s = J(t).toVar(), o = le(e).toVar(), a = ce(i).toVar();
  return Xe(g_(a, o, s, r), g_(a.add(ce(le(19), le(193), le(17))), o, s, r));
}).setLayout({
  name: "mx_fractal_noise_vec2",
  type: "vec2",
  inputs: [
    { name: "p", type: "vec3" },
    { name: "octaves", type: "int" },
    { name: "lacunarity", type: "float" },
    { name: "diminish", type: "float" }
  ]
}), Ase = /* @__PURE__ */ pe(([i, e, t, n]) => {
  const r = J(n).toVar(), s = J(t).toVar(), o = le(e).toVar(), a = ce(i).toVar(), l = ce(ix(a, o, s, r)).toVar(), u = J(g_(a.add(ce(le(19), le(193), le(17))), o, s, r)).toVar();
  return Gt(l, u);
}).setLayout({
  name: "mx_fractal_noise_vec4",
  type: "vec4",
  inputs: [
    { name: "p", type: "vec3" },
    { name: "octaves", type: "int" },
    { name: "lacunarity", type: "float" },
    { name: "diminish", type: "float" }
  ]
}), pse = /* @__PURE__ */ pe(([i, e, t, n, r, s, o]) => {
  const a = le(o).toVar(), l = J(s).toVar(), u = le(r).toVar(), c = le(n).toVar(), A = le(t).toVar(), m = le(e).toVar(), _ = Xe(i).toVar(), y = ce(nx(Xe(m.add(c), A.add(u)))).toVar(), T = Xe(y.x, y.y).toVar();
  T.subAssign(0.5), T.mulAssign(l), T.addAssign(0.5);
  const b = Xe(Xe(J(m), J(A)).add(T)).toVar(), S = Xe(b.sub(_)).toVar();
  return Ot(a.equal(le(2)), () => vi(S.x).add(vi(S.y))), Ot(a.equal(le(3)), () => qi(vi(S.x), vi(S.y))), $o(S, S);
}).setLayout({
  name: "mx_worley_distance_0",
  type: "float",
  inputs: [
    { name: "p", type: "vec2" },
    { name: "x", type: "int" },
    { name: "y", type: "int" },
    { name: "xoff", type: "int" },
    { name: "yoff", type: "int" },
    { name: "jitter", type: "float" },
    { name: "metric", type: "int" }
  ]
}), mse = /* @__PURE__ */ pe(([i, e, t, n, r, s, o, a, l]) => {
  const u = le(l).toVar(), c = J(a).toVar(), A = le(o).toVar(), m = le(s).toVar(), _ = le(r).toVar(), y = le(n).toVar(), T = le(t).toVar(), b = le(e).toVar(), S = ce(i).toVar(), E = ce(nx(ce(b.add(_), T.add(m), y.add(A)))).toVar();
  E.subAssign(0.5), E.mulAssign(c), E.addAssign(0.5);
  const R = ce(ce(J(b), J(T), J(y)).add(E)).toVar(), C = ce(R.sub(S)).toVar();
  return Ot(u.equal(le(2)), () => vi(C.x).add(vi(C.y)).add(vi(C.z))), Ot(u.equal(le(3)), () => qi(vi(C.x), vi(C.y), vi(C.z))), $o(C, C);
}).setLayout({
  name: "mx_worley_distance_1",
  type: "float",
  inputs: [
    { name: "p", type: "vec3" },
    { name: "x", type: "int" },
    { name: "y", type: "int" },
    { name: "z", type: "int" },
    { name: "xoff", type: "int" },
    { name: "yoff", type: "int" },
    { name: "zoff", type: "int" },
    { name: "jitter", type: "float" },
    { name: "metric", type: "int" }
  ]
}), AA = /* @__PURE__ */ Jr([pse, mse]), gse = /* @__PURE__ */ pe(([i, e, t]) => {
  const n = le(t).toVar(), r = J(e).toVar(), s = Xe(i).toVar(), o = le().toVar(), a = le().toVar(), l = Xe(Bi(s.x, o), Bi(s.y, a)).toVar(), u = J(1e6).toVar();
  return ri({ start: -1, end: le(1), name: "x", condition: "<=" }, ({ x: c }) => {
    ri({ start: -1, end: le(1), name: "y", condition: "<=" }, ({ y: A }) => {
      const m = J(AA(l, c, A, o, a, r, n)).toVar();
      u.assign(so(u, m));
    });
  }), Ot(n.equal(le(0)), () => {
    u.assign(ps(u));
  }), u;
}).setLayout({
  name: "mx_worley_noise_float_0",
  type: "float",
  inputs: [
    { name: "p", type: "vec2" },
    { name: "jitter", type: "float" },
    { name: "metric", type: "int" }
  ]
}), _se = /* @__PURE__ */ pe(([i, e, t]) => {
  const n = le(t).toVar(), r = J(e).toVar(), s = Xe(i).toVar(), o = le().toVar(), a = le().toVar(), l = Xe(Bi(s.x, o), Bi(s.y, a)).toVar(), u = Xe(1e6, 1e6).toVar();
  return ri({ start: -1, end: le(1), name: "x", condition: "<=" }, ({ x: c }) => {
    ri({ start: -1, end: le(1), name: "y", condition: "<=" }, ({ y: A }) => {
      const m = J(AA(l, c, A, o, a, r, n)).toVar();
      Ot(m.lessThan(u.x), () => {
        u.y.assign(u.x), u.x.assign(m);
      }).ElseIf(m.lessThan(u.y), () => {
        u.y.assign(m);
      });
    });
  }), Ot(n.equal(le(0)), () => {
    u.assign(ps(u));
  }), u;
}).setLayout({
  name: "mx_worley_noise_vec2_0",
  type: "vec2",
  inputs: [
    { name: "p", type: "vec2" },
    { name: "jitter", type: "float" },
    { name: "metric", type: "int" }
  ]
}), xse = /* @__PURE__ */ pe(([i, e, t]) => {
  const n = le(t).toVar(), r = J(e).toVar(), s = Xe(i).toVar(), o = le().toVar(), a = le().toVar(), l = Xe(Bi(s.x, o), Bi(s.y, a)).toVar(), u = ce(1e6, 1e6, 1e6).toVar();
  return ri({ start: -1, end: le(1), name: "x", condition: "<=" }, ({ x: c }) => {
    ri({ start: -1, end: le(1), name: "y", condition: "<=" }, ({ y: A }) => {
      const m = J(AA(l, c, A, o, a, r, n)).toVar();
      Ot(m.lessThan(u.x), () => {
        u.z.assign(u.y), u.y.assign(u.x), u.x.assign(m);
      }).ElseIf(m.lessThan(u.y), () => {
        u.z.assign(u.y), u.y.assign(m);
      }).ElseIf(m.lessThan(u.z), () => {
        u.z.assign(m);
      });
    });
  }), Ot(n.equal(le(0)), () => {
    u.assign(ps(u));
  }), u;
}).setLayout({
  name: "mx_worley_noise_vec3_0",
  type: "vec3",
  inputs: [
    { name: "p", type: "vec2" },
    { name: "jitter", type: "float" },
    { name: "metric", type: "int" }
  ]
}), yse = /* @__PURE__ */ pe(([i, e, t]) => {
  const n = le(t).toVar(), r = J(e).toVar(), s = ce(i).toVar(), o = le().toVar(), a = le().toVar(), l = le().toVar(), u = ce(Bi(s.x, o), Bi(s.y, a), Bi(s.z, l)).toVar(), c = J(1e6).toVar();
  return ri({ start: -1, end: le(1), name: "x", condition: "<=" }, ({ x: A }) => {
    ri({ start: -1, end: le(1), name: "y", condition: "<=" }, ({ y: m }) => {
      ri({ start: -1, end: le(1), name: "z", condition: "<=" }, ({ z: _ }) => {
        const y = J(AA(u, A, m, _, o, a, l, r, n)).toVar();
        c.assign(so(c, y));
      });
    });
  }), Ot(n.equal(le(0)), () => {
    c.assign(ps(c));
  }), c;
}).setLayout({
  name: "mx_worley_noise_float_1",
  type: "float",
  inputs: [
    { name: "p", type: "vec3" },
    { name: "jitter", type: "float" },
    { name: "metric", type: "int" }
  ]
}), vse = /* @__PURE__ */ Jr([gse, yse]), bse = /* @__PURE__ */ pe(([i, e, t]) => {
  const n = le(t).toVar(), r = J(e).toVar(), s = ce(i).toVar(), o = le().toVar(), a = le().toVar(), l = le().toVar(), u = ce(Bi(s.x, o), Bi(s.y, a), Bi(s.z, l)).toVar(), c = Xe(1e6, 1e6).toVar();
  return ri({ start: -1, end: le(1), name: "x", condition: "<=" }, ({ x: A }) => {
    ri({ start: -1, end: le(1), name: "y", condition: "<=" }, ({ y: m }) => {
      ri({ start: -1, end: le(1), name: "z", condition: "<=" }, ({ z: _ }) => {
        const y = J(AA(u, A, m, _, o, a, l, r, n)).toVar();
        Ot(y.lessThan(c.x), () => {
          c.y.assign(c.x), c.x.assign(y);
        }).ElseIf(y.lessThan(c.y), () => {
          c.y.assign(y);
        });
      });
    });
  }), Ot(n.equal(le(0)), () => {
    c.assign(ps(c));
  }), c;
}).setLayout({
  name: "mx_worley_noise_vec2_1",
  type: "vec2",
  inputs: [
    { name: "p", type: "vec3" },
    { name: "jitter", type: "float" },
    { name: "metric", type: "int" }
  ]
}), Sse = /* @__PURE__ */ Jr([_se, bse]), Tse = /* @__PURE__ */ pe(([i, e, t]) => {
  const n = le(t).toVar(), r = J(e).toVar(), s = ce(i).toVar(), o = le().toVar(), a = le().toVar(), l = le().toVar(), u = ce(Bi(s.x, o), Bi(s.y, a), Bi(s.z, l)).toVar(), c = ce(1e6, 1e6, 1e6).toVar();
  return ri({ start: -1, end: le(1), name: "x", condition: "<=" }, ({ x: A }) => {
    ri({ start: -1, end: le(1), name: "y", condition: "<=" }, ({ y: m }) => {
      ri({ start: -1, end: le(1), name: "z", condition: "<=" }, ({ z: _ }) => {
        const y = J(AA(u, A, m, _, o, a, l, r, n)).toVar();
        Ot(y.lessThan(c.x), () => {
          c.z.assign(c.y), c.y.assign(c.x), c.x.assign(y);
        }).ElseIf(y.lessThan(c.y), () => {
          c.z.assign(c.y), c.y.assign(y);
        }).ElseIf(y.lessThan(c.z), () => {
          c.z.assign(y);
        });
      });
    });
  }), Ot(n.equal(le(0)), () => {
    c.assign(ps(c));
  }), c;
}).setLayout({
  name: "mx_worley_noise_vec3_1",
  type: "vec3",
  inputs: [
    { name: "p", type: "vec3" },
    { name: "jitter", type: "float" },
    { name: "metric", type: "int" }
  ]
}), ow = /* @__PURE__ */ Jr([xse, Tse]), wse = /* @__PURE__ */ pe(([
  i,
  e,
  t,
  n,
  r,
  s,
  o,
  a,
  l,
  u,
  c
]) => {
  const A = le(i).toVar(), m = Xe(e).toVar(), _ = Xe(t).toVar(), y = Xe(n).toVar(), T = J(r).toVar(), b = J(s).toVar(), S = J(o).toVar(), E = Wo(a).toVar(), R = le(l).toVar(), C = J(u).toVar(), L = J(c).toVar(), D = m.mul(_).add(y), B = J(0).toVar();
  return Ot(A.equal(le(0)), () => {
    B.assign($0(D));
  }), Ot(A.equal(le(1)), () => {
    B.assign(nx(D));
  }), Ot(A.equal(le(2)), () => {
    B.assign(ow(D, T, le(0)));
  }), Ot(A.equal(le(3)), () => {
    B.assign(ix(ce(D, 0), R, C, L));
  }), B.assign(B.mul(S.sub(b)).add(b)), Ot(E, () => {
    B.assign(Sa(B, b, S));
  }), B;
}).setLayout({
  name: "mx_unifiednoise2d",
  type: "float",
  inputs: [
    { name: "noiseType", type: "int" },
    { name: "texcoord", type: "vec2" },
    { name: "freq", type: "vec2" },
    { name: "offset", type: "vec2" },
    { name: "jitter", type: "float" },
    { name: "outmin", type: "float" },
    { name: "outmax", type: "float" },
    { name: "clampoutput", type: "bool" },
    { name: "octaves", type: "int" },
    { name: "lacunarity", type: "float" },
    { name: "diminish", type: "float" }
  ]
}), Mse = /* @__PURE__ */ pe(([
  i,
  e,
  t,
  n,
  r,
  s,
  o,
  a,
  l,
  u,
  c
]) => {
  const A = le(i).toVar(), m = ce(e).toVar(), _ = ce(t).toVar(), y = ce(n).toVar(), T = J(r).toVar(), b = J(s).toVar(), S = J(o).toVar(), E = Wo(a).toVar(), R = le(l).toVar(), C = J(u).toVar(), L = J(c).toVar(), D = m.mul(_).add(y), B = J(0).toVar();
  return Ot(A.equal(le(0)), () => {
    B.assign($0(D));
  }), Ot(A.equal(le(1)), () => {
    B.assign(nx(D));
  }), Ot(A.equal(le(2)), () => {
    B.assign(ow(D, T, le(0)));
  }), Ot(A.equal(le(3)), () => {
    B.assign(ix(D, R, C, L));
  }), B.assign(B.mul(S.sub(b)).add(b)), Ot(E, () => {
    B.assign(Sa(B, b, S));
  }), B;
}).setLayout({
  name: "mx_unifiednoise3d",
  type: "float",
  inputs: [
    { name: "noiseType", type: "int" },
    { name: "position", type: "vec3" },
    { name: "freq", type: "vec3" },
    { name: "offset", type: "vec3" },
    { name: "jitter", type: "float" },
    { name: "outmin", type: "float" },
    { name: "outmax", type: "float" },
    { name: "clampoutput", type: "bool" },
    { name: "octaves", type: "int" },
    { name: "lacunarity", type: "float" },
    { name: "diminish", type: "float" }
  ]
}), Ese = /* @__PURE__ */ pe(([i]) => {
  const e = i.y, t = i.z, n = ce().toVar();
  return Ot(e.lessThan(1e-4), () => {
    n.assign(ce(t, t, t));
  }).Else(() => {
    let r = i.x;
    r = r.sub(Ja(r)).mul(6).toVar();
    const s = le(aT(r)), o = r.sub(J(s)), a = t.mul(e.oneMinus()), l = t.mul(e.mul(o).oneMinus()), u = t.mul(e.mul(o.oneMinus()).oneMinus());
    Ot(s.equal(le(0)), () => {
      n.assign(ce(t, u, a));
    }).ElseIf(s.equal(le(1)), () => {
      n.assign(ce(l, t, a));
    }).ElseIf(s.equal(le(2)), () => {
      n.assign(ce(a, t, u));
    }).ElseIf(s.equal(le(3)), () => {
      n.assign(ce(a, l, t));
    }).ElseIf(s.equal(le(4)), () => {
      n.assign(ce(u, a, t));
    }).Else(() => {
      n.assign(ce(t, a, l));
    });
  }), n;
}).setLayout({
  name: "mx_hsvtorgb",
  type: "vec3",
  inputs: [
    { name: "hsv", type: "vec3" }
  ]
}), Rse = /* @__PURE__ */ pe(([i]) => {
  const e = ce(i).toVar(), t = J(e.x).toVar(), n = J(e.y).toVar(), r = J(e.z).toVar(), s = J(so(t, so(n, r))).toVar(), o = J(qi(t, qi(n, r))).toVar(), a = J(o.sub(s)).toVar(), l = J().toVar(), u = J().toVar(), c = J().toVar();
  return c.assign(o), Ot(o.greaterThan(0), () => {
    u.assign(a.div(o));
  }).Else(() => {
    u.assign(0);
  }), Ot(u.lessThanEqual(0), () => {
    l.assign(0);
  }).Else(() => {
    Ot(t.greaterThanEqual(o), () => {
      l.assign(n.sub(r).div(a));
    }).ElseIf(n.greaterThanEqual(o), () => {
      l.assign(sr(2, r.sub(t).div(a)));
    }).Else(() => {
      l.assign(sr(4, t.sub(n).div(a)));
    }), l.mulAssign(1 / 6), Ot(l.lessThan(0), () => {
      l.addAssign(1);
    });
  }), ce(l, u, c);
}).setLayout({
  name: "mx_rgbtohsv",
  type: "vec3",
  inputs: [
    { name: "c", type: "vec3" }
  ]
}), Cse = /* @__PURE__ */ pe(([i]) => {
  const e = ce(i).toVar(), t = qS(ZS(e, ce(0.04045))).toVar(), n = ce(e.div(12.92)).toVar(), r = ce(ko(qi(e.add(ce(0.055)), ce(0)).div(1.055), ce(2.4))).toVar();
  return Bn(n, r, t);
}).setLayout({
  name: "mx_srgb_texture_to_lin_rec709",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" }
  ]
}), gI = (i, e) => {
  i = J(i), e = J(e);
  const t = Xe(e.dFdx(), e.dFdy()).length().mul(0.7071067811865476);
  return Ta(i.sub(t), i.add(t), e);
}, _I = (i, e, t, n) => Bn(i, e, t[n].clamp()), Pse = (i, e, t = hi()) => _I(i, e, t, "x"), Nse = (i, e, t = hi()) => _I(i, e, t, "y"), Dse = (i, e, t, n, r = hi()) => {
  const s = r.x.clamp(), o = r.y.clamp(), a = Bn(i, e, s), l = Bn(t, n, s);
  return Bn(a, l, o);
}, xI = (i, e, t, n, r) => Bn(i, e, gI(t, n[r])), Lse = (i, e, t, n = hi()) => xI(i, e, t, n, "x"), Ise = (i, e, t, n = hi()) => xI(i, e, t, n, "y"), Bse = (i = 1, e = 0, t = hi()) => t.mul(i).add(e), Fse = (i, e = 1) => (i = J(i), i.abs().pow(e).mul(i.sign())), Use = (i, e = 1, t = 0.5) => J(i).sub(t).mul(e).add(t), Ose = (i = hi(), e = 1, t = 0) => sw(i.convert("vec2|vec3")).mul(e).add(t), kse = (i = hi(), e = 1, t = 0) => $0(i.convert("vec2|vec3")).mul(e).add(t), Vse = (i = hi(), e = 1, t = 0) => (i = i.convert("vec2|vec3"), Gt($0(i), sw(i.add(Xe(19, 73)))).mul(e).add(t)), Gse = (i, e = hi(), t = Xe(1, 1), n = Xe(0, 0), r = 1, s = 0, o = 1, a = !1, l = 1, u = 2, c = 0.5) => wse(i, e.convert("vec2|vec3"), t, n, r, s, o, a, l, u, c), zse = (i, e = hi(), t = Xe(1, 1), n = Xe(0, 0), r = 1, s = 0, o = 1, a = !1, l = 1, u = 2, c = 0.5) => Mse(i, e.convert("vec2|vec3"), t, n, r, s, o, a, l, u, c), qse = (i = hi(), e = 1) => vse(i.convert("vec2|vec3"), e, le(1)), Hse = (i = hi(), e = 1) => Sse(i.convert("vec2|vec3"), e, le(1)), Wse = (i = hi(), e = 1) => ow(i.convert("vec2|vec3"), e, le(1)), $se = (i = hi()) => lse(i.convert("vec2|vec3")), jse = (i = hi(), e = 3, t = 2, n = 0.5, r = 1) => g_(i, le(e), t, n).mul(r), Xse = (i = hi(), e = 3, t = 2, n = 0.5, r = 1) => fse(i, le(e), t, n).mul(r), Yse = (i = hi(), e = 3, t = 2, n = 0.5, r = 1) => ix(i, le(e), t, n).mul(r), Qse = (i = hi(), e = 3, t = 2, n = 0.5, r = 1) => Ase(i, le(e), t, n).mul(r), Kse = (i, e = J(0)) => sr(i, e), Zse = (i, e = J(0)) => Un(i, e), Jse = (i, e = J(1)) => sn(i, e), eoe = (i, e = J(1)) => Ro(i, e), toe = (i, e = J(1)) => O0(i, e), noe = (i, e = J(1)) => ko(i, e), ioe = (i = J(0), e = J(1)) => B2(i, e), roe = () => fA, soe = () => LL, ooe = (i, e = J(1)) => Un(e, i), aoe = (i, e, t, n) => i.greaterThan(e).mix(t, n), loe = (i, e, t, n) => i.greaterThanEqual(e).mix(t, n), uoe = (i, e, t, n) => i.equal(e).mix(t, n), coe = (i, e = null) => {
  if (typeof e == "string") {
    const t = { x: 0, r: 0, y: 1, g: 1, z: 2, b: 2, w: 3, a: 3 }, n = e.replace(/^out/, "").toLowerCase();
    if (t[n] !== void 0) return i.element(t[n]);
  }
  if (typeof e == "number")
    return i.element(e);
  if (typeof e == "string" && e.length === 1) {
    const t = { x: 0, r: 0, y: 1, g: 1, z: 2, b: 2, w: 3, a: 3 };
    if (t[e] !== void 0) return i.element(t[e]);
  }
  return i;
}, hoe = (i, e = Xe(0.5, 0.5), t = Xe(1, 1), n = J(0), r = Xe(0, 0)) => {
  let s = i;
  if (e && (s = s.sub(e)), t && (s = s.mul(t)), n) {
    const o = n.mul(Math.PI / 180), a = o.cos(), l = o.sin();
    s = Xe(
      s.x.mul(a).sub(s.y.mul(l)),
      s.x.mul(l).add(s.y.mul(a))
    );
  }
  return e && (s = s.add(e)), r && (s = s.add(r)), s;
}, doe = (i, e) => {
  i = Xe(i), e = J(e);
  const t = e.mul(Math.PI / 180);
  return z0(i, t);
}, foe = (i, e, t) => {
  i = ce(i), e = J(e), t = ce(t);
  const n = e.mul(Math.PI / 180), r = t.normalize(), s = n.cos(), o = n.sin(), a = J(1).sub(s);
  return i.mul(s).add(r.cross(i).mul(o)).add(r.mul(r.dot(i)).mul(a));
}, Aoe = (i, e) => (i = ce(i), e = J(e), PT(i, e)), poe = /* @__PURE__ */ pe(([i, e, t]) => {
  const n = Fs(i).toVar(), r = Un(J(0.5).mul(e.sub(t)), tl).div(n).toVar(), s = Un(J(-0.5).mul(e.sub(t)), tl).div(n).toVar(), o = ce().toVar();
  o.x = n.x.greaterThan(J(0)).select(r.x, s.x), o.y = n.y.greaterThan(J(0)).select(r.y, s.y), o.z = n.z.greaterThan(J(0)).select(r.z, s.z);
  const a = so(o.x, o.y, o.z).toVar();
  return tl.add(n.mul(a)).toVar().sub(t);
}), yI = /* @__PURE__ */ pe(([i, e]) => {
  const t = i.x, n = i.y, r = i.z;
  let s = e.element(0).mul(0.886227);
  return s = s.add(e.element(1).mul(2 * 0.511664).mul(n)), s = s.add(e.element(2).mul(2 * 0.511664).mul(r)), s = s.add(e.element(3).mul(2 * 0.511664).mul(t)), s = s.add(e.element(4).mul(2 * 0.429043).mul(t).mul(n)), s = s.add(e.element(5).mul(2 * 0.429043).mul(n).mul(r)), s = s.add(e.element(6).mul(r.mul(r).mul(0.743125).sub(0.247708))), s = s.add(e.element(7).mul(2 * 0.429043).mul(t).mul(r)), s = s.add(e.element(8).mul(0.429043).mul(sn(t, t).sub(sn(n, n)))), s;
});
var F = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  BRDF_GGX: GT,
  BRDF_Lambert: Xh,
  BasicPointShadowFilter: lI,
  BasicShadowFilter: JL,
  Break: XD,
  Const: f6,
  Continue: tJ,
  DFGLUT: l0,
  D_GGX: dL,
  Discard: C6,
  EPSILON: JS,
  F_Schlick: Qf,
  Fn: pe,
  HALF_PI: EK,
  INFINITY: TK,
  If: Ot,
  Loop: ri,
  NodeAccess: Xr,
  NodeShaderStage: _p,
  NodeType: jQ,
  NodeUpdateType: hn,
  OnBeforeMaterialUpdate: Sne,
  OnBeforeObjectUpdate: bne,
  OnMaterialUpdate: vne,
  OnObjectUpdate: yne,
  PCFShadowFilter: eI,
  PCFSoftShadowFilter: tI,
  PI: u_,
  PI2: wK,
  PointShadowFilter: uI,
  Return: qK,
  Schlick_to_F0: jb,
  ScriptableNodeResources: u1,
  ShaderNode: df,
  Stack: C2,
  Switch: pK,
  TBNViewMatrix: rh,
  TWO_PI: MK,
  VSMShadowFilter: nI,
  V_GGX_SmithCorrelated: hL,
  Var: d6,
  VarIntent: A6,
  abs: vi,
  acesFilmicToneMapping: HL,
  acos: nT,
  add: sr,
  addMethodChaining: Be,
  addNodeElement: jK,
  agxToneMapping: WL,
  all: UN,
  alphaT: o_,
  and: bN,
  anisotropy: Mu,
  anisotropyB: hh,
  anisotropyT: Pp,
  any: ON,
  append: xK,
  array: pN,
  arrayBuffer: gK,
  asin: zN,
  assign: mN,
  atan: B2,
  atan2: o6,
  atomicAdd: Pie,
  atomicAnd: Iie,
  atomicFunc: hl,
  atomicLoad: Rie,
  atomicMax: Die,
  atomicMin: Lie,
  atomicOr: Bie,
  atomicStore: Cie,
  atomicSub: Nie,
  atomicXor: Fie,
  attenuationColor: XS,
  attenuationDistance: jS,
  attribute: Jl,
  attributeArray: wne,
  backgroundBlurriness: FL,
  backgroundIntensity: Zb,
  backgroundRotation: UL,
  batch: WD,
  bentNormalView: aD,
  billboarding: ine,
  bitAnd: MN,
  bitNot: EN,
  bitOr: RN,
  bitXor: CN,
  bitangentGeometry: LZ,
  bitangentLocal: IZ,
  bitangentView: sD,
  bitangentWorld: BZ,
  bitcast: NL,
  blendBurn: eL,
  blendColor: _J,
  blendDodge: tL,
  blendOverlay: iL,
  blendScreen: nL,
  blur: xL,
  bool: Wo,
  buffer: k0,
  bufferAttribute: _T,
  builtin: tu,
  builtinAOContext: c6,
  builtinShadowContext: u6,
  bumpMap: PT,
  burn: yJ,
  bvec2: lN,
  bvec3: qS,
  bvec4: uN,
  bypass: w6,
  cache: T6,
  call: gN,
  cameraFar: Pu,
  cameraIndex: rc,
  cameraNear: Cu,
  cameraNormalMatrix: lZ,
  cameraPosition: U6,
  cameraProjectionMatrix: Ol,
  cameraProjectionMatrixInverse: oZ,
  cameraViewMatrix: ea,
  cameraViewport: uZ,
  cameraWorldMatrix: aZ,
  cbrt: t6,
  cdl: qne,
  ceil: I2,
  checker: Lre,
  cineonToneMapping: qL,
  clamp: Sa,
  clearcoat: i_,
  clearcoatNormalView: ih,
  clearcoatRoughness: a0,
  code: J2,
  color: aN,
  colorSpaceToWorking: O2,
  colorToDirection: UZ,
  compute: S6,
  computeKernel: xT,
  computeSkinning: JZ,
  context: eu,
  convert: hN,
  convertColorSpace: IK,
  convertToTexture: pne,
  cos: ha,
  countLeadingZeros: Lte,
  countOneBits: Ite,
  countTrailingZeros: Dte,
  cross: Kl,
  cubeTexture: Is,
  cubeTextureBase: CT,
  dFdx: sT,
  dFdy: oT,
  dashSize: t1,
  debug: N6,
  decrement: BN,
  decrementBefore: LN,
  defaultBuildStages: Db,
  defaultShaderStages: tN,
  defined: r0,
  degrees: VN,
  deltaTime: Yte,
  densityFog: hie,
  densityFogFactor: KT,
  depth: UT,
  depthPass: Xne,
  determinant: jN,
  difference: ZN,
  diffuseColor: ni,
  diffuseContribution: Hc,
  directPointLight: hI,
  directionToColor: lD,
  directionToFaceDirection: hA,
  dispersion: YS,
  disposeShadowMaterial: rI,
  distance: KN,
  div: Ro,
  dodge: vJ,
  dot: $o,
  drawIndex: zD,
  dynamicBufferAttribute: kK,
  element: cN,
  emissive: Fb,
  equal: KS,
  equals: YN,
  equirectUV: OT,
  exp: eT,
  exp2: Xf,
  expression: Zl,
  faceDirection: MT,
  faceForward: fT,
  faceforward: RK,
  float: J,
  floatBitsToInt: Cte,
  floatBitsToUint: DL,
  floor: Ja,
  fog: c0,
  fract: ba,
  frameGroup: AN,
  frameId: LL,
  frontFacing: G6,
  fwidth: lT,
  gain: Fte,
  gapSize: Ub,
  getConstNodeType: oN,
  getCurrentStack: VS,
  getDirection: gL,
  getDistanceAttenuation: rw,
  getGeometryRoughness: cL,
  getNormalFromDepth: gne,
  getParallaxCorrectNormal: poe,
  getRoughness: VT,
  getScreenPosition: mne,
  getShIrradianceAt: yI,
  getShadowMaterial: iI,
  getShadowRenderObjectFunction: sI,
  getTextureIndex: CL,
  getViewPosition: of,
  ggxConvolution: yL,
  globalId: gie,
  glsl: iie,
  glslFn: rie,
  grayscale: kne,
  greaterThan: ZS,
  greaterThanEqual: vN,
  hash: Bte,
  highpModelNormalViewMatrix: Vb,
  highpModelViewMatrix: kb,
  hue: zne,
  increment: IN,
  incrementBefore: DN,
  inspector: L6,
  instance: QZ,
  instanceIndex: nl,
  instancedArray: Mne,
  instancedBufferAttribute: c_,
  instancedDynamicBufferAttribute: Ob,
  instancedMesh: HD,
  int: le,
  intBitsToFloat: Pte,
  interleavedGradientNoise: XT,
  inverse: XN,
  inverseSqrt: tT,
  inversesqrt: CK,
  invocationLocalIndex: YZ,
  invocationSubgroupIndex: XZ,
  ior: Np,
  iridescence: N2,
  iridescenceIOR: r_,
  iridescenceThickness: s_,
  isolate: bf,
  ivec2: ur,
  ivec3: zS,
  ivec4: HS,
  js: tie,
  label: h6,
  length: el,
  lengthSq: hT,
  lessThan: xN,
  lessThanEqual: yN,
  lightPosition: JT,
  lightProjectionUV: KL,
  lightShadowMatrix: tx,
  lightTargetDirection: tw,
  lightTargetPosition: ZL,
  lightViewPosition: ew,
  lightingContext: QD,
  lights: cre,
  linearDepth: d_,
  linearToneMapping: GL,
  localId: _ie,
  log: L2,
  log2: Za,
  logarithmicDepthToViewZ: cJ,
  luminance: YT,
  mat2: P2,
  mat3: Kr,
  mat4: Vu,
  matcapUV: bL,
  materialAO: kD,
  materialAlphaTest: uD,
  materialAnisotropy: TD,
  materialAnisotropyVector: sf,
  materialAttenuationColor: DD,
  materialAttenuationDistance: ND,
  materialClearcoat: _D,
  materialClearcoatNormal: yD,
  materialClearcoatRoughness: xD,
  materialColor: cD,
  materialDispersion: OD,
  materialEmissive: dD,
  materialEnvIntensity: r1,
  materialEnvRotation: RT,
  materialIOR: PD,
  materialIridescence: wD,
  materialIridescenceIOR: MD,
  materialIridescenceThickness: ED,
  materialLightMap: DT,
  materialLineDashOffset: FD,
  materialLineDashSize: ID,
  materialLineGapSize: BD,
  materialLineScale: LD,
  materialLineWidth: zZ,
  materialMetalness: mD,
  materialNormal: gD,
  materialOpacity: NT,
  materialPointSize: UD,
  materialReference: wl,
  materialReflectivity: s1,
  materialRefractionRatio: W6,
  materialRotation: vD,
  materialRoughness: pD,
  materialSheen: bD,
  materialSheenRoughness: SD,
  materialShininess: hD,
  materialSpecular: fD,
  materialSpecularColor: AD,
  materialSpecularIntensity: $b,
  materialSpecularStrength: Dp,
  materialThickness: CD,
  materialTransmission: RD,
  max: qi,
  maxMipLevel: yT,
  mediumpModelViewMatrix: V6,
  metalness: El,
  min: so,
  mix: Bn,
  mixElement: i6,
  mod: O0,
  modInt: FN,
  modelDirection: pZ,
  modelNormalMatrix: k6,
  modelPosition: mZ,
  modelRadius: xZ,
  modelScale: gZ,
  modelViewMatrix: sc,
  modelViewPosition: _Z,
  modelViewProjection: VD,
  modelWorldMatrix: Vo,
  modelWorldMatrixInverse: yZ,
  morphReference: YD,
  mrt: PL,
  mul: sn,
  mx_aastep: gI,
  mx_add: Kse,
  mx_atan2: ioe,
  mx_cell_noise_float: $se,
  mx_contrast: Use,
  mx_divide: eoe,
  mx_fractal_noise_float: jse,
  mx_fractal_noise_vec2: Xse,
  mx_fractal_noise_vec3: Yse,
  mx_fractal_noise_vec4: Qse,
  mx_frame: soe,
  mx_heighttonormal: Aoe,
  mx_hsvtorgb: Ese,
  mx_ifequal: uoe,
  mx_ifgreater: aoe,
  mx_ifgreatereq: loe,
  mx_invert: ooe,
  mx_modulo: toe,
  mx_multiply: Jse,
  mx_noise_float: Ose,
  mx_noise_vec3: kse,
  mx_noise_vec4: Vse,
  mx_place2d: hoe,
  mx_power: noe,
  mx_ramp4: Dse,
  mx_ramplr: Pse,
  mx_ramptb: Nse,
  mx_rgbtohsv: Rse,
  mx_rotate2d: doe,
  mx_rotate3d: foe,
  mx_safepower: Fse,
  mx_separate: coe,
  mx_splitlr: Lse,
  mx_splittb: Ise,
  mx_srgb_texture_to_lin_rec709: Cse,
  mx_subtract: Zse,
  mx_timer: roe,
  mx_transform_uv: Bse,
  mx_unifiednoise2d: Gse,
  mx_unifiednoise3d: zse,
  mx_worley_noise_float: qse,
  mx_worley_noise_vec2: Hse,
  mx_worley_noise_vec3: Wse,
  negate: rT,
  neutralToneMapping: $L,
  nodeArray: ch,
  nodeImmutable: st,
  nodeObject: ut,
  nodeObjectIntent: xp,
  nodeObjects: R2,
  nodeProxy: on,
  nodeProxyIntent: Ke,
  normalFlat: z6,
  normalGeometry: V2,
  normalLocal: oo,
  normalMap: Wb,
  normalView: Gn,
  normalViewGeometry: Yf,
  normalWorld: oc,
  normalWorldGeometry: q6,
  normalize: Fs,
  not: TN,
  notEqual: _N,
  numWorkgroups: pie,
  objectDirection: cZ,
  objectGroup: QS,
  objectPosition: O6,
  objectRadius: AZ,
  objectScale: dZ,
  objectViewPosition: fZ,
  objectWorldMatrix: hZ,
  oneMinus: qN,
  or: SN,
  orthographicDepthToViewZ: uJ,
  oscSawtooth: Jte,
  oscSine: Qte,
  oscSquare: Kte,
  oscTriangle: Zte,
  output: yf,
  outputStruct: Ete,
  overlay: SJ,
  overloadingFn: Jr,
  packHalf2x16: Gte,
  packSnorm2x16: kte,
  packUnorm2x16: Vte,
  parabola: Kb,
  parallaxDirection: oD,
  parallaxUV: FZ,
  parameter: vte,
  pass: $ne,
  passTexture: jne,
  pcurve: Ute,
  perspectiveDepthToViewZ: BT,
  pmremTexture: qT,
  pointShadow: cI,
  pointUV: Rne,
  pointWidth: yK,
  positionGeometry: V0,
  positionLocal: Vi,
  positionPrevious: h_,
  positionView: tr,
  positionViewDirection: gi,
  positionWorld: tl,
  positionWorldDirection: wT,
  posterize: Wne,
  pow: ko,
  pow2: uT,
  pow3: JN,
  pow4: cT,
  premultiplyAlpha: rL,
  property: Bl,
  quadBroadcast: are,
  quadSwapDiagonal: tre,
  quadSwapX: Jie,
  quadSwapY: ere,
  radians: kN,
  rand: n6,
  range: fie,
  rangeFog: cie,
  rangeFogFactor: QT,
  reciprocal: WN,
  reference: ui,
  referenceBuffer: Gb,
  reflect: QN,
  reflectVector: X6,
  reflectView: $6,
  reflector: cne,
  refract: dT,
  refractVector: Y6,
  refractView: j6,
  reinhardToneMapping: zL,
  remap: E6,
  remapClamp: R6,
  renderGroup: Lt,
  renderOutput: P6,
  rendererReference: y6,
  replaceDefaultUV: ene,
  rotate: z0,
  rotateUV: tne,
  roughness: Ha,
  round: HN,
  rtt: BL,
  sRGBTransferEOTF: m6,
  sRGBTransferOETF: g6,
  sample: xne,
  sampler: JK,
  samplerComparison: eZ,
  saturate: U2,
  saturation: Vne,
  screen: bJ,
  screenCoordinate: ad,
  screenDPR: B6,
  screenSize: jh,
  screenUV: Ul,
  scriptable: uie,
  scriptableValue: l1,
  select: Yr,
  setCurrentStack: s0,
  setName: AT,
  shaderStages: Lb,
  shadow: aI,
  shadowPositionWorld: iw,
  shapeCircle: Ire,
  sharedUniformGroup: D2,
  sheen: go,
  sheenRoughness: Ru,
  shiftLeft: PN,
  shiftRight: NN,
  shininess: a_,
  sign: iT,
  sin: Ns,
  sinc: Ote,
  skinning: jD,
  smoothstep: Ta,
  smoothstepElement: r6,
  specularColor: Yu,
  specularColorBlended: nh,
  specularF90: xf,
  spherizeUV: nne,
  split: _K,
  spritesheetUV: one,
  sqrt: ps,
  stack: o1,
  step: F2,
  stepElement: s6,
  storage: kl,
  storageBarrier: bie,
  storageObject: $Z,
  storageTexture: OL,
  string: mK,
  struct: Mte,
  sub: Un,
  subBuild: vf,
  subgroupAdd: kie,
  subgroupAll: Qie,
  subgroupAnd: Wie,
  subgroupAny: Kie,
  subgroupBallot: Oie,
  subgroupBroadcast: nre,
  subgroupBroadcastFirst: Zie,
  subgroupElect: Uie,
  subgroupExclusiveAdd: Gie,
  subgroupExclusiveMul: Hie,
  subgroupInclusiveAdd: Vie,
  subgroupInclusiveMul: qie,
  subgroupIndex: jZ,
  subgroupMax: Yie,
  subgroupMin: Xie,
  subgroupMul: zie,
  subgroupOr: $ie,
  subgroupShuffle: ire,
  subgroupShuffleDown: ore,
  subgroupShuffleUp: sre,
  subgroupShuffleXor: rre,
  subgroupSize: xie,
  subgroupXor: jie,
  tan: GN,
  tangentGeometry: z2,
  tangentLocal: G0,
  tangentView: q2,
  tangentWorld: rD,
  texture: Wn,
  texture3D: Z2,
  texture3DLevel: Ine,
  texture3DLoad: Lne,
  textureBarrier: Sie,
  textureBicubic: eee,
  textureBicubicLevel: zT,
  textureCubeUV: _L,
  textureLevel: ZK,
  textureLoad: $i,
  textureSize: Fl,
  textureStore: Pne,
  thickness: $S,
  time: fA,
  toneMapping: v6,
  toneMappingExposure: b6,
  toonOutlinePass: Qne,
  transformDirection: e6,
  transformNormal: H6,
  transformNormalToView: ET,
  transformedClearcoatNormalView: TZ,
  transformedNormalView: bZ,
  transformedNormalWorld: SZ,
  transmission: l_,
  transpose: $N,
  triNoise3D: $te,
  triplanarTexture: ane,
  triplanarTextures: IL,
  trunc: aT,
  uint: Ge,
  uintBitsToFloat: Nte,
  uniform: It,
  uniformArray: hs,
  uniformCubeTexture: MZ,
  uniformFlow: l6,
  uniformGroup: fN,
  uniformTexture: KK,
  unpackHalf2x16: Hte,
  unpackNormal: Hb,
  unpackSnorm2x16: zte,
  unpackUnorm2x16: qte,
  unpremultiplyAlpha: xJ,
  userData: Fne,
  uv: hi,
  uvec2: GS,
  uvec3: od,
  uvec4: WS,
  varying: cl,
  varyingProperty: o0,
  vec2: Xe,
  vec3: ce,
  vec4: Gt,
  vectorComponents: rd,
  velocity: One,
  vertexColor: JD,
  vertexIndex: GD,
  vertexStage: p6,
  vibrance: Gne,
  viewZToLogarithmicDepth: FT,
  viewZToOrthographicDepth: Sf,
  viewZToPerspectiveDepth: KD,
  viewport: ST,
  viewportCoordinate: F6,
  viewportDepthTexture: IT,
  viewportLinearDepth: hJ,
  viewportMipTexture: LT,
  viewportResolution: sZ,
  viewportSafeUV: rne,
  viewportSharedTexture: CJ,
  viewportSize: TT,
  viewportTexture: aJ,
  viewportUV: rZ,
  vogelDiskSample: fa,
  wgsl: nie,
  wgslFn: sie,
  workgroupArray: Mie,
  workgroupBarrier: vie,
  workgroupId: mie,
  workingToColorSpace: _6,
  xor: wN
});
const sa = /* @__PURE__ */ new HT();
class moe extends ac {
  /**
   * Constructs a new background management component.
   *
   * @param {Renderer} renderer - The renderer.
   * @param {Nodes} nodes - Renderer component for managing nodes related logic.
   */
  constructor(e, t) {
    super(), this.renderer = e, this.nodes = t;
  }
  /**
   * Updates the background for the given scene. Depending on how `Scene.background`
   * or `Scene.backgroundNode` are configured, this method might configure a simple clear
   * or add a mesh to the render list for rendering the background as a textured plane
   * or skybox.
   *
   * @param {Scene} scene - The scene.
   * @param {RenderList} renderList - The current render list.
   * @param {RenderContext} renderContext - The current render context.
   */
  update(e, t, n) {
    const r = this.renderer, s = this.nodes.getBackgroundNode(e) || e.background;
    let o = !1;
    if (s === null)
      r._clearColor.getRGB(sa), sa.a = r._clearColor.a;
    else if (s.isColor === !0)
      s.getRGB(sa), sa.a = 1, o = !0;
    else if (s.isNode === !0) {
      const l = this.get(e), u = s;
      sa.copy(r._clearColor);
      let c = l.backgroundMesh;
      if (c === void 0) {
        let E = function() {
          s.removeEventListener("dispose", E), c.material.dispose(), c.geometry.dispose();
        };
        const m = Gt(u).mul(Zb).context({
          // @TODO: Add Texture2D support using node context
          getUV: () => UL.mul(q6),
          getTextureLevel: () => FL
        }), _ = Ol.element(3).element(3).equal(1), y = Ro(1, Ol.element(1).element(1)).mul(3), T = _.select(Vi.mul(y), Vi);
        let b = Ol.mul(sc.mul(Gt(T, 0)));
        b = b.setZ(b.w);
        const S = new Yi();
        S.name = "Background.material", S.side = si, S.depthTest = !1, S.depthWrite = !1, S.allowOverride = !1, S.fog = !1, S.lights = !1, S.vertexNode = b, S.colorNode = m, l.backgroundMeshNode = m, l.backgroundMesh = c = new Tn(new Co(1, 32, 32), S), c.frustumCulled = !1, c.name = "Background.mesh", s.addEventListener("dispose", E);
      }
      const A = u.getCacheKey();
      l.backgroundCacheKey !== A && (l.backgroundMeshNode.node = Gt(u).mul(Zb), l.backgroundMeshNode.needsUpdate = !0, c.material.needsUpdate = !0, l.backgroundCacheKey = A), t.unshift(c, c.geometry, c.material, 0, 0, null, null);
    } else
      Ie("Renderer: Unsupported background configuration.", s);
    const a = r.xr.getEnvironmentBlendMode();
    if (a === "additive" ? sa.set(0, 0, 0, 1) : a === "alpha-blend" && sa.set(0, 0, 0, 0), r.autoClear === !0 || o === !0) {
      const l = n.clearColorValue;
      l.r = sa.r, l.g = sa.g, l.b = sa.b, l.a = sa.a, (r.backend.isWebGLBackend === !0 || r.alpha === !0) && (l.r *= l.a, l.g *= l.a, l.b *= l.a), n.depthClearValue = r._clearDepth, n.stencilClearValue = r._clearStencil, n.clearColor = r.autoClearColor === !0, n.clearDepth = r.autoClearDepth === !0, n.clearStencil = r.autoClearStencil === !0;
    } else
      n.clearColor = !1, n.clearDepth = !1, n.clearStencil = !1;
  }
}
let goe = 0;
class Jb {
  /**
   * Constructs a new bind group.
   *
   * @param {string} name - The bind group's name.
   * @param {Array<Binding>} bindings - An array of bindings.
   * @param {number} index - The group index.
   * @param {Array<Binding>} bindingsReference - An array of reference bindings.
   */
  constructor(e = "", t = [], n = 0, r = []) {
    this.name = e, this.bindings = t, this.index = n, this.bindingsReference = r, this.id = goe++;
  }
}
class _oe {
  /**
   * Constructs a new node builder state.
   *
   * @param {string} vertexShader - The native vertex shader code.
   * @param {string} fragmentShader - The native fragment shader code.
   * @param {string} computeShader - The native compute shader code.
   * @param {Array<NodeAttribute>} nodeAttributes - An array of node attributes.
   * @param {Array<BindGroup>} bindings - An array of bind groups.
   * @param {Array<Node>} updateNodes - An array of nodes that implement their `update()` method.
   * @param {Array<Node>} updateBeforeNodes - An array of nodes that implement their `updateBefore()` method.
   * @param {Array<Node>} updateAfterNodes - An array of nodes that implement their `updateAfter()` method.
   * @param {NodeMaterialObserver} observer - A node material observer.
   * @param {Array<Object>} transforms - An array with transform attribute objects. Only relevant when using compute shaders with WebGL 2.
   */
  constructor(e, t, n, r, s, o, a, l, u, c = []) {
    this.vertexShader = e, this.fragmentShader = t, this.computeShader = n, this.transforms = c, this.nodeAttributes = r, this.bindings = s, this.updateNodes = o, this.updateBeforeNodes = a, this.updateAfterNodes = l, this.observer = u, this.usedTimes = 0;
  }
  /**
   * This method is used to create a array of bind groups based
   * on the existing bind groups of this state. Shared groups are
   * not cloned.
   *
   * @return {Array<BindGroup>} A array of bind groups.
   */
  createBindings() {
    const e = [];
    for (const t of this.bindings)
      if (t.bindings[0].groupNode.shared !== !0) {
        const r = new Jb(t.name, [], t.index, t.bindingsReference);
        e.push(r);
        for (const s of t.bindings)
          r.bindings.push(s.clone());
      } else
        e.push(t);
    return e;
  }
}
class aC {
  /**
   * Constructs a new node attribute.
   *
   * @param {string} name - The name of the attribute.
   * @param {string} type - The type of the attribute.
   * @param {?Node} node - An optional reference to the node.
   */
  constructor(e, t, n = null) {
    this.isNodeAttribute = !0, this.name = e, this.type = t, this.node = n;
  }
}
class xoe {
  /**
   * Constructs a new node uniform.
   *
   * @param {string} name - The name of the uniform.
   * @param {string} type - The type of the uniform.
   * @param {UniformNode} node - An reference to the node.
   */
  constructor(e, t, n) {
    this.isNodeUniform = !0, this.name = e, this.type = t, this.node = n;
  }
  /**
   * The value of the uniform node.
   *
   * @type {any}
   */
  get value() {
    return this.node.value;
  }
  set value(e) {
    this.node.value = e;
  }
  /**
   * The id of the uniform node.
   *
   * @type {number}
   */
  get id() {
    return this.node.id;
  }
  /**
   * The uniform node's group.
   *
   * @type {UniformGroupNode}
   */
  get groupNode() {
    return this.node.groupNode;
  }
}
class vI {
  /**
   * Constructs a new node variable.
   *
   * @param {string} name - The name of the variable.
   * @param {string} type - The type of the variable.
   * @param {boolean} [readOnly=false] - The read-only flag.
   * @param {?number} [count=null] - The size.
   */
  constructor(e, t, n = !1, r = null) {
    this.isNodeVar = !0, this.name = e, this.type = t, this.readOnly = n, this.count = r;
  }
}
class yoe extends vI {
  /**
   * Constructs a new node varying.
   *
   * @param {string} name - The name of the varying.
   * @param {string} type - The type of the varying.
   * @param {?string} interpolationType - The interpolation type of the varying.
   * @param {?string} interpolationSampling - The interpolation sampling type of the varying.
   */
  constructor(e, t, n = null, r = null) {
    super(e, t), this.needsInterpolation = !1, this.isNodeVarying = !0, this.interpolationType = n, this.interpolationSampling = r;
  }
}
class voe {
  /**
   * Constructs a new code node.
   *
   * @param {string} name - The name of the code.
   * @param {string} type - The node type.
   * @param {string} [code=''] - The native shader code.
   */
  constructor(e, t, n = "") {
    this.name = e, this.type = t, this.code = n, Object.defineProperty(this, "isNodeCode", { value: !0 });
  }
}
let boe = 0;
class uv {
  /**
   * Constructs a new node cache.
   *
   * @param {?NodeCache} parent - A reference to a parent cache.
   */
  constructor(e = null) {
    this.id = boe++, this.nodesData = /* @__PURE__ */ new WeakMap(), this.parent = e;
  }
  /**
   * Returns the data for the given node.
   *
   * @param {Node} node - The node.
   * @return {?Object} The data for the node.
   */
  getData(e) {
    let t = this.nodesData.get(e);
    return t === void 0 && this.parent !== null && (t = this.parent.getData(e)), t;
  }
  /**
   * Sets the data for a given node.
   *
   * @param {Node} node - The node.
   * @param {Object} data - The data that should be cached.
   */
  setData(e, t) {
    this.nodesData.set(e, t);
  }
}
class Soe {
  constructor(e, t) {
    this.name = e, this.members = t, this.output = !1;
  }
}
class lc {
  /**
   * Constructs a new uniform.
   *
   * @param {string} name - The uniform's name.
   * @param {any} value - The uniform's value.
   */
  constructor(e, t) {
    this.name = e, this.value = t, this.boundary = 0, this.itemSize = 0, this.offset = 0;
  }
  /**
   * Sets the uniform's value.
   *
   * @param {any} value - The value to set.
   */
  setValue(e) {
    this.value = e;
  }
  /**
   * Returns the uniform's value.
   *
   * @return {any} The value.
   */
  getValue() {
    return this.value;
  }
}
class Toe extends lc {
  /**
   * Constructs a new Number uniform.
   *
   * @param {string} name - The uniform's name.
   * @param {number} value - The uniform's value.
   */
  constructor(e, t = 0) {
    super(e, t), this.isNumberUniform = !0, this.boundary = 4, this.itemSize = 1;
  }
}
class woe extends lc {
  /**
   * Constructs a new Number uniform.
   *
   * @param {string} name - The uniform's name.
   * @param {Vector2} value - The uniform's value.
   */
  constructor(e, t = new Le()) {
    super(e, t), this.isVector2Uniform = !0, this.boundary = 8, this.itemSize = 2;
  }
}
class Moe extends lc {
  /**
   * Constructs a new Number uniform.
   *
   * @param {string} name - The uniform's name.
   * @param {Vector3} value - The uniform's value.
   */
  constructor(e, t = new j()) {
    super(e, t), this.isVector3Uniform = !0, this.boundary = 16, this.itemSize = 3;
  }
}
class Eoe extends lc {
  /**
   * Constructs a new Number uniform.
   *
   * @param {string} name - The uniform's name.
   * @param {Vector4} value - The uniform's value.
   */
  constructor(e, t = new Kt()) {
    super(e, t), this.isVector4Uniform = !0, this.boundary = 16, this.itemSize = 4;
  }
}
class Roe extends lc {
  /**
   * Constructs a new Number uniform.
   *
   * @param {string} name - The uniform's name.
   * @param {Color} value - The uniform's value.
   */
  constructor(e, t = new ct()) {
    super(e, t), this.isColorUniform = !0, this.boundary = 16, this.itemSize = 3;
  }
}
class Coe extends lc {
  /**
   * Constructs a new Number uniform.
   *
   * @param {string} name - The uniform's name.
   * @param {Matrix2} value - The uniform's value.
   */
  constructor(e, t = new D0()) {
    super(e, t), this.isMatrix2Uniform = !0, this.boundary = 8, this.itemSize = 4;
  }
}
class Poe extends lc {
  /**
   * Constructs a new Number uniform.
   *
   * @param {string} name - The uniform's name.
   * @param {Matrix3} value - The uniform's value.
   */
  constructor(e, t = new fn()) {
    super(e, t), this.isMatrix3Uniform = !0, this.boundary = 48, this.itemSize = 12;
  }
}
class Noe extends lc {
  /**
   * Constructs a new Number uniform.
   *
   * @param {string} name - The uniform's name.
   * @param {Matrix4} value - The uniform's value.
   */
  constructor(e, t = new Mt()) {
    super(e, t), this.isMatrix4Uniform = !0, this.boundary = 64, this.itemSize = 16;
  }
}
class Doe extends Toe {
  /**
   * Constructs a new node-based Number uniform.
   *
   * @param {NodeUniform} nodeUniform - The node uniform.
   */
  constructor(e) {
    super(e.name, e.value), this.nodeUniform = e;
  }
  /**
   * Overwritten to return the value of the node uniform.
   *
   * @return {number} The value.
   */
  getValue() {
    return this.nodeUniform.value;
  }
  /**
   * Returns the node uniform data type.
   *
   * @return {string} The data type.
   */
  getType() {
    return this.nodeUniform.type;
  }
}
class Loe extends woe {
  /**
   * Constructs a new node-based Vector2 uniform.
   *
   * @param {NodeUniform} nodeUniform - The node uniform.
   */
  constructor(e) {
    super(e.name, e.value), this.nodeUniform = e;
  }
  /**
   * Overwritten to return the value of the node uniform.
   *
   * @return {Vector2} The value.
   */
  getValue() {
    return this.nodeUniform.value;
  }
  /**
   * Returns the node uniform data type.
   *
   * @return {string} The data type.
   */
  getType() {
    return this.nodeUniform.type;
  }
}
class Ioe extends Moe {
  /**
   * Constructs a new node-based Vector3 uniform.
   *
   * @param {NodeUniform} nodeUniform - The node uniform.
   */
  constructor(e) {
    super(e.name, e.value), this.nodeUniform = e;
  }
  /**
   * Overwritten to return the value of the node uniform.
   *
   * @return {Vector3} The value.
   */
  getValue() {
    return this.nodeUniform.value;
  }
  /**
   * Returns the node uniform data type.
   *
   * @return {string} The data type.
   */
  getType() {
    return this.nodeUniform.type;
  }
}
class Boe extends Eoe {
  /**
   * Constructs a new node-based Vector4 uniform.
   *
   * @param {NodeUniform} nodeUniform - The node uniform.
   */
  constructor(e) {
    super(e.name, e.value), this.nodeUniform = e;
  }
  /**
   * Overwritten to return the value of the node uniform.
   *
   * @return {Vector4} The value.
   */
  getValue() {
    return this.nodeUniform.value;
  }
  /**
   * Returns the node uniform data type.
   *
   * @return {string} The data type.
   */
  getType() {
    return this.nodeUniform.type;
  }
}
class Foe extends Roe {
  /**
   * Constructs a new node-based Color uniform.
   *
   * @param {NodeUniform} nodeUniform - The node uniform.
   */
  constructor(e) {
    super(e.name, e.value), this.nodeUniform = e;
  }
  /**
   * Overwritten to return the value of the node uniform.
   *
   * @return {Color} The value.
   */
  getValue() {
    return this.nodeUniform.value;
  }
  /**
   * Returns the node uniform data type.
   *
   * @return {string} The data type.
   */
  getType() {
    return this.nodeUniform.type;
  }
}
class Uoe extends Coe {
  /**
   * Constructs a new node-based Matrix2 uniform.
   *
   * @param {NodeUniform} nodeUniform - The node uniform.
   */
  constructor(e) {
    super(e.name, e.value), this.nodeUniform = e;
  }
  /**
   * Overwritten to return the value of the node uniform.
   *
   * @return {Matrix2} The value.
   */
  getValue() {
    return this.nodeUniform.value;
  }
  /**
   * Returns the node uniform data type.
   *
   * @return {string} The data type.
   */
  getType() {
    return this.nodeUniform.type;
  }
}
class Ooe extends Poe {
  /**
   * Constructs a new node-based Matrix3 uniform.
   *
   * @param {NodeUniform} nodeUniform - The node uniform.
   */
  constructor(e) {
    super(e.name, e.value), this.nodeUniform = e;
  }
  /**
   * Overwritten to return the value of the node uniform.
   *
   * @return {Matrix3} The value.
   */
  getValue() {
    return this.nodeUniform.value;
  }
  /**
   * Returns the node uniform data type.
   *
   * @return {string} The data type.
   */
  getType() {
    return this.nodeUniform.type;
  }
}
class koe extends Noe {
  /**
   * Constructs a new node-based Matrix4 uniform.
   *
   * @param {NodeUniform} nodeUniform - The node uniform.
   */
  constructor(e) {
    super(e.name, e.value), this.nodeUniform = e;
  }
  /**
   * Overwritten to return the value of the node uniform.
   *
   * @return {Matrix4} The value.
   */
  getValue() {
    return this.nodeUniform.value;
  }
  /**
   * Returns the node uniform data type.
   *
   * @return {string} The data type.
   */
  getType() {
    return this.nodeUniform.type;
  }
}
let Voe = 0;
const Goe = /* @__PURE__ */ new WeakMap(), lC = /* @__PURE__ */ new WeakMap(), zoe = /* @__PURE__ */ new Map([
  [Int8Array, "int"],
  [Int16Array, "int"],
  [Int32Array, "int"],
  [Uint8Array, "uint"],
  [Uint16Array, "uint"],
  [Uint32Array, "uint"],
  [Float32Array, "float"]
]), Sg = (i) => /e/g.test(i) ? String(i).replace(/\+/g, "") : (i = Number(i), i + (i % 1 ? "" : ".0"));
class bI {
  /**
   * Constructs a new node builder.
   *
   * @param {Object3D} object - The 3D object.
   * @param {Renderer} renderer - The current renderer.
   * @param {NodeParser} parser - A reference to a node parser.
   */
  constructor(e, t, n) {
    this.object = e, this.material = e && e.material || null, this.geometry = e && e.geometry || null, this.renderer = t, this.parser = n, this.scene = null, this.camera = null, this.nodes = [], this.sequentialNodes = [], this.updateNodes = [], this.updateBeforeNodes = [], this.updateAfterNodes = [], this.hashNodes = {}, this.observer = null, this.lightsNode = null, this.environmentNode = null, this.fogNode = null, this.clippingContext = null, this.vertexShader = null, this.fragmentShader = null, this.computeShader = null, this.flowNodes = { vertex: [], fragment: [], compute: [] }, this.flowCode = { vertex: "", fragment: "", compute: "" }, this.uniforms = { vertex: [], fragment: [], compute: [], index: 0 }, this.structs = { vertex: [], fragment: [], compute: [], index: 0 }, this.types = { vertex: [], fragment: [], compute: [], index: 0 }, this.bindings = { vertex: {}, fragment: {}, compute: {} }, this.bindingsIndexes = {}, this.bindGroups = null, this.attributes = [], this.bufferAttributes = [], this.varyings = [], this.codes = {}, this.vars = {}, this.declarations = {}, this.flow = { code: "" }, this.chaining = [], this.stack = o1(), this.stacks = [], this.tab = "	", this.currentFunctionNode = null, this.context = {
      material: this.material
    }, this.cache = new uv(), this.globalCache = this.cache, this.flowsData = /* @__PURE__ */ new WeakMap(), this.shaderStage = null, this.buildStage = null, this.subBuildLayers = [], this.activeStacks = [], this.subBuildFn = null, this.fnCall = null, Object.defineProperty(this, "id", { value: Voe++ });
  }
  /**
   * Whether the material is opaque or not.
   *
   * @return {boolean} Whether the material is opaque or not.
   */
  isOpaque() {
    const e = this.material;
    return e.transparent === !1 && e.blending === gs && e.alphaToCoverage === !1;
  }
  /**
   * Returns the bind groups of the current renderer.
   *
   * @return {ChainMap} The cache.
   */
  getBindGroupsCache() {
    let e = lC.get(this.renderer);
    return e === void 0 && (e = new wa(), lC.set(this.renderer, e)), e;
  }
  /**
   * Factory method for creating an instance of {@link RenderTarget} with the given
   * dimensions and options.
   *
   * @param {number} width - The width of the render target.
   * @param {number} height - The height of the render target.
   * @param {Object} options - The options of the render target.
   * @return {RenderTarget} The render target.
   */
  createRenderTarget(e, t, n) {
    return new Ma(e, t, n);
  }
  /**
   * Factory method for creating an instance of {@link CubeRenderTarget} with the given
   * dimensions and options.
   *
   * @param {number} size - The size of the cube render target.
   * @param {Object} options - The options of the cube render target.
   * @return {CubeRenderTarget} The cube render target.
   */
  createCubeRenderTarget(e, t) {
    return new sL(e, t);
  }
  /**
   * Whether the given node is included in the internal array of nodes or not.
   *
   * @param {Node} node - The node to test.
   * @return {boolean} Whether the given node is included in the internal array of nodes or not.
   */
  includes(e) {
    return this.nodes.includes(e);
  }
  /**
   * Returns the output struct name which is required by
   * {@link OutputStructNode}.
   *
   * @abstract
   * @return {string} The name of the output struct.
   */
  getOutputStructName() {
  }
  /**
   * Returns a bind group for the given group name and binding.
   *
   * @private
   * @param {string} groupName - The group name.
   * @param {Array<NodeUniformsGroup>} bindings - List of bindings.
   * @return {BindGroup} The bind group
   */
  _getBindGroup(e, t) {
    const n = this.getBindGroupsCache(), r = [];
    let s = !0;
    for (const a of t)
      r.push(a), s = s && a.groupNode.shared !== !0;
    let o;
    return s ? (o = n.get(r), o === void 0 && (o = new Jb(e, r, this.bindingsIndexes[e].group, r), n.set(r, o))) : o = new Jb(e, r, this.bindingsIndexes[e].group, r), o;
  }
  /**
   * Returns an array of node uniform groups for the given group name and shader stage.
   *
   * @param {string} groupName - The group name.
   * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
   * @return {Array<NodeUniformsGroup>} The array of node uniform groups.
   */
  getBindGroupArray(e, t) {
    const n = this.bindings[t];
    let r = n[e];
    return r === void 0 && (this.bindingsIndexes[e] === void 0 && (this.bindingsIndexes[e] = { binding: 0, group: Object.keys(this.bindingsIndexes).length }), n[e] = r = []), r;
  }
  /**
   * Returns a list bindings of all shader stages separated by groups.
   *
   * @return {Array<BindGroup>} The list of bindings.
   */
  getBindings() {
    let e = this.bindGroups;
    if (e === null) {
      const t = {}, n = this.bindings;
      for (const r of Lb)
        for (const s in n[r]) {
          const o = n[r][s];
          (t[s] || (t[s] = [])).push(...o);
        }
      e = [];
      for (const r in t) {
        const s = t[r], o = this._getBindGroup(r, s);
        e.push(o);
      }
      this.bindGroups = e;
    }
    return e;
  }
  /**
   * Sorts the bind groups and updates {@link NodeBuilder#bindingsIndexes}.
   */
  sortBindingGroups() {
    const e = this.getBindings();
    e.sort((t, n) => t.bindings[0].groupNode.order - n.bindings[0].groupNode.order);
    for (let t = 0; t < e.length; t++) {
      const n = e[t];
      this.bindingsIndexes[n.name].group = t, n.index = t;
    }
  }
  /**
   * The builder maintains each node in a hash-based dictionary.
   * This method sets the given node (value) with the given hash (key) into this dictionary.
   *
   * @param {Node} node - The node to add.
   * @param {number} hash - The hash of the node.
   */
  setHashNode(e, t) {
    this.hashNodes[t] = e;
  }
  /**
   * Adds a node to this builder.
   *
   * @param {Node} node - The node to add.
   */
  addNode(e) {
    this.nodes.includes(e) === !1 && (this.nodes.push(e), this.setHashNode(e, e.getHash(this)));
  }
  /**
   * It is used to add Nodes that will be used as FRAME and RENDER events,
   * and need to follow a certain sequence in the calls to work correctly.
   * This function should be called after 'setup()' in the 'build()' process to ensure that the child nodes are processed first.
   *
   * @param {Node} node - The node to add.
   */
  addSequentialNode(e) {
    this.sequentialNodes.includes(e) === !1 && this.sequentialNodes.push(e);
  }
  /**
   * Checks the update types of nodes
   */
  buildUpdateNodes() {
    for (const e of this.nodes)
      e.getUpdateType() !== hn.NONE && this.updateNodes.push(e);
    for (const e of this.sequentialNodes) {
      const t = e.getUpdateBeforeType(), n = e.getUpdateAfterType();
      t !== hn.NONE && this.updateBeforeNodes.push(e), n !== hn.NONE && this.updateAfterNodes.push(e);
    }
  }
  /**
   * A reference the current node which is the
   * last node in the chain of nodes.
   *
   * @type {Node}
   */
  get currentNode() {
    return this.chaining[this.chaining.length - 1];
  }
  /**
   * Whether the given texture is filtered or not.
   *
   * @param {Texture} texture - The texture to check.
   * @return {boolean} Whether the given texture is filtered or not.
   */
  isFilteredTexture(e) {
    return e.magFilter === qn || e.magFilter === Uu || e.magFilter === Aa || e.magFilter === $r || e.minFilter === qn || e.minFilter === Uu || e.minFilter === Aa || e.minFilter === $r;
  }
  /**
   * Adds the given node to the internal node chain.
   * This is used to check recursive calls in node-graph.
   *
   * @param {Node} node - The node to add.
   */
  addChain(e) {
    this.chaining.push(e);
  }
  /**
   * Removes the given node from the internal node chain.
   *
   * @param {Node} node - The node to remove.
   */
  removeChain(e) {
    if (this.chaining.pop() !== e)
      throw new Error("NodeBuilder: Invalid node chaining!");
  }
  /**
   * Returns the native shader method name for a given generic name. E.g.
   * the method name `textureDimensions` matches the WGSL name but must be
   * resolved to `textureSize` in GLSL.
   *
   * @abstract
   * @param {string} method - The method name to resolve.
   * @return {string} The resolved method name.
   */
  getMethod(e) {
    return e;
  }
  /**
   * Returns the native snippet for a ternary operation. E.g. GLSL would output
   * a ternary op as `cond ? x : y` whereas WGSL would output it as `select(y, x, cond)`
   *
   * @abstract
   * @param {string} condSnippet - The condition determining which expression gets resolved.
   * @param {string} ifSnippet - The expression to resolve to if the condition is true.
   * @param {string} elseSnippet - The expression to resolve to if the condition is false.
   * @return {string} The resolved method name.
   */
  getTernary() {
    return null;
  }
  /**
   * Returns a node for the given hash, see {@link NodeBuilder#setHashNode}.
   *
   * @param {number} hash - The hash of the node.
   * @return {Node} The found node.
   */
  getNodeFromHash(e) {
    return this.hashNodes[e];
  }
  /**
   * Adds the Node to a target flow so that it can generate code in the 'generate' process.
   *
   * @param {('vertex'|'fragment'|'compute')} shaderStage - The shader stage.
   * @param {Node} node - The node to add.
   * @return {Node} The node.
   */
  addFlow(e, t) {
    return this.flowNodes[e].push(t), t;
  }
  /**
   * Sets builder's context.
   *
   * @param {Object} context - The context to set.
   */
  setContext(e) {
    this.context = e;
  }
  /**
   * Returns the builder's current context.
   *
   * @return {Object} The builder's current context.
   */
  getContext() {
    return this.context;
  }
  /**
   * Adds context data to the builder's current context.
   *
   * @param {Object} context - The context to add.
   * @return {Object} The previous context.
   */
  addContext(e) {
    const t = this.getContext();
    return this.setContext({ ...this.context, ...e }), t;
  }
  /**
   * Gets a context used in shader construction that can be shared across different materials.
   * This is necessary since the renderer cache can reuse shaders generated in one material and use them in another.
   *
   * @return {Object} The builder's current context without material.
   */
  getSharedContext() {
    const e = { ...this.context };
    return delete e.material, delete e.getUV, delete e.getOutput, delete e.getTextureLevel, delete e.getAO, delete e.getShadow, e;
  }
  /**
   * Sets builder's cache.
   *
   * @param {NodeCache} cache - The cache to set.
   */
  setCache(e) {
    this.cache = e;
  }
  /**
   * Returns the builder's current cache.
   *
   * @return {NodeCache} The builder's current cache.
   */
  getCache() {
    return this.cache;
  }
  /**
   * Returns a cache for the given node.
   *
   * @param {Node} node - The node.
   * @param {boolean} [parent=true] - Whether this node refers to a shared parent cache or not.
   * @return {NodeCache} The cache.
   */
  getCacheFromNode(e, t = !0) {
    const n = this.getDataFromNode(e);
    return n.cache === void 0 && (n.cache = new uv(t ? this.getCache() : null)), n.cache;
  }
  /**
   * Whether the requested feature is available or not.
   *
   * @abstract
   * @param {string} name - The requested feature.
   * @return {boolean} Whether the requested feature is supported or not.
   */
  isAvailable() {
    return !1;
  }
  /**
   * Returns the vertexIndex input variable as a native shader string.
   *
   * @abstract
   * @return {string} The instanceIndex shader string.
   */
  getVertexIndex() {
    Me("Abstract function.");
  }
  /**
   * Contextually returns either the vertex stage instance index builtin
   * or the linearized index of an compute invocation within a grid of workgroups.
   *
   * @abstract
   * @return {string} The instanceIndex shader string.
   */
  getInstanceIndex() {
    Me("Abstract function.");
  }
  /**
   * Returns the drawIndex input variable as a native shader string.
   * Only relevant for WebGL and its `WEBGL_multi_draw` extension.
   *
   * @abstract
   * @return {?string} The drawIndex shader string.
   */
  getDrawIndex() {
    Me("Abstract function.");
  }
  /**
   * Returns the frontFacing input variable as a native shader string.
   *
   * @abstract
   * @return {string} The frontFacing shader string.
   */
  getFrontFacing() {
    Me("Abstract function.");
  }
  /**
   * Returns the fragCoord input variable as a native shader string.
   *
   * @abstract
   * @return {string} The fragCoord shader string.
   */
  getFragCoord() {
    Me("Abstract function.");
  }
  /**
   * Whether to flip texture data along its vertical axis or not. WebGL needs
   * this method evaluate to `true`, WebGPU to `false`.
   *
   * @abstract
   * @return {boolean} Whether to flip texture data along its vertical axis or not.
   */
  isFlipY() {
    return !1;
  }
  /**
   * Calling this method increases the usage count for the given node by one.
   *
   * @param {Node} node - The node to increase the usage count for.
   * @return {number} The updated usage count.
   */
  increaseUsage(e) {
    const t = this.getDataFromNode(e);
    return t.usageCount = t.usageCount === void 0 ? 1 : t.usageCount + 1, t.usageCount;
  }
  /**
   * Generates a texture sample shader string for the given texture data.
   *
   * @abstract
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The texture property name.
   * @param {string} uvSnippet - Snippet defining the texture coordinates.
   * @return {string} The generated shader string.
   */
  generateTexture() {
    Me("Abstract function.");
  }
  /**
   * Generates a texture LOD shader string for the given texture data.
   *
   * @abstract
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The texture property name.
   * @param {string} uvSnippet - Snippet defining the texture coordinates.
   * @param {?string} depthSnippet - Snippet defining the 0-based texture array index to sample.
   * @param {string} levelSnippet - Snippet defining the mip level.
   * @return {string} The generated shader string.
   */
  generateTextureLod() {
    Me("Abstract function.");
  }
  /**
   * Generates the array declaration string.
   *
   * @param {string} type - The type.
   * @param {?number} [count] - The count.
   * @return {string} The generated value as a shader string.
   */
  generateArrayDeclaration(e, t) {
    return this.getType(e) + "[ " + t + " ]";
  }
  /**
   * Generates the array shader string for the given type and value.
   *
   * @param {string} type - The type.
   * @param {?number} [count] - The count.
   * @param {?Array<Node>} [values=null] - The default values.
   * @return {string} The generated value as a shader string.
   */
  generateArray(e, t, n = null) {
    let r = this.generateArrayDeclaration(e, t) + "( ";
    for (let s = 0; s < t; s++) {
      const o = n ? n[s] : null;
      o !== null ? r += o.build(this, e) : r += this.generateConst(e), s < t - 1 && (r += ", ");
    }
    return r += " )", r;
  }
  /**
   * Generates the struct shader string.
   *
   * @param {string} type - The type.
   * @param {Array<Object>} [membersLayout] - The count.
   * @param {?Array<Node>} [values=null] - The default values.
   * @return {string} The generated value as a shader string.
   */
  generateStruct(e, t, n = null) {
    const r = [];
    for (const s of t) {
      const { name: o, type: a } = s;
      n && n[o] && n[o].isNode ? r.push(n[o].build(this, a)) : r.push(this.generateConst(a));
    }
    return e + "( " + r.join(", ") + " )";
  }
  /**
   * Generates the shader string for the given type and value.
   *
   * @param {string} type - The type.
   * @param {?any} [value=null] - The value.
   * @return {string} The generated value as a shader string.
   */
  generateConst(e, t = null) {
    if (t === null && (e === "float" || e === "int" || e === "uint" ? t = 0 : e === "bool" ? t = !1 : e === "color" ? t = new ct() : e === "vec2" || e === "uvec2" || e === "ivec2" ? t = new Le() : e === "vec3" || e === "uvec3" || e === "ivec3" ? t = new j() : (e === "vec4" || e === "uvec4" || e === "ivec4") && (t = new Kt())), e === "float") return Sg(t);
    if (e === "int") return `${Math.round(t)}`;
    if (e === "uint") return t >= 0 ? `${Math.round(t)}u` : "0u";
    if (e === "bool") return t ? "true" : "false";
    if (e === "color") return `${this.getType("vec3")}( ${Sg(t.r)}, ${Sg(t.g)}, ${Sg(t.b)} )`;
    const n = this.getTypeLength(e), r = this.getComponentType(e), s = (o) => this.generateConst(r, o);
    if (n === 2)
      return `${this.getType(e)}( ${s(t.x)}, ${s(t.y)} )`;
    if (n === 3)
      return `${this.getType(e)}( ${s(t.x)}, ${s(t.y)}, ${s(t.z)} )`;
    if (n === 4 && e !== "mat2")
      return `${this.getType(e)}( ${s(t.x)}, ${s(t.y)}, ${s(t.z)}, ${s(t.w)} )`;
    if (n >= 4 && t && (t.isMatrix2 || t.isMatrix3 || t.isMatrix4))
      return `${this.getType(e)}( ${t.elements.map(s).join(", ")} )`;
    if (n > 4)
      return `${this.getType(e)}()`;
    throw new Error(`NodeBuilder: Type '${e}' not found in generate constant attempt.`);
  }
  /**
   * It might be necessary to convert certain data types to different ones
   * so this method can be used to hide the conversion.
   *
   * @param {string} type - The type.
   * @return {string} The updated type.
   */
  getType(e) {
    return e === "color" ? "vec3" : e;
  }
  /**
   * Whether the given attribute name is defined in the geometry or not.
   *
   * @param {string} name - The attribute name.
   * @return {boolean} Whether the given attribute name is defined in the geometry.
   */
  hasGeometryAttribute(e) {
    return this.geometry && this.geometry.getAttribute(e) !== void 0;
  }
  /**
   * Returns a node attribute for the given name and type.
   *
   * @param {string} name - The attribute's name.
   * @param {string} type - The attribute's type.
   * @return {NodeAttribute} The node attribute.
   */
  getAttribute(e, t) {
    const n = this.attributes;
    for (const s of n)
      if (s.name === e)
        return s;
    const r = new aC(e, t);
    return this.registerDeclaration(r), n.push(r), r;
  }
  /**
   * Returns for the given node and shader stage the property name for the shader.
   *
   * @param {Node} node - The node.
   * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
   * @return {string} The property name.
   */
  getPropertyName(e) {
    return e.name;
  }
  /**
   * Whether the given type is a vector type or not.
   *
   * @param {string} type - The type to check.
   * @return {boolean} Whether the given type is a vector type or not.
   */
  isVector(e) {
    return /vec\d/.test(e);
  }
  /**
   * Whether the given type is a matrix type or not.
   *
   * @param {string} type - The type to check.
   * @return {boolean} Whether the given type is a matrix type or not.
   */
  isMatrix(e) {
    return /mat\d/.test(e);
  }
  /**
   * Whether the given type is a reference type or not.
   *
   * @param {string} type - The type to check.
   * @return {boolean} Whether the given type is a reference type or not.
   */
  isReference(e) {
    return e === "void" || e === "property" || e === "sampler" || e === "samplerComparison" || e === "texture" || e === "cubeTexture" || e === "storageTexture" || e === "depthTexture" || e === "texture3D";
  }
  /**
   * Checks if the given texture requires a manual conversion to the working color space.
   *
   * @abstract
   * @param {Texture} texture - The texture to check.
   * @return {boolean} Whether the given texture requires a conversion to working color space or not.
   */
  needsToWorkingColorSpace() {
    return !1;
  }
  /**
   * Returns the component type of a given texture.
   *
   * @param {Texture} texture - The texture.
   * @return {string} The component type.
   */
  getComponentTypeFromTexture(e) {
    const t = e.type;
    if (e.isDataTexture) {
      if (t === _r) return "int";
      if (t === Jn) return "uint";
    }
    return "float";
  }
  /**
   * Returns the element type for a given type.
   *
   * @param {string} type - The type.
   * @return {string} The element type.
   */
  getElementType(e) {
    return e === "mat2" ? "vec2" : e === "mat3" ? "vec3" : e === "mat4" ? "vec4" : this.getComponentType(e);
  }
  /**
   * Returns the component type for a given type.
   *
   * @param {string} type - The type.
   * @return {string} The component type.
   */
  getComponentType(e) {
    if (e = this.getVectorType(e), e === "float" || e === "bool" || e === "int" || e === "uint") return e;
    const t = /(b|i|u|)(vec|mat)([2-4])/.exec(e);
    return t === null ? null : t[1] === "b" ? "bool" : t[1] === "i" ? "int" : t[1] === "u" ? "uint" : "float";
  }
  /**
   * Returns the vector type for a given type.
   *
   * @param {string} type - The type.
   * @return {string} The vector type.
   */
  getVectorType(e) {
    return e === "color" ? "vec3" : e === "texture" || e === "cubeTexture" || e === "storageTexture" || e === "texture3D" ? "vec4" : e;
  }
  /**
   * Returns the data type for the given the length and component type.
   *
   * @param {number} length - The length.
   * @param {string} [componentType='float'] - The component type.
   * @return {string} The type.
   */
  getTypeFromLength(e, t = "float") {
    if (e === 1) return t;
    let n = QP(e);
    const r = t === "float" ? "" : t[0];
    return /mat2/.test(t) === !0 && (n = n.replace("vec", "mat")), r + n;
  }
  /**
   * Returns the type for a given typed array.
   *
   * @param {TypedArray} array - The typed array.
   * @return {string} The type.
   */
  getTypeFromArray(e) {
    return zoe.get(e.constructor);
  }
  /**
   * Returns the type is an integer type.
   *
   * @param {string} type - The type.
   * @return {boolean} Whether the type is an integer type or not.
   */
  isInteger(e) {
    return /int|uint|(i|u)vec/.test(e);
  }
  /**
   * Returns the type for a given buffer attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute.
   * @return {string} The type.
   */
  getTypeFromAttribute(e) {
    let t = e;
    e.isInterleavedBufferAttribute && (t = e.data);
    const n = t.array, r = e.itemSize, s = e.normalized;
    let o;
    return !(e instanceof N3) && s !== !0 && (o = this.getTypeFromArray(n)), this.getTypeFromLength(r, o);
  }
  /**
   * Returns the length for the given data type.
   *
   * @param {string} type - The data type.
   * @return {number} The length.
   */
  getTypeLength(e) {
    const t = this.getVectorType(e), n = /vec([2-4])/.exec(t);
    return n !== null ? Number(n[1]) : t === "float" || t === "bool" || t === "int" || t === "uint" ? 1 : /mat2/.test(e) === !0 ? 4 : /mat3/.test(e) === !0 ? 9 : /mat4/.test(e) === !0 ? 16 : 0;
  }
  /**
   * Returns the vector type for a given matrix type.
   *
   * @param {string} type - The matrix type.
   * @return {string} The vector type.
   */
  getVectorFromMatrix(e) {
    return e.replace("mat", "vec");
  }
  /**
   * For a given type this method changes the component type to the
   * given value. E.g. `vec4` should be changed to the new component type
   * `uint` which results in `uvec4`.
   *
   * @param {string} type - The type.
   * @param {string} newComponentType - The new component type.
   * @return {string} The new type.
   */
  changeComponentType(e, t) {
    return this.getTypeFromLength(this.getTypeLength(e), t);
  }
  /**
   * Returns the integer type pendant for the given type.
   *
   * @param {string} type - The type.
   * @return {string} The integer type.
   */
  getIntegerType(e) {
    const t = this.getComponentType(e);
    return t === "int" || t === "uint" ? e : this.changeComponentType(e, "int");
  }
  /**
   * Adds an active stack to the internal stack.
   *
   * @param {StackNode} stack - The stack node to add.
   */
  setActiveStack(e) {
    this.activeStacks.push(e);
  }
  /**
   * Removes the active stack from the internal stack.
   *
   * @param {StackNode} stack - The stack node to remove.
   */
  removeActiveStack(e) {
    if (this.activeStacks[this.activeStacks.length - 1] === e)
      this.activeStacks.pop();
    else
      throw new Error("NodeBuilder: Invalid active stack removal.");
  }
  /**
   * Returns the active stack.
   *
   * @return {StackNode} The active stack.
   */
  getActiveStack() {
    return this.activeStacks[this.activeStacks.length - 1];
  }
  /**
   * Returns the base stack.
   *
   * @return {StackNode} The base stack.
   */
  getBaseStack() {
    return this.activeStacks[0];
  }
  /**
   * Adds a stack node to the internal stack.
   *
   * @return {StackNode} The added stack node.
   */
  addStack() {
    this.stack = o1(this.stack);
    const e = VS();
    return this.stacks.push(e), s0(this.stack), this.stack;
  }
  /**
   * Removes the last stack node from the internal stack.
   *
   * @return {StackNode} The removed stack node.
   */
  removeStack() {
    const e = this.stack;
    for (const t of e.nodes) {
      const n = this.getDataFromNode(t);
      n.stack = e;
    }
    return this.stack = e.parent, s0(this.stacks.pop()), e;
  }
  /**
   * The builder maintains (cached) data for each node during the building process. This method
   * can be used to get these data for a specific shader stage and cache.
   *
   * @param {Node} node - The node to get the data for.
   * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage=this.shaderStage] - The shader stage.
   * @param {?NodeCache} cache - An optional cache.
   * @return {Object} The node data.
   */
  getDataFromNode(e, t = this.shaderStage, n = null) {
    n = n === null ? e.isGlobal(this) ? this.globalCache : this.cache : n;
    let r = n.getData(e);
    r === void 0 && (r = {}, n.setData(e, r)), r[t] === void 0 && (r[t] = {});
    let s = r[t];
    const o = r.any ? r.any.subBuilds : null, a = this.getClosestSubBuild(o);
    return a && (s.subBuildsCache === void 0 && (s.subBuildsCache = {}), s = s.subBuildsCache[a] || (s.subBuildsCache[a] = {}), s.subBuilds = o), s;
  }
  /**
   * Returns the properties for the given node and shader stage.
   *
   * Properties are typically used within a build stage to reference a node's
   * child node or nodes manually assigned to the properties in a separate build stage.
   * A typical usage pattern for defining nodes manually would be assigning dependency nodes
   * to the current node's properties in the setup stage and building those properties in the generate stage.
   *
   * @param {Node} node - The node to get the properties for.
   * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage='any'] - The shader stage.
   * @return {Object} The node properties.
   */
  getNodeProperties(e, t = "any") {
    const n = this.getDataFromNode(e, t);
    return n.properties || (n.properties = { outputNode: null });
  }
  /**
   * Returns an instance of {@link NodeAttribute} for the given buffer attribute node.
   *
   * @param {BufferAttributeNode} node - The buffer attribute node.
   * @param {string} type - The node type.
   * @return {NodeAttribute} The node attribute.
   */
  getBufferAttributeFromNode(e, t) {
    const n = this.getDataFromNode(e, "vertex");
    let r = n.bufferAttribute;
    if (r === void 0) {
      const s = this.uniforms.index++;
      r = new aC("nodeAttribute" + s, t, e), this.bufferAttributes.push(r), n.bufferAttribute = r;
    }
    return r;
  }
  /**
   * Returns an instance of {@link StructType} for the given struct name and shader stage
   * or null if not found.
   *
   * @param {string} name - The name of the struct.
   * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage=this.shaderStage] - The shader stage.
   * @return {?StructType} The struct type or null if not found.
   */
  getStructTypeNode(e, t = this.shaderStage) {
    return this.types[t][e] || null;
  }
  /**
   * Returns an instance of {@link StructType} for the given output struct node.
   *
   * @param {OutputStructNode} node - The output struct node.
   * @param {Array<Object>} membersLayout - The output struct types.
   * @param {?string} [name=null] - The name of the struct.
   * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage=this.shaderStage] - The shader stage.
   * @return {StructType} The struct type attribute.
   */
  getStructTypeFromNode(e, t, n = null, r = this.shaderStage) {
    const s = this.getDataFromNode(e, r, this.globalCache);
    let o = s.structType;
    if (o === void 0) {
      const a = this.structs.index++;
      n === null && (n = "StructType" + a), o = new Soe(n, t), this.structs[r].push(o), this.types[r][n] = e, s.structType = o;
    }
    return o;
  }
  /**
   * Returns an instance of {@link StructType} for the given output struct node.
   *
   * @param {OutputStructNode} node - The output struct node.
   * @param {Array<Object>} membersLayout - The output struct types.
   * @return {StructType} The struct type attribute.
   */
  getOutputStructTypeFromNode(e, t) {
    const n = this.getStructTypeFromNode(e, t, "OutputType", "fragment");
    return n.output = !0, n;
  }
  /**
   * Returns an instance of {@link NodeUniform} for the given uniform node.
   *
   * @param {UniformNode} node - The uniform node.
   * @param {string} type - The uniform type.
   * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage=this.shaderStage] - The shader stage.
   * @param {?string} name - The name of the uniform.
   * @return {NodeUniform} The node uniform.
   */
  getUniformFromNode(e, t, n = this.shaderStage, r = null) {
    const s = this.getDataFromNode(e, n, this.globalCache);
    let o = s.uniform;
    if (o === void 0) {
      const a = this.uniforms.index++;
      o = new xoe(r || "nodeUniform" + a, t, e), this.uniforms[n].push(o), this.registerDeclaration(o), s.uniform = o;
    }
    return o;
  }
  /**
   * Returns an instance of {@link NodeVar} for the given variable node.
   *
   * @param {VarNode} node - The variable node.
   * @param {?string} name - The variable's name.
   * @param {string} [type=node.getNodeType( this )] - The variable's type.
   * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage=this.shaderStage] - The shader stage.
   * @param {boolean} [readOnly=false] - Whether the variable is read-only or not.
   *
   * @return {NodeVar} The node variable.
   */
  getVarFromNode(e, t = null, n = e.getNodeType(this), r = this.shaderStage, s = !1) {
    const o = this.getDataFromNode(e, r), a = this.getSubBuildProperty("variable", o.subBuilds);
    let l = o[a];
    if (l === void 0) {
      const u = s ? "_const" : "_var", c = this.vars[r] || (this.vars[r] = []), A = this.vars[u] || (this.vars[u] = 0);
      t === null && (t = (s ? "nodeConst" : "nodeVar") + A, this.vars[u]++), a !== "variable" && (t = this.getSubBuildProperty(t, o.subBuilds));
      const m = e.getArrayCount(this);
      l = new vI(t, n, s, m), s || c.push(l), this.registerDeclaration(l), o[a] = l;
    }
    return l;
  }
  /**
   * Returns whether a Node or its flow is deterministic, useful for use in `const`.
   *
   * @param {Node} node - The varying node.
   * @return {boolean} Returns true if deterministic.
   */
  isDeterministic(e) {
    if (e.isMathNode)
      return this.isDeterministic(e.aNode) && (e.bNode ? this.isDeterministic(e.bNode) : !0) && (e.cNode ? this.isDeterministic(e.cNode) : !0);
    if (e.isOperatorNode)
      return this.isDeterministic(e.aNode) && (e.bNode ? this.isDeterministic(e.bNode) : !0);
    if (e.isArrayNode) {
      if (e.values !== null) {
        for (const t of e.values)
          if (!this.isDeterministic(t))
            return !1;
      }
      return !0;
    } else if (e.isConstNode)
      return !0;
    return !1;
  }
  /**
   * Returns an instance of {@link NodeVarying} for the given varying node.
   *
   * @param {(VaryingNode|PropertyNode)} node - The varying node.
   * @param {?string} name - The varying's name.
   * @param {string} [type=node.getNodeType( this )] - The varying's type.
   * @param {?string} interpolationType - The interpolation type of the varying.
   * @param {?string} interpolationSampling - The interpolation sampling type of the varying.
   * @return {NodeVar} The node varying.
   */
  getVaryingFromNode(e, t = null, n = e.getNodeType(this), r = null, s = null) {
    const o = this.getDataFromNode(e, "any"), a = this.getSubBuildProperty("varying", o.subBuilds);
    let l = o[a];
    if (l === void 0) {
      const u = this.varyings, c = u.length;
      t === null && (t = "nodeVarying" + c), a !== "varying" && (t = this.getSubBuildProperty(t, o.subBuilds)), l = new yoe(t, n, r, s), u.push(l), this.registerDeclaration(l), o[a] = l;
    }
    return l;
  }
  /**
   * Registers a node declaration in the current shader stage.
   *
   * @param {Object} node - The node to be registered.
   */
  registerDeclaration(e) {
    const t = this.shaderStage, n = this.declarations[t] || (this.declarations[t] = {}), r = this.getPropertyName(e);
    let s = 1, o = r;
    for (; n[o] !== void 0; )
      o = r + "_" + s++;
    s > 1 && (e.name = o, Me(`TSL: Declaration name '${r}' of '${e.type}' already in use. Renamed to '${o}'.`)), n[o] = e;
  }
  /**
   * Returns an instance of {@link NodeCode} for the given code node.
   *
   * @param {CodeNode} node - The code node.
   * @param {string} type - The node type.
   * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage=this.shaderStage] - The shader stage.
   * @return {NodeCode} The node code.
   */
  getCodeFromNode(e, t, n = this.shaderStage) {
    const r = this.getDataFromNode(e);
    let s = r.code;
    if (s === void 0) {
      const o = this.codes[n] || (this.codes[n] = []), a = o.length;
      s = new voe("nodeCode" + a, t), o.push(s), r.code = s;
    }
    return s;
  }
  /**
  	 * Adds a code flow based on the code-block hierarchy.

  	 * This is used so that code-blocks like If,Else create their variables locally if the Node
  	 * is only used inside one of these conditionals in the current shader stage.
  	 *
  	 * @param {Node} node - The node to add.
  	 * @param {Node} nodeBlock - Node-based code-block. Usually 'ConditionalNode'.
  	 */
  addFlowCodeHierarchy(e, t) {
    const { flowCodes: n, flowCodeBlock: r } = this.getDataFromNode(e);
    let s = !0, o = t;
    for (; o; ) {
      if (r.get(o) === !0) {
        s = !1;
        break;
      }
      o = this.getDataFromNode(o).parentNodeBlock;
    }
    if (s)
      for (const a of n)
        this.addLineFlowCode(a);
  }
  /**
   * Add a inline-code to the current flow code-block.
   *
   * @param {Node} node - The node to add.
   * @param {string} code - The code to add.
   * @param {Node} nodeBlock - Current ConditionalNode
   */
  addLineFlowCodeBlock(e, t, n) {
    const r = this.getDataFromNode(e), s = r.flowCodes || (r.flowCodes = []), o = r.flowCodeBlock || (r.flowCodeBlock = /* @__PURE__ */ new WeakMap());
    s.push(t), o.set(n, !0);
  }
  /**
   * Add a inline-code to the current flow.
   *
   * @param {string} code - The code to add.
   * @param {?Node} [node= null] - Optional Node, can help the system understand if the Node is part of a code-block.
   * @return {NodeBuilder} A reference to this node builder.
   */
  addLineFlowCode(e, t = null) {
    return e === "" ? this : (t !== null && this.context.nodeBlock && this.addLineFlowCodeBlock(t, e, this.context.nodeBlock), e = this.tab + e, /;\s*$/.test(e) || (e = e + `;
`), this.flow.code += e, this);
  }
  /**
   * Adds a code to the current code flow.
   *
   * @param {string} code - Shader code.
   * @return {NodeBuilder} A reference to this node builder.
   */
  addFlowCode(e) {
    return this.flow.code += e, this;
  }
  /**
   * Add tab in the code that will be generated so that other snippets respect the current tabulation.
   * Typically used in codes with If,Else.
   *
   * @return {NodeBuilder} A reference to this node builder.
   */
  addFlowTab() {
    return this.tab += "	", this;
  }
  /**
   * Removes a tab.
   *
   * @return {NodeBuilder} A reference to this node builder.
   */
  removeFlowTab() {
    return this.tab = this.tab.slice(0, -1), this;
  }
  /**
   * Gets the current flow data based on a Node.
   *
   * @param {Node} node - Node that the flow was started.
   * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
   * @return {Object} The flow data.
   */
  getFlowData(e) {
    return this.flowsData.get(e);
  }
  /**
   * Executes the node flow based on a root node to generate the final shader code.
   *
   * @param {Node} node - The node to execute.
   * @return {Object} The code flow.
   */
  flowNode(e) {
    const t = e.getNodeType(this), n = this.flowChildNode(e, t);
    return this.flowsData.set(e, n), n;
  }
  /**
   * Includes a node in the current function node.
   *
   * @param {Node} node - The node to include.
   * @returns {void}
   */
  addInclude(e) {
    this.currentFunctionNode !== null && this.currentFunctionNode.includes.push(e);
  }
  /**
   * Returns the native shader operator name for a given generic name.
   * It is a similar type of method like {@link NodeBuilder#getMethod}.
   *
   * @param {ShaderNodeInternal} shaderNode - The shader node to build the function node with.
   * @return {FunctionNode} The build function node.
   */
  buildFunctionNode(e) {
    const t = new jL(), n = this.currentFunctionNode;
    return this.currentFunctionNode = t, t.code = this.buildFunctionCode(e), this.currentFunctionNode = n, t;
  }
  /**
   * Generates a code flow based on a TSL function: Fn().
   *
   * @param {ShaderNodeInternal} shaderNode - A function code will be generated based on the input.
   * @return {Object}
   */
  flowShaderNode(e) {
    const t = e.layout, n = {
      [Symbol.iterator]() {
        let o = 0;
        const a = Object.values(this);
        return {
          next: () => ({
            value: a[o],
            done: o++ >= a.length
          })
        };
      }
    };
    for (const o of t.inputs)
      n[o.name] = new EL(o.type, o.name);
    e.layout = null;
    const r = e.call(n), s = this.flowStagesNode(r, t.type);
    return e.layout = t, s;
  }
  /**
   * Executes the node in a specific build stage.
   *
   * This function can be used to arbitrarily execute the specified build stage
   * outside of the standard build process. For instance, if a node's type depends
   * on properties created by the 'setup' stage, then flowBuildStage(node, 'setup')
   * can be used to execute the setup build stage and access its generated nodes
   * before the standard build process begins.
   *
   * @param {Node} node - The node to execute.
   * @param {string} buildStage - The build stage to execute the node in.
   * @param {?(Node|string)} [output=null] - Expected output type. For example 'vec3'.
   * @return {?(Node|string)} The result of the node build.
   */
  flowBuildStage(e, t, n = null) {
    const r = this.getBuildStage();
    this.setBuildStage(t);
    const s = e.build(this, n);
    return this.setBuildStage(r), s;
  }
  /**
   * Runs the node flow through all the steps of creation, 'setup', 'analyze', 'generate'.
   *
   * @param {Node} node - The node to execute.
   * @param {?string} output - Expected output type. For example 'vec3'.
   * @return {Object}
   */
  flowStagesNode(e, t = null) {
    const n = this.flow, r = this.vars, s = this.declarations, o = this.cache, a = this.buildStage, l = this.stack, u = {
      code: ""
    };
    this.flow = u, this.vars = {}, this.declarations = {}, this.cache = new uv(), this.stack = o1();
    for (const c of Db)
      this.setBuildStage(c), u.result = e.build(this, t);
    return u.vars = this.getVars(this.shaderStage), this.flow = n, this.vars = r, this.declarations = s, this.cache = o, this.stack = l, this.setBuildStage(a), u;
  }
  /**
   * Returns the native shader operator name for a given generic name.
   * It is a similar type of method like {@link NodeBuilder#getMethod}.
   *
   * @abstract
   * @param {string} op - The operator name to resolve.
   * @return {?string} The resolved operator name.
   */
  getFunctionOperator() {
    return null;
  }
  /**
   * Builds the given shader node.
   *
   * @abstract
   * @param {ShaderNodeInternal} shaderNode - The shader node.
   * @return {string} The function code.
   */
  buildFunctionCode() {
    Me("Abstract function.");
  }
  /**
   * Generates a code flow based on a child Node.
   *
   * @param {Node} node - The node to execute.
   * @param {?string} output - Expected output type. For example 'vec3'.
   * @return {Object} The code flow.
   */
  flowChildNode(e, t = null) {
    const n = this.flow, r = {
      code: ""
    };
    return this.flow = r, r.result = e.build(this, t), this.flow = n, r;
  }
  /**
   * Executes a flow of code in a different stage.
   *
   * Some nodes like `varying()` have the ability to compute code in vertex-stage and
   * return the value in fragment-stage even if it is being executed in an input fragment.
   *
   * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
   * @param {Node} node - The node to execute.
   * @param {?string} output - Expected output type. For example 'vec3'.
   * @param {?string} propertyName - The property name to assign the result.
   * @return {?(Object|Node)} The code flow or node.build() result.
   */
  flowNodeFromShaderStage(e, t, n = null, r = null) {
    const s = this.tab, o = this.cache, a = this.shaderStage, l = this.context;
    this.setShaderStage(e);
    const u = { ...this.context };
    delete u.nodeBlock, this.cache = this.globalCache, this.tab = "	", this.context = u;
    let c = null;
    if (this.buildStage === "generate") {
      const A = this.flowChildNode(t, n);
      r !== null && (A.code += `${this.tab + r} = ${A.result};
`), this.flowCode[e] = this.flowCode[e] + A.code, c = A;
    } else
      c = t.build(this);
    return this.setShaderStage(a), this.cache = o, this.tab = s, this.context = l, c;
  }
  /**
   * Returns an array holding all node attributes of this node builder.
   *
   * @return {Array<NodeAttribute>} The node attributes of this builder.
   */
  getAttributesArray() {
    return this.attributes.concat(this.bufferAttributes);
  }
  /**
   * Returns the attribute definitions as a shader string for the given shader stage.
   *
   * @abstract
   * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
   * @return {string} The attribute code section.
   */
  getAttributes() {
    Me("Abstract function.");
  }
  /**
   * Returns the varying definitions as a shader string for the given shader stage.
   *
   * @abstract
   * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
   * @return {string} The varying code section.
   */
  getVaryings() {
    Me("Abstract function.");
  }
  /**
   * Returns a single variable definition as a shader string for the given variable type and name.
   *
   * @param {string} type - The variable's type.
   * @param {string} name - The variable's name.
   * @param {?number} [count=null] - The array length.
   * @return {string} The shader string.
   */
  getVar(e, t, n = null) {
    return `${n !== null ? this.generateArrayDeclaration(e, n) : this.getType(e)} ${t}`;
  }
  /**
   * Returns the variable definitions as a shader string for the given shader stage.
   *
   * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
   * @return {string} The variable code section.
   */
  getVars(e) {
    let t = "";
    const n = this.vars[e];
    if (n !== void 0)
      for (const r of n)
        t += `${this.getVar(r.type, r.name)}; `;
    return t;
  }
  /**
   * Returns the uniform definitions as a shader string for the given shader stage.
   *
   * @abstract
   * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
   * @return {string} The uniform code section.
   */
  getUniforms() {
    Me("Abstract function.");
  }
  /**
   * Returns the native code definitions as a shader string for the given shader stage.
   *
   * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
   * @return {string} The native code section.
   */
  getCodes(e) {
    const t = this.codes[e];
    let n = "";
    if (t !== void 0)
      for (const r of t)
        n += r.code + `
`;
    return n;
  }
  /**
   * Returns the hash of this node builder.
   *
   * @return {string} The hash.
   */
  getHash() {
    return this.vertexShader + this.fragmentShader + this.computeShader;
  }
  /**
   * Sets the current shader stage.
   *
   * @param {?('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage to set.
   */
  setShaderStage(e) {
    this.shaderStage = e;
  }
  /**
   * Returns the current shader stage.
   *
   * @return {?('vertex'|'fragment'|'compute'|'any')} The current shader stage.
   */
  getShaderStage() {
    return this.shaderStage;
  }
  /**
   * Sets the current build stage.
   *
   * @param {?('setup'|'analyze'|'generate')} buildStage - The build stage to set.
   */
  setBuildStage(e) {
    this.buildStage = e;
  }
  /**
   * Returns the current build stage.
   *
   * @return {?('setup'|'analyze'|'generate')} The current build stage.
   */
  getBuildStage() {
    return this.buildStage;
  }
  /**
   * Controls the code build of the shader stages.
   *
   * @abstract
   */
  buildCode() {
    Me("Abstract function.");
  }
  /**
   * Returns the current sub-build layer.
   *
   * @return {SubBuildNode} The current sub-build layers.
   */
  get subBuild() {
    return this.subBuildLayers[this.subBuildLayers.length - 1] || null;
  }
  /**
   * Adds a sub-build layer to the node builder.
   *
   * @param {SubBuildNode} subBuild - The sub-build layer to add.
   */
  addSubBuild(e) {
    this.subBuildLayers.push(e);
  }
  /**
   * Removes the last sub-build layer from the node builder.
   *
   * @return {SubBuildNode} The removed sub-build layer.
   */
  removeSubBuild() {
    return this.subBuildLayers.pop();
  }
  /**
   * Returns the closest sub-build layer for the given data.
   *
   * @param {Node|Set<string>|Array<string>} data - The data to get the closest sub-build layer from.
   * @return {?string} The closest sub-build name or null if none found.
   */
  getClosestSubBuild(e) {
    let t;
    if (e && e.isNode ? e.isShaderCallNodeInternal ? t = e.shaderNode.subBuilds : e.isStackNode ? t = [e.subBuild] : t = this.getDataFromNode(e, "any").subBuilds : e instanceof Set ? t = [...e] : t = e, !t) return null;
    const n = this.subBuildLayers;
    for (let r = t.length - 1; r >= 0; r--) {
      const s = t[r];
      if (n.includes(s))
        return s;
    }
    return null;
  }
  /**
   * Returns the output node of a sub-build layer.
   *
   * @param {Node} node - The node to get the output from.
   * @return {string} The output node name.
   */
  getSubBuildOutput(e) {
    return this.getSubBuildProperty("outputNode", e);
  }
  /**
   * Returns the sub-build property name for the given property and node.
   *
   * @param {string} [property=''] - The property name.
   * @param {?Node} [node=null] - The node to get the sub-build from.
   * @return {string} The sub-build property name.
   */
  getSubBuildProperty(e = "", t = null) {
    let n;
    t !== null ? n = this.getClosestSubBuild(t) : n = this.subBuildFn;
    let r;
    return n ? r = e ? n + "_" + e : n : r = e, r;
  }
  /**
   * Central build method which controls the build for the given object.
   *
   * @return {NodeBuilder} A reference to this node builder.
   */
  build() {
    const { object: e, material: t, renderer: n } = this;
    if (t !== null) {
      let r = n.library.fromMaterial(t);
      r === null && (Ie(`NodeMaterial: Material "${t.type}" is not compatible.`), r = new Yi()), r.build(this);
    } else
      this.addFlow("compute", e);
    for (const r of Db) {
      this.setBuildStage(r), this.context.vertex && this.context.vertex.isNode && this.flowNodeFromShaderStage("vertex", this.context.vertex);
      for (const s of Lb) {
        this.setShaderStage(s);
        const o = this.flowNodes[s];
        for (const a of o)
          r === "generate" ? this.flowNode(a) : a.build(this);
      }
    }
    return this.setBuildStage(null), this.setShaderStage(null), this.buildCode(), this.buildUpdateNodes(), this;
  }
  /**
   * Returns shared data object for the given node.
   *
   * @param {Node} node - The node to get shared data from.
   * @return {Object} The shared data.
   */
  getSharedDataFromNode(e) {
    let t = Goe.get(e);
    return t === void 0 && (t = {}), t;
  }
  /**
   * Returns a uniform representation which is later used for UBO generation and rendering.
   *
   * @param {NodeUniform} uniformNode - The uniform node.
   * @param {string} type - The requested type.
   * @return {Uniform} The uniform.
   */
  getNodeUniform(e, t) {
    const n = this.getSharedDataFromNode(e);
    let r = n.cache;
    if (r === void 0) {
      if (t === "float" || t === "int" || t === "uint") r = new Doe(e);
      else if (t === "vec2" || t === "ivec2" || t === "uvec2") r = new Loe(e);
      else if (t === "vec3" || t === "ivec3" || t === "uvec3") r = new Ioe(e);
      else if (t === "vec4" || t === "ivec4" || t === "uvec4") r = new Boe(e);
      else if (t === "color") r = new Foe(e);
      else if (t === "mat2") r = new Uoe(e);
      else if (t === "mat3") r = new Ooe(e);
      else if (t === "mat4") r = new koe(e);
      else
        throw new Error(`Uniform "${t}" not implemented.`);
      n.cache = r;
    }
    return r;
  }
  /**
   * Formats the given shader snippet from a given type into another one. E.g.
   * this method might be used to convert a simple float string `"1.0"` into a
   * `vec3` representation: `"vec3<f32>( 1.0 )"`.
   *
   * @param {string} snippet - The shader snippet.
   * @param {string} fromType - The source type.
   * @param {string} toType - The target type.
   * @return {string} The updated shader string.
   */
  format(e, t, n) {
    if (t = this.getVectorType(t), n = this.getVectorType(n), t === n || n === null || this.isReference(n))
      return e;
    const r = this.getTypeLength(t), s = this.getTypeLength(n);
    return r === 16 && s === 9 ? `${this.getType(n)}( ${e}[ 0 ].xyz, ${e}[ 1 ].xyz, ${e}[ 2 ].xyz )` : r === 9 && s === 4 ? `${this.getType(n)}( ${e}[ 0 ].xy, ${e}[ 1 ].xy )` : r > 4 || s > 4 || s === 0 ? e : r === s ? `${this.getType(n)}( ${e} )` : r > s ? (e = n === "bool" ? `all( ${e} )` : `${e}.${"xyz".slice(0, s)}`, this.format(e, this.getTypeFromLength(s, this.getComponentType(t)), n)) : s === 4 && r > 1 ? `${this.getType(n)}( ${this.format(e, t, "vec3")}, 1.0 )` : r === 2 ? `${this.getType(n)}( ${this.format(e, t, "vec2")}, 0.0 )` : (r === 1 && s > 1 && t !== this.getComponentType(n) && (e = `${this.getType(this.getComponentType(n))}( ${e} )`), `${this.getType(n)}( ${e} )`);
  }
  /**
   * Returns a signature with the engine's current revision.
   *
   * @return {string} The signature.
   */
  getSignature() {
    return `// Three.js r${Ku} - Node System
`;
  }
}
class uC {
  /**
   * Constructs a new node fame.
   */
  constructor() {
    this.time = 0, this.deltaTime = 0, this.frameId = 0, this.renderId = 0, this.updateMap = /* @__PURE__ */ new WeakMap(), this.updateBeforeMap = /* @__PURE__ */ new WeakMap(), this.updateAfterMap = /* @__PURE__ */ new WeakMap(), this.renderer = null, this.material = null, this.camera = null, this.object = null, this.scene = null;
  }
  /**
   * Returns a dictionary for a given node and update map which
   * is used to correctly call node update methods per frame or render.
   *
   * @private
   * @param {WeakMap<Node, Object>} referenceMap - The reference weak map.
   * @param {Node} nodeRef - The reference to the current node.
   * @return {Object<string,WeakMap<Object, number>>} The dictionary.
   */
  _getMaps(e, t) {
    let n = e.get(t);
    return n === void 0 && (n = {
      renderId: 0,
      frameId: 0
    }, e.set(t, n)), n;
  }
  /**
   * This method executes the {@link Node#updateBefore} for the given node.
   * It makes sure {@link Node#updateBeforeType} is honored meaning the update
   * is only executed once per frame, render or object depending on the update
   * type.
   *
   * @param {Node} node - The node that should be updated.
   */
  updateBeforeNode(e) {
    const t = e.getUpdateBeforeType(), n = e.updateReference(this);
    if (t === hn.FRAME) {
      const r = this._getMaps(this.updateBeforeMap, n);
      if (r.frameId !== this.frameId) {
        const s = r.frameId;
        r.frameId = this.frameId, e.updateBefore(this) === !1 && (r.frameId = s);
      }
    } else if (t === hn.RENDER) {
      const r = this._getMaps(this.updateBeforeMap, n);
      if (r.renderId !== this.renderId) {
        const s = r.renderId;
        r.renderId = this.renderId, e.updateBefore(this) === !1 && (r.renderId = s);
      }
    } else t === hn.OBJECT && e.updateBefore(this);
  }
  /**
   * This method executes the {@link Node#updateAfter} for the given node.
   * It makes sure {@link Node#updateAfterType} is honored meaning the update
   * is only executed once per frame, render or object depending on the update
   * type.
   *
   * @param {Node} node - The node that should be updated.
   */
  updateAfterNode(e) {
    const t = e.getUpdateAfterType(), n = e.updateReference(this);
    if (t === hn.FRAME) {
      const r = this._getMaps(this.updateAfterMap, n);
      r.frameId !== this.frameId && e.updateAfter(this) !== !1 && (r.frameId = this.frameId);
    } else if (t === hn.RENDER) {
      const r = this._getMaps(this.updateAfterMap, n);
      r.renderId !== this.renderId && e.updateAfter(this) !== !1 && (r.renderId = this.renderId);
    } else t === hn.OBJECT && e.updateAfter(this);
  }
  /**
   * This method executes the {@link Node#update} for the given node.
   * It makes sure {@link Node#updateType} is honored meaning the update
   * is only executed once per frame, render or object depending on the update
   * type.
   *
   * @param {Node} node - The node that should be updated.
   */
  updateNode(e) {
    const t = e.getUpdateType(), n = e.updateReference(this);
    if (t === hn.FRAME) {
      const r = this._getMaps(this.updateMap, n);
      r.frameId !== this.frameId && e.update(this) !== !1 && (r.frameId = this.frameId);
    } else if (t === hn.RENDER) {
      const r = this._getMaps(this.updateMap, n);
      r.renderId !== this.renderId && e.update(this) !== !1 && (r.renderId = this.renderId);
    } else t === hn.OBJECT && e.update(this);
  }
  /**
   * Updates the internal state of the node frame. This method is
   * called by the renderer in its internal animation loop.
   */
  update() {
    this.frameId++, this.lastTime === void 0 && (this.lastTime = performance.now()), this.deltaTime = (performance.now() - this.lastTime) / 1e3, this.lastTime = performance.now(), this.time += this.deltaTime;
  }
}
class aw {
  /**
   * Constructs a new node function input.
   *
   * @param {string} type - The input type.
   * @param {string} name - The input name.
   * @param {?number} [count=null] - If the input is an Array, count will be the length.
   * @param {('in'|'out'|'inout')} [qualifier=''] - The parameter qualifier (only relevant for GLSL).
   * @param {boolean} [isConst=false] - Whether the input uses a const qualifier or not (only relevant for GLSL).
   */
  constructor(e, t, n = null, r = "", s = !1) {
    this.type = e, this.name = t, this.count = n, this.qualifier = r, this.isConst = s;
  }
}
aw.isNodeFunctionInput = !0;
class qoe extends ld {
  static get type() {
    return "DirectionalLightNode";
  }
  /**
   * Constructs a new directional light node.
   *
   * @param {?DirectionalLight} [light=null] - The directional light source.
   */
  constructor(e = null) {
    super(e);
  }
  setupDirect() {
    const e = this.colorNode;
    return { lightDirection: tw(this.light), lightColor: e };
  }
}
const cv = /* @__PURE__ */ new Mt(), Tg = /* @__PURE__ */ new Mt();
let ep = null;
class Hoe extends ld {
  static get type() {
    return "RectAreaLightNode";
  }
  /**
   * Constructs a new rect area light node.
   *
   * @param {?RectAreaLight} [light=null] - The rect area light source.
   */
  constructor(e = null) {
    super(e), this.halfHeight = It(new j()).setGroup(Lt), this.halfWidth = It(new j()).setGroup(Lt), this.updateType = hn.RENDER;
  }
  /**
   * Overwritten to updated rect area light specific uniforms.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  update(e) {
    super.update(e);
    const { light: t } = this, n = e.camera.matrixWorldInverse;
    Tg.identity(), cv.copy(t.matrixWorld), cv.premultiply(n), Tg.extractRotation(cv), this.halfWidth.value.set(t.width * 0.5, 0, 0), this.halfHeight.value.set(0, t.height * 0.5, 0), this.halfWidth.value.applyMatrix4(Tg), this.halfHeight.value.applyMatrix4(Tg);
  }
  setupDirectRectArea(e) {
    let t, n;
    e.isAvailable("float32Filterable") ? (t = Wn(ep.LTC_FLOAT_1), n = Wn(ep.LTC_FLOAT_2)) : (t = Wn(ep.LTC_HALF_1), n = Wn(ep.LTC_HALF_2));
    const { colorNode: r, light: s } = this, o = ew(s);
    return {
      lightColor: r,
      lightPosition: o,
      halfWidth: this.halfWidth,
      halfHeight: this.halfHeight,
      ltc_1: t,
      ltc_2: n
    };
  }
  /**
   * Used to configure the internal BRDF approximation texture data.
   *
   * @param {RectAreaLightTexturesLib} ltc - The BRDF approximation texture data.
   */
  static setLTC(e) {
    ep = e;
  }
}
class lw extends ld {
  static get type() {
    return "SpotLightNode";
  }
  /**
   * Constructs a new spot light node.
   *
   * @param {?SpotLight} [light=null] - The spot light source.
   */
  constructor(e = null) {
    super(e), this.coneCosNode = It(0).setGroup(Lt), this.penumbraCosNode = It(0).setGroup(Lt), this.cutoffDistanceNode = It(0).setGroup(Lt), this.decayExponentNode = It(0).setGroup(Lt), this.colorNode = It(this.color).setGroup(Lt);
  }
  /**
   * Overwritten to updated spot light specific uniforms.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  update(e) {
    super.update(e);
    const { light: t } = this;
    this.coneCosNode.value = Math.cos(t.angle), this.penumbraCosNode.value = Math.cos(t.angle * (1 - t.penumbra)), this.cutoffDistanceNode.value = t.distance, this.decayExponentNode.value = t.decay;
  }
  /**
   * Computes the spot attenuation for the given angle.
   *
   * @param {NodeBuilder} builder - The node builder.
   * @param {Node<float>} angleCosine - The angle to compute the spot attenuation for.
   * @return {Node<float>} The spot attenuation.
   */
  getSpotAttenuation(e, t) {
    const { coneCosNode: n, penumbraCosNode: r } = this;
    return Ta(n, r, t);
  }
  getLightCoord(e) {
    const t = e.getNodeProperties(this);
    let n = t.projectionUV;
    return n === void 0 && (n = KL(this.light, e.context.positionWorld), t.projectionUV = n), n;
  }
  setupDirect(e) {
    const { colorNode: t, cutoffDistanceNode: n, decayExponentNode: r, light: s } = this, o = this.getLightVector(e), a = o.normalize(), l = a.dot(tw(s)), u = this.getSpotAttenuation(e, l), c = o.length(), A = rw({
      lightDistance: c,
      cutoffDistance: n,
      decayExponent: r
    });
    let m = t.mul(u).mul(A), _, y;
    return s.colorNode ? (y = this.getLightCoord(e), _ = s.colorNode(y)) : s.map && (y = this.getLightCoord(e), _ = Wn(s.map, y.xy).onRenderUpdate(() => s.map)), _ && (m = y.mul(2).sub(1).abs().lessThan(1).all().select(m.mul(_), m)), { lightColor: m, lightDirection: a };
  }
}
class Woe extends lw {
  static get type() {
    return "IESSpotLightNode";
  }
  /**
   * Overwrites the default implementation to compute an IES conform spot attenuation.
   *
   * @param {NodeBuilder} builder - The node builder.
   * @param {Node<float>} angleCosine - The angle to compute the spot attenuation for.
   * @return {Node<float>} The spot attenuation.
   */
  getSpotAttenuation(e, t) {
    const n = this.light.iesMap;
    let r = null;
    if (n && n.isTexture === !0) {
      const s = t.acos().mul(1 / Math.PI);
      r = Wn(n, Xe(s, 0), 0).r;
    } else
      r = super.getSpotAttenuation(t);
    return r;
  }
}
const $oe = /* @__PURE__ */ pe(([i, e]) => {
  const t = i.abs().sub(e);
  return el(qi(t, 0)).add(so(qi(t.x, t.y), 0));
});
class joe extends lw {
  static get type() {
    return "ProjectorLightNode";
  }
  update(e) {
    super.update(e);
    const t = this.light;
    if (this.penumbraCosNode.value = Math.min(Math.cos(t.angle * (1 - t.penumbra)), 0.99999), t.aspect === null) {
      let n = 1;
      t.map !== null && (n = t.map.width / t.map.height), t.shadow.aspect = n;
    } else
      t.shadow.aspect = t.aspect;
  }
  /**
   * Overwrites the default implementation to compute projection attenuation.
   *
   * @param {NodeBuilder} builder - The node builder.
   * @return {Node<float>} The spot attenuation.
   */
  getSpotAttenuation(e) {
    const t = J(0), n = this.penumbraCosNode, r = tx(this.light).mul(e.context.positionWorld || tl);
    return Ot(r.w.greaterThan(0), () => {
      const s = r.xyz.div(r.w), o = $oe(s.xy.sub(Xe(0.5)), Xe(0.5)), a = Ro(-1, Un(1, nT(n)).sub(1));
      t.assign(U2(o.mul(-2).mul(a)));
    }), t;
  }
}
class Xoe extends ld {
  static get type() {
    return "AmbientLightNode";
  }
  /**
   * Constructs a new ambient light node.
   *
   * @param {?AmbientLight} [light=null] - The ambient light source.
   */
  constructor(e = null) {
    super(e);
  }
  setup({ context: e }) {
    e.irradiance.addAssign(this.colorNode);
  }
}
class Yoe extends ld {
  static get type() {
    return "HemisphereLightNode";
  }
  /**
   * Constructs a new hemisphere light node.
   *
   * @param {?HemisphereLight} [light=null] - The hemisphere light source.
   */
  constructor(e = null) {
    super(e), this.lightPositionNode = JT(e), this.lightDirectionNode = this.lightPositionNode.normalize(), this.groundColorNode = It(new ct()).setGroup(Lt);
  }
  /**
   * Overwritten to updated hemisphere light specific uniforms.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  update(e) {
    const { light: t } = this;
    super.update(e), this.lightPositionNode.object3d = t, this.groundColorNode.value.copy(t.groundColor).multiplyScalar(t.intensity);
  }
  setup(e) {
    const { colorNode: t, groundColorNode: n, lightDirectionNode: r } = this, o = oc.dot(r).mul(0.5).add(0.5), a = Bn(n, t, o);
    e.context.irradiance.addAssign(a);
  }
}
class Qoe extends ld {
  static get type() {
    return "LightProbeNode";
  }
  /**
   * Constructs a new light probe node.
   *
   * @param {?LightProbe} [light=null] - The light probe.
   */
  constructor(e = null) {
    super(e);
    const t = [];
    for (let n = 0; n < 9; n++) t.push(new j());
    this.lightProbe = hs(t);
  }
  /**
   * Overwritten to updated light probe specific uniforms.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  update(e) {
    const { light: t } = this;
    super.update(e);
    for (let n = 0; n < 9; n++)
      this.lightProbe.array[n].copy(t.sh.coefficients[n]).multiplyScalar(t.intensity);
  }
  setup(e) {
    const t = yI(oc, this.lightProbe);
    e.context.irradiance.addAssign(t);
  }
}
class SI {
  /**
   * The method parses the given native code an returns a node function.
   *
   * @abstract
   * @param {string} source - The native shader code.
   * @return {NodeFunction} A node function.
   */
  parseFunction() {
    Me("Abstract function.");
  }
}
class uw {
  /**
   * Constructs a new node function.
   *
   * @param {string} type - The node type. This type is the return type of the node function.
   * @param {Array<NodeFunctionInput>} inputs - The function's inputs.
   * @param {string} [name=''] - The function's name.
   * @param {string} [precision=''] - The precision qualifier.
   */
  constructor(e, t, n = "", r = "") {
    this.type = e, this.inputs = t, this.name = n, this.precision = r;
  }
  /**
   * This method returns the native code of the node function.
   *
   * @abstract
   * @param {string} name - The function's name.
   * @return {string} A shader code.
   */
  getCode() {
    Me("Abstract function.");
  }
}
uw.isNodeFunction = !0;
const Koe = /^\s*(highp|mediump|lowp)?\s*([a-z_0-9]+)\s*([a-z_0-9]+)?\s*\(([\s\S]*?)\)/i, Zoe = /[a-z_0-9]+/ig, cC = "#pragma main", Joe = (i) => {
  i = i.trim();
  const e = i.indexOf(cC), t = e !== -1 ? i.slice(e + cC.length) : i, n = t.match(Koe);
  if (n !== null && n.length === 5) {
    const r = n[4], s = [];
    let o = null;
    for (; (o = Zoe.exec(r)) !== null; )
      s.push(o);
    const a = [];
    let l = 0;
    for (; l < s.length; ) {
      const y = s[l][0] === "const";
      y === !0 && l++;
      let T = s[l][0];
      T === "in" || T === "out" || T === "inout" ? l++ : T = "";
      const b = s[l++][0];
      let S = Number.parseInt(s[l][0]);
      Number.isNaN(S) === !1 ? l++ : S = null;
      const E = s[l++][0];
      a.push(new aw(b, E, S, T, y));
    }
    const u = t.substring(n[0].length), c = n[3] !== void 0 ? n[3] : "", A = n[2], m = n[1] !== void 0 ? n[1] : "", _ = e !== -1 ? i.slice(0, e) : "";
    return {
      type: A,
      inputs: a,
      name: c,
      precision: m,
      inputsCode: r,
      blockCode: u,
      headerCode: _
    };
  } else
    throw new Error("FunctionNode: Function is not a GLSL code.");
};
class eae extends uw {
  /**
   * Constructs a new GLSL node function.
   *
   * @param {string} source - The GLSL source.
   */
  constructor(e) {
    const { type: t, inputs: n, name: r, precision: s, inputsCode: o, blockCode: a, headerCode: l } = Joe(e);
    super(t, n, r, s), this.inputsCode = o, this.blockCode = a, this.headerCode = l;
  }
  /**
   * This method returns the GLSL code of the node function.
   *
   * @param {string} [name=this.name] - The function's name.
   * @return {string} The shader code.
   */
  getCode(e = this.name) {
    let t;
    const n = this.blockCode;
    if (n !== "") {
      const { type: r, inputsCode: s, headerCode: o, precision: a } = this;
      let l = `${r} ${e} ( ${s.trim()} )`;
      a !== "" && (l = `${a} ${l}`), t = o + l + n;
    } else
      t = "";
    return t;
  }
}
class tae extends SI {
  /**
   * The method parses the given GLSL code an returns a node function.
   *
   * @param {string} source - The GLSL code.
   * @return {GLSLNodeFunction} A node function.
   */
  parseFunction(e) {
    return new eae(e);
  }
}
const hC = /* @__PURE__ */ new WeakMap(), Ua = [], xu = [];
class nae extends ac {
  /**
   * Constructs a new nodes management component.
   *
   * @param {Renderer} renderer - The renderer.
   * @param {Backend} backend - The renderer's backend.
   */
  constructor(e, t) {
    super(), this.renderer = e, this.backend = t, this.nodeFrame = new uC(), this.nodeBuilderCache = /* @__PURE__ */ new Map(), this.callHashCache = new wa(), this.groupsData = new wa(), this.cacheLib = {};
  }
  /**
   * Returns `true` if the given node uniforms group must be updated or not.
   *
   * @param {NodeUniformsGroup} nodeUniformsGroup - The node uniforms group.
   * @return {boolean} Whether the node uniforms group requires an update or not.
   */
  updateGroup(e) {
    const t = e.groupNode, n = t.name;
    if (n === QS.name) return !0;
    if (n === Lt.name) {
      const s = this.get(e), o = this.nodeFrame.renderId;
      return s.renderId !== o ? (s.renderId = o, !0) : !1;
    }
    if (n === AN.name) {
      const s = this.get(e), o = this.nodeFrame.frameId;
      return s.frameId !== o ? (s.frameId = o, !0) : !1;
    }
    Ua[0] = t, Ua[1] = e;
    let r = this.groupsData.get(Ua);
    return r === void 0 && this.groupsData.set(Ua, r = {}), Ua.length = 0, r.version !== t.version ? (r.version = t.version, !0) : !1;
  }
  /**
   * Returns the cache key for the given render object.
   *
   * @param {RenderObject} renderObject - The render object.
   * @return {number} The cache key.
   */
  getForRenderCacheKey(e) {
    return e.initialCacheKey;
  }
  /**
   * Returns a node builder state for the given render object.
   *
   * @param {RenderObject} renderObject - The render object.
   * @return {NodeBuilderState} The node builder state.
   */
  getForRender(e) {
    const t = this.get(e);
    let n = t.nodeBuilderState;
    if (n === void 0) {
      const { nodeBuilderCache: r } = this, s = this.getForRenderCacheKey(e);
      if (n = r.get(s), n === void 0) {
        const o = (l) => {
          const u = this.backend.createNodeBuilder(e.object, this.renderer);
          return u.scene = e.scene, u.material = l, u.camera = e.camera, u.context.material = l, u.lightsNode = e.lightsNode, u.environmentNode = this.getEnvironmentNode(e.scene), u.fogNode = this.getFogNode(e.scene), u.clippingContext = e.clippingContext, this.renderer.getOutputRenderTarget() && this.renderer.getOutputRenderTarget().multiview && u.enableMultiview(), u;
        };
        let a = o(e.material);
        try {
          a.build();
        } catch (l) {
          a = o(new Yi()), a.build(), Ie("TSL: " + l);
        }
        n = this._createNodeBuilderState(a), r.set(s, n);
      }
      n.usedTimes++, t.nodeBuilderState = n;
    }
    return n;
  }
  /**
   * Deletes the given object from the internal data map
   *
   * @param {any} object - The object to delete.
   * @return {?Object} The deleted dictionary.
   */
  delete(e) {
    if (e.isRenderObject) {
      const t = this.get(e).nodeBuilderState;
      t.usedTimes--, t.usedTimes === 0 && this.nodeBuilderCache.delete(this.getForRenderCacheKey(e));
    }
    return super.delete(e);
  }
  /**
   * Returns a node builder state for the given compute node.
   *
   * @param {Node} computeNode - The compute node.
   * @return {NodeBuilderState} The node builder state.
   */
  getForCompute(e) {
    const t = this.get(e);
    let n = t.nodeBuilderState;
    if (n === void 0) {
      const r = this.backend.createNodeBuilder(e, this.renderer);
      r.build(), n = this._createNodeBuilderState(r), t.nodeBuilderState = n;
    }
    return n;
  }
  /**
   * Creates a node builder state for the given node builder.
   *
   * @private
   * @param {NodeBuilder} nodeBuilder - The node builder.
   * @return {NodeBuilderState} The node builder state.
   */
  _createNodeBuilderState(e) {
    return new _oe(
      e.vertexShader,
      e.fragmentShader,
      e.computeShader,
      e.getAttributesArray(),
      e.getBindings(),
      e.updateNodes,
      e.updateBeforeNodes,
      e.updateAfterNodes,
      e.observer,
      e.transforms
    );
  }
  /**
   * Returns an environment node for the current configured
   * scene environment.
   *
   * @param {Scene} scene - The scene.
   * @return {Node} A node representing the current scene environment.
   */
  getEnvironmentNode(e) {
    this.updateEnvironment(e);
    let t = null;
    if (e.environmentNode && e.environmentNode.isNode)
      t = e.environmentNode;
    else {
      const n = this.get(e);
      n.environmentNode && (t = n.environmentNode);
    }
    return t;
  }
  /**
   * Returns a background node for the current configured
   * scene background.
   *
   * @param {Scene} scene - The scene.
   * @return {Node} A node representing the current scene background.
   */
  getBackgroundNode(e) {
    this.updateBackground(e);
    let t = null;
    if (e.backgroundNode && e.backgroundNode.isNode)
      t = e.backgroundNode;
    else {
      const n = this.get(e);
      n.backgroundNode && (t = n.backgroundNode);
    }
    return t;
  }
  /**
   * Returns a fog node for the current configured scene fog.
   *
   * @param {Scene} scene - The scene.
   * @return {Node} A node representing the current scene fog.
   */
  getFogNode(e) {
    return this.updateFog(e), e.fogNode || this.get(e).fogNode || null;
  }
  /**
   * Returns a cache key for the given scene and lights node.
   * This key is used by `RenderObject` as a part of the dynamic
   * cache key (a key that must be checked every time the render
   * objects is drawn).
   *
   * @param {Scene} scene - The scene.
   * @param {LightsNode} lightsNode - The lights node.
   * @return {number} The cache key.
   */
  getCacheKey(e, t) {
    Ua[0] = e, Ua[1] = t;
    const n = this.renderer.info.calls, r = this.callHashCache.get(Ua) || {};
    if (r.callId !== n) {
      const s = this.getEnvironmentNode(e), o = this.getFogNode(e);
      t && xu.push(t.getCacheKey(!0)), s && xu.push(s.getCacheKey()), o && xu.push(o.getCacheKey()), xu.push(this.renderer.getOutputRenderTarget() && this.renderer.getOutputRenderTarget().multiview ? 1 : 0), xu.push(this.renderer.shadowMap.enabled ? 1 : 0), xu.push(this.renderer.shadowMap.type), r.callId = n, r.cacheKey = cA(xu), this.callHashCache.set(Ua, r), xu.length = 0;
    }
    return Ua.length = 0, r.cacheKey;
  }
  /**
   * A boolean that indicates whether tone mapping should be enabled
   * or not.
   *
   * @type {boolean}
   */
  get isToneMappingState() {
    return !this.renderer.getRenderTarget();
  }
  /**
   * If a scene background is configured, this method makes sure to
   * represent the background with a corresponding node-based implementation.
   *
   * @param {Scene} scene - The scene.
   */
  updateBackground(e) {
    const t = this.get(e), n = e.background;
    if (n) {
      const r = e.backgroundBlurriness === 0 && t.backgroundBlurriness > 0 || e.backgroundBlurriness > 0 && t.backgroundBlurriness === 0;
      if (t.background !== n || r) {
        const s = this.getCacheNode("background", n, () => {
          if (n.isCubeTexture === !0 || n.mapping === Gu || n.mapping === zu || n.mapping === Gl) {
            if (e.backgroundBlurriness > 0 || n.mapping === Gl)
              return qT(n);
            {
              let o;
              return n.isCubeTexture === !0 ? o = Is(n) : o = Wn(n), aL(o);
            }
          } else {
            if (n.isTexture === !0)
              return Wn(n, Ul.flipY()).setUpdateMatrix(!0);
            n.isColor !== !0 && Ie("WebGPUNodes: Unsupported background configuration.", n);
          }
        }, r);
        t.backgroundNode = s, t.background = n, t.backgroundBlurriness = e.backgroundBlurriness;
      }
    } else t.backgroundNode && (delete t.backgroundNode, delete t.background);
  }
  /**
   * This method is part of the caching of nodes which are used to represents the
   * scene's background, fog or environment.
   *
   * @param {string} type - The type of object to cache.
   * @param {Object} object - The object.
   * @param {Function} callback - A callback that produces a node representation for the given object.
   * @param {boolean} [forceUpdate=false] - Whether an update should be enforced or not.
   * @return {Node} The node representation.
   */
  getCacheNode(e, t, n, r = !1) {
    const s = this.cacheLib[e] || (this.cacheLib[e] = /* @__PURE__ */ new WeakMap());
    let o = s.get(t);
    return (o === void 0 || r) && (o = n(), s.set(t, o)), o;
  }
  /**
   * If a scene fog is configured, this method makes sure to
   * represent the fog with a corresponding node-based implementation.
   *
   * @param {Scene} scene - The scene.
   */
  updateFog(e) {
    const t = this.get(e), n = e.fog;
    if (n) {
      if (t.fog !== n) {
        const r = this.getCacheNode("fog", n, () => {
          if (n.isFogExp2) {
            const s = ui("color", "color", n).setGroup(Lt), o = ui("density", "float", n).setGroup(Lt);
            return c0(s, KT(o));
          } else if (n.isFog) {
            const s = ui("color", "color", n).setGroup(Lt), o = ui("near", "float", n).setGroup(Lt), a = ui("far", "float", n).setGroup(Lt);
            return c0(s, QT(o, a));
          } else
            Ie("Renderer: Unsupported fog configuration.", n);
        });
        t.fogNode = r, t.fog = n;
      }
    } else
      delete t.fogNode, delete t.fog;
  }
  /**
   * If a scene environment is configured, this method makes sure to
   * represent the environment with a corresponding node-based implementation.
   *
   * @param {Scene} scene - The scene.
   */
  updateEnvironment(e) {
    const t = this.get(e), n = e.environment;
    if (n) {
      if (t.environment !== n) {
        const r = this.getCacheNode("environment", n, () => {
          if (n.isCubeTexture === !0)
            return Is(n);
          if (n.isTexture === !0)
            return Wn(n);
          Ie("Nodes: Unsupported environment configuration.", n);
        });
        t.environmentNode = r, t.environment = n;
      }
    } else t.environmentNode && (delete t.environmentNode, delete t.environment);
  }
  getNodeFrame(e = this.renderer, t = null, n = null, r = null, s = null) {
    const o = this.nodeFrame;
    return o.renderer = e, o.scene = t, o.object = n, o.camera = r, o.material = s, o;
  }
  getNodeFrameForRender(e) {
    return this.getNodeFrame(e.renderer, e.scene, e.object, e.camera, e.material);
  }
  /**
   * Returns the current output cache key.
   *
   * @return {string} The output cache key.
   */
  getOutputCacheKey() {
    const e = this.renderer;
    return e.toneMapping + "," + e.currentColorSpace + "," + e.xr.isPresenting;
  }
  /**
   * Checks if the output configuration (tone mapping and color space) for
   * the given target has changed.
   *
   * @param {Texture} outputTarget - The output target.
   * @return {boolean} Whether the output configuration has changed or not.
   */
  hasOutputChange(e) {
    return hC.get(e) !== this.getOutputCacheKey();
  }
  /**
   * Returns a node that represents the output configuration (tone mapping and
   * color space) for the current target.
   *
   * @param {Texture} outputTarget - The output target.
   * @return {Node} The output node.
   */
  getOutputNode(e) {
    const t = this.renderer, n = this.getOutputCacheKey(), r = e.isArrayTexture ? Z2(e, ce(Ul, tu("gl_ViewID_OVR"))).renderOutput(t.toneMapping, t.currentColorSpace) : Wn(e, Ul).renderOutput(t.toneMapping, t.currentColorSpace);
    return hC.set(e, n), r;
  }
  /**
   * Triggers the call of `updateBefore()` methods
   * for all nodes of the given render object.
   *
   * @param {RenderObject} renderObject - The render object.
   */
  updateBefore(e) {
    const t = e.getNodeBuilderState();
    for (const n of t.updateBeforeNodes)
      this.getNodeFrameForRender(e).updateBeforeNode(n);
  }
  /**
   * Triggers the call of `updateAfter()` methods
   * for all nodes of the given render object.
   *
   * @param {RenderObject} renderObject - The render object.
   */
  updateAfter(e) {
    const t = e.getNodeBuilderState();
    for (const n of t.updateAfterNodes)
      this.getNodeFrameForRender(e).updateAfterNode(n);
  }
  /**
   * Triggers the call of `update()` methods
   * for all nodes of the given compute node.
   *
   * @param {Node} computeNode - The compute node.
   */
  updateForCompute(e) {
    const t = this.getNodeFrame(), n = this.getForCompute(e);
    for (const r of n.updateNodes)
      t.updateNode(r);
  }
  /**
   * Triggers the call of `update()` methods
   * for all nodes of the given compute node.
   *
   * @param {RenderObject} renderObject - The render object.
   */
  updateForRender(e) {
    const t = this.getNodeFrameForRender(e), n = e.getNodeBuilderState();
    for (const r of n.updateNodes)
      t.updateNode(r);
  }
  /**
   * Returns `true` if the given render object requires a refresh.
   *
   * @param {RenderObject} renderObject - The render object.
   * @return {boolean} Whether the given render object requires a refresh or not.
   */
  needsRefresh(e) {
    const t = this.getNodeFrameForRender(e);
    return e.getMonitor().needsRefresh(e, t);
  }
  /**
   * Frees the internal resources.
   */
  dispose() {
    super.dispose(), this.nodeFrame = new uC(), this.nodeBuilderCache = /* @__PURE__ */ new Map(), this.cacheLib = {};
  }
}
const hv = /* @__PURE__ */ new ca();
class __ {
  /**
   * Constructs a new clipping context.
   *
   * @param {?ClippingContext} [parentContext=null] - A reference to the parent clipping context.
   */
  constructor(e = null) {
    this.version = 0, this.clipIntersection = null, this.cacheKey = "", this.shadowPass = !1, this.viewNormalMatrix = new fn(), this.clippingGroupContexts = /* @__PURE__ */ new WeakMap(), this.intersectionPlanes = [], this.unionPlanes = [], this.parentVersion = null, e !== null && (this.viewNormalMatrix = e.viewNormalMatrix, this.clippingGroupContexts = e.clippingGroupContexts, this.shadowPass = e.shadowPass, this.viewMatrix = e.viewMatrix);
  }
  /**
   * Projects the given source clipping planes and writes the result into the
   * destination array.
   *
   * @param {Array<Plane>} source - The source clipping planes.
   * @param {Array<Vector4>} destination - The destination.
   * @param {number} offset - The offset.
   */
  projectPlanes(e, t, n) {
    const r = e.length;
    for (let s = 0; s < r; s++) {
      hv.copy(e[s]).applyMatrix4(this.viewMatrix, this.viewNormalMatrix);
      const o = t[n + s], a = hv.normal;
      o.x = -a.x, o.y = -a.y, o.z = -a.z, o.w = hv.constant;
    }
  }
  /**
   * Updates the root clipping context of a scene.
   *
   * @param {Scene} scene - The scene.
   * @param {Camera} camera - The camera that is used to render the scene.
   */
  updateGlobal(e, t) {
    this.shadowPass = e.overrideMaterial !== null && e.overrideMaterial.isShadowPassMaterial, this.viewMatrix = t.matrixWorldInverse, this.viewNormalMatrix.getNormalMatrix(this.viewMatrix);
  }
  /**
   * Updates the clipping context.
   *
   * @param {ClippingContext} parentContext - The parent context.
   * @param {ClippingGroup} clippingGroup - The clipping group this context belongs to.
   */
  update(e, t) {
    let n = !1;
    e.version !== this.parentVersion && (this.intersectionPlanes = Array.from(e.intersectionPlanes), this.unionPlanes = Array.from(e.unionPlanes), this.parentVersion = e.version), this.clipIntersection !== t.clipIntersection && (this.clipIntersection = t.clipIntersection, this.clipIntersection ? this.unionPlanes.length = e.unionPlanes.length : this.intersectionPlanes.length = e.intersectionPlanes.length);
    const r = t.clippingPlanes, s = r.length;
    let o, a;
    if (this.clipIntersection ? (o = this.intersectionPlanes, a = e.intersectionPlanes.length) : (o = this.unionPlanes, a = e.unionPlanes.length), o.length !== a + s) {
      o.length = a + s;
      for (let l = 0; l < s; l++)
        o[a + l] = new Kt();
      n = !0;
    }
    this.projectPlanes(r, o, a), n && (this.version++, this.cacheKey = `${this.intersectionPlanes.length}:${this.unionPlanes.length}`);
  }
  /**
   * Returns a clipping context for the given clipping group.
   *
   * @param {ClippingGroup} clippingGroup - The clipping group.
   * @return {ClippingContext} The clipping context.
   */
  getGroupContext(e) {
    if (this.shadowPass && !e.clipShadows) return this;
    let t = this.clippingGroupContexts.get(e);
    return t === void 0 && (t = new __(this), this.clippingGroupContexts.set(e, t)), t.update(this, e), t;
  }
  /**
   * The count of union clipping planes.
   *
   * @type {number}
   * @readonly
   */
  get unionClippingCount() {
    return this.unionPlanes.length;
  }
}
class iae {
  /**
   * Constructs a new bundle group.
   *
   * @param {BundleGroup} bundleGroup - The bundle group.
   * @param {Camera} camera - The camera the bundle group is rendered with.
   */
  constructor(e, t) {
    this.bundleGroup = e, this.camera = t;
  }
}
const tp = [];
class rae {
  /**
   * Constructs a new render bundle management component.
   */
  constructor() {
    this.bundles = new wa();
  }
  /**
   * Returns a render bundle for the given bundle group and camera.
   *
   * @param {BundleGroup} bundleGroup - The bundle group.
   * @param {Camera} camera - The camera the bundle group is rendered with.
   * @return {RenderBundle} The render bundle.
   */
  get(e, t) {
    const n = this.bundles;
    tp[0] = e, tp[1] = t;
    let r = n.get(tp);
    return r === void 0 && (r = new iae(e, t), n.set(tp, r)), tp.length = 0, r;
  }
  /**
   * Frees all internal resources.
   */
  dispose() {
    this.bundles = new wa();
  }
}
class TI {
  /**
   * Constructs a new node library.
   */
  constructor() {
    this.lightNodes = /* @__PURE__ */ new WeakMap(), this.materialNodes = /* @__PURE__ */ new Map(), this.toneMappingNodes = /* @__PURE__ */ new Map();
  }
  /**
   * Returns a matching node material instance for the given material object.
   *
   * This method also assigns/copies the properties of the given material object
   * to the node material. This is done to make sure the current material
   * configuration carries over to the node version.
   *
   * @param {Material} material - A material.
   * @return {NodeMaterial} The corresponding node material.
   */
  fromMaterial(e) {
    if (e.isNodeMaterial) return e;
    let t = null;
    const n = this.getMaterialNodeClass(e.type);
    if (n !== null) {
      t = new n();
      for (const r in e)
        t[r] = e[r];
    }
    return t;
  }
  /**
   * Adds a tone mapping node function for a tone mapping technique (constant).
   *
   * @param {Function} toneMappingNode - The tone mapping node function.
   * @param {number} toneMapping - The tone mapping.
   */
  addToneMapping(e, t) {
    this.addType(e, t, this.toneMappingNodes);
  }
  /**
   * Returns a tone mapping node function for a tone mapping technique (constant).
   *
   * @param {number} toneMapping - The tone mapping.
   * @return {?Function} The tone mapping node function. Returns `null` if no node function is found.
   */
  getToneMappingFunction(e) {
    return this.toneMappingNodes.get(e) || null;
  }
  /**
   * Returns a node material class definition for a material type.
   *
   * @param {string} materialType - The material type.
   * @return {?NodeMaterial.constructor} The node material class definition. Returns `null` if no node material is found.
   */
  getMaterialNodeClass(e) {
    return this.materialNodes.get(e) || null;
  }
  /**
   * Adds a node material class definition for a given material type.
   *
   * @param {NodeMaterial.constructor} materialNodeClass - The node material class definition.
   * @param {string} materialClassType - The material type.
   */
  addMaterial(e, t) {
    this.addType(e, t, this.materialNodes);
  }
  /**
   * Returns a light node class definition for a light class definition.
   *
   * @param {Light.constructor} light - The light class definition.
   * @return {?AnalyticLightNode.constructor} The light node class definition. Returns `null` if no light node is found.
   */
  getLightNodeClass(e) {
    return this.lightNodes.get(e) || null;
  }
  /**
   * Adds a light node class definition for a given light class definition.
   *
   * @param {AnalyticLightNode.constructor} lightNodeClass - The light node class definition.
   * @param {Light.constructor} lightClass - The light class definition.
   */
  addLight(e, t) {
    this.addClass(e, t, this.lightNodes);
  }
  /**
   * Adds a node class definition for the given type to the provided type library.
   *
   * @param {Node.constructor} nodeClass - The node class definition.
   * @param {number|string} type - The object type.
   * @param {Map<number|string,Node.constructor>} library - The type library.
   */
  addType(e, t, n) {
    if (n.has(t)) {
      Me(`Redefinition of node ${t}`);
      return;
    }
    if (typeof e != "function") throw new Error(`Node class ${e.name} is not a class.`);
    if (typeof t == "function" || typeof t == "object") throw new Error(`Base class ${t} is not a class.`);
    n.set(t, e);
  }
  /**
   * Adds a node class definition for the given class definition to the provided type library.
   *
   * @param {Node.constructor} nodeClass - The node class definition.
   * @param {Node.constructor} baseClass - The class definition.
   * @param {WeakMap<Node.constructor, Node.constructor>} library - The type library.
   */
  addClass(e, t, n) {
    if (n.has(t)) {
      Me(`Redefinition of node ${t.name}`);
      return;
    }
    if (typeof e != "function") throw new Error(`Node class ${e.name} is not a class.`);
    if (typeof t != "function") throw new Error(`Base class ${t.name} is not a class.`);
    n.set(t, e);
  }
}
const sae = /* @__PURE__ */ new nw(), np = [];
class oae extends wa {
  /**
   * Constructs a lighting management component.
   */
  constructor() {
    super();
  }
  /**
   * Creates a new lights node for the given array of lights.
   *
   * @param {Array<Light>} lights - The render object.
   * @return {LightsNode} The lights node.
   */
  createNode(e = []) {
    return new nw().setLights(e);
  }
  /**
   * Returns a lights node for the given scene and camera.
   *
   * @param {Scene} scene - The scene.
   * @param {Camera} camera - The camera.
   * @return {LightsNode} The lights node.
   */
  getNode(e, t) {
    if (e.isQuadMesh) return sae;
    np[0] = e, np[1] = t;
    let n = this.get(np);
    return n === void 0 && (n = this.createNode(), this.set(np, n)), np.length = 0, n;
  }
}
class yp extends Ma {
  /**
   * Constructs a new XR render target.
   *
   * @param {number} [width=1] - The width of the render target.
   * @param {number} [height=1] - The height of the render target.
   * @param {Object} [options={}] - The configuration options.
   */
  constructor(e = 1, t = 1, n = {}) {
    super(e, t, n), this.isXRRenderTarget = !0, this._hasExternalTextures = !1, this._autoAllocateDepthBuffer = !0, this._isOpaqueFramebuffer = !1;
  }
  copy(e) {
    return super.copy(e), this._hasExternalTextures = e._hasExternalTextures, this._autoAllocateDepthBuffer = e._autoAllocateDepthBuffer, this._isOpaqueFramebuffer = e._isOpaqueFramebuffer, this;
  }
}
const dC = /* @__PURE__ */ new j(), fC = /* @__PURE__ */ new j();
class aae extends lo {
  /**
   * Constructs a new XR manager.
   *
   * @param {Renderer} renderer - The renderer.
   * @param {boolean} [multiview=false] - Enables multiview if the device supports it.
   */
  constructor(e, t = !1) {
    super(), this.enabled = !1, this.isPresenting = !1, this.cameraAutoUpdate = !0, this._renderer = e, this._cameraL = new Ji(), this._cameraL.viewport = new Kt(), this._cameraR = new Ji(), this._cameraR.viewport = new Kt(), this._cameras = [this._cameraL, this._cameraR], this._cameraXR = new dS(), this._currentDepthNear = null, this._currentDepthFar = null, this._controllers = [], this._controllerInputSources = [], this._xrRenderTarget = null, this._layers = [], this._sessionUsesLayers = !1, this._supportsGlBinding = typeof XRWebGLBinding < "u", this._frameBufferTargets = null, this._createXRLayer = fae.bind(this), this._gl = null, this._currentAnimationContext = null, this._currentAnimationLoop = null, this._currentPixelRatio = null, this._currentSize = new Le(), this._onSessionEvent = cae.bind(this), this._onSessionEnd = hae.bind(this), this._onInputSourcesChange = dae.bind(this), this._onAnimationFrame = Aae.bind(this), this._referenceSpace = null, this._referenceSpaceType = "local-floor", this._customReferenceSpace = null, this._framebufferScaleFactor = 1, this._foveation = 1, this._session = null, this._glBaseLayer = null, this._glBinding = null, this._glProjLayer = null, this._xrFrame = null, this._supportsLayers = this._supportsGlBinding && "createProjectionLayer" in XRWebGLBinding.prototype, this._useMultiviewIfPossible = t, this._useMultiview = !1;
  }
  /**
   * Returns an instance of `THREE.Group` that represents the transformation
   * of a XR controller in target ray space. The requested controller is defined
   * by the given index.
   *
   * @param {number} index - The index of the XR controller.
   * @return {Group} A group that represents the controller's transformation.
   */
  getController(e) {
    return this._getController(e).getTargetRaySpace();
  }
  /**
   * Returns an instance of `THREE.Group` that represents the transformation
   * of a XR controller in grip space. The requested controller is defined
   * by the given index.
   *
   * @param {number} index - The index of the XR controller.
   * @return {Group} A group that represents the controller's transformation.
   */
  getControllerGrip(e) {
    return this._getController(e).getGripSpace();
  }
  /**
   * Returns an instance of `THREE.Group` that represents the transformation
   * of a XR controller in hand space. The requested controller is defined
   * by the given index.
   *
   * @param {number} index - The index of the XR controller.
   * @return {Group} A group that represents the controller's transformation.
   */
  getHand(e) {
    return this._getController(e).getHandSpace();
  }
  /**
   * Returns the foveation value.
   *
   * @return {number|undefined} The foveation value. Returns `undefined` if no base or projection layer is defined.
   */
  getFoveation() {
    if (!(this._glProjLayer === null && this._glBaseLayer === null))
      return this._foveation;
  }
  /**
   * Sets the foveation value.
   *
   * @param {number} foveation - A number in the range `[0,1]` where `0` means no foveation (full resolution)
   * and `1` means maximum foveation (the edges render at lower resolution).
   */
  setFoveation(e) {
    this._foveation = e, this._glProjLayer !== null && (this._glProjLayer.fixedFoveation = e), this._glBaseLayer !== null && this._glBaseLayer.fixedFoveation !== void 0 && (this._glBaseLayer.fixedFoveation = e);
  }
  /**
   * Returns the framebuffer scale factor.
   *
   * @return {number} The framebuffer scale factor.
   */
  getFramebufferScaleFactor() {
    return this._framebufferScaleFactor;
  }
  /**
   * Sets the framebuffer scale factor.
   *
   * This method can not be used during a XR session.
   *
   * @param {number} factor - The framebuffer scale factor.
   */
  setFramebufferScaleFactor(e) {
    this._framebufferScaleFactor = e, this.isPresenting === !0 && Me("XRManager: Cannot change framebuffer scale while presenting.");
  }
  /**
   * Returns the reference space type.
   *
   * @return {XRReferenceSpaceType} The reference space type.
   */
  getReferenceSpaceType() {
    return this._referenceSpaceType;
  }
  /**
   * Sets the reference space type.
   *
   * This method can not be used during a XR session.
   *
   * @param {XRReferenceSpaceType} type - The reference space type.
   */
  setReferenceSpaceType(e) {
    this._referenceSpaceType = e, this.isPresenting === !0 && Me("XRManager: Cannot change reference space type while presenting.");
  }
  /**
   * Returns the XR reference space.
   *
   * @return {XRReferenceSpace} The XR reference space.
   */
  getReferenceSpace() {
    return this._customReferenceSpace || this._referenceSpace;
  }
  /**
   * Sets a custom XR reference space.
   *
   * @param {XRReferenceSpace} space - The XR reference space.
   */
  setReferenceSpace(e) {
    this._customReferenceSpace = e;
  }
  /**
   * Returns the XR camera.
   *
   * @return {ArrayCamera} The XR camera.
   */
  getCamera() {
    return this._cameraXR;
  }
  /**
   * Returns the environment blend mode from the current XR session.
   *
   * @return {'opaque'|'additive'|'alpha-blend'|undefined} The environment blend mode. Returns `undefined` when used outside of a XR session.
   */
  getEnvironmentBlendMode() {
    if (this._session !== null)
      return this._session.environmentBlendMode;
  }
  /**
   * Returns the current XR binding.
   *
   * Creates a new binding if needed and the browser is
   * capable of doing so.
   *
   * @return {?XRWebGLBinding} The XR binding. Returns `null` if one cannot be created.
   */
  getBinding() {
    return this._glBinding === null && this._supportsGlBinding && (this._glBinding = new XRWebGLBinding(this._session, this._gl)), this._glBinding;
  }
  /**
   * Returns the current XR frame.
   *
   * @return {?XRFrame} The XR frame. Returns `null` when used outside a XR session.
   */
  getFrame() {
    return this._xrFrame;
  }
  /**
   * Returns `true` if the engine renders to a multiview target.
   *
   * @return {boolean} Whether the engine renders to a multiview render target or not.
   */
  useMultiview() {
    return this._useMultiview;
  }
  /**
   * This method can be used in XR applications to create a quadratic layer that presents a separate
   * rendered scene.
   *
   * @param {number} width - The width of the layer plane in world units.
   * @param {number} height - The height of the layer plane in world units.
   * @param {Vector3} translation - The position/translation of the layer plane in world units.
   * @param {Quaternion} quaternion - The orientation of the layer plane expressed as a quaternion.
   * @param {number} pixelwidth - The width of the layer's render target in pixels.
   * @param {number} pixelheight - The height of the layer's render target in pixels.
   * @param {Function} rendercall - A callback function that renders the layer. Similar to code in
   * the default animation loop, this method can be used to update/transform 3D object in the layer's scene.
   * @param {Object} [attributes={}] - Allows to configure the layer's render target.
   * @return {Mesh} A mesh representing the quadratic XR layer. This mesh should be added to the XR scene.
   */
  createQuadLayer(e, t, n, r, s, o, a, l = {}) {
    const u = new td(e, t), c = new yp(
      s,
      o,
      {
        format: Pi,
        type: Mi,
        depthTexture: new Qr(
          s,
          o,
          l.stencil ? Js : Jn,
          void 0,
          void 0,
          void 0,
          void 0,
          void 0,
          void 0,
          l.stencil ? ds : Lr
        ),
        stencilBuffer: l.stencil,
        resolveDepthBuffer: !1,
        resolveStencilBuffer: !1
      }
    );
    c._autoAllocateDepthBuffer = !0;
    const A = new Nr({ color: 16777215, side: Zs });
    A.map = c.texture, A.map.offset.y = 1, A.map.repeat.y = -1;
    const m = new Tn(u, A);
    m.position.copy(n), m.quaternion.copy(r);
    const _ = {
      type: "quad",
      width: e,
      height: t,
      translation: n,
      quaternion: r,
      pixelwidth: s,
      pixelheight: o,
      plane: m,
      material: A,
      rendercall: a,
      renderTarget: c
    };
    if (this._layers.push(_), this._session !== null) {
      _.plane.material = new Nr({ color: 16777215, side: Zs }), _.plane.material.blending = oh, _.plane.material.blendEquation = Wr, _.plane.material.blendSrc = Ga, _.plane.material.blendDst = Ga, _.xrlayer = this._createXRLayer(_);
      const y = this._session.renderState.layers;
      y.unshift(_.xrlayer), this._session.updateRenderState({ layers: y });
    } else
      c.isXRRenderTarget = !1;
    return m;
  }
  /**
   * This method can be used in XR applications to create a cylindrical layer that presents a separate
   * rendered scene.
   *
   * @param {number} radius - The radius of the cylinder in world units.
   * @param {number} centralAngle - The central angle of the cylinder in radians.
   * @param {number} aspectratio - The aspect ratio.
   * @param {Vector3} translation - The position/translation of the layer plane in world units.
   * @param {Quaternion} quaternion - The orientation of the layer plane expressed as a quaternion.
   * @param {number} pixelwidth - The width of the layer's render target in pixels.
   * @param {number} pixelheight - The height of the layer's render target in pixels.
   * @param {Function} rendercall - A callback function that renders the layer. Similar to code in
   * the default animation loop, this method can be used to update/transform 3D object in the layer's scene.
   * @param {Object} [attributes={}] - Allows to configure the layer's render target.
   * @return {Mesh} A mesh representing the cylindrical XR layer. This mesh should be added to the XR scene.
   */
  createCylinderLayer(e, t, n, r, s, o, a, l, u = {}) {
    const c = new ed(e, e, e * t / n, 64, 64, !0, Math.PI - t / 2, t), A = new yp(
      o,
      a,
      {
        format: Pi,
        type: Mi,
        depthTexture: new Qr(
          o,
          a,
          u.stencil ? Js : Jn,
          void 0,
          void 0,
          void 0,
          void 0,
          void 0,
          void 0,
          u.stencil ? ds : Lr
        ),
        stencilBuffer: u.stencil,
        resolveDepthBuffer: !1,
        resolveStencilBuffer: !1
      }
    );
    A._autoAllocateDepthBuffer = !0;
    const m = new Nr({ color: 16777215, side: si });
    m.map = A.texture, m.map.offset.y = 1, m.map.repeat.y = -1;
    const _ = new Tn(c, m);
    _.position.copy(r), _.quaternion.copy(s);
    const y = {
      type: "cylinder",
      radius: e,
      centralAngle: t,
      aspectratio: n,
      translation: r,
      quaternion: s,
      pixelwidth: o,
      pixelheight: a,
      plane: _,
      material: m,
      rendercall: l,
      renderTarget: A
    };
    if (this._layers.push(y), this._session !== null) {
      y.plane.material = new Nr({ color: 16777215, side: si }), y.plane.material.blending = oh, y.plane.material.blendEquation = Wr, y.plane.material.blendSrc = Ga, y.plane.material.blendDst = Ga, y.xrlayer = this._createXRLayer(y);
      const T = this._session.renderState.layers;
      T.unshift(y.xrlayer), this._session.updateRenderState({ layers: T });
    } else
      A.isXRRenderTarget = !1;
    return _;
  }
  /**
   * Renders the XR layers that have been previously added to the scene.
   *
   * This method is usually called in your animation loop before rendering
   * the actual scene via `renderer.render( scene, camera );`.
   */
  renderLayers() {
    const e = new j(), t = new hr(), n = this._renderer, r = this.isPresenting, s = n.getOutputRenderTarget(), o = n._frameBufferTarget;
    this.isPresenting = !1;
    const a = new Le();
    n.getSize(a);
    const l = n._quad;
    for (const u of this._layers)
      if (u.renderTarget.isXRRenderTarget = this._session !== null, u.renderTarget._hasExternalTextures = u.renderTarget.isXRRenderTarget, u.renderTarget.isXRRenderTarget && this._sessionUsesLayers) {
        u.xrlayer.transform = new XRRigidTransform(u.plane.getWorldPosition(e), u.plane.getWorldQuaternion(t));
        const c = this._glBinding.getSubImage(u.xrlayer, this._xrFrame);
        n.backend.setXRRenderTargetTextures(
          u.renderTarget,
          c.colorTexture,
          void 0
        ), n._setXRLayerSize(u.renderTarget.width, u.renderTarget.height), n.setOutputRenderTarget(u.renderTarget), n.setRenderTarget(null), n._frameBufferTarget = null, this._frameBufferTargets || (this._frameBufferTargets = /* @__PURE__ */ new WeakMap());
        const { frameBufferTarget: A, quad: m } = this._frameBufferTargets.get(u.renderTarget) || { frameBufferTarget: null, quad: null };
        A ? (n._frameBufferTarget = A, n._quad = m) : (n._quad = new Q2(new Yi()), this._frameBufferTargets.set(u.renderTarget, { frameBufferTarget: n._getFrameBufferTarget(), quad: n._quad })), u.rendercall(), n._frameBufferTarget = null;
      } else
        n.setRenderTarget(u.renderTarget), u.rendercall();
    n.setRenderTarget(null), n.setOutputRenderTarget(s), n._frameBufferTarget = o, n._setXRLayerSize(a.x, a.y), n._quad = l, this.isPresenting = r;
  }
  /**
   * Returns the current XR session.
   *
   * @return {?XRSession} The XR session. Returns `null` when used outside a XR session.
   */
  getSession() {
    return this._session;
  }
  /**
   * After a XR session has been requested usually with one of the `*Button` modules, it
   * is injected into the renderer with this method. This method triggers the start of
   * the actual XR rendering.
   *
   * @async
   * @param {XRSession} session - The XR session to set.
   * @return {Promise} A Promise that resolves when the session has been set.
   */
  async setSession(e) {
    const t = this._renderer, n = t.backend;
    this._gl = t.getContext();
    const r = this._gl, s = r.getContextAttributes();
    if (this._session = e, e !== null) {
      if (n.isWebGPUBackend === !0) throw new Error('THREE.XRManager: XR is currently not supported with a WebGPU backend. Use WebGL by passing "{ forceWebGL: true }" to the constructor of the renderer.');
      if (e.addEventListener("select", this._onSessionEvent), e.addEventListener("selectstart", this._onSessionEvent), e.addEventListener("selectend", this._onSessionEvent), e.addEventListener("squeeze", this._onSessionEvent), e.addEventListener("squeezestart", this._onSessionEvent), e.addEventListener("squeezeend", this._onSessionEvent), e.addEventListener("end", this._onSessionEnd), e.addEventListener("inputsourceschange", this._onInputSourcesChange), await n.makeXRCompatible(), this._currentPixelRatio = t.getPixelRatio(), t.getSize(this._currentSize), this._currentAnimationContext = t._animation.getContext(), this._currentAnimationLoop = t._animation.getAnimationLoop(), t._animation.stop(), this._supportsLayers === !0) {
        let o = null, a = null, l = null;
        t.depth && (l = t.stencil ? r.DEPTH24_STENCIL8 : r.DEPTH_COMPONENT24, o = t.stencil ? ds : Lr, a = t.stencil ? Js : Jn);
        const u = {
          colorFormat: r.RGBA8,
          depthFormat: l,
          scaleFactor: this._framebufferScaleFactor,
          clearOnAccess: !1
        };
        this._useMultiviewIfPossible && t.hasFeature("OVR_multiview2") && (u.textureType = "texture-array", this._useMultiview = !0), this._glBinding = this.getBinding();
        const c = this._glBinding.createProjectionLayer(u), A = [c];
        this._glProjLayer = c, t.setPixelRatio(1), t._setXRLayerSize(c.textureWidth, c.textureHeight);
        const m = this._useMultiview ? 2 : 1, _ = new Qr(c.textureWidth, c.textureHeight, a, void 0, void 0, void 0, void 0, void 0, void 0, o, m);
        if (this._xrRenderTarget = new yp(
          c.textureWidth,
          c.textureHeight,
          {
            format: Pi,
            type: Mi,
            colorSpace: t.outputColorSpace,
            depthTexture: _,
            stencilBuffer: t.stencil,
            samples: s.antialias ? 4 : 0,
            resolveDepthBuffer: c.ignoreDepthValues === !1,
            resolveStencilBuffer: c.ignoreDepthValues === !1,
            depth: this._useMultiview ? 2 : 1,
            multiview: this._useMultiview
          }
        ), this._xrRenderTarget._hasExternalTextures = !0, this._xrRenderTarget.depth = this._useMultiview ? 2 : 1, this._sessionUsesLayers = e.enabledFeatures.includes("layers"), this._referenceSpace = await e.requestReferenceSpace(this.getReferenceSpaceType()), this._sessionUsesLayers)
          for (const y of this._layers)
            y.plane.material = new Nr({ color: 16777215, side: y.type === "cylinder" ? si : Zs }), y.plane.material.blending = oh, y.plane.material.blendEquation = Wr, y.plane.material.blendSrc = Ga, y.plane.material.blendDst = Ga, y.xrlayer = this._createXRLayer(y), A.unshift(y.xrlayer);
        e.updateRenderState({ layers: A });
      } else {
        const o = {
          antialias: t.currentSamples > 0,
          alpha: !0,
          depth: t.depth,
          stencil: t.stencil,
          framebufferScaleFactor: this.getFramebufferScaleFactor()
        }, a = new XRWebGLLayer(e, r, o);
        this._glBaseLayer = a, e.updateRenderState({ baseLayer: a }), t.setPixelRatio(1), t._setXRLayerSize(a.framebufferWidth, a.framebufferHeight), this._xrRenderTarget = new yp(
          a.framebufferWidth,
          a.framebufferHeight,
          {
            format: Pi,
            type: Mi,
            colorSpace: t.outputColorSpace,
            stencilBuffer: t.stencil,
            resolveDepthBuffer: a.ignoreDepthValues === !1,
            resolveStencilBuffer: a.ignoreDepthValues === !1
          }
        ), this._xrRenderTarget._isOpaqueFramebuffer = !0, this._referenceSpace = await e.requestReferenceSpace(this.getReferenceSpaceType());
      }
      this.setFoveation(this.getFoveation()), t._animation.setAnimationLoop(this._onAnimationFrame), t._animation.setContext(e), t._animation.start(), this.isPresenting = !0, this.dispatchEvent({ type: "sessionstart" });
    }
  }
  /**
   * This method is called by the renderer per frame and updates the XR camera
   * and it sub cameras based on the given camera. The given camera is the "user"
   * camera created on application level and used for non-XR rendering.
   *
   * @param {PerspectiveCamera} camera - The camera.
   */
  updateCamera(e) {
    const t = this._session;
    if (t === null) return;
    const n = e.near, r = e.far, s = this._cameraXR, o = this._cameraL, a = this._cameraR;
    s.near = a.near = o.near = n, s.far = a.far = o.far = r, s.isMultiViewCamera = this._useMultiview, (this._currentDepthNear !== s.near || this._currentDepthFar !== s.far) && (t.updateRenderState({
      depthNear: s.near,
      depthFar: s.far
    }), this._currentDepthNear = s.near, this._currentDepthFar = s.far), s.layers.mask = e.layers.mask | 6, o.layers.mask = s.layers.mask & 3, a.layers.mask = s.layers.mask & 5;
    const l = e.parent, u = s.cameras;
    AC(s, l);
    for (let c = 0; c < u.length; c++)
      AC(u[c], l);
    u.length === 2 ? lae(s, o, a) : s.projectionMatrix.copy(o.projectionMatrix), uae(e, s, l);
  }
  /**
   * Returns a WebXR controller for the given controller index.
   *
   * @private
   * @param {number} index - The controller index.
   * @return {WebXRController} The XR controller.
   */
  _getController(e) {
    let t = this._controllers[e];
    return t === void 0 && (t = new bp(), this._controllers[e] = t), t;
  }
}
function lae(i, e, t) {
  dC.setFromMatrixPosition(e.matrixWorld), fC.setFromMatrixPosition(t.matrixWorld);
  const n = dC.distanceTo(fC), r = e.projectionMatrix.elements, s = t.projectionMatrix.elements, o = r[14] / (r[10] - 1), a = r[14] / (r[10] + 1), l = (r[9] + 1) / r[5], u = (r[9] - 1) / r[5], c = (r[8] - 1) / r[0], A = (s[8] + 1) / s[0], m = o * c, _ = o * A, y = n / (-c + A), T = y * -c;
  if (e.matrixWorld.decompose(i.position, i.quaternion, i.scale), i.translateX(T), i.translateZ(y), i.matrixWorld.compose(i.position, i.quaternion, i.scale), i.matrixWorldInverse.copy(i.matrixWorld).invert(), r[10] === -1)
    i.projectionMatrix.copy(e.projectionMatrix), i.projectionMatrixInverse.copy(e.projectionMatrixInverse);
  else {
    const b = o + y, S = a + y, E = m - T, R = _ + (n - T), C = l * a / S * b, L = u * a / S * b;
    i.projectionMatrix.makePerspective(E, R, C, L, b, S), i.projectionMatrixInverse.copy(i.projectionMatrix).invert();
  }
}
function AC(i, e) {
  e === null ? i.matrixWorld.copy(i.matrix) : i.matrixWorld.multiplyMatrices(e.matrixWorld, i.matrix), i.matrixWorldInverse.copy(i.matrixWorld).invert();
}
function uae(i, e, t) {
  t === null ? i.matrix.copy(e.matrixWorld) : (i.matrix.copy(t.matrixWorld), i.matrix.invert(), i.matrix.multiply(e.matrixWorld)), i.matrix.decompose(i.position, i.quaternion, i.scale), i.updateMatrixWorld(!0), i.projectionMatrix.copy(e.projectionMatrix), i.projectionMatrixInverse.copy(e.projectionMatrixInverse), i.isPerspectiveCamera && (i.fov = Gh * 2 * Math.atan(1 / i.projectionMatrix.elements[5]), i.zoom = 1);
}
function cae(i) {
  const e = this._controllerInputSources.indexOf(i.inputSource);
  if (e === -1)
    return;
  const t = this._controllers[e];
  if (t !== void 0) {
    const n = this.getReferenceSpace();
    t.update(i.inputSource, i.frame, n), t.dispatchEvent({ type: i.type, data: i.inputSource });
  }
}
function hae() {
  const i = this._session, e = this._renderer;
  i.removeEventListener("select", this._onSessionEvent), i.removeEventListener("selectstart", this._onSessionEvent), i.removeEventListener("selectend", this._onSessionEvent), i.removeEventListener("squeeze", this._onSessionEvent), i.removeEventListener("squeezestart", this._onSessionEvent), i.removeEventListener("squeezeend", this._onSessionEvent), i.removeEventListener("end", this._onSessionEnd), i.removeEventListener("inputsourceschange", this._onInputSourcesChange);
  for (let t = 0; t < this._controllers.length; t++) {
    const n = this._controllerInputSources[t];
    n !== null && (this._controllerInputSources[t] = null, this._controllers[t].disconnect(n));
  }
  if (this._currentDepthNear = null, this._currentDepthFar = null, e._resetXRState(), this._session = null, this._xrRenderTarget = null, this._glBinding = null, this._glBaseLayer = null, this._glProjLayer = null, this._sessionUsesLayers === !0)
    for (const t of this._layers)
      t.renderTarget = new yp(
        t.pixelwidth,
        t.pixelheight,
        {
          format: Pi,
          type: Mi,
          depthTexture: new Qr(
            t.pixelwidth,
            t.pixelheight,
            t.stencilBuffer ? Js : Jn,
            void 0,
            void 0,
            void 0,
            void 0,
            void 0,
            void 0,
            t.stencilBuffer ? ds : Lr
          ),
          stencilBuffer: t.stencilBuffer,
          resolveDepthBuffer: !1,
          resolveStencilBuffer: !1
        }
      ), t.renderTarget.isXRRenderTarget = !1, t.plane.material = t.material, t.material.map = t.renderTarget.texture, t.material.map.offset.y = 1, t.material.map.repeat.y = -1, delete t.xrlayer;
  this.isPresenting = !1, this._useMultiview = !1, e._animation.stop(), e._animation.setAnimationLoop(this._currentAnimationLoop), e._animation.setContext(this._currentAnimationContext), e._animation.start(), e.setPixelRatio(this._currentPixelRatio), e.setSize(this._currentSize.width, this._currentSize.height, !1), this.dispatchEvent({ type: "sessionend" });
}
function dae(i) {
  const e = this._controllers, t = this._controllerInputSources;
  for (let n = 0; n < i.removed.length; n++) {
    const r = i.removed[n], s = t.indexOf(r);
    s >= 0 && (t[s] = null, e[s].disconnect(r));
  }
  for (let n = 0; n < i.added.length; n++) {
    const r = i.added[n];
    let s = t.indexOf(r);
    if (s === -1) {
      for (let a = 0; a < e.length; a++)
        if (a >= t.length) {
          t.push(r), s = a;
          break;
        } else if (t[a] === null) {
          t[a] = r, s = a;
          break;
        }
      if (s === -1) break;
    }
    const o = e[s];
    o && o.connect(r);
  }
}
function fae(i) {
  return i.type === "quad" ? this._glBinding.createQuadLayer({
    transform: new XRRigidTransform(i.translation, i.quaternion),
    width: i.width / 2,
    height: i.height / 2,
    space: this._referenceSpace,
    viewPixelWidth: i.pixelwidth,
    viewPixelHeight: i.pixelheight,
    clearOnAccess: !1
  }) : this._glBinding.createCylinderLayer({
    transform: new XRRigidTransform(i.translation, i.quaternion),
    radius: i.radius,
    centralAngle: i.centralAngle,
    aspectRatio: i.aspectRatio,
    space: this._referenceSpace,
    viewPixelWidth: i.pixelwidth,
    viewPixelHeight: i.pixelheight,
    clearOnAccess: !1
  });
}
function Aae(i, e) {
  if (e === void 0) return;
  const t = this._cameraXR, n = this._renderer, r = n.backend, s = this._glBaseLayer, o = this.getReferenceSpace(), a = e.getViewerPose(o);
  if (this._xrFrame = e, a !== null) {
    const l = a.views;
    this._glBaseLayer !== null && r.setXRTarget(s.framebuffer);
    let u = !1;
    l.length !== t.cameras.length && (t.cameras.length = 0, u = !0);
    for (let c = 0; c < l.length; c++) {
      const A = l[c];
      let m;
      if (this._supportsLayers === !0) {
        const y = this._glBinding.getViewSubImage(this._glProjLayer, A);
        m = y.viewport, c === 0 && r.setXRRenderTargetTextures(
          this._xrRenderTarget,
          y.colorTexture,
          this._glProjLayer.ignoreDepthValues && !this._useMultiview ? void 0 : y.depthStencilTexture
        );
      } else
        m = s.getViewport(A);
      let _ = this._cameras[c];
      _ === void 0 && (_ = new Ji(), _.layers.enable(c), _.viewport = new Kt(), this._cameras[c] = _), _.matrix.fromArray(A.transform.matrix), _.matrix.decompose(_.position, _.quaternion, _.scale), _.projectionMatrix.fromArray(A.projectionMatrix), _.projectionMatrixInverse.copy(_.projectionMatrix).invert(), _.viewport.set(m.x, m.y, m.width, m.height), c === 0 && (t.matrix.copy(_.matrix), t.matrix.decompose(t.position, t.quaternion, t.scale)), u === !0 && t.cameras.push(_);
    }
    n.setOutputRenderTarget(this._xrRenderTarget);
  }
  for (let l = 0; l < this._controllers.length; l++) {
    const u = this._controllerInputSources[l], c = this._controllers[l];
    u !== null && c !== void 0 && c.update(u, e, o);
  }
  this._currentAnimationLoop && this._currentAnimationLoop(i, e), e.detectedPlanes && this.dispatchEvent({ type: "planesdetected", data: e }), this._xrFrame = null;
}
class pae extends lo {
  /**
   * Constructs a new CanvasTarget.
   *
   * @param {HTMLCanvasElement|OffscreenCanvas} domElement - The canvas element to render to.
   */
  constructor(e) {
    super(), this.domElement = e, this._pixelRatio = 1, this._width = this.domElement.width, this._height = this.domElement.height, this._viewport = new Kt(0, 0, this._width, this._height), this._scissor = new Kt(0, 0, this._width, this._height), this._scissorTest = !1, this.colorTexture = new t2(), this.depthTexture = new Qr();
  }
  /**
   * Returns the pixel ratio.
   *
   * @return {number} The pixel ratio.
   */
  getPixelRatio() {
    return this._pixelRatio;
  }
  /**
   * Returns the drawing buffer size in physical pixels. This method honors the pixel ratio.
   *
   * @param {Vector2} target - The method writes the result in this target object.
   * @return {Vector2} The drawing buffer size.
   */
  getDrawingBufferSize(e) {
    return e.set(this._width * this._pixelRatio, this._height * this._pixelRatio).floor();
  }
  /**
   * Returns the renderer's size in logical pixels. This method does not honor the pixel ratio.
   *
   * @param {Vector2} target - The method writes the result in this target object.
   * @return {Vector2} The renderer's size in logical pixels.
   */
  getSize(e) {
    return e.set(this._width, this._height);
  }
  /**
   * Sets the given pixel ratio and resizes the canvas if necessary.
   *
   * @param {number} [value=1] - The pixel ratio.
   */
  setPixelRatio(e = 1) {
    this._pixelRatio !== e && (this._pixelRatio = e, this.setSize(this._width, this._height, !1));
  }
  /**
   * This method allows to define the drawing buffer size by specifying
   * width, height and pixel ratio all at once. The size of the drawing
   * buffer is computed with this formula:
   * ```js
   * size.x = width * pixelRatio;
   * size.y = height * pixelRatio;
   * ```
   *
   * @param {number} width - The width in logical pixels.
   * @param {number} height - The height in logical pixels.
   * @param {number} pixelRatio - The pixel ratio.
   */
  setDrawingBufferSize(e, t, n) {
    this.xr && this.xr.isPresenting || (this._width = e, this._height = t, this._pixelRatio = n, this.domElement.width = Math.floor(e * n), this.domElement.height = Math.floor(t * n), this.setViewport(0, 0, e, t), this._dispatchResize());
  }
  /**
   * Sets the size of the renderer.
   *
   * @param {number} width - The width in logical pixels.
   * @param {number} height - The height in logical pixels.
   * @param {boolean} [updateStyle=true] - Whether to update the `style` attribute of the canvas or not.
   */
  setSize(e, t, n = !0) {
    this.xr && this.xr.isPresenting || (this._width = e, this._height = t, this.domElement.width = Math.floor(e * this._pixelRatio), this.domElement.height = Math.floor(t * this._pixelRatio), n === !0 && (this.domElement.style.width = e + "px", this.domElement.style.height = t + "px"), this.setViewport(0, 0, e, t), this._dispatchResize());
  }
  /**
   * Returns the scissor rectangle.
   *
   * @param {Vector4} target - The method writes the result in this target object.
   * @return {Vector4} The scissor rectangle.
   */
  getScissor(e) {
    const t = this._scissor;
    return e.x = t.x, e.y = t.y, e.width = t.width, e.height = t.height, e;
  }
  /**
   * Defines the scissor rectangle.
   *
   * @param {number | Vector4} x - The horizontal coordinate for the lower left corner of the box in logical pixel unit.
   * Instead of passing four arguments, the method also works with a single four-dimensional vector.
   * @param {number} y - The vertical coordinate for the lower left corner of the box in logical pixel unit.
   * @param {number} width - The width of the scissor box in logical pixel unit.
   * @param {number} height - The height of the scissor box in logical pixel unit.
   */
  setScissor(e, t, n, r) {
    const s = this._scissor;
    e.isVector4 ? s.copy(e) : s.set(e, t, n, r);
  }
  /**
   * Returns the scissor test value.
   *
   * @return {boolean} Whether the scissor test should be enabled or not.
   */
  getScissorTest() {
    return this._scissorTest;
  }
  /**
   * Defines the scissor test.
   *
   * @param {boolean} boolean - Whether the scissor test should be enabled or not.
   */
  setScissorTest(e) {
    this._scissorTest = e;
  }
  /**
   * Returns the viewport definition.
   *
   * @param {Vector4} target - The method writes the result in this target object.
   * @return {Vector4} The viewport definition.
   */
  getViewport(e) {
    return e.copy(this._viewport);
  }
  /**
   * Defines the viewport.
   *
   * @param {number | Vector4} x - The horizontal coordinate for the lower left corner of the viewport origin in logical pixel unit.
   * @param {number} y - The vertical coordinate for the lower left corner of the viewport origin  in logical pixel unit.
   * @param {number} width - The width of the viewport in logical pixel unit.
   * @param {number} height - The height of the viewport in logical pixel unit.
   * @param {number} minDepth - The minimum depth value of the viewport. WebGPU only.
   * @param {number} maxDepth - The maximum depth value of the viewport. WebGPU only.
   */
  setViewport(e, t, n, r, s = 0, o = 1) {
    const a = this._viewport;
    e.isVector4 ? a.copy(e) : a.set(e, t, n, r), a.minDepth = s, a.maxDepth = o;
  }
  /**
   * Dispatches the resize event.
   *
   * @private
   */
  _dispatchResize() {
    this.dispatchEvent({ type: "resize" });
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   *
   * @fires RenderTarget#dispose
   */
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const pC = /* @__PURE__ */ new oA(), Zd = /* @__PURE__ */ new Le(), dv = /* @__PURE__ */ new Kt(), fv = /* @__PURE__ */ new ec(), Av = /* @__PURE__ */ new b0(), wg = /* @__PURE__ */ new Mt(), vl = /* @__PURE__ */ new Kt();
class mae {
  /**
   * Renderer options.
   *
   * @typedef {Object} Renderer~Options
   * @property {boolean} [logarithmicDepthBuffer=false] - Whether logarithmic depth buffer is enabled or not.
   * @property {boolean} [alpha=true] - Whether the default framebuffer (which represents the final contents of the canvas) should be transparent or opaque.
   * @property {boolean} [depth=true] - Whether the default framebuffer should have a depth buffer or not.
   * @property {boolean} [stencil=false] - Whether the default framebuffer should have a stencil buffer or not.
   * @property {boolean} [antialias=false] - Whether MSAA as the default anti-aliasing should be enabled or not.
   * @property {number} [samples=0] - When `antialias` is `true`, `4` samples are used by default. This parameter can set to any other integer value than 0
   * to overwrite the default.
   * @property {?Function} [getFallback=null] - This callback function can be used to provide a fallback backend, if the primary backend can't be targeted.
   * @property {number} [outputBufferType=HalfFloatType] - Defines the type of output buffers. The default `HalfFloatType` is recommend for best
   * quality. To save memory and bandwidth, `UnsignedByteType` might be used. This will reduce rendering quality though.
   * @property {boolean} [multiview=false] - If set to `true`, the renderer will use multiview during WebXR rendering if supported.
   */
  /**
  	 * Constructs a new renderer.
  	 *
  	 * @param {Backend} backend - The backend the renderer is targeting (e.g. WebGPU or WebGL 2).
  	 * @param {Renderer~Options} [parameters] - The configuration parameter.

  	 */
  constructor(e, t = {}) {
    this.isRenderer = !0;
    const {
      logarithmicDepthBuffer: n = !1,
      alpha: r = !0,
      depth: s = !0,
      stencil: o = !1,
      antialias: a = !1,
      samples: l = 0,
      getFallback: u = null,
      outputBufferType: c = Ri,
      multiview: A = !1
    } = t;
    this.backend = e, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.alpha = r, this.logarithmicDepthBuffer = n, this.outputColorSpace = gr, this.toneMapping = Dr, this.toneMappingExposure = 1, this.sortObjects = !0, this.depth = s, this.stencil = o, this.info = new ste(), this.contextNode = eu(), this.library = new TI(), this.lighting = new oae(), this._samples = l || a === !0 ? 4 : 0, this._onCanvasTargetResize = this._onCanvasTargetResize.bind(this), this._canvasTarget = new pae(e.getDomElement()), this._canvasTarget.addEventListener("resize", this._onCanvasTargetResize), this._canvasTarget.isDefaultCanvasTarget = !0, this._inspector = new D6(), this._inspector.setRenderer(this), this._getFallback = u, this._attributes = null, this._geometries = null, this._nodes = null, this._animation = null, this._bindings = null, this._objects = null, this._pipelines = null, this._bundles = null, this._renderLists = null, this._renderContexts = null, this._textures = null, this._background = null, this._quad = new Q2(new Yi()), this._quad.name = "Output Color Transform", this._quad.material.name = "outputColorTransform", this._currentRenderContext = null, this._opaqueSort = null, this._transparentSort = null, this._frameBufferTarget = null;
    const m = this.alpha === !0 ? 0 : 1;
    this._clearColor = new HT(0, 0, 0, m), this._clearDepth = 1, this._clearStencil = 0, this._renderTarget = null, this._activeCubeFace = 0, this._activeMipmapLevel = 0, this._outputRenderTarget = null, this._mrt = null, this._renderObjectFunction = null, this._currentRenderObjectFunction = null, this._currentRenderBundle = null, this._handleObjectFunction = this._renderObjectDirect, this._isDeviceLost = !1, this.onDeviceLost = this._onDeviceLost, this._outputBufferType = c, this._cacheShadowNodes = /* @__PURE__ */ new WeakMap(), this._initialized = !1, this._initPromise = null, this._compilationPromises = null, this.transparent = !0, this.opaque = !0, this.shadowMap = {
      enabled: !1,
      type: Af
    }, this.xr = new aae(this, A), this.debug = {
      checkShaderErrors: !0,
      onShaderError: null,
      getShaderAsync: async (_, y, T) => {
        await this.compileAsync(_, y);
        const b = this._renderLists.get(_, y), S = this._renderContexts.get(_, y, this._renderTarget, this._mrt), E = _.overrideMaterial || T.material, R = this._objects.get(T, E, _, y, b.lightsNode, S, S.clippingContext), { fragmentShader: C, vertexShader: L } = R.getNodeBuilderState();
        return { fragmentShader: C, vertexShader: L };
      }
    };
  }
  /**
   * Initializes the renderer so it is ready for usage.
   *
   * @async
   * @return {Promise<this>} A Promise that resolves when the renderer has been initialized.
   */
  async init() {
    return this._initPromise !== null ? this._initPromise : (this._initPromise = new Promise(async (e, t) => {
      let n = this.backend;
      try {
        await n.init(this);
      } catch (r) {
        if (this._getFallback !== null)
          try {
            this.backend = n = this._getFallback(r), await n.init(this);
          } catch (s) {
            t(s);
            return;
          }
        else {
          t(r);
          return;
        }
      }
      this._nodes = new nae(this, n), this._animation = new Qee(this, this._nodes, this.info), this._attributes = new ite(n), this._background = new moe(this, this._nodes), this._geometries = new rte(this._attributes, this.info), this._textures = new yte(this, n, this.info), this._pipelines = new ute(n, this._nodes), this._bindings = new cte(n, this._nodes, this._textures, this._attributes, this._pipelines, this.info), this._objects = new ete(this, this._nodes, this._geometries, this._pipelines, this._bindings, this.info), this._renderLists = new fte(this.lighting), this._bundles = new rae(), this._renderContexts = new _te(), this._animation.start(), this._initialized = !0, this._inspector.init(), e(this);
    }), this._initPromise);
  }
  /**
   * A reference to the canvas element the renderer is drawing to.
   * This value of this property will automatically be created by
   * the renderer.
   *
   * @type {HTMLCanvasElement|OffscreenCanvas}
   */
  get domElement() {
    return this._canvasTarget.domElement;
  }
  /**
   * The coordinate system of the renderer. The value of this property
   * depends on the selected backend. Either `THREE.WebGLCoordinateSystem` or
   * `THREE.WebGPUCoordinateSystem`.
   *
   * @readonly
   * @type {number}
   */
  get coordinateSystem() {
    return this.backend.coordinateSystem;
  }
  /**
   * Compiles all materials in the given scene. This can be useful to avoid a
   * phenomenon which is called "shader compilation stutter", which occurs when
   * rendering an object with a new shader for the first time.
   *
   * If you want to add a 3D object to an existing scene, use the third optional
   * parameter for applying the target scene. Note that the (target) scene's lighting
   * and environment must be configured before calling this method.
   *
   * @async
   * @param {Object3D} scene - The scene or 3D object to precompile.
   * @param {Camera} camera - The camera that is used to render the scene.
   * @param {?Scene} targetScene - If the first argument is a 3D object, this parameter must represent the scene the 3D object is going to be added.
   * @return {Promise} A Promise that resolves when the compile has been finished.
   */
  async compileAsync(e, t, n = null) {
    if (this._isDeviceLost === !0) return;
    this._initialized === !1 && await this.init();
    const r = this._nodes.nodeFrame, s = r.renderId, o = this._currentRenderContext, a = this._currentRenderObjectFunction, l = this._compilationPromises, u = e.isScene === !0 ? e : pC;
    n === null && (n = e);
    const c = this._renderTarget, A = this._renderContexts.get(n, t, c, this._mrt), m = this._activeMipmapLevel, _ = [];
    this._currentRenderContext = A, this._currentRenderObjectFunction = this.renderObject, this._handleObjectFunction = this._createObjectPipeline, this._compilationPromises = _, r.renderId++, r.update(), A.depth = this.depth, A.stencil = this.stencil, A.clippingContext || (A.clippingContext = new __()), A.clippingContext.updateGlobal(u, t), u.onBeforeRender(this, e, t, c);
    const y = this._renderLists.get(e, t);
    if (y.begin(), this._projectObject(e, t, 0, y, A.clippingContext), n !== e && n.traverseVisible(function(R) {
      R.isLight && R.layers.test(t.layers) && y.pushLight(R);
    }), y.finish(), c !== null) {
      this._textures.updateRenderTarget(c, m);
      const R = this._textures.get(c);
      A.textures = R.textures, A.depthTexture = R.depthTexture;
    } else
      A.textures = null, A.depthTexture = null;
    this._background.update(u, y, A);
    const T = y.opaque, b = y.transparent, S = y.transparentDoublePass, E = y.lightsNode;
    this.opaque === !0 && T.length > 0 && this._renderObjects(T, t, u, E), this.transparent === !0 && b.length > 0 && this._renderTransparents(b, S, t, u, E), r.renderId = s, this._currentRenderContext = o, this._currentRenderObjectFunction = a, this._compilationPromises = l, this._handleObjectFunction = this._renderObjectDirect, await Promise.all(_);
  }
  /**
   * Renders the scene in an async fashion.
   *
   * @async
   * @deprecated
   * @param {Object3D} scene - The scene or 3D object to render.
   * @param {Camera} camera - The camera.
   * @return {Promise} A Promise that resolves when the render has been finished.
   */
  async renderAsync(e, t) {
    li('Renderer: "renderAsync()" has been deprecated. Use "render()" and "await renderer.init();" when creating the renderer.'), await this.init(), this.render(e, t);
  }
  /**
   * Can be used to synchronize CPU operations with GPU tasks. So when this method is called,
   * the CPU waits for the GPU to complete its operation (e.g. a compute task).
   *
   * @async
   * @deprecated
   * @return {Promise} A Promise that resolves when synchronization has been finished.
   */
  async waitForGPU() {
    Ie("Renderer: waitForGPU() has been removed. Read https://github.com/mrdoob/three.js/issues/32012 for more information.");
  }
  //
  set inspector(e) {
    this._inspector !== null && this._inspector.setRenderer(null), this._inspector = e, this._inspector.setRenderer(this);
  }
  /**
   * The inspector instance. The inspector can be any class that extends from `InspectorBase`.
   *
   * @type {InspectorBase}
   */
  get inspector() {
    return this._inspector;
  }
  /**
   * Enables or disables high precision for model-view and normal-view matrices.
   * When enabled, will use CPU 64-bit precision for higher precision instead of GPU 32-bit for higher performance.
   *
   * NOTE: 64-bit precision is not compatible with `InstancedMesh` and `SkinnedMesh`.
   *
   * @param {boolean} value - Whether to enable or disable high precision.
   * @type {boolean}
   */
  set highPrecision(e) {
    const t = this.contextNode.value;
    e === !0 ? (t.modelViewMatrix = kb, t.modelNormalViewMatrix = Vb) : this.highPrecision && (delete t.modelViewMatrix, delete t.modelNormalViewMatrix);
  }
  /**
   * Returns whether high precision is enabled or not.
   *
   * @return {boolean} Whether high precision is enabled or not.
   * @type {boolean}
   */
  get highPrecision() {
    const e = this.contextNode.value;
    return e.modelViewMatrix === kb && e.modelNormalViewMatrix === Vb;
  }
  /**
   * Sets the given MRT configuration.
   *
   * @param {MRTNode} mrt - The MRT node to set.
   * @return {Renderer} A reference to this renderer.
   */
  setMRT(e) {
    return this._mrt = e, this;
  }
  /**
   * Returns the MRT configuration.
   *
   * @return {MRTNode} The MRT configuration.
   */
  getMRT() {
    return this._mrt;
  }
  /**
   * Returns the output buffer type.
   *
   * @return {number} The output buffer type.
   */
  getOutputBufferType() {
    return this._outputBufferType;
  }
  /**
   * Returns the output buffer type.
   *
   * @deprecated since r182. Use `.getOutputBufferType()` instead.
   * @return {number} The output buffer type.
   */
  getColorBufferType() {
    return li('Renderer: ".getColorBufferType()" has been renamed to ".getOutputBufferType()".'), this.getOutputBufferType();
  }
  /**
   * Default implementation of the device lost callback.
   *
   * @private
   * @param {Object} info - Information about the context lost.
   */
  _onDeviceLost(e) {
    let t = `THREE.WebGPURenderer: ${e.api} Device Lost:

Message: ${e.message}`;
    e.reason && (t += `
Reason: ${e.reason}`), Ie(t), this._isDeviceLost = !0;
  }
  /**
   * Renders the given render bundle.
   *
   * @private
   * @param {Object} bundle - Render bundle data.
   * @param {Scene} sceneRef - The scene the render bundle belongs to.
   * @param {LightsNode} lightsNode - The lights node.
   */
  _renderBundle(e, t, n) {
    const { bundleGroup: r, camera: s, renderList: o } = e, a = this._currentRenderContext, l = this._bundles.get(r, s), u = this.backend.get(l);
    u.renderContexts === void 0 && (u.renderContexts = /* @__PURE__ */ new Set());
    const c = r.version !== u.version, A = u.renderContexts.has(a) === !1 || c;
    if (u.renderContexts.add(a), A) {
      this.backend.beginBundle(a), (u.renderObjects === void 0 || c) && (u.renderObjects = []), this._currentRenderBundle = l;
      const {
        transparentDoublePass: m,
        transparent: _,
        opaque: y
      } = o;
      this.opaque === !0 && y.length > 0 && this._renderObjects(y, s, t, n), this.transparent === !0 && _.length > 0 && this._renderTransparents(_, m, s, t, n), this._currentRenderBundle = null, this.backend.finishBundle(a, l), u.version = r.version;
    } else {
      const { renderObjects: m } = u;
      for (let _ = 0, y = m.length; _ < y; _++) {
        const T = m[_];
        this._nodes.needsRefresh(T) && (this._nodes.updateBefore(T), this._nodes.updateForRender(T), this._bindings.updateForRender(T), this._nodes.updateAfter(T));
      }
    }
    this.backend.addBundle(a, l);
  }
  /**
   * Renders the scene or 3D object with the given camera. This method can only be called
   * if the renderer has been initialized. When using `render()` inside an animation loop,
   * it's guaranteed the renderer will be initialized. The animation loop must be defined
   * with {@link Renderer#setAnimationLoop} though.
   *
   * For all other use cases (like when using on-demand rendering), you must call
   * {@link Renderer#init} before rendering.
   *
   * The target of the method is the default framebuffer (meaning the canvas)
   * or alternatively a render target when specified via `setRenderTarget()`.
   *
   * @param {Object3D} scene - The scene or 3D object to render.
   * @param {Camera} camera - The camera to render the scene with.
   */
  render(e, t) {
    if (this._initialized === !1)
      throw new Error('Renderer: .render() called before the backend is initialized. Use "await renderer.init();" before rendering.');
    this._renderScene(e, t);
  }
  /**
   * Returns whether the renderer has been initialized or not.
   *
   * @readonly
   * @return {boolean} Whether the renderer has been initialized or not.
   */
  get initialized() {
    return this._initialized;
  }
  /**
   * Returns an internal render target which is used when computing the output tone mapping
   * and color space conversion. Unlike in `WebGLRenderer`, this is done in a separate render
   * pass and not inline to achieve more correct results.
   *
   * @private
   * @return {?RenderTarget} The render target. The method returns `null` if no output conversion should be applied.
   */
  _getFrameBufferTarget() {
    const { currentToneMapping: e, currentColorSpace: t } = this, n = e !== Dr, r = t !== Xt.workingColorSpace;
    if (n === !1 && r === !1) return null;
    const { width: s, height: o } = this.getDrawingBufferSize(Zd), { depth: a, stencil: l } = this;
    let u = this._frameBufferTarget;
    u === null && (u = new Ma(s, o, {
      depthBuffer: a,
      stencilBuffer: l,
      type: this._outputBufferType,
      format: Pi,
      colorSpace: Xt.workingColorSpace,
      generateMipmaps: !1,
      minFilter: qn,
      magFilter: qn,
      samples: this.samples
    }), u.isPostProcessingRenderTarget = !0, this._frameBufferTarget = u);
    const c = this.getOutputRenderTarget();
    u.depthBuffer = a, u.stencilBuffer = l, c !== null ? u.setSize(c.width, c.height, c.depth) : u.setSize(s, o, 1);
    const A = this._canvasTarget;
    return u.viewport.copy(A._viewport), u.scissor.copy(A._scissor), u.viewport.multiplyScalar(A._pixelRatio), u.scissor.multiplyScalar(A._pixelRatio), u.scissorTest = A._scissorTest, u.multiview = c !== null ? c.multiview : !1, u.resolveDepthBuffer = c !== null ? c.resolveDepthBuffer : !0, u._autoAllocateDepthBuffer = c !== null ? c._autoAllocateDepthBuffer : !1, u;
  }
  /**
   * Renders the scene or 3D object with the given camera.
   *
   * @private
   * @param {Object3D} scene - The scene or 3D object to render.
   * @param {Camera} camera - The camera to render the scene with.
   * @param {boolean} [useFrameBufferTarget=true] - Whether to use a framebuffer target or not.
   * @return {RenderContext} The current render context.
   */
  _renderScene(e, t, n = !0) {
    if (this._isDeviceLost === !0) return;
    const r = n ? this._getFrameBufferTarget() : null, s = this._nodes.nodeFrame, o = s.renderId, a = this._currentRenderContext, l = this._currentRenderObjectFunction, u = e.isScene === !0 ? e : pC, c = this._renderTarget || this._outputRenderTarget, A = this._activeCubeFace, m = this._activeMipmapLevel;
    let _;
    r !== null ? (_ = r, this.setRenderTarget(_)) : _ = c;
    const y = this._renderContexts.get(e, t, _, this._mrt);
    this._currentRenderContext = y, this._currentRenderObjectFunction = this._renderObjectFunction || this.renderObject, this.info.calls++, this.info.render.calls++, this.info.render.frameCalls++, s.renderId = this.info.calls, this.backend.updateTimeStampUID(y), this.inspector.beginRender(this.backend.getTimestampUID(y), e, t, _);
    const T = this.coordinateSystem, b = this.xr;
    if (t.coordinateSystem !== T && b.isPresenting === !1 && (t.coordinateSystem = T, t.updateProjectionMatrix(), t.isArrayCamera))
      for (const K of t.cameras)
        K.coordinateSystem = T, K.updateProjectionMatrix();
    e.matrixWorldAutoUpdate === !0 && e.updateMatrixWorld(), t.parent === null && t.matrixWorldAutoUpdate === !0 && t.updateMatrixWorld(), b.enabled === !0 && b.isPresenting === !0 && (b.cameraAutoUpdate === !0 && b.updateCamera(t), t = b.getCamera());
    const S = this._canvasTarget;
    let E = S._viewport, R = S._scissor, C = S._pixelRatio;
    _ !== null && (E = _.viewport, R = _.scissor, C = 1), this.getDrawingBufferSize(Zd), dv.set(0, 0, Zd.width, Zd.height);
    const L = E.minDepth === void 0 ? 0 : E.minDepth, D = E.maxDepth === void 0 ? 1 : E.maxDepth;
    y.viewportValue.copy(E).multiplyScalar(C).floor(), y.viewportValue.width >>= m, y.viewportValue.height >>= m, y.viewportValue.minDepth = L, y.viewportValue.maxDepth = D, y.viewport = y.viewportValue.equals(dv) === !1, y.scissorValue.copy(R).multiplyScalar(C).floor(), y.scissor = S._scissorTest && y.scissorValue.equals(dv) === !1, y.scissorValue.width >>= m, y.scissorValue.height >>= m, y.clippingContext || (y.clippingContext = new __()), y.clippingContext.updateGlobal(u, t), u.onBeforeRender(this, e, t, _);
    const B = t.isArrayCamera ? Av : fv;
    t.isArrayCamera || (wg.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), B.setFromProjectionMatrix(wg, t.coordinateSystem, t.reversedDepth));
    const U = this._renderLists.get(e, t);
    if (U.begin(), this._projectObject(e, t, 0, U, y.clippingContext), U.finish(), this.sortObjects === !0 && U.sort(this._opaqueSort, this._transparentSort), _ !== null) {
      this._textures.updateRenderTarget(_, m);
      const K = this._textures.get(_);
      y.textures = K.textures, y.depthTexture = K.depthTexture, y.width = K.width, y.height = K.height, y.renderTarget = _, y.depth = _.depthBuffer, y.stencil = _.stencilBuffer;
    } else
      y.textures = null, y.depthTexture = null, y.width = Zd.width, y.height = Zd.height, y.depth = this.depth, y.stencil = this.stencil;
    y.width >>= m, y.height >>= m, y.activeCubeFace = A, y.activeMipmapLevel = m, y.occlusionQueryCount = U.occlusionQueryCount, y.scissorValue.max(vl.set(0, 0, 0, 0)), y.scissorValue.x + y.scissorValue.width > y.width && (y.scissorValue.width = Math.max(y.width - y.scissorValue.x, 0)), y.scissorValue.y + y.scissorValue.height > y.height && (y.scissorValue.height = Math.max(y.height - y.scissorValue.y, 0)), this._background.update(u, U, y), y.camera = t, this.backend.beginRender(y);
    const {
      bundles: N,
      lightsNode: O,
      transparentDoublePass: G,
      transparent: H,
      opaque: Y
    } = U;
    return N.length > 0 && this._renderBundles(N, u, O), this.opaque === !0 && Y.length > 0 && this._renderObjects(Y, t, u, O), this.transparent === !0 && H.length > 0 && this._renderTransparents(H, G, t, u, O), this.backend.finishRender(y), s.renderId = o, this._currentRenderContext = a, this._currentRenderObjectFunction = l, r !== null && (this.setRenderTarget(c, A, m), this._renderOutput(_)), u.onAfterRender(this, e, t, _), this.inspector.finishRender(this.backend.getTimestampUID(y)), y;
  }
  _setXRLayerSize(e, t) {
    this._canvasTarget._width = e, this._canvasTarget._height = t, this.setViewport(0, 0, e, t);
  }
  /**
   * The output pass performs tone mapping and color space conversion.
   *
   * @private
   * @param {RenderTarget} renderTarget - The current render target.
   */
  _renderOutput(e) {
    const t = this._quad;
    this._nodes.hasOutputChange(e.texture) && (t.material.fragmentNode = this._nodes.getOutputNode(e.texture), t.material.needsUpdate = !0);
    const n = this.autoClear, r = this.xr.enabled;
    this.autoClear = !1, this.xr.enabled = !1, this._renderScene(t, t.camera, !1), this.autoClear = n, this.xr.enabled = r;
  }
  /**
   * Returns the maximum available anisotropy for texture filtering.
   *
   * @return {number} The maximum available anisotropy.
   */
  getMaxAnisotropy() {
    return this.backend.getMaxAnisotropy();
  }
  /**
   * Returns the active cube face.
   *
   * @return {number} The active cube face.
   */
  getActiveCubeFace() {
    return this._activeCubeFace;
  }
  /**
   * Returns the active mipmap level.
   *
   * @return {number} The active mipmap level.
   */
  getActiveMipmapLevel() {
    return this._activeMipmapLevel;
  }
  /**
   * Applications are advised to always define the animation loop
   * with this method and not manually with `requestAnimationFrame()`
   * for best compatibility.
   *
   * @async
   * @param {?onAnimationCallback} callback - The application's animation loop.
   * @return {Promise} A Promise that resolves when the set has been executed.
   */
  async setAnimationLoop(e) {
    this._initialized === !1 && await this.init(), this._animation.setAnimationLoop(e);
  }
  /**
   * Returns the current animation loop callback.
   *
   * @return {?Function} The current animation loop callback.
   */
  getAnimationLoop() {
    return this._animation.getAnimationLoop();
  }
  /**
   * Can be used to transfer buffer data from a storage buffer attribute
   * from the GPU to the CPU in context of compute shaders.
   *
   * @async
   * @param {StorageBufferAttribute} attribute - The storage buffer attribute.
   * @return {Promise<ArrayBuffer>} A promise that resolves with the buffer data when the data are ready.
   */
  async getArrayBufferAsync(e) {
    return await this.backend.getArrayBufferAsync(e);
  }
  /**
   * Returns the rendering context.
   *
   * @return {GPUCanvasContext|WebGL2RenderingContext} The rendering context.
   */
  getContext() {
    return this.backend.getContext();
  }
  /**
   * Returns the pixel ratio.
   *
   * @return {number} The pixel ratio.
   */
  getPixelRatio() {
    return this._canvasTarget.getPixelRatio();
  }
  /**
   * Returns the drawing buffer size in physical pixels. This method honors the pixel ratio.
   *
   * @param {Vector2} target - The method writes the result in this target object.
   * @return {Vector2} The drawing buffer size.
   */
  getDrawingBufferSize(e) {
    return this._canvasTarget.getDrawingBufferSize(e);
  }
  /**
   * Returns the renderer's size in logical pixels. This method does not honor the pixel ratio.
   *
   * @param {Vector2} target - The method writes the result in this target object.
   * @return {Vector2} The renderer's size in logical pixels.
   */
  getSize(e) {
    return this._canvasTarget.getSize(e);
  }
  /**
   * Sets the given pixel ratio and resizes the canvas if necessary.
   *
   * @param {number} [value=1] - The pixel ratio.
   */
  setPixelRatio(e = 1) {
    this._canvasTarget.setPixelRatio(e);
  }
  /**
   * This method allows to define the drawing buffer size by specifying
   * width, height and pixel ratio all at once. The size of the drawing
   * buffer is computed with this formula:
   * ```js
   * size.x = width * pixelRatio;
   * size.y = height * pixelRatio;
   * ```
   *
   * @param {number} width - The width in logical pixels.
   * @param {number} height - The height in logical pixels.
   * @param {number} pixelRatio - The pixel ratio.
   */
  setDrawingBufferSize(e, t, n) {
    this.xr && this.xr.isPresenting || this._canvasTarget.setDrawingBufferSize(e, t, n);
  }
  /**
   * Sets the size of the renderer.
   *
   * @param {number} width - The width in logical pixels.
   * @param {number} height - The height in logical pixels.
   * @param {boolean} [updateStyle=true] - Whether to update the `style` attribute of the canvas or not.
   */
  setSize(e, t, n = !0) {
    this.xr && this.xr.isPresenting || this._canvasTarget.setSize(e, t, n);
  }
  /**
   * Defines a manual sort function for the opaque render list.
   * Pass `null` to use the default sort.
   *
   * @param {Function} method - The sort function.
   */
  setOpaqueSort(e) {
    this._opaqueSort = e;
  }
  /**
   * Defines a manual sort function for the transparent render list.
   * Pass `null` to use the default sort.
   *
   * @param {Function} method - The sort function.
   */
  setTransparentSort(e) {
    this._transparentSort = e;
  }
  /**
   * Returns the scissor rectangle.
   *
   * @param {Vector4} target - The method writes the result in this target object.
   * @return {Vector4} The scissor rectangle.
   */
  getScissor(e) {
    return this._canvasTarget.getScissor(e);
  }
  /**
   * Defines the scissor rectangle.
   *
   * @param {number | Vector4} x - The horizontal coordinate for the upper left corner of the box in logical pixel unit.
   * Instead of passing four arguments, the method also works with a single four-dimensional vector.
   * @param {number} y - The vertical coordinate for the upper left corner of the box in logical pixel unit.
   * @param {number} width - The width of the scissor box in logical pixel unit.
   * @param {number} height - The height of the scissor box in logical pixel unit.
   */
  setScissor(e, t, n, r) {
    this._canvasTarget.setScissor(e, t, n, r);
  }
  /**
   * Returns the scissor test value.
   *
   * @return {boolean} Whether the scissor test should be enabled or not.
   */
  getScissorTest() {
    return this._canvasTarget.getScissorTest();
  }
  /**
   * Defines the scissor test.
   *
   * @param {boolean} boolean - Whether the scissor test should be enabled or not.
   */
  setScissorTest(e) {
    this._canvasTarget.setScissorTest(e), this.backend.setScissorTest(e);
  }
  /**
   * Returns the viewport definition.
   *
   * @param {Vector4} target - The method writes the result in this target object.
   * @return {Vector4} The viewport definition.
   */
  getViewport(e) {
    return this._canvasTarget.getViewport(e);
  }
  /**
   * Defines the viewport.
   *
   * @param {number | Vector4} x - The horizontal coordinate for the upper left corner of the viewport origin in logical pixel unit.
   * @param {number} y - The vertical coordinate for the upper left corner of the viewport origin  in logical pixel unit.
   * @param {number} width - The width of the viewport in logical pixel unit.
   * @param {number} height - The height of the viewport in logical pixel unit.
   * @param {number} minDepth - The minimum depth value of the viewport. WebGPU only.
   * @param {number} maxDepth - The maximum depth value of the viewport. WebGPU only.
   */
  setViewport(e, t, n, r, s = 0, o = 1) {
    this._canvasTarget.setViewport(e, t, n, r, s, o);
  }
  /**
   * Returns the clear color.
   *
   * @param {Color} target - The method writes the result in this target object.
   * @return {Color} The clear color.
   */
  getClearColor(e) {
    return e.copy(this._clearColor);
  }
  /**
   * Defines the clear color and optionally the clear alpha.
   *
   * @param {Color} color - The clear color.
   * @param {number} [alpha=1] - The clear alpha.
   */
  setClearColor(e, t = 1) {
    this._clearColor.set(e), this._clearColor.a = t;
  }
  /**
   * Returns the clear alpha.
   *
   * @return {number} The clear alpha.
   */
  getClearAlpha() {
    return this._clearColor.a;
  }
  /**
   * Defines the clear alpha.
   *
   * @param {number} alpha - The clear alpha.
   */
  setClearAlpha(e) {
    this._clearColor.a = e;
  }
  /**
   * Returns the clear depth.
   *
   * @return {number} The clear depth.
   */
  getClearDepth() {
    return this._clearDepth;
  }
  /**
   * Defines the clear depth.
   *
   * @param {number} depth - The clear depth.
   */
  setClearDepth(e) {
    this._clearDepth = e;
  }
  /**
   * Returns the clear stencil.
   *
   * @return {number} The clear stencil.
   */
  getClearStencil() {
    return this._clearStencil;
  }
  /**
   * Defines the clear stencil.
   *
   * @param {number} stencil - The clear stencil.
   */
  setClearStencil(e) {
    this._clearStencil = e;
  }
  /**
   * This method performs an occlusion query for the given 3D object.
   * It returns `true` if the given 3D object is fully occluded by other
   * 3D objects in the scene.
   *
   * @param {Object3D} object - The 3D object to test.
   * @return {boolean} Whether the 3D object is fully occluded or not.
   */
  isOccluded(e) {
    const t = this._currentRenderContext;
    return t && this.backend.isOccluded(t, e);
  }
  /**
   * Performs a manual clear operation. This method ignores `autoClear` properties.
   *
   * @param {boolean} [color=true] - Whether the color buffer should be cleared or not.
   * @param {boolean} [depth=true] - Whether the depth buffer should be cleared or not.
   * @param {boolean} [stencil=true] - Whether the stencil buffer should be cleared or not.
   */
  clear(e = !0, t = !0, n = !0) {
    if (this._initialized === !1)
      throw new Error('Renderer: .clear() called before the backend is initialized. Use "await renderer.init();" before before using this method.');
    const r = this._renderTarget || this._getFrameBufferTarget();
    let s = null;
    if (r !== null) {
      this._textures.updateRenderTarget(r);
      const o = this._textures.get(r);
      s = this._renderContexts.getForClear(r), s.textures = o.textures, s.depthTexture = o.depthTexture, s.width = o.width, s.height = o.height, s.renderTarget = r, s.depth = r.depthBuffer, s.stencil = r.stencilBuffer, s.clearColorValue = this.backend.getClearColor(), s.activeCubeFace = this.getActiveCubeFace(), s.activeMipmapLevel = this.getActiveMipmapLevel();
    }
    this.backend.clear(e, t, n, s), r !== null && this._renderTarget === null && this._renderOutput(r);
  }
  /**
   * Performs a manual clear operation of the color buffer. This method ignores `autoClear` properties.
   */
  clearColor() {
    this.clear(!0, !1, !1);
  }
  /**
   * Performs a manual clear operation of the depth buffer. This method ignores `autoClear` properties.
   */
  clearDepth() {
    this.clear(!1, !0, !1);
  }
  /**
   * Performs a manual clear operation of the stencil buffer. This method ignores `autoClear` properties.
   */
  clearStencil() {
    this.clear(!1, !1, !0);
  }
  /**
   * Async version of {@link Renderer#clear}.
   *
   * @async
   * @deprecated
   * @param {boolean} [color=true] - Whether the color buffer should be cleared or not.
   * @param {boolean} [depth=true] - Whether the depth buffer should be cleared or not.
   * @param {boolean} [stencil=true] - Whether the stencil buffer should be cleared or not.
   * @return {Promise} A Promise that resolves when the clear operation has been executed.
   */
  async clearAsync(e = !0, t = !0, n = !0) {
    li('Renderer: "clearAsync()" has been deprecated. Use "clear()" and "await renderer.init();" when creating the renderer.'), await this.init(), this.clear(e, t, n);
  }
  /**
   * Async version of {@link Renderer#clearColor}.
   *
   * @async
   * @deprecated
   * @return {Promise} A Promise that resolves when the clear operation has been executed.
   */
  async clearColorAsync() {
    li('Renderer: "clearColorAsync()" has been deprecated. Use "clearColor()" and "await renderer.init();" when creating the renderer.'), this.clear(!0, !1, !1);
  }
  /**
   * Async version of {@link Renderer#clearDepth}.
   *
   * @async
   * @deprecated
   * @return {Promise} A Promise that resolves when the clear operation has been executed.
   */
  async clearDepthAsync() {
    li('Renderer: "clearDepthAsync()" has been deprecated. Use "clearDepth()" and "await renderer.init();" when creating the renderer.'), this.clear(!1, !0, !1);
  }
  /**
   * Async version of {@link Renderer#clearStencil}.
   *
   * @async
   * @deprecated
   * @return {Promise} A Promise that resolves when the clear operation has been executed.
   */
  async clearStencilAsync() {
    li('Renderer: "clearStencilAsync()" has been deprecated. Use "clearStencil()" and "await renderer.init();" when creating the renderer.'), this.clear(!1, !1, !0);
  }
  /**
   * Returns `true` if a framebuffer target is needed to perform tone mapping or color space conversion.
   * If this is the case, the renderer allocates an internal render target for that purpose.
   *
   */
  get needsFrameBufferTarget() {
    const e = this.currentToneMapping !== Dr, t = this.currentColorSpace !== Xt.workingColorSpace;
    return e || t;
  }
  /**
   * The number of samples used for multi-sample anti-aliasing (MSAA).
   *
   * @type {number}
   * @default 0
   */
  get samples() {
    return this._samples;
  }
  /**
   * The current number of samples used for multi-sample anti-aliasing (MSAA).
   *
   * When rendering to a custom render target, the number of samples of that render target is used.
   * If the renderer needs an internal framebuffer target for tone mapping or color space conversion,
   * the number of samples is set to 0.
   *
   * @type {number}
   */
  get currentSamples() {
    let e = this._samples;
    return this._renderTarget !== null ? e = this._renderTarget.samples : this.needsFrameBufferTarget && (e = 0), e;
  }
  /**
   * The current tone mapping of the renderer. When not producing screen output,
   * the tone mapping is always `NoToneMapping`.
   *
   * @type {number}
   */
  get currentToneMapping() {
    return this.isOutputTarget ? this.toneMapping : Dr;
  }
  /**
   * The current color space of the renderer. When not producing screen output,
   * the color space is always the working color space.
   *
   * @type {string}
   */
  get currentColorSpace() {
    return this.isOutputTarget ? this.outputColorSpace : Xt.workingColorSpace;
  }
  /**
   * Returns `true` if the rendering settings are set to screen output.
   *
   * @returns {boolean} True if the current render target is the same of output render target or `null`, otherwise false.
   */
  get isOutputTarget() {
    return this._renderTarget === this._outputRenderTarget || this._renderTarget === null;
  }
  /**
   * Frees all internal resources of the renderer. Call this method if the renderer
   * is no longer in use by your app.
   */
  dispose() {
    this._initialized === !0 && (this.info.dispose(), this.backend.dispose(), this._animation.dispose(), this._objects.dispose(), this._geometries.dispose(), this._pipelines.dispose(), this._nodes.dispose(), this._bindings.dispose(), this._renderLists.dispose(), this._renderContexts.dispose(), this._textures.dispose(), this._frameBufferTarget !== null && this._frameBufferTarget.dispose(), Object.values(this.backend.timestampQueryPool).forEach((e) => {
      e !== null && e.dispose();
    })), this.setRenderTarget(null), this.setAnimationLoop(null);
  }
  /**
   * Sets the given render target. Calling this method means the renderer does not
   * target the default framebuffer (meaning the canvas) anymore but a custom framebuffer.
   * Use `null` as the first argument to reset the state.
   *
   * @param {?RenderTarget} renderTarget - The render target to set.
   * @param {number} [activeCubeFace=0] - The active cube face.
   * @param {number} [activeMipmapLevel=0] - The active mipmap level.
   */
  setRenderTarget(e, t = 0, n = 0) {
    this._renderTarget = e, this._activeCubeFace = t, this._activeMipmapLevel = n;
  }
  /**
   * Returns the current render target.
   *
   * @return {?RenderTarget} The render target. Returns `null` if no render target is set.
   */
  getRenderTarget() {
    return this._renderTarget;
  }
  /**
   * Sets the output render target for the renderer.
   *
   * @param {Object} renderTarget - The render target to set as the output target.
   */
  setOutputRenderTarget(e) {
    this._outputRenderTarget = e;
  }
  /**
   * Returns the current output target.
   *
   * @return {?RenderTarget} The current output render target. Returns `null` if no output target is set.
   */
  getOutputRenderTarget() {
    return this._outputRenderTarget;
  }
  /**
   * Sets the canvas target. The canvas target manages the HTML canvas
   * or the offscreen canvas the renderer draws into.
   *
   * @param {CanvasTarget} canvasTarget - The canvas target.
   */
  setCanvasTarget(e) {
    this._canvasTarget.removeEventListener("resize", this._onCanvasTargetResize), this._canvasTarget = e, this._canvasTarget.addEventListener("resize", this._onCanvasTargetResize);
  }
  /**
   * Returns the current canvas target.
   *
   * @return {CanvasTarget} The current canvas target.
   */
  getCanvasTarget() {
    return this._canvasTarget;
  }
  /**
   * Resets the renderer to the initial state before WebXR started.
   *
   * @private
   */
  _resetXRState() {
    this.backend.setXRTarget(null), this.setOutputRenderTarget(null), this.setRenderTarget(null), this._frameBufferTarget.dispose(), this._frameBufferTarget = null;
  }
  /**
   * Callback for {@link Renderer#setRenderObjectFunction}.
   *
   * @callback renderObjectFunction
   * @param {Object3D} object - The 3D object.
   * @param {Scene} scene - The scene the 3D object belongs to.
   * @param {Camera} camera - The camera the object should be rendered with.
   * @param {BufferGeometry} geometry - The object's geometry.
   * @param {Material} material - The object's material.
   * @param {?Object} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.
   * @param {LightsNode} lightsNode - The current lights node.
   * @param {ClippingContext} clippingContext - The clipping context.
   * @param {?string} [passId=null] - An optional ID for identifying the pass.
   */
  /**
   * Sets the given render object function. Calling this method overwrites the default implementation
   * which is {@link Renderer#renderObject}. Defining a custom function can be useful
   * if you want to modify the way objects are rendered. For example you can define things like "every
   * object that has material of a certain type should perform a pre-pass with a special overwrite material".
   * The custom function must always call `renderObject()` in its implementation.
   *
   * Use `null` as the first argument to reset the state.
   *
   * @param {?renderObjectFunction} renderObjectFunction - The render object function.
   */
  setRenderObjectFunction(e) {
    this._renderObjectFunction = e;
  }
  /**
   * Returns the current render object function.
   *
   * @return {?Function} The current render object function. Returns `null` if no function is set.
   */
  getRenderObjectFunction() {
    return this._renderObjectFunction;
  }
  /**
   * Execute a single or an array of compute nodes. This method can only be called
   * if the renderer has been initialized.
   *
   * @param {Node|Array<Node>} computeNodes - The compute node(s).
   * @param {number|Array<number>|IndirectStorageBufferAttribute} [dispatchSize=null]
   * - A single number representing count, or
   * - An array [x, y, z] representing dispatch size, or
   * - A IndirectStorageBufferAttribute for indirect dispatch size.
   * @return {Promise|undefined} A Promise that resolve when the compute has finished. Only returned when the renderer has not been initialized.
   */
  compute(e, t = null) {
    if (this._isDeviceLost === !0) return;
    if (this._initialized === !1)
      return Me("Renderer: .compute() called before the backend is initialized. Try using .computeAsync() instead."), this.computeAsync(e, t);
    const n = this._nodes.nodeFrame, r = n.renderId;
    this.info.calls++, this.info.compute.calls++, this.info.compute.frameCalls++, n.renderId = this.info.calls, this.backend.updateTimeStampUID(e), this.inspector.beginCompute(this.backend.getTimestampUID(e), e);
    const s = this.backend, o = this._pipelines, a = this._bindings, l = this._nodes, u = Array.isArray(e) ? e : [e];
    if (u[0] === void 0 || u[0].isComputeNode !== !0)
      throw new Error("THREE.Renderer: .compute() expects a ComputeNode.");
    s.beginCompute(e);
    for (const c of u) {
      if (o.has(c) === !1) {
        const _ = () => {
          c.removeEventListener("dispose", _), o.delete(c), a.deleteForCompute(c), l.delete(c);
        };
        c.addEventListener("dispose", _);
        const y = c.onInitFunction;
        y !== null && y.call(c, { renderer: this });
      }
      l.updateForCompute(c), a.updateForCompute(c);
      const A = a.getForCompute(c), m = o.getForCompute(c, A);
      s.compute(e, c, A, m, t);
    }
    s.finishCompute(e), n.renderId = r, this.inspector.finishCompute(this.backend.getTimestampUID(e));
  }
  /**
   * Execute a single or an array of compute nodes.
   *
   * @async
   * @param {Node|Array<Node>} computeNodes - The compute node(s).
   * @param {number|Array<number>|IndirectStorageBufferAttribute} [dispatchSize=null]
   * - A single number representing count, or
   * - An array [x, y, z] representing dispatch size, or
   * - A IndirectStorageBufferAttribute for indirect dispatch size.
   * @return {Promise} A Promise that resolve when the compute has finished.
   */
  async computeAsync(e, t = null) {
    this._initialized === !1 && await this.init(), this.compute(e, t);
  }
  /**
   * Checks if the given feature is supported by the selected backend.
   *
   * @async
   * @deprecated
   * @param {string} name - The feature's name.
   * @return {Promise<boolean>} A Promise that resolves with a bool that indicates whether the feature is supported or not.
   */
  async hasFeatureAsync(e) {
    return li('Renderer: "hasFeatureAsync()" has been deprecated. Use "hasFeature()" and "await renderer.init();" when creating the renderer.'), await this.init(), this.hasFeature(e);
  }
  async resolveTimestampsAsync(e = "render") {
    return this._initialized === !1 && await this.init(), this.backend.resolveTimestampsAsync(e);
  }
  /**
   * Checks if the given feature is supported by the selected backend. If the
   * renderer has not been initialized, this method always returns `false`.
   *
   * @param {string} name - The feature's name.
   * @return {boolean} Whether the feature is supported or not.
   */
  hasFeature(e) {
    if (this._initialized === !1)
      throw new Error('Renderer: .hasFeature() called before the backend is initialized. Use "await renderer.init();" before before using this method.');
    return this.backend.hasFeature(e);
  }
  /**
   * Returns `true` when the renderer has been initialized.
   *
   * @return {boolean} Whether the renderer has been initialized or not.
   */
  hasInitialized() {
    return this._initialized;
  }
  /**
   * Initializes the given textures. Useful for preloading a texture rather than waiting until first render
   * (which can cause noticeable lags due to decode and GPU upload overhead).
   *
   * @async
   * @deprecated
   * @param {Texture} texture - The texture.
   * @return {Promise} A Promise that resolves when the texture has been initialized.
   */
  async initTextureAsync(e) {
    li('Renderer: "initTextureAsync()" has been deprecated. Use "initTexture()" and "await renderer.init();" when creating the renderer.'), await this.init(), this.initTexture(e);
  }
  /**
   * Initializes the given texture. Useful for preloading a texture rather than waiting until first render
   * (which can cause noticeable lags due to decode and GPU upload overhead).
   *
   * This method can only be used if the renderer has been initialized.
   *
   * @param {Texture} texture - The texture.
   */
  initTexture(e) {
    if (this._initialized === !1)
      throw new Error('Renderer: .initTexture() called before the backend is initialized. Use "await renderer.init();" before before using this method.');
    this._textures.updateTexture(e);
  }
  /**
   * Copies the current bound framebuffer into the given texture.
   *
   * @param {FramebufferTexture} framebufferTexture - The texture.
   * @param {?(Vector2|Vector4)} [rectangle=null] - A two or four dimensional vector that defines the rectangular portion of the framebuffer that should be copied.
   */
  copyFramebufferToTexture(e, t = null) {
    if (t !== null)
      if (t.isVector2)
        t = vl.set(t.x, t.y, e.image.width, e.image.height).floor();
      else if (t.isVector4)
        t = vl.copy(t).floor();
      else {
        Ie("Renderer.copyFramebufferToTexture: Invalid rectangle.");
        return;
      }
    else
      t = vl.set(0, 0, e.image.width, e.image.height);
    let n = this._currentRenderContext, r;
    n !== null ? r = n.renderTarget : (r = this._renderTarget || this._getFrameBufferTarget(), r !== null && (this._textures.updateRenderTarget(r), n = this._textures.get(r))), this._textures.updateTexture(e, { renderTarget: r }), this.backend.copyFramebufferToTexture(e, n, t), this._inspector.copyFramebufferToTexture(e);
  }
  /**
   * Copies data of the given source texture into a destination texture.
   *
   * @param {Texture} srcTexture - The source texture.
   * @param {Texture} dstTexture - The destination texture.
   * @param {Box2|Box3} [srcRegion=null] - A bounding box which describes the source region. Can be two or three-dimensional.
   * @param {Vector2|Vector3} [dstPosition=null] - A vector that represents the origin of the destination region. Can be two or three-dimensional.
   * @param {number} [srcLevel=0] - The source mip level to copy from.
   * @param {number} [dstLevel=0] - The destination mip level to copy to.
   */
  copyTextureToTexture(e, t, n = null, r = null, s = 0, o = 0) {
    this._textures.updateTexture(e), this._textures.updateTexture(t), this.backend.copyTextureToTexture(e, t, n, r, s, o), this._inspector.copyTextureToTexture(e, t);
  }
  /**
   * Reads pixel data from the given render target.
   *
   * @async
   * @param {RenderTarget} renderTarget - The render target to read from.
   * @param {number} x - The `x` coordinate of the copy region's origin.
   * @param {number} y - The `y` coordinate of the copy region's origin.
   * @param {number} width - The width of the copy region.
   * @param {number} height - The height of the copy region.
   * @param {number} [textureIndex=0] - The texture index of a MRT render target.
   * @param {number} [faceIndex=0] - The active cube face index.
   * @return {Promise<TypedArray>} A Promise that resolves when the read has been finished. The resolve provides the read data as a typed array.
   */
  async readRenderTargetPixelsAsync(e, t, n, r, s, o = 0, a = 0) {
    return this.backend.copyTextureToBuffer(e.textures[o], t, n, r, s, a);
  }
  /**
   * Analyzes the given 3D object's hierarchy and builds render lists from the
   * processed hierarchy.
   *
   * @private
   * @param {Object3D} object - The 3D object to process (usually a scene).
   * @param {Camera} camera - The camera the object is rendered with.
   * @param {number} groupOrder - The group order is derived from the `renderOrder` of groups and is used to group 3D objects within groups.
   * @param {RenderList} renderList - The current render list.
   * @param {ClippingContext} clippingContext - The current clipping context.
   */
  _projectObject(e, t, n, r, s) {
    if (e.visible === !1) return;
    if (e.layers.test(t.layers)) {
      if (e.isGroup)
        n = e.renderOrder, e.isClippingGroup && e.enabled && (s = s.getGroupContext(e));
      else if (e.isLOD)
        e.autoUpdate === !0 && e.update(t);
      else if (e.isLight)
        r.pushLight(e);
      else if (e.isSprite) {
        const l = t.isArrayCamera ? Av : fv;
        if (!e.frustumCulled || l.intersectsSprite(e, t)) {
          this.sortObjects === !0 && vl.setFromMatrixPosition(e.matrixWorld).applyMatrix4(wg);
          const { geometry: u, material: c } = e;
          c.visible && r.push(e, u, c, n, vl.z, null, s);
        }
      } else if (e.isLineLoop)
        Ie("Renderer: Objects of type THREE.LineLoop are not supported. Please use THREE.Line or THREE.LineSegments.");
      else if (e.isMesh || e.isLine || e.isPoints) {
        const l = t.isArrayCamera ? Av : fv;
        if (!e.frustumCulled || l.intersectsObject(e, t)) {
          const { geometry: u, material: c } = e;
          if (this.sortObjects === !0 && (u.boundingSphere === null && u.computeBoundingSphere(), vl.copy(u.boundingSphere.center).applyMatrix4(e.matrixWorld).applyMatrix4(wg)), Array.isArray(c)) {
            const A = u.groups;
            for (let m = 0, _ = A.length; m < _; m++) {
              const y = A[m], T = c[y.materialIndex];
              T && T.visible && r.push(e, u, T, n, vl.z, y, s);
            }
          } else c.visible && r.push(e, u, c, n, vl.z, null, s);
        }
      }
    }
    if (e.isBundleGroup === !0 && this.backend.beginBundle !== void 0) {
      const l = r;
      r = this._renderLists.get(e, t), r.begin(), l.pushBundle({
        bundleGroup: e,
        camera: t,
        renderList: r
      }), r.finish();
    }
    const a = e.children;
    for (let l = 0, u = a.length; l < u; l++)
      this._projectObject(a[l], t, n, r, s);
  }
  /**
   * Renders the given render bundles.
   *
   * @private
   * @param {Array<Object>} bundles - Array with render bundle data.
   * @param {Scene} sceneRef - The scene the render bundles belong to.
   * @param {LightsNode} lightsNode - The current lights node.
   */
  _renderBundles(e, t, n) {
    for (const r of e)
      this._renderBundle(r, t, n);
  }
  /**
   * Renders the transparent objects from the given render lists.
   *
   * @private
   * @param {Array<Object>} renderList - The transparent render list.
   * @param {Array<Object>} doublePassList - The list of transparent objects which require a double pass (e.g. because of transmission).
   * @param {Camera} camera - The camera the render list should be rendered with.
   * @param {Scene} scene - The scene the render list belongs to.
   * @param {LightsNode} lightsNode - The current lights node.
   */
  _renderTransparents(e, t, n, r, s) {
    if (t.length > 0) {
      for (const { material: o } of t)
        o.side = si;
      this._renderObjects(t, n, r, s, "backSide");
      for (const { material: o } of t)
        o.side = Zs;
      this._renderObjects(e, n, r, s);
      for (const { material: o } of t)
        o.side = er;
    } else
      this._renderObjects(e, n, r, s);
  }
  /**
   * Renders the objects from the given render list.
   *
   * @private
   * @param {Array<Object>} renderList - The render list.
   * @param {Camera} camera - The camera the render list should be rendered with.
   * @param {Scene} scene - The scene the render list belongs to.
   * @param {LightsNode} lightsNode - The current lights node.
   * @param {?string} [passId=null] - An optional ID for identifying the pass.
   */
  _renderObjects(e, t, n, r, s = null) {
    for (let o = 0, a = e.length; o < a; o++) {
      const { object: l, geometry: u, material: c, group: A, clippingContext: m } = e[o];
      this._currentRenderObjectFunction(l, n, t, u, c, A, r, m, s);
    }
  }
  /**
   * Retrieves shadow nodes for the given material. This is used to setup shadow passes.
   * The result is cached per material and updated when the material's version changes.
   *
   * @private
   * @param {Material} material
   * @returns {Object} - The shadow nodes for the material.
   */
  _getShadowNodes(e) {
    const t = e.version;
    let n = this._cacheShadowNodes.get(e);
    if (n === void 0 || n.version !== t) {
      const r = e.map !== null, s = e.colorNode && e.colorNode.isNode, o = e.castShadowNode && e.castShadowNode.isNode;
      let a = null, l = null, u = null;
      if (r || s || o) {
        let c, A;
        o ? (c = e.castShadowNode.rgb, A = e.castShadowNode.a) : (c = ce(0), A = J(1)), r && (A = A.mul(ui("map", "texture", e).a)), s && (A = A.mul(e.colorNode.a)), l = Gt(c, A);
      }
      e.depthNode && e.depthNode.isNode && (u = e.depthNode), e.castShadowPositionNode && e.castShadowPositionNode.isNode ? a = e.castShadowPositionNode : e.positionNode && e.positionNode.isNode && (a = e.positionNode), n = {
        version: t,
        colorNode: l,
        depthNode: u,
        positionNode: a
      }, this._cacheShadowNodes.set(e, n);
    }
    return n;
  }
  /**
   * This method represents the default render object function that manages the render lifecycle
   * of the object.
   *
   * @param {Object3D} object - The 3D object.
   * @param {Scene} scene - The scene the 3D object belongs to.
   * @param {Camera} camera - The camera the object should be rendered with.
   * @param {BufferGeometry} geometry - The object's geometry.
   * @param {Material} material - The object's material.
   * @param {?Object} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.
   * @param {LightsNode} lightsNode - The current lights node.
   * @param {?ClippingContext} clippingContext - The clipping context.
   * @param {?string} [passId=null] - An optional ID for identifying the pass.
   */
  renderObject(e, t, n, r, s, o, a, l = null, u = null) {
    let c = !1, A, m, _, y;
    if (e.onBeforeRender(this, t, n, r, s, o), s.allowOverride === !0 && t.overrideMaterial !== null) {
      const T = t.overrideMaterial;
      if (c = !0, A = t.overrideMaterial.colorNode, m = t.overrideMaterial.depthNode, _ = t.overrideMaterial.positionNode, y = t.overrideMaterial.side, s.positionNode && s.positionNode.isNode && (T.positionNode = s.positionNode), T.alphaTest = s.alphaTest, T.alphaMap = s.alphaMap, T.transparent = s.transparent || s.transmission > 0 || s.transmissionNode && s.transmissionNode.isNode || s.backdropNode && s.backdropNode.isNode, T.isShadowPassMaterial) {
        const { colorNode: b, depthNode: S, positionNode: E } = this._getShadowNodes(s);
        T.side = s.shadowSide === null ? s.side : s.shadowSide, b !== null && (T.colorNode = b), S !== null && (T.depthNode = S), E !== null && (T.positionNode = E);
      }
      s = T;
    }
    s.transparent === !0 && s.side === er && s.forceSinglePass === !1 ? (s.side = si, this._handleObjectFunction(e, s, t, n, a, o, l, "backSide"), s.side = Zs, this._handleObjectFunction(e, s, t, n, a, o, l, u), s.side = er) : this._handleObjectFunction(e, s, t, n, a, o, l, u), c && (t.overrideMaterial.colorNode = A, t.overrideMaterial.depthNode = m, t.overrideMaterial.positionNode = _, t.overrideMaterial.side = y), e.onAfterRender(this, t, n, r, s, o);
  }
  /**
   * This method represents the default `_handleObjectFunction` implementation which creates
   * a render object from the given data and performs the draw command with the selected backend.
   *
   * @private
   * @param {Object3D} object - The 3D object.
   * @param {Material} material - The object's material.
   * @param {Scene} scene - The scene the 3D object belongs to.
   * @param {Camera} camera - The camera the object should be rendered with.
   * @param {LightsNode} lightsNode - The current lights node.
   * @param {?{start: number, count: number}} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.
   * @param {ClippingContext} clippingContext - The clipping context.
   * @param {string} [passId] - An optional ID for identifying the pass.
   */
  _renderObjectDirect(e, t, n, r, s, o, a, l) {
    const u = this._objects.get(e, t, n, r, s, this._currentRenderContext, a, l);
    u.drawRange = e.geometry.drawRange, u.group = o;
    const c = this._nodes.needsRefresh(u);
    c && (this._nodes.updateBefore(u), this._geometries.updateForRender(u), this._nodes.updateForRender(u), this._bindings.updateForRender(u)), this._pipelines.updateForRender(u), this._currentRenderBundle !== null && (this.backend.get(this._currentRenderBundle).renderObjects.push(u), u.bundle = this._currentRenderBundle.bundleGroup), this.backend.draw(u, this.info), c && this._nodes.updateAfter(u);
  }
  /**
   * A different implementation for `_handleObjectFunction` which only makes sure the object is ready for rendering.
   * Used in `compileAsync()`.
   *
   * @private
   * @param {Object3D} object - The 3D object.
   * @param {Material} material - The object's material.
   * @param {Scene} scene - The scene the 3D object belongs to.
   * @param {Camera} camera - The camera the object should be rendered with.
   * @param {LightsNode} lightsNode - The current lights node.
   * @param {?{start: number, count: number}} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.
   * @param {ClippingContext} clippingContext - The clipping context.
   * @param {string} [passId] - An optional ID for identifying the pass.
   */
  _createObjectPipeline(e, t, n, r, s, o, a, l) {
    const u = this._objects.get(e, t, n, r, s, this._currentRenderContext, a, l);
    u.drawRange = e.geometry.drawRange, u.group = o, this._nodes.updateBefore(u), this._geometries.updateForRender(u), this._nodes.updateForRender(u), this._bindings.updateForRender(u), this._pipelines.getForRender(u, this._compilationPromises), this._nodes.updateAfter(u);
  }
  /**
   * Callback when the canvas has been resized.
   *
   * @private
   */
  _onCanvasTargetResize() {
    this._initialized && this.backend.updateSize();
  }
  /**
   * Alias for `compileAsync()`.
   *
   * @method
   * @param {Object3D} scene - The scene or 3D object to precompile.
   * @param {Camera} camera - The camera that is used to render the scene.
   * @param {Scene} targetScene - If the first argument is a 3D object, this parameter must represent the scene the 3D object is going to be added.
   * @return {function(Object3D, Camera, ?Scene): Promise|undefined} A Promise that resolves when the compile has been finished.
   */
  get compile() {
    return this.compileAsync;
  }
}
class wI {
  /**
   * Constructs a new binding.
   *
   * @param {string} [name=''] - The binding's name.
   */
  constructor(e = "") {
    this.name = e, this.visibility = 0;
  }
  /**
   * Makes sure binding's resource is visible for the given shader stage.
   *
   * @param {number} visibility - The shader stage.
   */
  setVisibility(e) {
    this.visibility |= e;
  }
  /**
   * The shader stages in which the binding's resource is visible.
   *
   * @return {number} The visibility bitmask.
   */
  getVisibility() {
    return this.visibility;
  }
  /**
   * Clones the binding.
   *
   * @return {Binding} The cloned binding.
   */
  clone() {
    return Object.assign(new this.constructor(), this);
  }
}
function gae(i) {
  return i + (Nu - i % Nu) % Nu;
}
class MI extends wI {
  /**
   * Constructs a new buffer.
   *
   * @param {string} name - The buffer's name.
   * @param {TypedArray} [buffer=null] - The buffer.
   */
  constructor(e, t = null) {
    super(e), this.isBuffer = !0, this.bytesPerElement = Float32Array.BYTES_PER_ELEMENT, this._buffer = t, this._updateRanges = [];
  }
  /**
   * The array of update ranges.
   *
   * @type {Array<{start: number, count: number}>}
   */
  get updateRanges() {
    return this._updateRanges;
  }
  /**
   * Adds an update range.
   *
   * @param {number} start - The start index.
   * @param {number} count - The number of elements.
   */
  addUpdateRange(e, t) {
    this.updateRanges.push({ start: e, count: t });
  }
  /**
   * Clears all update ranges.
   */
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  /**
   * The buffer's byte length.
   *
   * @type {number}
   * @readonly
   */
  get byteLength() {
    return gae(this._buffer.byteLength);
  }
  /**
   * A reference to the internal buffer.
   *
   * @type {Float32Array}
   * @readonly
   */
  get buffer() {
    return this._buffer;
  }
  /**
   * Updates the binding.
   *
   * @return {boolean} Whether the buffer has been updated and must be
   * uploaded to the GPU.
   */
  update() {
    return !0;
  }
}
class EI extends MI {
  /**
   * Constructs a new uniform buffer.
   *
   * @param {string} name - The buffer's name.
   * @param {TypedArray} [buffer=null] - The buffer.
   */
  constructor(e, t = null) {
    super(e, t), this.isUniformBuffer = !0;
  }
}
let _ae = 0;
class RI extends EI {
  /**
   * Constructs a new node-based uniform buffer.
   *
   * @param {BufferNode} nodeUniform - The uniform buffer node.
   * @param {UniformGroupNode} groupNode - The uniform group node.
   */
  constructor(e, t) {
    super("UniformBuffer_" + _ae++, e ? e.value : null), this.nodeUniform = e, this.groupNode = t, this.isNodeUniformBuffer = !0;
  }
  /**
   * The array of update ranges.
   *
   * @param {Array<{start: number, count: number}>} value - The update ranges.
   */
  set updateRanges(e) {
    this.nodeUniform.updateRanges = e;
  }
  /**
   * The array of update ranges.
   *
   * @type {Array<{start: number, count: number}>}
   */
  get updateRanges() {
    return this.nodeUniform.updateRanges;
  }
  /**
   * Adds a range of data in the data array to be updated on the GPU.
   *
   * @param {number} start - Position at which to start update.
   * @param {number} count - The number of components to update.
   */
  addUpdateRange(e, t) {
    this.nodeUniform.addUpdateRange(e, t);
  }
  /**
   * Clears all update ranges.
   */
  clearUpdateRanges() {
    this.nodeUniform.clearUpdateRanges();
  }
  /**
   * The uniform buffer.
   *
   * @type {Float32Array}
   */
  get buffer() {
    return this.nodeUniform.value;
  }
}
class xae extends EI {
  /**
   * Constructs a new uniforms group.
   *
   * @param {string} name - The group's name.
   */
  constructor(e) {
    super(e), this.isUniformsGroup = !0, this._values = null, this.uniforms = [];
  }
  /**
   * Adds a uniform to this group.
   *
   * @param {Uniform} uniform - The uniform to add.
   * @return {UniformsGroup} A reference to this group.
   */
  addUniform(e) {
    return this.uniforms.push(e), this;
  }
  /**
   * Removes a uniform from this group.
   *
   * @param {Uniform} uniform - The uniform to remove.
   * @return {UniformsGroup} A reference to this group.
   */
  removeUniform(e) {
    const t = this.uniforms.indexOf(e);
    return t !== -1 && this.uniforms.splice(t, 1), this;
  }
  /**
   * An array with the raw uniform values.
   *
   * @type {Array<number>}
   */
  get values() {
    return this._values === null && (this._values = Array.from(this.buffer)), this._values;
  }
  /**
   * A Float32 array buffer with the uniform values.
   *
   * @type {Float32Array}
   */
  get buffer() {
    let e = this._buffer;
    if (e === null) {
      const t = this.byteLength;
      e = new Float32Array(new ArrayBuffer(t)), this._buffer = e;
    }
    return e;
  }
  /**
   * The byte length of the buffer with correct buffer alignment.
   *
   * @type {number}
   */
  get byteLength() {
    const e = this.bytesPerElement;
    let t = 0;
    for (let n = 0, r = this.uniforms.length; n < r; n++) {
      const s = this.uniforms[n], o = s.boundary, a = s.itemSize * e, l = t % Nu, u = l % o, c = l + u;
      t += u, c !== 0 && Nu - c < a && (t += Nu - c), s.offset = t / e, t += a;
    }
    return Math.ceil(t / Nu) * Nu;
  }
  /**
   * Updates this group by updating each uniform object of
   * the internal uniform list. The uniform objects check if their
   * values has actually changed so this method only returns
   * `true` if there is a real value change.
   *
   * @return {boolean} Whether the uniforms have been updated and
   * must be uploaded to the GPU.
   */
  update() {
    let e = !1;
    for (const t of this.uniforms)
      this.updateByType(t) === !0 && (e = !0);
    return e;
  }
  /**
   * Updates a given uniform by calling an update method matching
   * the uniforms type.
   *
   * @param {Uniform} uniform - The uniform to update.
   * @return {boolean} Whether the uniform has been updated or not.
   */
  updateByType(e) {
    if (e.isNumberUniform) return this.updateNumber(e);
    if (e.isVector2Uniform) return this.updateVector2(e);
    if (e.isVector3Uniform) return this.updateVector3(e);
    if (e.isVector4Uniform) return this.updateVector4(e);
    if (e.isColorUniform) return this.updateColor(e);
    if (e.isMatrix3Uniform) return this.updateMatrix3(e);
    if (e.isMatrix4Uniform) return this.updateMatrix4(e);
    Ie("WebGPUUniformsGroup: Unsupported uniform type.", e);
  }
  /**
   * Updates a given Number uniform.
   *
   * @param {NumberUniform} uniform - The Number uniform.
   * @return {boolean} Whether the uniform has been updated or not.
   */
  updateNumber(e) {
    let t = !1;
    const n = this.values, r = e.getValue(), s = e.offset, o = e.getType();
    if (n[s] !== r) {
      const a = this._getBufferForType(o);
      a[s] = n[s] = r, t = !0;
    }
    return t;
  }
  /**
   * Updates a given Vector2 uniform.
   *
   * @param {Vector2Uniform} uniform - The Vector2 uniform.
   * @return {boolean} Whether the uniform has been updated or not.
   */
  updateVector2(e) {
    let t = !1;
    const n = this.values, r = e.getValue(), s = e.offset, o = e.getType();
    if (n[s + 0] !== r.x || n[s + 1] !== r.y) {
      const a = this._getBufferForType(o);
      a[s + 0] = n[s + 0] = r.x, a[s + 1] = n[s + 1] = r.y, t = !0;
    }
    return t;
  }
  /**
   * Updates a given Vector3 uniform.
   *
   * @param {Vector3Uniform} uniform - The Vector3 uniform.
   * @return {boolean} Whether the uniform has been updated or not.
   */
  updateVector3(e) {
    let t = !1;
    const n = this.values, r = e.getValue(), s = e.offset, o = e.getType();
    if (n[s + 0] !== r.x || n[s + 1] !== r.y || n[s + 2] !== r.z) {
      const a = this._getBufferForType(o);
      a[s + 0] = n[s + 0] = r.x, a[s + 1] = n[s + 1] = r.y, a[s + 2] = n[s + 2] = r.z, t = !0;
    }
    return t;
  }
  /**
   * Updates a given Vector4 uniform.
   *
   * @param {Vector4Uniform} uniform - The Vector4 uniform.
   * @return {boolean} Whether the uniform has been updated or not.
   */
  updateVector4(e) {
    let t = !1;
    const n = this.values, r = e.getValue(), s = e.offset, o = e.getType();
    if (n[s + 0] !== r.x || n[s + 1] !== r.y || n[s + 2] !== r.z || n[s + 4] !== r.w) {
      const a = this._getBufferForType(o);
      a[s + 0] = n[s + 0] = r.x, a[s + 1] = n[s + 1] = r.y, a[s + 2] = n[s + 2] = r.z, a[s + 3] = n[s + 3] = r.w, t = !0;
    }
    return t;
  }
  /**
   * Updates a given Color uniform.
   *
   * @param {ColorUniform} uniform - The Color uniform.
   * @return {boolean} Whether the uniform has been updated or not.
   */
  updateColor(e) {
    let t = !1;
    const n = this.values, r = e.getValue(), s = e.offset;
    if (n[s + 0] !== r.r || n[s + 1] !== r.g || n[s + 2] !== r.b) {
      const o = this.buffer;
      o[s + 0] = n[s + 0] = r.r, o[s + 1] = n[s + 1] = r.g, o[s + 2] = n[s + 2] = r.b, t = !0;
    }
    return t;
  }
  /**
   * Updates a given Matrix3 uniform.
   *
   * @param {Matrix3Uniform} uniform - The Matrix3 uniform.
   * @return {boolean} Whether the uniform has been updated or not.
   */
  updateMatrix3(e) {
    let t = !1;
    const n = this.values, r = e.getValue().elements, s = e.offset;
    if (n[s + 0] !== r[0] || n[s + 1] !== r[1] || n[s + 2] !== r[2] || n[s + 4] !== r[3] || n[s + 5] !== r[4] || n[s + 6] !== r[5] || n[s + 8] !== r[6] || n[s + 9] !== r[7] || n[s + 10] !== r[8]) {
      const o = this.buffer;
      o[s + 0] = n[s + 0] = r[0], o[s + 1] = n[s + 1] = r[1], o[s + 2] = n[s + 2] = r[2], o[s + 4] = n[s + 4] = r[3], o[s + 5] = n[s + 5] = r[4], o[s + 6] = n[s + 6] = r[5], o[s + 8] = n[s + 8] = r[6], o[s + 9] = n[s + 9] = r[7], o[s + 10] = n[s + 10] = r[8], t = !0;
    }
    return t;
  }
  /**
   * Updates a given Matrix4 uniform.
   *
   * @param {Matrix4Uniform} uniform - The Matrix4 uniform.
   * @return {boolean} Whether the uniform has been updated or not.
   */
  updateMatrix4(e) {
    let t = !1;
    const n = this.values, r = e.getValue().elements, s = e.offset;
    return vae(n, r, s) === !1 && (this.buffer.set(r, s), yae(n, r, s), t = !0), t;
  }
  /**
   * Returns a typed array that matches the given data type.
   *
   * @private
   * @param {string} type - The data type.
   * @return {TypedArray} The typed array.
   */
  _getBufferForType(e) {
    return e === "int" || e === "ivec2" || e === "ivec3" || e === "ivec4" ? new Int32Array(this.buffer.buffer) : e === "uint" || e === "uvec2" || e === "uvec3" || e === "uvec4" ? new Uint32Array(this.buffer.buffer) : this.buffer;
  }
}
function yae(i, e, t) {
  for (let n = 0, r = e.length; n < r; n++)
    i[t + n] = e[n];
}
function vae(i, e, t) {
  for (let n = 0, r = e.length; n < r; n++)
    if (i[t + n] !== e[n]) return !1;
  return !0;
}
let bae = 0;
class CI extends xae {
  /**
   * Constructs a new node-based uniforms group.
   *
   * @param {string} name - The group's name.
   * @param {UniformGroupNode} groupNode - The uniform group node.
   */
  constructor(e, t) {
    super(e), this.id = bae++, this.groupNode = t, this.isNodeUniformsGroup = !0;
  }
}
class PI extends wI {
  /**
   * Constructs a new sampler.
   *
   * @param {string} name - The samplers's name.
   * @param {?Texture} texture - The texture this binding is referring to.
   */
  constructor(e, t) {
    super(e), this._texture = null, this._onTextureDispose = () => {
      this.generation = null, this.version = 0;
    }, this.texture = t, this.version = t ? t.version : 0, this.generation = null, this.samplerKey = "", this.isSampler = !0;
  }
  /**
   * Sets the texture of this sampler.
   *
   * @param {Texture} value - The texture to set.
   */
  set texture(e) {
    this._texture !== e && (this._texture && this._texture.removeEventListener("dispose", this._onTextureDispose), this._texture = e, this.generation = null, this.version = 0, this._texture && this._texture.addEventListener("dispose", this._onTextureDispose));
  }
  /**
   * Gets the texture of this sampler.
   * @return {?Texture} The texture.
   */
  get texture() {
    return this._texture;
  }
  /**
   * Updates the binding.
   *
   * @return {boolean} Whether the texture has been updated and must be
   * uploaded to the GPU.
   */
  update() {
    const { texture: e, version: t } = this;
    return t !== e.version ? (this.version = e.version, !0) : !1;
  }
  clone() {
    const e = super.clone();
    return e._texture = null, e._onTextureDispose = () => {
      e.generation = null, e.version = 0;
    }, e.texture = this.texture, e;
  }
}
let Sae = 0;
class Tae extends PI {
  /**
   * Constructs a new sampled texture.
   *
   * @param {string} name - The sampled texture's name.
   * @param {?Texture} texture - The texture this binding is referring to.
   */
  constructor(e, t) {
    super(e, t), this.id = Sae++, this.store = !1, this.mipLevel = 0, this.isSampledTexture = !0;
  }
}
class rx extends Tae {
  /**
   * Constructs a new node-based sampled texture.
   *
   * @param {string} name - The textures's name.
   * @param {TextureNode} textureNode - The texture node.
   * @param {UniformGroupNode} groupNode - The uniform group node.
   * @param {?string} [access=null] - The access type.
   */
  constructor(e, t, n, r = null) {
    super(e, t ? t.value : null), this.textureNode = t, this.groupNode = n, this.access = r;
  }
  /**
   * Updates the binding.
   *
   * @return {boolean} Whether the texture has been updated and must be
   * uploaded to the GPU.
   */
  update() {
    const { textureNode: e } = this;
    return this.texture !== e.value ? (this.texture = e.value, !0) : super.update();
  }
}
class NI extends rx {
  /**
   * Constructs a new node-based sampled cube texture.
   *
   * @param {string} name - The textures's name.
   * @param {TextureNode} textureNode - The texture node.
   * @param {UniformGroupNode} groupNode - The uniform group node.
   * @param {?string} [access=null] - The access type.
   */
  constructor(e, t, n, r = null) {
    super(e, t, n, r), this.isSampledCubeTexture = !0;
  }
}
class e3 extends rx {
  /**
   * Constructs a new node-based sampled 3D texture.
   *
   * @param {string} name - The textures's name.
   * @param {TextureNode} textureNode - The texture node.
   * @param {UniformGroupNode} groupNode - The uniform group node.
   * @param {?string} [access=null] - The access type.
   */
  constructor(e, t, n, r = null) {
    super(e, t, n, r), this.isSampledTexture3D = !0;
  }
}
const mC = {
  bitcast_int_uint: new Cr(
    /* glsl */
    "uint tsl_bitcast_int_to_uint ( int x ) { return floatBitsToUint( intBitsToFloat ( x ) ); }"
  ),
  bitcast_uint_int: new Cr(
    /* glsl */
    "uint tsl_bitcast_uint_to_int ( uint x ) { return floatBitsToInt( uintBitsToFloat ( x ) ); }"
  )
}, wae = {
  textureDimensions: "textureSize",
  equals: "equal",
  bitcast_float_int: "floatBitsToInt",
  bitcast_int_float: "intBitsToFloat",
  bitcast_uint_float: "uintBitsToFloat",
  bitcast_float_uint: "floatBitsToUint",
  bitcast_uint_int: "tsl_bitcast_uint_to_int",
  bitcast_int_uint: "tsl_bitcast_int_to_uint",
  floatpack_snorm_2x16: "packSnorm2x16",
  floatpack_unorm_2x16: "packUnorm2x16",
  floatpack_float16_2x16: "packHalf2x16",
  floatunpack_snorm_2x16: "unpackSnorm2x16",
  floatunpack_unorm_2x16: "unpackUnorm2x16",
  floatunpack_float16_2x16: "unpackHalf2x16"
}, Mae = {
  low: "lowp",
  medium: "mediump",
  high: "highp"
}, gC = {
  swizzleAssign: !0,
  storageBuffer: !1
}, _C = {
  perspective: "smooth",
  linear: "noperspective"
}, xC = {
  centroid: "centroid"
}, yC = `
precision highp float;
precision highp int;
precision highp sampler2D;
precision highp sampler3D;
precision highp samplerCube;
precision highp sampler2DArray;

precision highp usampler2D;
precision highp usampler3D;
precision highp usamplerCube;
precision highp usampler2DArray;

precision highp isampler2D;
precision highp isampler3D;
precision highp isamplerCube;
precision highp isampler2DArray;

precision lowp sampler2DShadow;
precision lowp sampler2DArrayShadow;
precision lowp samplerCubeShadow;
`;
class Eae extends bI {
  /**
   * Constructs a new GLSL node builder renderer.
   *
   * @param {Object3D} object - The 3D object.
   * @param {Renderer} renderer - The renderer.
   */
  constructor(e, t) {
    super(e, t, new tae()), this.uniformGroups = {}, this.transforms = [], this.extensions = {}, this.builtins = { vertex: [], fragment: [], compute: [] };
  }
  /**
   * Checks if the given texture requires a manual conversion to the working color space.
   *
   * @param {Texture} texture - The texture to check.
   * @return {boolean} Whether the given texture requires a conversion to working color space or not.
   */
  needsToWorkingColorSpace(e) {
    return e.isVideoTexture === !0 && e.colorSpace !== Ds;
  }
  /**
   * Includes the given method name into the current
   * function node.
   *
   * @private
   * @param {string} name - The method name to include.
   * @return {CodeNode} The respective code node.
   */
  _include(e) {
    const t = mC[e];
    return t.build(this), this.addInclude(t), t;
  }
  /**
   * Returns the native shader method name for a given generic name.
   *
   * @param {string} method - The method name to resolve.
   * @return {string} The resolved GLSL method name.
   */
  getMethod(e) {
    return mC[e] !== void 0 && this._include(e), wae[e] || e;
  }
  /**
   * Returns the bitcast method name for a given input and outputType.
   *
   * @param {string} type - The output type to bitcast to.
   * @param {string} inputType - The input type of the.
   * @return {string} The resolved WGSL bitcast invocation.
   */
  getBitcastMethod(e, t) {
    return this.getMethod(`bitcast_${t}_${e}`);
  }
  /**
   * Returns the float packing method name for a given numeric encoding.
   *
   * @param {string} encoding - The numeric encoding that describes how the float values are mapped to the integer range.
   * @returns {string} The resolved GLSL float packing method name.
   */
  getFloatPackingMethod(e) {
    return this.getMethod(`floatpack_${e}_2x16`);
  }
  /**
   * Returns the float unpacking method name for a given numeric encoding.
   *
   * @param {string} encoding - The numeric encoding that describes how the integer values are mapped to the float range.
   * @returns {string} The resolved GLSL float unpacking method name.
   */
  getFloatUnpackingMethod(e) {
    return this.getMethod(`floatunpack_${e}_2x16`);
  }
  /**
   * Returns the native snippet for a ternary operation.
   *
   * @param {string} condSnippet - The condition determining which expression gets resolved.
   * @param {string} ifSnippet - The expression to resolve to if the condition is true.
   * @param {string} elseSnippet - The expression to resolve to if the condition is false.
   * @return {string} The resolved method name.
   */
  getTernary(e, t, n) {
    return `${e} ? ${t} : ${n}`;
  }
  /**
   * Returns the output struct name. Not relevant for GLSL.
   *
   * @return {string}
   */
  getOutputStructName() {
    return "";
  }
  /**
   * Builds the given shader node.
   *
   * @param {ShaderNodeInternal} shaderNode - The shader node.
   * @return {string} The GLSL function code.
   */
  buildFunctionCode(e) {
    const t = e.layout, n = this.flowShaderNode(e), r = [];
    for (const o of t.inputs)
      r.push(this.getType(o.type) + " " + o.name);
    return `${this.getType(t.type)} ${t.name}( ${r.join(", ")} ) {

	${n.vars}

${n.code}
	return ${n.result};

}`;
  }
  /**
   * Setups the Pixel Buffer Object (PBO) for the given storage
   * buffer node.
   *
   * @param {StorageBufferNode} storageBufferNode - The storage buffer node.
   */
  setupPBO(e) {
    const t = e.value;
    if (t.pbo === void 0) {
      const n = t.array, r = t.count * t.itemSize, { itemSize: s } = t, o = t.array.constructor.name.toLowerCase().includes("int");
      let a = o ? Zu : Yh;
      s === 2 ? a = o ? Qh : fs : s === 3 ? a = o ? b5 : nA : s === 4 && (a = o ? Kh : Pi);
      const l = {
        Float32Array: Ei,
        Uint8Array: Mi,
        Uint16Array: Oo,
        Uint32Array: Jn,
        Int8Array: Ou,
        Int16Array: ku,
        Int32Array: _r,
        Uint8ClampedArray: Mi
      }, u = Math.pow(2, Math.ceil(Math.log2(Math.sqrt(r / s))));
      let c = Math.ceil(r / s / u);
      u * c * s < r && c++;
      const A = u * c * s, m = new n.constructor(A);
      m.set(n, 0), t.array = m;
      const _ = new wo(t.array, u, c, a, l[t.array.constructor.name] || Ei);
      _.needsUpdate = !0, _.isPBOTexture = !0;
      const y = new sl(_, null, null);
      y.setPrecision("high"), t.pboNode = y, t.pbo = y.value, this.getUniformFromNode(t.pboNode, "texture", this.shaderStage, this.context.nodeName);
    }
  }
  /**
   * Returns a GLSL snippet that represents the property name of the given node.
   *
   * @param {Node} node - The node.
   * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.
   * @return {string} The property name.
   */
  getPropertyName(e, t = this.shaderStage) {
    return e.isNodeUniform && e.node.isTextureNode !== !0 && e.node.isBufferNode !== !0 ? t.charAt(0) + "_" + e.name : super.getPropertyName(e, t);
  }
  /**
   * Setups the Pixel Buffer Object (PBO) for the given storage
   * buffer node.
   *
   * @param {StorageArrayElementNode} storageArrayElementNode - The storage array element node.
   * @return {string} The property name.
   */
  generatePBO(e) {
    const { node: t, indexNode: n } = e, r = t.value;
    if (this.renderer.backend.has(r)) {
      const c = this.renderer.backend.get(r);
      c.pbo = r.pbo;
    }
    const s = this.getUniformFromNode(r.pboNode, "texture", this.shaderStage, this.context.nodeName), o = this.getPropertyName(s);
    this.increaseUsage(n);
    const a = n.build(this, "uint"), l = this.getDataFromNode(e);
    let u = l.propertyName;
    if (u === void 0) {
      const c = this.getVarFromNode(e);
      u = this.getPropertyName(c);
      const A = this.getDataFromNode(t);
      let m = A.propertySizeName;
      m === void 0 && (m = u + "Size", this.getVarFromNode(t, m, "uint"), this.addLineFlowCode(`${m} = uint( textureSize( ${o}, 0 ).x )`, e), A.propertySizeName = m);
      const { itemSize: _ } = r, y = "." + rd.join("").slice(0, _), T = `ivec2(${a} % ${m}, ${a} / ${m})`, b = this.generateTextureLoad(null, o, T, "0", null, null);
      let S = "vec4";
      r.pbo.type === Jn ? S = "uvec4" : r.pbo.type === _r && (S = "ivec4"), this.addLineFlowCode(`${u} = ${S}(${b})${y}`, e), l.propertyName = u;
    }
    return u;
  }
  /**
   * Generates the GLSL snippet that reads a single texel from a texture without sampling or filtering.
   *
   * @param {?Texture} texture - The texture.
   * @param {string} textureProperty - The name of the texture uniform in the shader.
   * @param {string} uvIndexSnippet - A GLSL snippet that represents texture coordinates used for sampling.
   * @param {?string} levelSnippet - A GLSL snippet that represents the mip level, with level 0 containing a full size version of the texture.
   * @param {?string} depthSnippet - A GLSL snippet that represents the 0-based texture array index to sample.
   * @param {?string} offsetSnippet - A GLSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.
   * @return {string} The GLSL snippet.
   */
  generateTextureLoad(e, t, n, r, s, o) {
    r === null && (r = "0");
    let a;
    return s ? o ? a = `texelFetchOffset( ${t}, ivec3( ${n}, ${s} ), ${r}, ${o} )` : a = `texelFetch( ${t}, ivec3( ${n}, ${s} ), ${r} )` : o ? a = `texelFetchOffset( ${t}, ${n}, ${r}, ${o} )` : a = `texelFetch( ${t}, ${n}, ${r} )`, e !== null && e.isDepthTexture && (a += ".x"), a;
  }
  /**
   * Generates the GLSL snippet for sampling/loading the given texture.
   *
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The name of the texture uniform in the shader.
   * @param {string} uvSnippet - A GLSL snippet that represents texture coordinates used for sampling.
   * @param {?string} depthSnippet -  A GLSL snippet that represents the 0-based texture array index to sample.
   * @param {?string} offsetSnippet - A GLSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.
   * @return {string} The GLSL snippet.
   */
  generateTexture(e, t, n, r, s) {
    return r && (n = `vec3( ${n}, ${r} )`), e.isDepthTexture ? s ? `textureOffset( ${t}, ${n}, ${s} ).x` : `texture( ${t}, ${n} ).x` : s ? `textureOffset( ${t}, ${n}, ${s} )` : `texture( ${t}, ${n} )`;
  }
  /**
   * Generates the GLSL snippet when sampling textures with explicit mip level.
   *
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The name of the texture uniform in the shader.
   * @param {string} uvSnippet - A GLSL snippet that represents texture coordinates used for sampling.
   * @param {string} levelSnippet - A GLSL snippet that represents the mip level, with level 0 containing a full size version of the texture.
   * @param {?string} offsetSnippet - A GLSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.
   * @return {string} The GLSL snippet.
   */
  generateTextureLevel(e, t, n, r, s) {
    return s ? `textureLodOffset( ${t}, ${n}, ${r}, ${s} )` : `textureLod( ${t}, ${n}, ${r} )`;
  }
  /**
   * Generates the GLSL snippet when sampling textures with a bias to the mip level.
   *
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The name of the texture uniform in the shader.
   * @param {string} uvSnippet - A GLSL snippet that represents texture coordinates used for sampling.
   * @param {string} biasSnippet - A GLSL snippet that represents the bias to apply to the mip level before sampling.
   * @param {?string} offsetSnippet - A GLSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.
   * @return {string} The GLSL snippet.
   */
  generateTextureBias(e, t, n, r, s) {
    return s ? `textureOffset( ${t}, ${n}, ${s}, ${r} )` : `texture( ${t}, ${n}, ${r} )`;
  }
  /**
   * Generates the GLSL snippet for sampling/loading the given texture using explicit gradients.
   *
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The name of the texture uniform in the shader.
   * @param {string} uvSnippet - A GLSL snippet that represents texture coordinates used for sampling.
   * @param {Array<string>} gradSnippet - An array holding both gradient GLSL snippets.
   * @param {?string} offsetSnippet - A GLSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.
   * @return {string} The GLSL snippet.
   */
  generateTextureGrad(e, t, n, r, s) {
    return s ? `textureGradOffset( ${t}, ${n}, ${r[0]}, ${r[1]}, ${s} )` : `textureGrad( ${t}, ${n}, ${r[0]}, ${r[1]} )`;
  }
  /**
   * Generates the GLSL snippet for sampling a depth texture and comparing the sampled depth values
   * against a reference value.
   *
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The name of the texture uniform in the shader.
   * @param {string} uvSnippet - A GLSL snippet that represents texture coordinates used for sampling.
   * @param {string} compareSnippet -  A GLSL snippet that represents the reference value.
   * @param {?string} depthSnippet - A GLSL snippet that represents 0-based texture array index to sample.
   * @param {?string} offsetSnippet - A GLSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.
   * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.
   * @return {string} The GLSL snippet.
   */
  generateTextureCompare(e, t, n, r, s, o, a = this.shaderStage) {
    if (a === "fragment")
      return e.isCubeTexture ? `texture( ${t}, vec4( ${n}, ${r} ) )` : s ? o ? `textureOffset( ${t}, vec4( ${n}, ${s}, ${r} ), ${o} )` : `texture( ${t}, vec4( ${n}, ${s}, ${r} ) )` : o ? `textureOffset( ${t}, vec3( ${n}, ${r} ), ${o} )` : `texture( ${t}, vec3( ${n}, ${r} ) )`;
    Ie(`WebGPURenderer: THREE.DepthTexture.compareFunction() does not support ${a} shader.`);
  }
  /**
   * Returns the variables of the given shader stage as a GLSL string.
   *
   * @param {string} shaderStage - The shader stage.
   * @return {string} The GLSL snippet that defines the variables.
   */
  getVars(e) {
    const t = [], n = this.vars[e];
    if (n !== void 0)
      for (const r of n)
        t.push(`${this.getVar(r.type, r.name, r.count)};`);
    return t.join(`
	`);
  }
  /**
   * Returns the uniforms of the given shader stage as a GLSL string.
   *
   * @param {string} shaderStage - The shader stage.
   * @return {string} The GLSL snippet that defines the uniforms.
   */
  getUniforms(e) {
    const t = this.uniforms[e], n = [], r = {};
    for (const o of t) {
      let a = null, l = !1;
      if (o.type === "texture" || o.type === "texture3D") {
        const c = o.node.value;
        let A = "";
        (c.isDataTexture === !0 || c.isData3DTexture === !0) && (c.type === Jn ? A = "u" : c.type === _r && (A = "i")), o.type === "texture3D" && c.isArrayTexture === !1 ? a = `${A}sampler3D ${o.name};` : c.compareFunction ? c.isArrayTexture === !0 ? a = `sampler2DArrayShadow ${o.name};` : a = `sampler2DShadow ${o.name};` : c.isArrayTexture === !0 || c.isDataArrayTexture === !0 || c.isCompressedArrayTexture === !0 ? a = `${A}sampler2DArray ${o.name};` : a = `${A}sampler2D ${o.name};`;
      } else if (o.type === "cubeTexture")
        a = `samplerCube ${o.name};`;
      else if (o.type === "cubeDepthTexture")
        a = `samplerCubeShadow ${o.name};`;
      else if (o.type === "buffer") {
        const c = o.node, A = this.getType(c.bufferType), m = c.bufferCount, _ = m > 0 ? m : "";
        a = `${c.name} {
	${A} ${o.name}[${_}];
};
`;
      } else
        a = `${this.getVectorType(o.type)} ${this.getPropertyName(o, e)};`, l = !0;
      const u = o.node.precision;
      if (u !== null && (a = Mae[u] + " " + a), l) {
        a = "	" + a;
        const c = o.groupNode.name;
        (r[c] || (r[c] = [])).push(a);
      } else
        a = "uniform " + a, n.push(a);
    }
    let s = "";
    for (const o in r) {
      const a = r[o];
      s += this._getGLSLUniformStruct(e + "_" + o, a.join(`
`)) + `
`;
    }
    return s += n.join(`
`), s;
  }
  /**
   * Returns the type for a given buffer attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute.
   * @return {string} The type.
   */
  getTypeFromAttribute(e) {
    let t = super.getTypeFromAttribute(e);
    if (/^[iu]/.test(t) && e.gpuType !== _r) {
      let n = e;
      e.isInterleavedBufferAttribute && (n = e.data);
      const r = n.array;
      r instanceof Uint32Array || r instanceof Int32Array || (t = t.slice(1));
    }
    return t;
  }
  /**
   * Returns the shader attributes of the given shader stage as a GLSL string.
   *
   * @param {string} shaderStage - The shader stage.
   * @return {string} The GLSL snippet that defines the shader attributes.
   */
  getAttributes(e) {
    let t = "";
    if (e === "vertex" || e === "compute") {
      const n = this.getAttributesArray();
      let r = 0;
      for (const s of n)
        t += `layout( location = ${r++} ) in ${s.type} ${s.name};
`;
    }
    return t;
  }
  /**
   * Returns the members of the given struct type node as a GLSL string.
   *
   * @param {StructTypeNode} struct - The struct type node.
   * @return {string} The GLSL snippet that defines the struct members.
   */
  getStructMembers(e) {
    const t = [];
    for (const n of e.members)
      t.push(`	${n.type} ${n.name};`);
    return t.join(`
`);
  }
  /**
   * Returns the structs of the given shader stage as a GLSL string.
   *
   * @param {string} shaderStage - The shader stage.
   * @return {string} The GLSL snippet that defines the structs.
   */
  getStructs(e) {
    const t = [], n = this.structs[e], r = [];
    for (const s of n)
      if (s.output)
        for (const o of s.members)
          r.push(`layout( location = ${o.index} ) out ${o.type} ${o.name};`);
      else {
        let o = "struct " + s.name + ` {
`;
        o += this.getStructMembers(s), o += `
};
`, t.push(o);
      }
    return r.length === 0 && r.push("layout( location = 0 ) out vec4 fragColor;"), `
` + r.join(`
`) + `

` + t.join(`
`);
  }
  /**
   * Returns the varyings of the given shader stage as a GLSL string.
   *
   * @param {string} shaderStage - The shader stage.
   * @return {string} The GLSL snippet that defines the varyings.
   */
  getVaryings(e) {
    let t = "";
    const n = this.varyings;
    if (e === "vertex" || e === "compute")
      for (const r of n) {
        e === "compute" && (r.needsInterpolation = !0);
        const s = this.getType(r.type);
        if (r.needsInterpolation)
          if (r.interpolationType) {
            const o = _C[r.interpolationType] || r.interpolationType, a = xC[r.interpolationSampling] || "";
            t += `${o} ${a} out ${s} ${r.name};
`;
          } else {
            const o = s.includes("int") || s.includes("uv") || s.includes("iv") ? "flat " : "";
            t += `${o}out ${s} ${r.name};
`;
          }
        else
          t += `${s} ${r.name};
`;
      }
    else if (e === "fragment") {
      for (const r of n)
        if (r.needsInterpolation) {
          const s = this.getType(r.type);
          if (r.interpolationType) {
            const o = _C[r.interpolationType] || r.interpolationType, a = xC[r.interpolationSampling] || "";
            t += `${o} ${a} in ${s} ${r.name};
`;
          } else {
            const o = s.includes("int") || s.includes("uv") || s.includes("iv") ? "flat " : "";
            t += `${o}in ${s} ${r.name};
`;
          }
        }
    }
    for (const r of this.builtins[e])
      t += `${r};
`;
    return t;
  }
  /**
   * Returns the vertex index builtin.
   *
   * @return {string} The vertex index.
   */
  getVertexIndex() {
    return "uint( gl_VertexID )";
  }
  /**
   * Contextually returns either the vertex stage instance index builtin
   * or the linearized index of an compute invocation within a grid of workgroups.
   *
   * @return {string} The instance index.
   */
  getInstanceIndex() {
    return "uint( gl_InstanceID )";
  }
  /**
   * Returns a builtin representing the index of an invocation within its workgroup.
   *
   * @return {string} The invocation local index.
   */
  getInvocationLocalIndex() {
    return `uint( gl_InstanceID ) % ${this.object.workgroupSize.reduce((n, r) => n * r, 1)}u`;
  }
  /**
   * Returns a builtin representing the size of a subgroup within the current shader.
   */
  getSubgroupSize() {
    Ie("GLSLNodeBuilder: WebGLBackend does not support the subgroupSize node");
  }
  /**
   * Returns a builtin representing the index of an invocation within its subgroup.
   */
  getInvocationSubgroupIndex() {
    Ie("GLSLNodeBuilder: WebGLBackend does not support the invocationSubgroupIndex node");
  }
  /**
   * Returns a builtin representing the index of the current invocation's subgroup within its workgroup.
   */
  getSubgroupIndex() {
    Ie("GLSLNodeBuilder: WebGLBackend does not support the subgroupIndex node");
  }
  /**
   * Returns the draw index builtin.
   *
   * @return {?string} The drawIndex shader string. Returns `null` if `WEBGL_multi_draw` isn't supported by the device.
   */
  getDrawIndex() {
    return this.renderer.backend.extensions.has("WEBGL_multi_draw") ? "uint( gl_DrawID )" : null;
  }
  /**
   * Returns the front facing builtin.
   *
   * @return {string} The front facing builtin.
   */
  getFrontFacing() {
    return "gl_FrontFacing";
  }
  /**
   * Returns the frag coord builtin.
   *
   * @return {string} The frag coord builtin.
   */
  getFragCoord() {
    return "gl_FragCoord.xy";
  }
  /**
   * Returns the frag depth builtin.
   *
   * @return {string} The frag depth builtin.
   */
  getFragDepth() {
    return "gl_FragDepth";
  }
  /**
   * Enables the given extension.
   *
   * @param {string} name - The extension name.
   * @param {string} behavior - The extension behavior.
   * @param {string} [shaderStage=this.shaderStage] - The shader stage.
   */
  enableExtension(e, t, n = this.shaderStage) {
    const r = this.extensions[n] || (this.extensions[n] = /* @__PURE__ */ new Map());
    r.has(e) === !1 && r.set(e, {
      name: e,
      behavior: t
    });
  }
  /**
   * Returns the enabled extensions of the given shader stage as a GLSL string.
   *
   * @param {string} shaderStage - The shader stage.
   * @return {string} The GLSL snippet that defines the enabled extensions.
   */
  getExtensions(e) {
    const t = [];
    if (e === "vertex") {
      const r = this.renderer.backend.extensions;
      this.object.isBatchedMesh && r.has("WEBGL_multi_draw") && this.enableExtension("GL_ANGLE_multi_draw", "require", e);
    }
    const n = this.extensions[e];
    if (n !== void 0)
      for (const { name: r, behavior: s } of n.values())
        t.push(`#extension ${r} : ${s}`);
    return t.join(`
`);
  }
  /**
   * Returns the clip distances builtin.
   *
   * @return {string} The clip distances builtin.
   */
  getClipDistance() {
    return "gl_ClipDistance";
  }
  /**
   * Whether the requested feature is available or not.
   *
   * @param {string} name - The requested feature.
   * @return {boolean} Whether the requested feature is supported or not.
   */
  isAvailable(e) {
    let t = gC[e];
    if (t === void 0) {
      let n;
      switch (t = !1, e) {
        case "float32Filterable":
          n = "OES_texture_float_linear";
          break;
        case "clipDistance":
          n = "WEBGL_clip_cull_distance";
          break;
      }
      if (n !== void 0) {
        const r = this.renderer.backend.extensions;
        r.has(n) && (r.get(n), t = !0);
      }
      gC[e] = t;
    }
    return t;
  }
  /**
   * Whether to flip texture data along its vertical axis or not.
   *
   * @return {boolean} Returns always `true` in context of GLSL.
   */
  isFlipY() {
    return !0;
  }
  /**
   * Enables hardware clipping.
   *
   * @param {string} planeCount - The clipping plane count.
   */
  enableHardwareClipping(e) {
    this.enableExtension("GL_ANGLE_clip_cull_distance", "require"), this.builtins.vertex.push(`out float gl_ClipDistance[ ${e} ]`);
  }
  /**
   * Enables multiview.
   */
  enableMultiview() {
    this.enableExtension("GL_OVR_multiview2", "require", "fragment"), this.enableExtension("GL_OVR_multiview2", "require", "vertex"), this.builtins.vertex.push("layout(num_views = 2) in");
  }
  /**
   * Registers a transform in context of Transform Feedback.
   *
   * @param {string} varyingName - The varying name.
   * @param {AttributeNode} attributeNode - The attribute node.
   */
  registerTransform(e, t) {
    this.transforms.push({ varyingName: e, attributeNode: t });
  }
  /**
   * Returns the transforms of the given shader stage as a GLSL string.
   *
   * @param {string} shaderStage - The shader stage.
   * @return {string} The GLSL snippet that defines the transforms.
   */
  getTransforms() {
    const e = this.transforms;
    let t = "";
    for (let n = 0; n < e.length; n++) {
      const r = e[n], s = this.getPropertyName(r.attributeNode);
      s && (t += `${r.varyingName} = ${s};
	`);
    }
    return t;
  }
  /**
   * Returns a GLSL struct based on the given name and variables.
   *
   * @private
   * @param {string} name - The struct name.
   * @param {string} vars - The struct variables.
   * @return {string} The GLSL snippet representing a struct.
   */
  _getGLSLUniformStruct(e, t) {
    return `
layout( std140 ) uniform ${e} {
${t}
};`;
  }
  /**
   * Returns a GLSL vertex shader based on the given shader data.
   *
   * @private
   * @param {Object} shaderData - The shader data.
   * @return {string} The vertex shader.
   */
  _getGLSLVertexCode(e) {
    return `#version 300 es

${this.getSignature()}

// extensions
${e.extensions}

// precision
${yC}

// uniforms
${e.uniforms}

// varyings
${e.varyings}

// attributes
${e.attributes}

// codes
${e.codes}

void main() {

	// vars
	${e.vars}

	// transforms
	${e.transforms}

	// flow
	${e.flow}

	gl_PointSize = 1.0;

}
`;
  }
  /**
   * Returns a GLSL fragment shader based on the given shader data.
   *
   * @private
   * @param {Object} shaderData - The shader data.
   * @return {string} The vertex shader.
   */
  _getGLSLFragmentCode(e) {
    return `#version 300 es

${this.getSignature()}

// extensions
${e.extensions}

// precision
${yC}

// structs
${e.structs}

// uniforms
${e.uniforms}

// varyings
${e.varyings}

// codes
${e.codes}

void main() {

	// vars
	${e.vars}

	// flow
	${e.flow}

}
`;
  }
  /**
   * Controls the code build of the shader stages.
   */
  buildCode() {
    const e = this.material !== null ? { fragment: {}, vertex: {} } : { compute: {} };
    this.sortBindingGroups();
    for (const t in e) {
      let n = `// code

`;
      n += this.flowCode[t];
      const r = this.flowNodes[t], s = r[r.length - 1];
      for (const a of r) {
        const l = this.getFlowData(
          a
          /*, shaderStage*/
        ), u = a.name;
        u && (n.length > 0 && (n += `
`), n += `	// flow -> ${u}
	`), n += `${l.code}
	`, a === s && t !== "compute" && (n += `// result
	`, t === "vertex" ? (n += "gl_Position = ", n += `${l.result};`) : t === "fragment" && (a.outputNode.isOutputStructNode || (n += "fragColor = ", n += `${l.result};`)));
      }
      const o = e[t];
      o.extensions = this.getExtensions(t), o.uniforms = this.getUniforms(t), o.attributes = this.getAttributes(t), o.varyings = this.getVaryings(t), o.vars = this.getVars(t), o.structs = this.getStructs(t), o.codes = this.getCodes(t), o.transforms = this.getTransforms(t), o.flow = n;
    }
    this.material !== null ? (this.vertexShader = this._getGLSLVertexCode(e.vertex), this.fragmentShader = this._getGLSLFragmentCode(e.fragment)) : this.computeShader = this._getGLSLVertexCode(e.compute);
  }
  /**
   * This method is one of the more important ones since it's responsible
   * for generating a matching binding instance for the given uniform node.
   *
   * These bindings are later used in the renderer to create bind groups
   * and layouts.
   *
   * @param {UniformNode} node - The uniform node.
   * @param {string} type - The node data type.
   * @param {string} shaderStage - The shader stage.
   * @param {?string} [name=null] - An optional uniform name.
   * @return {NodeUniform} The node uniform object.
   */
  getUniformFromNode(e, t, n, r = null) {
    const s = super.getUniformFromNode(e, t, n, r), o = this.getDataFromNode(e, n, this.globalCache);
    let a = o.uniformGPU;
    if (a === void 0) {
      const l = e.groupNode, u = l.name, c = this.getBindGroupArray(u, n);
      if (t === "texture")
        a = new rx(s.name, s.node, l), c.push(a);
      else if (t === "cubeTexture" || t === "cubeDepthTexture")
        a = new NI(s.name, s.node, l), c.push(a);
      else if (t === "texture3D")
        a = new e3(s.name, s.node, l), c.push(a);
      else if (t === "buffer") {
        s.name = `buffer${e.id}`;
        const A = this.getSharedDataFromNode(e);
        let m = A.buffer;
        m === void 0 && (e.name = `NodeBuffer_${e.id}`, m = new RI(e, l), m.name = e.name, A.buffer = m), c.push(m), a = m;
      } else {
        const A = this.uniformGroups[n] || (this.uniformGroups[n] = {});
        let m = A[u];
        m === void 0 && (m = new CI(n + "_" + u, l), A[u] = m, c.push(m)), a = this.getNodeUniform(s, t), m.addUniform(a);
      }
      o.uniformGPU = a;
    }
    return s;
  }
}
let pv = null, Jd = null;
class DI {
  /**
   * Constructs a new backend.
   *
   * @param {Object} parameters - An object holding parameters for the backend.
   */
  constructor(e = {}) {
    this.parameters = Object.assign({}, e), this.data = /* @__PURE__ */ new WeakMap(), this.renderer = null, this.domElement = null, this.timestampQueryPool = {
      [pa.RENDER]: null,
      [pa.COMPUTE]: null
    }, this.trackTimestamp = e.trackTimestamp === !0;
  }
  /**
   * Initializes the backend so it is ready for usage. Concrete backends
   * are supposed to implement their rendering context creation and related
   * operations in this method.
   *
   * @async
   * @param {Renderer} renderer - The renderer.
   * @return {Promise} A Promise that resolves when the backend has been initialized.
   */
  async init(e) {
    this.renderer = e;
  }
  /**
   * The coordinate system of the backend.
   *
   * @abstract
   * @type {number}
   * @readonly
   */
  get coordinateSystem() {
  }
  // render context
  /**
   * This method is executed at the beginning of a render call and
   * can be used by the backend to prepare the state for upcoming
   * draw calls.
   *
   * @abstract
   * @param {RenderContext} renderContext - The render context.
   */
  beginRender() {
  }
  /**
   * This method is executed at the end of a render call and
   * can be used by the backend to finalize work after draw
   * calls.
   *
   * @abstract
   * @param {RenderContext} renderContext - The render context.
   */
  finishRender() {
  }
  /**
   * This method is executed at the beginning of a compute call and
   * can be used by the backend to prepare the state for upcoming
   * compute tasks.
   *
   * @abstract
   * @param {Node|Array<Node>} computeGroup - The compute node(s).
   */
  beginCompute() {
  }
  /**
   * This method is executed at the end of a compute call and
   * can be used by the backend to finalize work after compute
   * tasks.
   *
   * @abstract
   * @param {Node|Array<Node>} computeGroup - The compute node(s).
   */
  finishCompute() {
  }
  // render object
  /**
   * Executes a draw command for the given render object.
   *
   * @abstract
   * @param {RenderObject} renderObject - The render object to draw.
   * @param {Info} info - Holds a series of statistical information about the GPU memory and the rendering process.
   */
  draw() {
  }
  // compute node
  /**
   * Executes a compute command for the given compute node.
   *
   * @abstract
   * @param {Node|Array<Node>} computeGroup - The group of compute nodes of a compute call. Can be a single compute node.
   * @param {Node} computeNode - The compute node.
   * @param {Array<BindGroup>} bindings - The bindings.
   * @param {ComputePipeline} computePipeline - The compute pipeline.
   */
  compute() {
  }
  // program
  /**
   * Creates a shader program from the given programmable stage.
   *
   * @abstract
   * @param {ProgrammableStage} program - The programmable stage.
   */
  createProgram() {
  }
  /**
   * Destroys the shader program of the given programmable stage.
   *
   * @abstract
   * @param {ProgrammableStage} program - The programmable stage.
   */
  destroyProgram() {
  }
  // bindings
  /**
   * Creates bindings from the given bind group definition.
   *
   * @abstract
   * @param {BindGroup} bindGroup - The bind group.
   * @param {Array<BindGroup>} bindings - Array of bind groups.
   * @param {number} cacheIndex - The cache index.
   * @param {number} version - The version.
   */
  createBindings() {
  }
  /**
   * Updates the given bind group definition.
   *
   * @abstract
   * @param {BindGroup} bindGroup - The bind group.
   * @param {Array<BindGroup>} bindings - Array of bind groups.
   * @param {number} cacheIndex - The cache index.
   * @param {number} version - The version.
   */
  updateBindings() {
  }
  /**
   * Updates a buffer binding.
   *
   * @abstract
   * @param {Buffer} binding - The buffer binding to update.
   */
  updateBinding() {
  }
  // pipeline
  /**
   * Creates a render pipeline for the given render object.
   *
   * @abstract
   * @param {RenderObject} renderObject - The render object.
   * @param {Array<Promise>} promises - An array of compilation promises which are used in `compileAsync()`.
   */
  createRenderPipeline() {
  }
  /**
   * Creates a compute pipeline for the given compute node.
   *
   * @abstract
   * @param {ComputePipeline} computePipeline - The compute pipeline.
   * @param {Array<BindGroup>} bindings - The bindings.
   */
  createComputePipeline() {
  }
  // cache key
  /**
   * Returns `true` if the render pipeline requires an update.
   *
   * @abstract
   * @param {RenderObject} renderObject - The render object.
   * @return {boolean} Whether the render pipeline requires an update or not.
   */
  needsRenderUpdate() {
  }
  /**
   * Returns a cache key that is used to identify render pipelines.
   *
   * @abstract
   * @param {RenderObject} renderObject - The render object.
   * @return {string} The cache key.
   */
  getRenderCacheKey() {
  }
  // node builder
  /**
   * Returns a node builder for the given render object.
   *
   * @abstract
   * @param {RenderObject} renderObject - The render object.
   * @param {Renderer} renderer - The renderer.
   * @return {NodeBuilder} The node builder.
   */
  createNodeBuilder() {
  }
  // textures
  /**
   * Updates a GPU sampler for the given texture.
   *
   * @abstract
   * @param {Texture} texture - The texture to update the sampler for.
   * @return {string} The current sampler key.
   */
  updateSampler() {
  }
  /**
   * Creates a default texture for the given texture that can be used
   * as a placeholder until the actual texture is ready for usage.
   *
   * @abstract
   * @param {Texture} texture - The texture to create a default texture for.
   */
  createDefaultTexture() {
  }
  /**
   * Defines a texture on the GPU for the given texture object.
   *
   * @abstract
   * @param {Texture} texture - The texture.
   * @param {Object} [options={}] - Optional configuration parameter.
   */
  createTexture() {
  }
  /**
   * Uploads the updated texture data to the GPU.
   *
   * @abstract
   * @param {Texture} texture - The texture.
   * @param {Object} [options={}] - Optional configuration parameter.
   */
  updateTexture() {
  }
  /**
   * Generates mipmaps for the given texture.
   *
   * @abstract
   * @param {Texture} texture - The texture.
   */
  generateMipmaps() {
  }
  /**
   * Destroys the GPU data for the given texture object.
   *
   * @abstract
   * @param {Texture} texture - The texture.
   * @param {boolean} [isDefaultTexture=false] - Whether the texture uses a default GPU texture or not.
   */
  destroyTexture() {
  }
  /**
   * Returns texture data as a typed array.
   *
   * @abstract
   * @async
   * @param {Texture} texture - The texture to copy.
   * @param {number} x - The x coordinate of the copy origin.
   * @param {number} y - The y coordinate of the copy origin.
   * @param {number} width - The width of the copy.
   * @param {number} height - The height of the copy.
   * @param {number} faceIndex - The face index.
   * @return {Promise<TypedArray>} A Promise that resolves with a typed array when the copy operation has finished.
   */
  async copyTextureToBuffer() {
  }
  /**
   * Copies data of the given source texture to the given destination texture.
   *
   * @abstract
   * @param {Texture} srcTexture - The source texture.
   * @param {Texture} dstTexture - The destination texture.
   * @param {?(Box3|Box2)} [srcRegion=null] - The region of the source texture to copy.
   * @param {?(Vector2|Vector3)} [dstPosition=null] - The destination position of the copy.
   * @param {number} [srcLevel=0] - The source mip level to copy from.
   * @param {number} [dstLevel=0] - The destination mip level to copy to.
   */
  copyTextureToTexture() {
  }
  /**
  * Copies the current bound framebuffer to the given texture.
  *
  * @abstract
  * @param {Texture} texture - The destination texture.
  * @param {RenderContext} renderContext - The render context.
  * @param {Vector4} rectangle - A four dimensional vector defining the origin and dimension of the copy.
  */
  copyFramebufferToTexture() {
  }
  // attributes
  /**
   * Creates the GPU buffer of a shader attribute.
   *
   * @abstract
   * @param {BufferAttribute} attribute - The buffer attribute.
   */
  createAttribute() {
  }
  /**
   * Creates the GPU buffer of an indexed shader attribute.
   *
   * @abstract
   * @param {BufferAttribute} attribute - The indexed buffer attribute.
   */
  createIndexAttribute() {
  }
  /**
   * Creates the GPU buffer of a storage attribute.
   *
   * @abstract
   * @param {BufferAttribute} attribute - The buffer attribute.
   */
  createStorageAttribute() {
  }
  /**
   * Updates the GPU buffer of a shader attribute.
   *
   * @abstract
   * @param {BufferAttribute} attribute - The buffer attribute to update.
   */
  updateAttribute() {
  }
  /**
   * Destroys the GPU buffer of a shader attribute.
   *
   * @abstract
   * @param {BufferAttribute} attribute - The buffer attribute to destroy.
   */
  destroyAttribute() {
  }
  // canvas
  /**
   * Returns the backend's rendering context.
   *
   * @abstract
   * @return {Object} The rendering context.
   */
  getContext() {
  }
  /**
   * Backends can use this method if they have to run
   * logic when the renderer gets resized.
   *
   * @abstract
   */
  updateSize() {
  }
  /**
   * Updates the viewport with the values from the given render context.
   *
   * @abstract
   * @param {RenderContext} renderContext - The render context.
   */
  updateViewport() {
  }
  // utils
  /**
   * Updates a unique identifier for the given render context that can be used
   * to allocate resources like occlusion queries or timestamp queries.
   *
   * @param {RenderContext|ComputeNode} abstractRenderContext - The render context.
   */
  updateTimeStampUID(e) {
    const t = this.get(e), n = this.renderer.info.frame;
    let r;
    e.isComputeNode === !0 ? r = "c:" + this.renderer.info.compute.frameCalls : r = "r:" + this.renderer.info.render.frameCalls, t.timestampUID = r + ":" + e.id + ":f" + n;
  }
  /**
   * Returns a unique identifier for the given render context that can be used
   * to allocate resources like occlusion queries or timestamp queries.
   *
   * @param {RenderContext|ComputeNode} abstractRenderContext - The render context.
   * @return {string} The unique identifier.
   */
  getTimestampUID(e) {
    return this.get(e).timestampUID;
  }
  /**
   * Returns all timestamp frames for the given type.
   *
   * @param {string} type - The type of the time stamp.
   * @return {Array<number>} The timestamp frames.
   */
  getTimestampFrames(e) {
    const t = this.timestampQueryPool[e];
    return t ? t.getTimestampFrames() : [];
  }
  /**
   * Returns the query pool for the given uid.
   *
   * @param {string} uid - The unique identifier.
   * @return {TimestampQueryPool} The query pool.
   */
  _getQueryPool(e) {
    const t = e.startsWith("c:") ? pa.COMPUTE : pa.RENDER;
    return this.timestampQueryPool[t];
  }
  /**
   * Returns the timestamp for the given uid.
   *
   * @param {string} uid - The unique identifier.
   * @return {number} The timestamp.
   */
  getTimestamp(e) {
    return this._getQueryPool(e).getTimestamp(e);
  }
  /**
   * Returns `true` if a timestamp for the given uid is available.
   *
   * @param {string} uid - The unique identifier.
   * @return {boolean} Whether the timestamp is available or not.
   */
  hasTimestamp(e) {
    return this._getQueryPool(e).hasTimestamp(e);
  }
  /**
   * Returns `true` if the given 3D object is fully occluded by other
   * 3D objects in the scene. Backends must implement this method by using
   * a Occlusion Query API.
   *
   * @abstract
   * @param {RenderContext} renderContext - The render context.
   * @param {Object3D} object - The 3D object to test.
   * @return {boolean} Whether the 3D object is fully occluded or not.
   */
  isOccluded() {
  }
  /**
   * Resolves the time stamp for the given render context and type.
   *
   * @async
   * @abstract
   * @param {string} [type='render'] - The type of the time stamp.
   * @return {Promise<number>} A Promise that resolves with the time stamp.
   */
  async resolveTimestampsAsync(e = "render") {
    if (!this.trackTimestamp) {
      li("WebGPURenderer: Timestamp tracking is disabled.");
      return;
    }
    const t = this.timestampQueryPool[e];
    if (!t)
      return;
    const n = await t.resolveQueriesAsync();
    return this.renderer.info[e].timestamp = n, n;
  }
  /**
   * This method performs a readback operation by moving buffer data from
   * a storage buffer attribute from the GPU to the CPU.
   *
   * @async
   * @param {StorageBufferAttribute} attribute - The storage buffer attribute.
   * @return {Promise<ArrayBuffer>} A promise that resolves with the buffer data when the data are ready.
   */
  async getArrayBufferAsync() {
  }
  /**
   * Checks if the given feature is supported by the backend.
   *
   * @async
   * @abstract
   * @param {string} name - The feature's name.
   * @return {Promise<boolean>} A Promise that resolves with a bool that indicates whether the feature is supported or not.
   */
  async hasFeatureAsync() {
  }
  /**
   * Checks if the given feature is supported  by the backend.
   *
   * @abstract
   * @param {string} name - The feature's name.
   * @return {boolean} Whether the feature is supported or not.
   */
  hasFeature() {
  }
  /**
   * Returns the maximum anisotropy texture filtering value.
   *
   * @abstract
   * @return {number} The maximum anisotropy texture filtering value.
   */
  getMaxAnisotropy() {
  }
  /**
   * Returns the drawing buffer size.
   *
   * @return {Vector2} The drawing buffer size.
   */
  getDrawingBufferSize() {
    return pv = pv || new Le(), this.renderer.getDrawingBufferSize(pv);
  }
  /**
   * Defines the scissor test.
   *
   * @abstract
   * @param {boolean} boolean - Whether the scissor test should be enabled or not.
   */
  setScissorTest() {
  }
  /**
   * Returns the clear color and alpha into a single
   * color object.
   *
   * @return {Color4} The clear color.
   */
  getClearColor() {
    const e = this.renderer;
    return Jd = Jd || new HT(), e.getClearColor(Jd), Jd.getRGB(Jd), Jd;
  }
  /**
   * Returns the DOM element. If no DOM element exists, the backend
   * creates a new one.
   *
   * @return {HTMLCanvasElement} The DOM element.
   */
  getDomElement() {
    let e = this.domElement;
    return e === null && (e = this.parameters.canvas !== void 0 ? this.parameters.canvas : C3(), "setAttribute" in e && e.setAttribute("data-engine", `three.js r${Ku} webgpu`), this.domElement = e), e;
  }
  /**
   * Sets a dictionary for the given object into the
   * internal data structure.
   *
   * @param {Object} object - The object.
   * @param {Object} value - The dictionary to set.
   */
  set(e, t) {
    this.data.set(e, t);
  }
  /**
   * Returns the dictionary for the given object.
   *
   * @param {Object} object - The object.
   * @return {Object} The object's dictionary.
   */
  get(e) {
    let t = this.data.get(e);
    return t === void 0 && (t = {}, this.data.set(e, t)), t;
  }
  /**
   * Checks if the given object has a dictionary
   * with data defined.
   *
   * @param {Object} object - The object.
   * @return {boolean} Whether a dictionary for the given object as been defined or not.
   */
  has(e) {
    return this.data.has(e);
  }
  /**
   * Deletes an object from the internal data structure.
   *
   * @param {Object} object - The object to delete.
   */
  delete(e) {
    this.data.delete(e);
  }
  /**
   * Delete GPU data associated with a bind group.
   *
   * @abstract
   * @param {BindGroup} bindGroup - The bind group.
   */
  deleteBindGroupData() {
  }
  /**
   * Frees internal resources.
   *
   * @abstract
   */
  dispose() {
  }
}
let Rae = 0;
class Cae {
  constructor(e, t) {
    this.buffers = [e.bufferGPU, t], this.type = e.type, this.bufferType = e.bufferType, this.pbo = e.pbo, this.byteLength = e.byteLength, this.bytesPerElement = e.BYTES_PER_ELEMENT, this.version = e.version, this.isInteger = e.isInteger, this.activeBufferIndex = 0, this.baseId = e.id;
  }
  get id() {
    return `${this.baseId}|${this.activeBufferIndex}`;
  }
  get bufferGPU() {
    return this.buffers[this.activeBufferIndex];
  }
  get transformBuffer() {
    return this.buffers[this.activeBufferIndex ^ 1];
  }
  switchBuffers() {
    this.activeBufferIndex ^= 1;
  }
}
class Pae {
  /**
   * Constructs a new utility object.
   *
   * @param {WebGLBackend} backend - The WebGL 2 backend.
   */
  constructor(e) {
    this.backend = e;
  }
  /**
   * Creates the GPU buffer for the given buffer attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute.
   * @param {GLenum } bufferType - A flag that indicates the buffer type and thus binding point target.
   */
  createAttribute(e, t) {
    const n = this.backend, { gl: r } = n, s = e.array, o = e.usage || r.STATIC_DRAW, a = e.isInterleavedBufferAttribute ? e.data : e, l = n.get(a);
    let u = l.bufferGPU;
    u === void 0 && (u = this._createBuffer(r, t, s, o), l.bufferGPU = u, l.bufferType = t, l.version = a.version);
    let c;
    if (s instanceof Float32Array)
      c = r.FLOAT;
    else if (typeof Float16Array < "u" && s instanceof Float16Array)
      c = r.HALF_FLOAT;
    else if (s instanceof Uint16Array)
      e.isFloat16BufferAttribute ? c = r.HALF_FLOAT : c = r.UNSIGNED_SHORT;
    else if (s instanceof Int16Array)
      c = r.SHORT;
    else if (s instanceof Uint32Array)
      c = r.UNSIGNED_INT;
    else if (s instanceof Int32Array)
      c = r.INT;
    else if (s instanceof Int8Array)
      c = r.BYTE;
    else if (s instanceof Uint8Array)
      c = r.UNSIGNED_BYTE;
    else if (s instanceof Uint8ClampedArray)
      c = r.UNSIGNED_BYTE;
    else
      throw new Error("THREE.WebGLBackend: Unsupported buffer data format: " + s);
    let A = {
      bufferGPU: u,
      bufferType: t,
      type: c,
      byteLength: s.byteLength,
      bytesPerElement: s.BYTES_PER_ELEMENT,
      version: e.version,
      pbo: e.pbo,
      isInteger: c === r.INT || c === r.UNSIGNED_INT || e.gpuType === _r,
      id: Rae++
    };
    if (e.isStorageBufferAttribute || e.isStorageInstancedBufferAttribute) {
      const m = this._createBuffer(r, t, s, o);
      A = new Cae(A, m);
    }
    n.set(e, A);
  }
  /**
   * Updates the GPU buffer of the given buffer attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute.
   */
  updateAttribute(e) {
    const t = this.backend, { gl: n } = t, r = e.array, s = e.isInterleavedBufferAttribute ? e.data : e, o = t.get(s), a = o.bufferType, l = e.isInterleavedBufferAttribute ? e.data.updateRanges : e.updateRanges;
    if (n.bindBuffer(a, o.bufferGPU), l.length === 0)
      n.bufferSubData(a, 0, r);
    else {
      for (let u = 0, c = l.length; u < c; u++) {
        const A = l[u];
        n.bufferSubData(
          a,
          A.start * r.BYTES_PER_ELEMENT,
          r,
          A.start,
          A.count
        );
      }
      s.clearUpdateRanges();
    }
    n.bindBuffer(a, null), o.version = s.version;
  }
  /**
   * Destroys the GPU buffer of the given buffer attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute.
   */
  destroyAttribute(e) {
    const t = this.backend, { gl: n } = t;
    e.isInterleavedBufferAttribute && t.delete(e.data);
    const r = t.get(e);
    n.deleteBuffer(r.bufferGPU), t.delete(e);
  }
  /**
   * This method performs a readback operation by moving buffer data from
   * a storage buffer attribute from the GPU to the CPU.
   *
   * @async
   * @param {StorageBufferAttribute} attribute - The storage buffer attribute.
   * @return {Promise<ArrayBuffer>} A promise that resolves with the buffer data when the data are ready.
   */
  async getArrayBufferAsync(e) {
    const t = this.backend, { gl: n } = t, r = e.isInterleavedBufferAttribute ? e.data : e, { bufferGPU: s } = t.get(r), o = e.array, a = o.byteLength;
    n.bindBuffer(n.COPY_READ_BUFFER, s);
    const l = n.createBuffer();
    n.bindBuffer(n.COPY_WRITE_BUFFER, l), n.bufferData(n.COPY_WRITE_BUFFER, a, n.STREAM_READ), n.copyBufferSubData(n.COPY_READ_BUFFER, n.COPY_WRITE_BUFFER, 0, 0, a), await t.utils._clientWaitAsync();
    const u = new e.array.constructor(o.length);
    return n.bindBuffer(n.COPY_WRITE_BUFFER, l), n.getBufferSubData(n.COPY_WRITE_BUFFER, 0, u), n.deleteBuffer(l), n.bindBuffer(n.COPY_READ_BUFFER, null), n.bindBuffer(n.COPY_WRITE_BUFFER, null), u.buffer;
  }
  /**
   * Creates a WebGL buffer with the given data.
   *
   * @private
   * @param {WebGL2RenderingContext} gl - The rendering context.
   * @param {GLenum } bufferType - A flag that indicates the buffer type and thus binding point target.
   * @param {TypedArray} array - The array of the buffer attribute.
   * @param {GLenum} usage - The usage.
   * @return {WebGLBuffer} The WebGL buffer.
   */
  _createBuffer(e, t, n, r) {
    const s = e.createBuffer();
    return e.bindBuffer(t, s), e.bufferData(t, n, r), e.bindBuffer(t, null), s;
  }
}
let mv, ip;
class Nae {
  /**
   * Constructs a new utility object.
   *
   * @param {WebGLBackend} backend - The WebGL 2 backend.
   */
  constructor(e) {
    this.backend = e, this.gl = this.backend.gl, this.enabled = {}, this.currentFlipSided = null, this.currentCullFace = null, this.currentProgram = null, this.currentBlendingEnabled = !1, this.currentBlending = null, this.currentBlendSrc = null, this.currentBlendDst = null, this.currentBlendSrcAlpha = null, this.currentBlendDstAlpha = null, this.currentPremultipledAlpha = null, this.currentPolygonOffsetFactor = null, this.currentPolygonOffsetUnits = null, this.currentColorMask = null, this.currentDepthFunc = null, this.currentDepthMask = null, this.currentStencilFunc = null, this.currentStencilRef = null, this.currentStencilFuncMask = null, this.currentStencilFail = null, this.currentStencilZFail = null, this.currentStencilZPass = null, this.currentStencilMask = null, this.currentLineWidth = null, this.currentClippingPlanes = 0, this.currentVAO = null, this.currentIndex = null, this.currentBoundFramebuffers = {}, this.currentDrawbuffers = /* @__PURE__ */ new WeakMap(), this.maxTextures = this.gl.getParameter(this.gl.MAX_TEXTURE_IMAGE_UNITS), this.currentTextureSlot = null, this.currentBoundTextures = {}, this.currentBoundBufferBases = {}, this._init();
  }
  /**
   * Inits the state of the utility.
   *
   * @private
   */
  _init() {
    const e = this.gl;
    mv = {
      [Wr]: e.FUNC_ADD,
      [S_]: e.FUNC_SUBTRACT,
      [T_]: e.FUNC_REVERSE_SUBTRACT
    }, ip = {
      [Ga]: e.ZERO,
      [w_]: e.ONE,
      [M_]: e.SRC_COLOR,
      [Tf]: e.SRC_ALPHA,
      [D_]: e.SRC_ALPHA_SATURATE,
      [P_]: e.DST_COLOR,
      [R_]: e.DST_ALPHA,
      [E_]: e.ONE_MINUS_SRC_COLOR,
      [wf]: e.ONE_MINUS_SRC_ALPHA,
      [N_]: e.ONE_MINUS_DST_COLOR,
      [C_]: e.ONE_MINUS_DST_ALPHA
    };
    const t = e.getParameter(e.SCISSOR_BOX), n = e.getParameter(e.VIEWPORT);
    this.currentScissor = new Kt().fromArray(t), this.currentViewport = new Kt().fromArray(n), this._tempVec4 = new Kt();
  }
  /**
   * Enables the given WebGL capability.
   *
   * This method caches the capability state so
   * `gl.enable()` is only called when necessary.
   *
   * @param {GLenum} id - The capability to enable.
   */
  enable(e) {
    const { enabled: t } = this;
    t[e] !== !0 && (this.gl.enable(e), t[e] = !0);
  }
  /**
   * Disables the given WebGL capability.
   *
   * This method caches the capability state so
   * `gl.disable()` is only called when necessary.
   *
   * @param {GLenum} id - The capability to enable.
   */
  disable(e) {
    const { enabled: t } = this;
    t[e] !== !1 && (this.gl.disable(e), t[e] = !1);
  }
  /**
   * Specifies whether polygons are front- or back-facing
   * by setting the winding orientation.
   *
   * This method caches the state so `gl.frontFace()` is only
   * called when necessary.
   *
   * @param {boolean} flipSided - Whether triangles flipped their sides or not.
   */
  setFlipSided(e) {
    if (this.currentFlipSided !== e) {
      const { gl: t } = this;
      e ? t.frontFace(t.CW) : t.frontFace(t.CCW), this.currentFlipSided = e;
    }
  }
  /**
   * Specifies whether or not front- and/or back-facing
   * polygons can be culled.
   *
   * This method caches the state so `gl.cullFace()` is only
   * called when necessary.
   *
   * @param {number} cullFace - Defines which polygons are candidates for culling.
   */
  setCullFace(e) {
    const { gl: t } = this;
    e !== _3 ? (this.enable(t.CULL_FACE), e !== this.currentCullFace && (e === h1 ? t.cullFace(t.BACK) : e === x3 ? t.cullFace(t.FRONT) : t.cullFace(t.FRONT_AND_BACK))) : this.disable(t.CULL_FACE), this.currentCullFace = e;
  }
  /**
   * Specifies the width of line primitives.
   *
   * This method caches the state so `gl.lineWidth()` is only
   * called when necessary.
   *
   * @param {number} width - The line width.
   */
  setLineWidth(e) {
    const { currentLineWidth: t, gl: n } = this;
    e !== t && (n.lineWidth(e), this.currentLineWidth = e);
  }
  setMRTBlending(e) {
    const t = this.gl, n = this.backend.drawBuffersIndexedExt;
    if (n)
      for (let r = 1; r < e.length; r++)
        n.blendFuncSeparateiOES(r, t.ONE, t.ZERO, t.ONE, t.ZERO);
  }
  /**
   * Defines the blending.
   *
   * This method caches the state so `gl.blendEquation()`, `gl.blendEquationSeparate()`,
   * `gl.blendFunc()` and  `gl.blendFuncSeparate()` are only called when necessary.
   *
   * @param {number} blending - The blending type.
   * @param {number} blendEquation - The blending equation.
   * @param {number} blendSrc - Only relevant for custom blending. The RGB source blending factor.
   * @param {number} blendDst - Only relevant for custom blending. The RGB destination blending factor.
   * @param {number} blendEquationAlpha - Only relevant for custom blending. The blending equation for alpha.
   * @param {number} blendSrcAlpha - Only relevant for custom blending. The alpha source blending factor.
   * @param {number} blendDstAlpha - Only relevant for custom blending. The alpha destination blending factor.
   * @param {boolean} premultipliedAlpha - Whether premultiplied alpha is enabled or not.
   */
  setBlending(e, t, n, r, s, o, a, l) {
    const { gl: u } = this;
    if (e === ms) {
      this.currentBlendingEnabled === !0 && (this.disable(u.BLEND), this.currentBlendingEnabled = !1);
      return;
    }
    if (this.currentBlendingEnabled === !1 && (this.enable(u.BLEND), this.currentBlendingEnabled = !0), e !== oh) {
      if (e !== this.currentBlending || l !== this.currentPremultipledAlpha) {
        if ((this.currentBlendEquation !== Wr || this.currentBlendEquationAlpha !== Wr) && (u.blendEquation(u.FUNC_ADD), this.currentBlendEquation = Wr, this.currentBlendEquationAlpha = Wr), l)
          switch (e) {
            case gs:
              u.blendFuncSeparate(u.ONE, u.ONE_MINUS_SRC_ALPHA, u.ONE, u.ONE_MINUS_SRC_ALPHA);
              break;
            case fh:
              u.blendFunc(u.ONE, u.ONE);
              break;
            case Ah:
              u.blendFuncSeparate(u.ZERO, u.ONE_MINUS_SRC_COLOR, u.ZERO, u.ONE);
              break;
            case ph:
              u.blendFuncSeparate(u.DST_COLOR, u.ONE_MINUS_SRC_ALPHA, u.ZERO, u.ONE);
              break;
            default:
              Ie("WebGLState: Invalid blending: ", e);
              break;
          }
        else
          switch (e) {
            case gs:
              u.blendFuncSeparate(u.SRC_ALPHA, u.ONE_MINUS_SRC_ALPHA, u.ONE, u.ONE_MINUS_SRC_ALPHA);
              break;
            case fh:
              u.blendFuncSeparate(u.SRC_ALPHA, u.ONE, u.ONE, u.ONE);
              break;
            case Ah:
              Ie("WebGLState: SubtractiveBlending requires material.premultipliedAlpha = true");
              break;
            case ph:
              Ie("WebGLState: MultiplyBlending requires material.premultipliedAlpha = true");
              break;
            default:
              Ie("WebGLState: Invalid blending: ", e);
              break;
          }
        this.currentBlendSrc = null, this.currentBlendDst = null, this.currentBlendSrcAlpha = null, this.currentBlendDstAlpha = null, this.currentBlending = e, this.currentPremultipledAlpha = l;
      }
      return;
    }
    s = s || t, o = o || n, a = a || r, (t !== this.currentBlendEquation || s !== this.currentBlendEquationAlpha) && (u.blendEquationSeparate(mv[t], mv[s]), this.currentBlendEquation = t, this.currentBlendEquationAlpha = s), (n !== this.currentBlendSrc || r !== this.currentBlendDst || o !== this.currentBlendSrcAlpha || a !== this.currentBlendDstAlpha) && (u.blendFuncSeparate(ip[n], ip[r], ip[o], ip[a]), this.currentBlendSrc = n, this.currentBlendDst = r, this.currentBlendSrcAlpha = o, this.currentBlendDstAlpha = a), this.currentBlending = e, this.currentPremultipledAlpha = !1;
  }
  /**
   * Specifies whether colors can be written when rendering
   * into a framebuffer or not.
   *
   * This method caches the state so `gl.colorMask()` is only
   * called when necessary.
   *
   * @param {boolean} colorMask - The color mask.
   */
  setColorMask(e) {
    this.currentColorMask !== e && (this.gl.colorMask(e, e, e, e), this.currentColorMask = e);
  }
  /**
   * Specifies whether the depth test is enabled or not.
   *
   * @param {boolean} depthTest - Whether the depth test is enabled or not.
   */
  setDepthTest(e) {
    const { gl: t } = this;
    e ? this.enable(t.DEPTH_TEST) : this.disable(t.DEPTH_TEST);
  }
  /**
   * Specifies whether depth values can be written when rendering
   * into a framebuffer or not.
   *
   * This method caches the state so `gl.depthMask()` is only
   * called when necessary.
   *
   * @param {boolean} depthMask - The depth mask.
   */
  setDepthMask(e) {
    this.currentDepthMask !== e && (this.gl.depthMask(e), this.currentDepthMask = e);
  }
  /**
   * Specifies the depth compare function.
   *
   * This method caches the state so `gl.depthFunc()` is only
   * called when necessary.
   *
   * @param {number} depthFunc - The depth compare function.
   */
  setDepthFunc(e) {
    if (this.currentDepthFunc !== e) {
      const { gl: t } = this;
      switch (e) {
        case Mf:
          t.depthFunc(t.NEVER);
          break;
        case Ef:
          t.depthFunc(t.ALWAYS);
          break;
        case Rf:
          t.depthFunc(t.LESS);
          break;
        case Vl:
          t.depthFunc(t.LEQUAL);
          break;
        case Cf:
          t.depthFunc(t.EQUAL);
          break;
        case Pf:
          t.depthFunc(t.GEQUAL);
          break;
        case Nf:
          t.depthFunc(t.GREATER);
          break;
        case Df:
          t.depthFunc(t.NOTEQUAL);
          break;
        default:
          t.depthFunc(t.LEQUAL);
      }
      this.currentDepthFunc = e;
    }
  }
  /**
   * Specifies the scissor box.
   *
   * @param {number} x - The x-coordinate of the lower left corner of the viewport.
   * @param {number} y - The y-coordinate of the lower left corner of the viewport.
   * @param {number} width - The width of the viewport.
   * @param {number} height - The height of the viewport.
   *
   */
  scissor(e, t, n, r) {
    const s = this._tempVec4.set(e, t, n, r);
    if (this.currentScissor.equals(s) === !1) {
      const { gl: o } = this;
      o.scissor(s.x, s.y, s.z, s.w), this.currentScissor.copy(s);
    }
  }
  /**
   * Specifies the viewport.
   *
   * @param {number} x - The x-coordinate of the lower left corner of the viewport.
   * @param {number} y - The y-coordinate of the lower left corner of the viewport.
   * @param {number} width - The width of the viewport.
   * @param {number} height - The height of the viewport.
   *
   */
  viewport(e, t, n, r) {
    const s = this._tempVec4.set(e, t, n, r);
    if (this.currentViewport.equals(s) === !1) {
      const { gl: o } = this;
      o.viewport(s.x, s.y, s.z, s.w), this.currentViewport.copy(s);
    }
  }
  /**
   * Defines the scissor test.
   *
   * @param {boolean} boolean - Whether the scissor test should be enabled or not.
   */
  setScissorTest(e) {
    const t = this.gl;
    e ? this.enable(t.SCISSOR_TEST) : this.disable(t.SCISSOR_TEST);
  }
  /**
   * Specifies whether the stencil test is enabled or not.
   *
   * @param {boolean} stencilTest - Whether the stencil test is enabled or not.
   */
  setStencilTest(e) {
    const { gl: t } = this;
    e ? this.enable(t.STENCIL_TEST) : this.disable(t.STENCIL_TEST);
  }
  /**
   * Specifies whether stencil values can be written when rendering
   * into a framebuffer or not.
   *
   * This method caches the state so `gl.stencilMask()` is only
   * called when necessary.
   *
   * @param {boolean} stencilMask - The stencil mask.
   */
  setStencilMask(e) {
    this.currentStencilMask !== e && (this.gl.stencilMask(e), this.currentStencilMask = e);
  }
  /**
   * Specifies whether the stencil test functions.
   *
   * This method caches the state so `gl.stencilFunc()` is only
   * called when necessary.
   *
   * @param {number} stencilFunc - The stencil compare function.
   * @param {number} stencilRef - The reference value for the stencil test.
   * @param {number} stencilMask - A bit-wise mask that is used to AND the reference value and the stored stencil value when the test is done.
   */
  setStencilFunc(e, t, n) {
    (this.currentStencilFunc !== e || this.currentStencilRef !== t || this.currentStencilFuncMask !== n) && (this.gl.stencilFunc(e, t, n), this.currentStencilFunc = e, this.currentStencilRef = t, this.currentStencilFuncMask = n);
  }
  /**
   * Specifies whether the stencil test operation.
   *
   * This method caches the state so `gl.stencilOp()` is only
   * called when necessary.
   *
   * @param {number} stencilFail - The function to use when the stencil test fails.
   * @param {number} stencilZFail - The function to use when the stencil test passes, but the depth test fail.
   * @param {number} stencilZPass - The function to use when both the stencil test and the depth test pass,
   * or when the stencil test passes and there is no depth buffer or depth testing is disabled.
   */
  setStencilOp(e, t, n) {
    (this.currentStencilFail !== e || this.currentStencilZFail !== t || this.currentStencilZPass !== n) && (this.gl.stencilOp(e, t, n), this.currentStencilFail = e, this.currentStencilZFail = t, this.currentStencilZPass = n);
  }
  /**
   * Configures the WebGL state for the given material.
   *
   * @param {Material} material - The material to configure the state for.
   * @param {number} frontFaceCW - Whether the front faces are counter-clockwise or not.
   * @param {number} hardwareClippingPlanes - The number of hardware clipping planes.
   */
  setMaterial(e, t, n) {
    const { gl: r } = this;
    e.side === er ? this.disable(r.CULL_FACE) : this.enable(r.CULL_FACE);
    let s = e.side === si;
    t && (s = !s), this.setFlipSided(s), e.blending === gs && e.transparent === !1 ? this.setBlending(ms) : this.setBlending(e.blending, e.blendEquation, e.blendSrc, e.blendDst, e.blendEquationAlpha, e.blendSrcAlpha, e.blendDstAlpha, e.premultipliedAlpha), this.setDepthFunc(e.depthFunc), this.setDepthTest(e.depthTest), this.setDepthMask(e.depthWrite), this.setColorMask(e.colorWrite);
    const o = e.stencilWrite;
    if (this.setStencilTest(o), o && (this.setStencilMask(e.stencilWriteMask), this.setStencilFunc(e.stencilFunc, e.stencilRef, e.stencilFuncMask), this.setStencilOp(e.stencilFail, e.stencilZFail, e.stencilZPass)), this.setPolygonOffset(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits), e.alphaToCoverage === !0 && this.backend.renderer.currentSamples > 0 ? this.enable(r.SAMPLE_ALPHA_TO_COVERAGE) : this.disable(r.SAMPLE_ALPHA_TO_COVERAGE), n > 0 && this.currentClippingPlanes !== n)
      for (let l = 0; l < 8; l++)
        l < n ? this.enable(12288 + l) : this.disable(12288 + l);
  }
  /**
   * Specifies the polygon offset.
   *
   * This method caches the state so `gl.polygonOffset()` is only
   * called when necessary.
   *
   * @param {boolean} polygonOffset - Whether polygon offset is enabled or not.
   * @param {number} factor - The scale factor for the variable depth offset for each polygon.
   * @param {number} units - The multiplier by which an implementation-specific value is multiplied with to create a constant depth offset.
   */
  setPolygonOffset(e, t, n) {
    const { gl: r } = this;
    e ? (this.enable(r.POLYGON_OFFSET_FILL), (this.currentPolygonOffsetFactor !== t || this.currentPolygonOffsetUnits !== n) && (r.polygonOffset(t, n), this.currentPolygonOffsetFactor = t, this.currentPolygonOffsetUnits = n)) : this.disable(r.POLYGON_OFFSET_FILL);
  }
  /**
   * Defines the usage of the given WebGL program.
   *
   * This method caches the state so `gl.useProgram()` is only
   * called when necessary.
   *
   * @param {WebGLProgram} program - The WebGL program to use.
   * @return {boolean} Whether a program change has been executed or not.
   */
  useProgram(e) {
    return this.currentProgram !== e ? (this.gl.useProgram(e), this.currentProgram = e, !0) : !1;
  }
  /**
   * Sets the vertex state by binding the given VAO and element buffer.
   *
   * @param {WebGLVertexArrayObject} vao - The VAO.
   * @param {?WebGLBuffer} indexBuffer - The index buffer.
   * @return {boolean} Whether a vertex state has been changed or not.
   */
  setVertexState(e, t = null) {
    const n = this.gl;
    return this.currentVAO !== e || this.currentIndex !== t ? (n.bindVertexArray(e), t !== null && n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, t), this.currentVAO = e, this.currentIndex = t, !0) : !1;
  }
  /**
   * Resets the vertex array state by resetting the VAO and element buffer.
   */
  resetVertexState() {
    const e = this.gl;
    e.bindVertexArray(null), e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, null), this.currentVAO = null, this.currentIndex = null;
  }
  // framebuffer
  /**
   * Binds the given framebuffer.
   *
   * This method caches the state so `gl.bindFramebuffer()` is only
   * called when necessary.
   *
   * @param {number} target - The binding point (target).
   * @param {WebGLFramebuffer} framebuffer - The WebGL framebuffer to bind.
   * @return {boolean} Whether a bind has been executed or not.
   */
  bindFramebuffer(e, t) {
    const { gl: n, currentBoundFramebuffers: r } = this;
    return r[e] !== t ? (n.bindFramebuffer(e, t), r[e] = t, e === n.DRAW_FRAMEBUFFER && (r[n.FRAMEBUFFER] = t), e === n.FRAMEBUFFER && (r[n.DRAW_FRAMEBUFFER] = t), !0) : !1;
  }
  /**
   * Defines draw buffers to which fragment colors are written into.
   * Configures the MRT setup of custom framebuffers.
   *
   * This method caches the state so `gl.drawBuffers()` is only
   * called when necessary.
   *
   * @param {RenderContext} renderContext - The render context.
   * @param {WebGLFramebuffer} framebuffer - The WebGL framebuffer.
   */
  drawBuffers(e, t) {
    const { gl: n } = this;
    let r = [], s = !1;
    if (e.textures !== null) {
      r = this.currentDrawbuffers.get(t), r === void 0 && (r = [], this.currentDrawbuffers.set(t, r));
      const o = e.textures;
      if (r.length !== o.length || r[0] !== n.COLOR_ATTACHMENT0) {
        for (let a = 0, l = o.length; a < l; a++)
          r[a] = n.COLOR_ATTACHMENT0 + a;
        r.length = o.length, s = !0;
      }
    } else
      r[0] !== n.BACK && (r[0] = n.BACK, s = !0);
    s && n.drawBuffers(r);
  }
  // texture
  /**
   * Makes the given texture unit active.
   *
   * This method caches the state so `gl.activeTexture()` is only
   * called when necessary.
   *
   * @param {number} webglSlot - The texture unit to make active.
   */
  activeTexture(e) {
    const { gl: t, currentTextureSlot: n, maxTextures: r } = this;
    e === void 0 && (e = t.TEXTURE0 + r - 1), n !== e && (t.activeTexture(e), this.currentTextureSlot = e);
  }
  /**
   * Binds the given WebGL texture to a target.
   *
   * This method caches the state so `gl.bindTexture()` is only
   * called when necessary.
   *
   * @param {number} webglType - The binding point (target).
   * @param {WebGLTexture} webglTexture - The WebGL texture to bind.
   * @param {number} webglSlot - The texture.
   */
  bindTexture(e, t, n) {
    const { gl: r, currentTextureSlot: s, currentBoundTextures: o, maxTextures: a } = this;
    n === void 0 && (s === null ? n = r.TEXTURE0 + a - 1 : n = s);
    let l = o[n];
    l === void 0 && (l = { type: void 0, texture: void 0 }, o[n] = l), (l.type !== e || l.texture !== t) && (s !== n && (r.activeTexture(n), this.currentTextureSlot = n), r.bindTexture(e, t), l.type = e, l.texture = t);
  }
  /**
   * Binds a given WebGL buffer to a given binding point (target) at a given index.
   *
   * This method caches the state so `gl.bindBufferBase()` is only
   * called when necessary.
   *
   * @param {number} target - The target for the bind operation.
   * @param {number} index - The index of the target.
   * @param {WebGLBuffer} buffer - The WebGL buffer.
   * @return {boolean} Whether a bind has been executed or not.
   */
  bindBufferBase(e, t, n) {
    const { gl: r } = this, s = `${e}-${t}`;
    return this.currentBoundBufferBases[s] !== n ? (r.bindBufferBase(e, t, n), this.currentBoundBufferBases[s] = n, !0) : !1;
  }
  /**
   * Unbinds the current bound texture.
   *
   * This method caches the state so `gl.bindTexture()` is only
   * called when necessary.
   */
  unbindTexture() {
    const { gl: e, currentTextureSlot: t, currentBoundTextures: n } = this, r = n[t];
    r !== void 0 && r.type !== void 0 && (e.bindTexture(r.type, null), r.type = void 0, r.texture = void 0);
  }
}
class Dae {
  /**
   * Constructs a new utility object.
   *
   * @param {WebGLBackend} backend - The WebGL 2 backend.
   */
  constructor(e) {
    this.backend = e, this.gl = this.backend.gl, this.extensions = e.extensions;
  }
  /**
   * Converts the given three.js constant into a WebGL constant.
   * The method currently supports the conversion of texture formats
   * and types.
   *
   * @param {number} p - The three.js constant.
   * @param {string} [colorSpace=NoColorSpace] - The color space.
   * @return {?number} The corresponding WebGL constant.
   */
  convert(e, t = Ds) {
    const { gl: n, extensions: r } = this;
    let s;
    const o = Xt.getTransfer(t);
    if (e === Mi) return n.UNSIGNED_BYTE;
    if (e === m0) return n.UNSIGNED_SHORT_4_4_4_4;
    if (e === g0) return n.UNSIGNED_SHORT_5_5_5_1;
    if (e === _0) return n.UNSIGNED_INT_5_9_9_9_REV;
    if (e === x0) return n.UNSIGNED_INT_10F_11F_11F_REV;
    if (e === Ou) return n.BYTE;
    if (e === ku) return n.SHORT;
    if (e === Oo) return n.UNSIGNED_SHORT;
    if (e === _r) return n.INT;
    if (e === Jn) return n.UNSIGNED_INT;
    if (e === Ei) return n.FLOAT;
    if (e === Ri)
      return n.HALF_FLOAT;
    if (e === k_) return n.ALPHA;
    if (e === nA) return n.RGB;
    if (e === Pi) return n.RGBA;
    if (e === Lr) return n.DEPTH_COMPONENT;
    if (e === ds) return n.DEPTH_STENCIL;
    if (e === Yh) return n.RED;
    if (e === Zu) return n.RED_INTEGER;
    if (e === fs) return n.RG;
    if (e === Qh) return n.RG_INTEGER;
    if (e === Kh) return n.RGBA_INTEGER;
    if (e === Rl || e === Cl || e === Pl || e === Nl)
      if (o === vt)
        if (s = r.get("WEBGL_compressed_texture_s3tc_srgb"), s !== null) {
          if (e === Rl) return s.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (e === Cl) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (e === Pl) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (e === Nl) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else
          return null;
      else if (s = r.get("WEBGL_compressed_texture_s3tc"), s !== null) {
        if (e === Rl) return s.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (e === Cl) return s.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (e === Pl) return s.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (e === Nl) return s.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else
        return null;
    if (e === Lf || e === If || e === Bf || e === Ff)
      if (s = r.get("WEBGL_compressed_texture_pvrtc"), s !== null) {
        if (e === Lf) return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (e === If) return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (e === Bf) return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (e === Ff) return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else
        return null;
    if (e === mh || e === gh || e === _h || e === xh || e === yh || e === qu || e === vh)
      if (s = r.get("WEBGL_compressed_texture_etc"), s !== null) {
        if (e === mh || e === gh) return o === vt ? s.COMPRESSED_SRGB8_ETC2 : s.COMPRESSED_RGB8_ETC2;
        if (e === _h) return o === vt ? s.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : s.COMPRESSED_RGBA8_ETC2_EAC;
        if (e === xh) return s.COMPRESSED_R11_EAC;
        if (e === yh) return s.COMPRESSED_SIGNED_R11_EAC;
        if (e === qu) return s.COMPRESSED_RG11_EAC;
        if (e === vh) return s.COMPRESSED_SIGNED_RG11_EAC;
      } else
        return null;
    if (e === bh || e === Sh || e === Th || e === wh || e === Mh || e === Eh || e === Rh || e === Ch || e === Ph || e === Nh || e === Dh || e === Lh || e === Ih || e === Bh)
      if (s = r.get("WEBGL_compressed_texture_astc"), s !== null) {
        if (e === bh) return o === vt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : s.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (e === Sh) return o === vt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : s.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (e === Th) return o === vt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : s.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (e === wh) return o === vt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : s.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (e === Mh) return o === vt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : s.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (e === Eh) return o === vt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : s.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (e === Rh) return o === vt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : s.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (e === Ch) return o === vt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : s.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (e === Ph) return o === vt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : s.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (e === Nh) return o === vt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : s.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (e === Dh) return o === vt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : s.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (e === Lh) return o === vt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : s.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (e === Ih) return o === vt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : s.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (e === Bh) return o === vt ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : s.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else
        return null;
    if (e === Fh)
      if (s = r.get("EXT_texture_compression_bptc"), s !== null) {
        if (e === Fh) return o === vt ? s.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : s.COMPRESSED_RGBA_BPTC_UNORM_EXT;
      } else
        return null;
    if (e === Uh || e === Oh || e === Hu || e === kh)
      if (s = r.get("EXT_texture_compression_rgtc"), s !== null) {
        if (e === Uh) return s.COMPRESSED_RED_RGTC1_EXT;
        if (e === Oh) return s.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (e === Hu) return s.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (e === kh) return s.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else
        return null;
    return e === Js ? n.UNSIGNED_INT_24_8 : n[e] !== void 0 ? n[e] : null;
  }
  /**
   * This method can be used to synchronize the CPU with the GPU by waiting until
   * ongoing GPU commands have been completed.
   *
   * @private
   * @return {Promise} A promise that resolves when all ongoing GPU commands have been completed.
   */
  _clientWaitAsync() {
    const { gl: e } = this, t = e.fenceSync(e.SYNC_GPU_COMMANDS_COMPLETE, 0);
    return e.flush(), new Promise((n, r) => {
      function s() {
        const o = e.clientWaitSync(t, e.SYNC_FLUSH_COMMANDS_BIT, 0);
        if (o === e.WAIT_FAILED) {
          e.deleteSync(t), r();
          return;
        }
        if (o === e.TIMEOUT_EXPIRED) {
          requestAnimationFrame(s);
          return;
        }
        e.deleteSync(t), n();
      }
      s();
    });
  }
}
let vC = !1, Mg, gv, bC;
class Lae {
  /**
   * Constructs a new utility object.
   *
   * @param {WebGLBackend} backend - The WebGL 2 backend.
   */
  constructor(e) {
    this.backend = e, this.gl = e.gl, this.extensions = e.extensions, this.defaultTextures = {}, this._srcFramebuffer = null, this._dstFramebuffer = null, vC === !1 && (this._init(), vC = !0);
  }
  /**
   * Inits the state of the utility.
   *
   * @private
   */
  _init() {
    const e = this.gl;
    Mg = {
      [zl]: e.REPEAT,
      [xr]: e.CLAMP_TO_EDGE,
      [ql]: e.MIRRORED_REPEAT
    }, gv = {
      [ei]: e.NEAREST,
      [p0]: e.NEAREST_MIPMAP_NEAREST,
      [Aa]: e.NEAREST_MIPMAP_LINEAR,
      [qn]: e.LINEAR,
      [Uu]: e.LINEAR_MIPMAP_NEAREST,
      [$r]: e.LINEAR_MIPMAP_LINEAR
    }, bC = {
      [G_]: e.NEVER,
      [W_]: e.ALWAYS,
      [iA]: e.LESS,
      [rA]: e.LEQUAL,
      [z_]: e.EQUAL,
      [sA]: e.GEQUAL,
      [q_]: e.GREATER,
      [H_]: e.NOTEQUAL
    };
  }
  /**
   * Returns the native texture type for the given texture.
   *
   * @param {Texture} texture - The texture.
   * @return {GLenum} The native texture type.
   */
  getGLTextureType(e) {
    const { gl: t } = this;
    let n;
    return e.isCubeTexture === !0 ? n = t.TEXTURE_CUBE_MAP : e.isArrayTexture === !0 || e.isDataArrayTexture === !0 || e.isCompressedArrayTexture === !0 ? n = t.TEXTURE_2D_ARRAY : e.isData3DTexture === !0 ? n = t.TEXTURE_3D : n = t.TEXTURE_2D, n;
  }
  /**
   * Returns the native texture type for the given texture.
   *
   * @param {?string} internalFormatName - The internal format name. When `null`, the internal format is derived from the subsequent parameters.
   * @param {GLenum} glFormat - The WebGL format.
   * @param {GLenum} glType - The WebGL type.
   * @param {string} colorSpace - The texture's color space.
   * @param {boolean} [forceLinearTransfer=false] - Whether to force a linear transfer or not.
   * @return {GLenum} The internal format.
   */
  getInternalFormat(e, t, n, r, s = !1) {
    const { gl: o, extensions: a } = this;
    if (e !== null) {
      if (o[e] !== void 0) return o[e];
      Me("WebGLBackend: Attempt to use non-existing WebGL internal format '" + e + "'");
    }
    let l = t;
    if (t === o.RED && (n === o.FLOAT && (l = o.R32F), n === o.HALF_FLOAT && (l = o.R16F), n === o.UNSIGNED_BYTE && (l = o.R8), n === o.UNSIGNED_SHORT && (l = o.R16), n === o.UNSIGNED_INT && (l = o.R32UI), n === o.BYTE && (l = o.R8I), n === o.SHORT && (l = o.R16I), n === o.INT && (l = o.R32I)), t === o.RED_INTEGER && (n === o.UNSIGNED_BYTE && (l = o.R8UI), n === o.UNSIGNED_SHORT && (l = o.R16UI), n === o.UNSIGNED_INT && (l = o.R32UI), n === o.BYTE && (l = o.R8I), n === o.SHORT && (l = o.R16I), n === o.INT && (l = o.R32I)), t === o.RG && (n === o.FLOAT && (l = o.RG32F), n === o.HALF_FLOAT && (l = o.RG16F), n === o.UNSIGNED_BYTE && (l = o.RG8), n === o.UNSIGNED_SHORT && (l = o.RG16), n === o.UNSIGNED_INT && (l = o.RG32UI), n === o.BYTE && (l = o.RG8I), n === o.SHORT && (l = o.RG16I), n === o.INT && (l = o.RG32I)), t === o.RG_INTEGER && (n === o.UNSIGNED_BYTE && (l = o.RG8UI), n === o.UNSIGNED_SHORT && (l = o.RG16UI), n === o.UNSIGNED_INT && (l = o.RG32UI), n === o.BYTE && (l = o.RG8I), n === o.SHORT && (l = o.RG16I), n === o.INT && (l = o.RG32I)), t === o.RGB) {
      const u = s ? Vh : Xt.getTransfer(r);
      n === o.FLOAT && (l = o.RGB32F), n === o.HALF_FLOAT && (l = o.RGB16F), n === o.UNSIGNED_BYTE && (l = o.RGB8), n === o.UNSIGNED_SHORT && (l = o.RGB16), n === o.UNSIGNED_INT && (l = o.RGB32UI), n === o.BYTE && (l = o.RGB8I), n === o.SHORT && (l = o.RGB16I), n === o.INT && (l = o.RGB32I), n === o.UNSIGNED_BYTE && (l = u === vt ? o.SRGB8 : o.RGB8), n === o.UNSIGNED_SHORT_5_6_5 && (l = o.RGB565), n === o.UNSIGNED_SHORT_5_5_5_1 && (l = o.RGB5_A1), n === o.UNSIGNED_SHORT_4_4_4_4 && (l = o.RGB4), n === o.UNSIGNED_INT_5_9_9_9_REV && (l = o.RGB9_E5), n === o.UNSIGNED_INT_10F_11F_11F_REV && (l = o.R11F_G11F_B10F);
    }
    if (t === o.RGB_INTEGER && (n === o.UNSIGNED_BYTE && (l = o.RGB8UI), n === o.UNSIGNED_SHORT && (l = o.RGB16UI), n === o.UNSIGNED_INT && (l = o.RGB32UI), n === o.BYTE && (l = o.RGB8I), n === o.SHORT && (l = o.RGB16I), n === o.INT && (l = o.RGB32I)), t === o.RGBA) {
      const u = s ? Vh : Xt.getTransfer(r);
      n === o.FLOAT && (l = o.RGBA32F), n === o.HALF_FLOAT && (l = o.RGBA16F), n === o.UNSIGNED_BYTE && (l = o.RGBA8), n === o.UNSIGNED_SHORT && (l = o.RGBA16), n === o.UNSIGNED_INT && (l = o.RGBA32UI), n === o.BYTE && (l = o.RGBA8I), n === o.SHORT && (l = o.RGBA16I), n === o.INT && (l = o.RGBA32I), n === o.UNSIGNED_BYTE && (l = u === vt ? o.SRGB8_ALPHA8 : o.RGBA8), n === o.UNSIGNED_SHORT_4_4_4_4 && (l = o.RGBA4), n === o.UNSIGNED_SHORT_5_5_5_1 && (l = o.RGB5_A1);
    }
    return t === o.RGBA_INTEGER && (n === o.UNSIGNED_BYTE && (l = o.RGBA8UI), n === o.UNSIGNED_SHORT && (l = o.RGBA16UI), n === o.UNSIGNED_INT && (l = o.RGBA32UI), n === o.BYTE && (l = o.RGBA8I), n === o.SHORT && (l = o.RGBA16I), n === o.INT && (l = o.RGBA32I)), t === o.DEPTH_COMPONENT && (n === o.UNSIGNED_SHORT && (l = o.DEPTH_COMPONENT16), n === o.UNSIGNED_INT && (l = o.DEPTH_COMPONENT24), n === o.FLOAT && (l = o.DEPTH_COMPONENT32F)), t === o.DEPTH_STENCIL && n === o.UNSIGNED_INT_24_8 && (l = o.DEPTH24_STENCIL8), (l === o.R16F || l === o.R32F || l === o.RG16F || l === o.RG32F || l === o.RGBA16F || l === o.RGBA32F) && a.get("EXT_color_buffer_float"), l;
  }
  /**
   * Sets the texture parameters for the given texture.
   *
   * @param {GLenum} textureType - The texture type.
   * @param {Texture} texture - The texture.
   */
  setTextureParameters(e, t) {
    const { gl: n, extensions: r, backend: s } = this, o = Xt.getPrimaries(Xt.workingColorSpace), a = t.colorSpace === Ds ? null : Xt.getPrimaries(t.colorSpace), l = t.colorSpace === Ds || o === a ? n.NONE : n.BROWSER_DEFAULT_WEBGL;
    n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, t.flipY), n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t.premultiplyAlpha), n.pixelStorei(n.UNPACK_ALIGNMENT, t.unpackAlignment), n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, l), n.texParameteri(e, n.TEXTURE_WRAP_S, Mg[t.wrapS]), n.texParameteri(e, n.TEXTURE_WRAP_T, Mg[t.wrapT]), (e === n.TEXTURE_3D || e === n.TEXTURE_2D_ARRAY) && (t.isArrayTexture || n.texParameteri(e, n.TEXTURE_WRAP_R, Mg[t.wrapR])), n.texParameteri(e, n.TEXTURE_MAG_FILTER, gv[t.magFilter]);
    const u = t.mipmaps !== void 0 && t.mipmaps.length > 0, c = t.minFilter === qn && u ? $r : t.minFilter;
    if (n.texParameteri(e, n.TEXTURE_MIN_FILTER, gv[c]), t.compareFunction && (n.texParameteri(e, n.TEXTURE_COMPARE_MODE, n.COMPARE_REF_TO_TEXTURE), n.texParameteri(e, n.TEXTURE_COMPARE_FUNC, bC[t.compareFunction])), r.has("EXT_texture_filter_anisotropic") === !0) {
      if (t.magFilter === ei || t.minFilter !== Aa && t.minFilter !== $r || t.type === Ei && r.has("OES_texture_float_linear") === !1) return;
      if (t.anisotropy > 1) {
        const A = r.get("EXT_texture_filter_anisotropic");
        n.texParameterf(e, A.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(t.anisotropy, s.getMaxAnisotropy()));
      }
    }
  }
  /**
   * Creates a default texture for the given texture that can be used
   * as a placeholder until the actual texture is ready for usage.
   *
   * @param {Texture} texture - The texture to create a default texture for.
   */
  createDefaultTexture(e) {
    const { gl: t, backend: n, defaultTextures: r } = this, s = this.getGLTextureType(e);
    let o = r[s];
    o === void 0 && (o = t.createTexture(), n.state.bindTexture(s, o), t.texParameteri(s, t.TEXTURE_MIN_FILTER, t.NEAREST), t.texParameteri(s, t.TEXTURE_MAG_FILTER, t.NEAREST), r[s] = o), n.set(e, {
      textureGPU: o,
      glTextureType: s
    });
  }
  /**
   * Defines a texture on the GPU for the given texture object.
   *
   * @param {Texture} texture - The texture.
   * @param {Object} [options={}] - Optional configuration parameter.
   * @return {undefined}
   */
  createTexture(e, t) {
    const { gl: n, backend: r } = this, { levels: s, width: o, height: a, depth: l } = t, u = r.utils.convert(e.format, e.colorSpace), c = r.utils.convert(e.type), A = this.getInternalFormat(e.internalFormat, u, c, e.colorSpace, e.isVideoTexture), m = n.createTexture(), _ = this.getGLTextureType(e);
    r.state.bindTexture(_, m), this.setTextureParameters(_, e), e.isArrayTexture || e.isDataArrayTexture || e.isCompressedArrayTexture ? n.texStorage3D(n.TEXTURE_2D_ARRAY, s, A, o, a, l) : e.isData3DTexture ? n.texStorage3D(n.TEXTURE_3D, s, A, o, a, l) : e.isVideoTexture || n.texStorage2D(_, s, A, o, a), r.set(e, {
      textureGPU: m,
      glTextureType: _,
      glFormat: u,
      glType: c,
      glInternalFormat: A
    });
  }
  /**
   * Uploads texture buffer data to the GPU memory.
   *
   * @param {WebGLBuffer} buffer - The buffer data.
   * @param {Texture} texture - The texture,
   */
  copyBufferToTexture(e, t) {
    const { gl: n, backend: r } = this, { textureGPU: s, glTextureType: o, glFormat: a, glType: l } = r.get(t), { width: u, height: c } = t.source.data;
    n.bindBuffer(n.PIXEL_UNPACK_BUFFER, e), r.state.bindTexture(o, s), n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, !1), n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1), n.texSubImage2D(o, 0, 0, 0, u, c, a, l, 0), n.bindBuffer(n.PIXEL_UNPACK_BUFFER, null), r.state.unbindTexture();
  }
  /**
   * Uploads the updated texture data to the GPU.
   *
   * @param {Texture} texture - The texture.
   * @param {Object} [options={}] - Optional configuration parameter.
   */
  updateTexture(e, t) {
    const { gl: n } = this, { width: r, height: s } = t, { textureGPU: o, glTextureType: a, glFormat: l, glType: u, glInternalFormat: c } = this.backend.get(e);
    if (!(e.isRenderTargetTexture || o === void 0))
      if (this.backend.state.bindTexture(a, o), this.setTextureParameters(a, e), e.isCompressedTexture) {
        const A = e.mipmaps, m = t.image;
        for (let _ = 0; _ < A.length; _++) {
          const y = A[_];
          e.isCompressedArrayTexture ? e.format !== n.RGBA ? l !== null ? n.compressedTexSubImage3D(n.TEXTURE_2D_ARRAY, _, 0, 0, 0, y.width, y.height, m.depth, l, y.data) : Me("WebGLBackend: Attempt to load unsupported compressed texture format in .uploadTexture()") : n.texSubImage3D(n.TEXTURE_2D_ARRAY, _, 0, 0, 0, y.width, y.height, m.depth, l, u, y.data) : l !== null ? n.compressedTexSubImage2D(n.TEXTURE_2D, _, 0, 0, y.width, y.height, l, y.data) : Me("WebGLBackend: Unsupported compressed texture format");
        }
      } else if (e.isCubeTexture) {
        const A = t.images, m = e.mipmaps;
        for (let _ = 0; _ < 6; _++) {
          const y = Eg(A[_]);
          n.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + _, 0, 0, 0, r, s, l, u, y);
          for (let T = 0; T < m.length; T++) {
            const b = m[T], S = Eg(b.images[_]);
            n.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + _, T + 1, 0, 0, S.width, S.height, l, u, S);
          }
        }
      } else if (e.isDataArrayTexture || e.isArrayTexture) {
        const A = t.image;
        if (e.layerUpdates.size > 0) {
          const m = y1(A.width, A.height, e.format, e.type);
          for (const _ of e.layerUpdates) {
            const y = A.data.subarray(
              _ * m / A.data.BYTES_PER_ELEMENT,
              (_ + 1) * m / A.data.BYTES_PER_ELEMENT
            );
            n.texSubImage3D(n.TEXTURE_2D_ARRAY, 0, 0, 0, _, A.width, A.height, 1, l, u, y);
          }
          e.clearLayerUpdates();
        } else
          n.texSubImage3D(n.TEXTURE_2D_ARRAY, 0, 0, 0, 0, A.width, A.height, A.depth, l, u, A.data);
      } else if (e.isData3DTexture) {
        const A = t.image;
        n.texSubImage3D(n.TEXTURE_3D, 0, 0, 0, 0, A.width, A.height, A.depth, l, u, A.data);
      } else if (e.isVideoTexture)
        e.update(), n.texImage2D(a, 0, c, l, u, t.image);
      else {
        const A = e.mipmaps;
        if (A.length > 0)
          for (let m = 0, _ = A.length; m < _; m++) {
            const y = A[m], T = Eg(y);
            n.texSubImage2D(a, m, 0, 0, y.width, y.height, l, u, T);
          }
        else {
          const m = Eg(t.image);
          n.texSubImage2D(a, 0, 0, 0, r, s, l, u, m);
        }
      }
  }
  /**
   * Generates mipmaps for the given texture.
   *
   * @param {Texture} texture - The texture.
   */
  generateMipmaps(e) {
    const { gl: t, backend: n } = this, { textureGPU: r, glTextureType: s } = n.get(e);
    n.state.bindTexture(s, r), t.generateMipmap(s);
  }
  /**
   * Deallocates the render buffers of the given render target.
   *
   * @param {RenderTarget} renderTarget - The render target.
   */
  deallocateRenderBuffers(e) {
    const { gl: t, backend: n } = this;
    if (e) {
      const r = n.get(e);
      if (r.renderBufferStorageSetup = void 0, r.framebuffers) {
        for (const s in r.framebuffers)
          t.deleteFramebuffer(r.framebuffers[s]);
        delete r.framebuffers;
      }
      if (r.depthRenderbuffer && (t.deleteRenderbuffer(r.depthRenderbuffer), delete r.depthRenderbuffer), r.stencilRenderbuffer && (t.deleteRenderbuffer(r.stencilRenderbuffer), delete r.stencilRenderbuffer), r.msaaFrameBuffer && (t.deleteFramebuffer(r.msaaFrameBuffer), delete r.msaaFrameBuffer), r.msaaRenderbuffers) {
        for (let s = 0; s < r.msaaRenderbuffers.length; s++)
          t.deleteRenderbuffer(r.msaaRenderbuffers[s]);
        delete r.msaaRenderbuffers;
      }
    }
  }
  /**
   * Destroys the GPU data for the given texture object.
   *
   * @param {Texture} texture - The texture.
   * @param {boolean} [isDefaultTexture=false] - Whether the texture uses a default GPU texture or not.
   */
  destroyTexture(e, t = !1) {
    const { gl: n, backend: r } = this, { textureGPU: s, renderTarget: o } = r.get(e);
    this.deallocateRenderBuffers(o), t === !1 && n.deleteTexture(s), r.delete(e);
  }
  /**
   * Copies data of the given source texture to the given destination texture.
   *
   * @param {Texture} srcTexture - The source texture.
   * @param {Texture} dstTexture - The destination texture.
   * @param {?(Box3|Box2)} [srcRegion=null] - The region of the source texture to copy.
   * @param {?(Vector2|Vector3)} [dstPosition=null] - The destination position of the copy.
   * @param {number} [srcLevel=0] - The source mip level to copy from.
   * @param {number} [dstLevel=0] - The destination mip level to copy to.
   */
  copyTextureToTexture(e, t, n = null, r = null, s = 0, o = 0) {
    const { gl: a, backend: l } = this, { state: u } = this.backend, { textureGPU: c, glTextureType: A, glType: m, glFormat: _ } = l.get(t);
    u.bindTexture(A, c);
    let y, T, b, S, E, R, C, L, D;
    const B = e.isCompressedTexture ? e.mipmaps[o] : e.image;
    if (n !== null)
      y = n.max.x - n.min.x, T = n.max.y - n.min.y, b = n.isBox3 ? n.max.z - n.min.z : 1, S = n.min.x, E = n.min.y, R = n.isBox3 ? n.min.z : 0;
    else {
      const X = Math.pow(2, -s);
      y = Math.floor(B.width * X), T = Math.floor(B.height * X), e.isDataArrayTexture || e.isArrayTexture ? b = B.depth : e.isData3DTexture ? b = Math.floor(B.depth * X) : b = 1, S = 0, E = 0, R = 0;
    }
    r !== null ? (C = r.x, L = r.y, D = r.z) : (C = 0, L = 0, D = 0), a.pixelStorei(a.UNPACK_FLIP_Y_WEBGL, t.flipY), a.pixelStorei(a.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t.premultiplyAlpha), a.pixelStorei(a.UNPACK_ALIGNMENT, t.unpackAlignment);
    const U = a.getParameter(a.UNPACK_ROW_LENGTH), N = a.getParameter(a.UNPACK_IMAGE_HEIGHT), O = a.getParameter(a.UNPACK_SKIP_PIXELS), G = a.getParameter(a.UNPACK_SKIP_ROWS), H = a.getParameter(a.UNPACK_SKIP_IMAGES);
    a.pixelStorei(a.UNPACK_ROW_LENGTH, B.width), a.pixelStorei(a.UNPACK_IMAGE_HEIGHT, B.height), a.pixelStorei(a.UNPACK_SKIP_PIXELS, S), a.pixelStorei(a.UNPACK_SKIP_ROWS, E), a.pixelStorei(a.UNPACK_SKIP_IMAGES, R);
    const Y = e.isDataArrayTexture || e.isData3DTexture || t.isArrayTexture, K = t.isDataArrayTexture || t.isData3DTexture || t.isArrayTexture;
    if (e.isDepthTexture) {
      const X = l.get(e), ee = l.get(t), oe = l.get(X.renderTarget), fe = l.get(ee.renderTarget), _e = oe.framebuffers[X.cacheKey], Te = fe.framebuffers[ee.cacheKey];
      u.bindFramebuffer(a.READ_FRAMEBUFFER, _e), u.bindFramebuffer(a.DRAW_FRAMEBUFFER, Te);
      for (let Ce = 0; Ce < b; Ce++)
        Y && (a.framebufferTextureLayer(a.READ_FRAMEBUFFER, a.COLOR_ATTACHMENT0, X.textureGPU, s, R + Ce), a.framebufferTextureLayer(a.DRAW_FRAMEBUFFER, a.COLOR_ATTACHMENT0, c, o, D + Ce)), a.blitFramebuffer(S, E, y, T, C, L, y, T, a.DEPTH_BUFFER_BIT, a.NEAREST);
      u.bindFramebuffer(a.READ_FRAMEBUFFER, null), u.bindFramebuffer(a.DRAW_FRAMEBUFFER, null);
    } else if (s !== 0 || e.isRenderTargetTexture || l.has(e)) {
      const X = l.get(e);
      this._srcFramebuffer === null && (this._srcFramebuffer = a.createFramebuffer()), this._dstFramebuffer === null && (this._dstFramebuffer = a.createFramebuffer()), u.bindFramebuffer(a.READ_FRAMEBUFFER, this._srcFramebuffer), u.bindFramebuffer(a.DRAW_FRAMEBUFFER, this._dstFramebuffer);
      for (let ee = 0; ee < b; ee++)
        Y ? a.framebufferTextureLayer(a.READ_FRAMEBUFFER, a.COLOR_ATTACHMENT0, X.textureGPU, s, R + ee) : a.framebufferTexture2D(a.READ_FRAMEBUFFER, a.COLOR_ATTACHMENT0, a.TEXTURE_2D, X.textureGPU, s), K ? a.framebufferTextureLayer(a.DRAW_FRAMEBUFFER, a.COLOR_ATTACHMENT0, c, o, D + ee) : a.framebufferTexture2D(a.DRAW_FRAMEBUFFER, a.COLOR_ATTACHMENT0, a.TEXTURE_2D, c, o), s !== 0 ? a.blitFramebuffer(S, E, y, T, C, L, y, T, a.COLOR_BUFFER_BIT, a.NEAREST) : K ? a.copyTexSubImage3D(A, o, C, L, D + ee, S, E, y, T) : a.copyTexSubImage2D(A, o, C, L, S, E, y, T);
      u.bindFramebuffer(a.READ_FRAMEBUFFER, null), u.bindFramebuffer(a.DRAW_FRAMEBUFFER, null);
    } else
      K ? e.isDataTexture || e.isData3DTexture ? a.texSubImage3D(A, o, C, L, D, y, T, b, _, m, B.data) : t.isCompressedArrayTexture ? a.compressedTexSubImage3D(A, o, C, L, D, y, T, b, _, B.data) : a.texSubImage3D(A, o, C, L, D, y, T, b, _, m, B) : e.isDataTexture ? a.texSubImage2D(a.TEXTURE_2D, o, C, L, y, T, _, m, B.data) : e.isCompressedTexture ? a.compressedTexSubImage2D(a.TEXTURE_2D, o, C, L, B.width, B.height, _, B.data) : a.texSubImage2D(a.TEXTURE_2D, o, C, L, y, T, _, m, B);
    a.pixelStorei(a.UNPACK_ROW_LENGTH, U), a.pixelStorei(a.UNPACK_IMAGE_HEIGHT, N), a.pixelStorei(a.UNPACK_SKIP_PIXELS, O), a.pixelStorei(a.UNPACK_SKIP_ROWS, G), a.pixelStorei(a.UNPACK_SKIP_IMAGES, H), o === 0 && t.generateMipmaps && a.generateMipmap(A), u.unbindTexture();
  }
  /**
   * Copies the current bound framebuffer to the given texture.
   *
   * @param {Texture} texture - The destination texture.
   * @param {RenderContext} renderContext - The render context.
   * @param {Vector4} rectangle - A four dimensional vector defining the origin and dimension of the copy.
   */
  copyFramebufferToTexture(e, t, n) {
    const { gl: r } = this, { state: s } = this.backend, { textureGPU: o } = this.backend.get(e), { x: a, y: l, z: u, w: c } = n, A = e.isDepthTexture === !0 || t.renderTarget && t.renderTarget.samples > 0, m = t.renderTarget ? t.renderTarget.height : this.backend.getDrawingBufferSize().y;
    if (A) {
      const _ = a !== 0 || l !== 0;
      let y, T;
      if (e.isDepthTexture === !0 ? (y = r.DEPTH_BUFFER_BIT, T = r.DEPTH_ATTACHMENT, t.stencil && (y |= r.STENCIL_BUFFER_BIT)) : (y = r.COLOR_BUFFER_BIT, T = r.COLOR_ATTACHMENT0), _) {
        const b = this.backend.get(t.renderTarget), S = b.framebuffers[t.getCacheKey()], E = b.msaaFrameBuffer;
        s.bindFramebuffer(r.DRAW_FRAMEBUFFER, S), s.bindFramebuffer(r.READ_FRAMEBUFFER, E);
        const R = m - l - c;
        r.blitFramebuffer(a, R, a + u, R + c, a, R, a + u, R + c, y, r.NEAREST), s.bindFramebuffer(r.READ_FRAMEBUFFER, S), s.bindTexture(r.TEXTURE_2D, o), r.copyTexSubImage2D(r.TEXTURE_2D, 0, 0, 0, a, R, u, c), s.unbindTexture();
      } else {
        const b = r.createFramebuffer();
        s.bindFramebuffer(r.DRAW_FRAMEBUFFER, b), r.framebufferTexture2D(r.DRAW_FRAMEBUFFER, T, r.TEXTURE_2D, o, 0), r.blitFramebuffer(0, 0, u, c, 0, 0, u, c, y, r.NEAREST), r.deleteFramebuffer(b);
      }
    } else
      s.bindTexture(r.TEXTURE_2D, o), r.copyTexSubImage2D(r.TEXTURE_2D, 0, 0, 0, a, m - c - l, u, c), s.unbindTexture();
    e.generateMipmaps && this.generateMipmaps(e), this.backend._setFramebuffer(t);
  }
  /**
   * SetupS storage for internal depth/stencil buffers and bind to correct framebuffer.
   *
   * @param {WebGLRenderbuffer} renderbuffer - The render buffer.
   * @param {RenderContext} renderContext - The render context.
   * @param {number} samples - The MSAA sample count.
   * @param {boolean} [useMultisampledRTT=false] - Whether to use WEBGL_multisampled_render_to_texture or not.
   */
  setupRenderBufferStorage(e, t, n, r = !1) {
    const { gl: s } = this, o = t.renderTarget, { depthTexture: a, depthBuffer: l, stencilBuffer: u, width: c, height: A } = o;
    if (s.bindRenderbuffer(s.RENDERBUFFER, e), l && !u) {
      let m = s.DEPTH_COMPONENT24;
      r === !0 ? this.extensions.get("WEBGL_multisampled_render_to_texture").renderbufferStorageMultisampleEXT(s.RENDERBUFFER, o.samples, m, c, A) : n > 0 ? (a && a.isDepthTexture && a.type === s.FLOAT && (m = s.DEPTH_COMPONENT32F), s.renderbufferStorageMultisample(s.RENDERBUFFER, n, m, c, A)) : s.renderbufferStorage(s.RENDERBUFFER, m, c, A), s.framebufferRenderbuffer(s.FRAMEBUFFER, s.DEPTH_ATTACHMENT, s.RENDERBUFFER, e);
    } else l && u && (n > 0 ? s.renderbufferStorageMultisample(s.RENDERBUFFER, n, s.DEPTH24_STENCIL8, c, A) : s.renderbufferStorage(s.RENDERBUFFER, s.DEPTH_STENCIL, c, A), s.framebufferRenderbuffer(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, s.RENDERBUFFER, e));
    s.bindRenderbuffer(s.RENDERBUFFER, null);
  }
  /**
   * Returns texture data as a typed array.
   *
   * @async
   * @param {Texture} texture - The texture to copy.
   * @param {number} x - The x coordinate of the copy origin.
   * @param {number} y - The y coordinate of the copy origin.
   * @param {number} width - The width of the copy.
   * @param {number} height - The height of the copy.
   * @param {number} faceIndex - The face index.
   * @return {Promise<TypedArray>} A Promise that resolves with a typed array when the copy operation has finished.
   */
  async copyTextureToBuffer(e, t, n, r, s, o) {
    const { backend: a, gl: l } = this, { textureGPU: u, glFormat: c, glType: A } = this.backend.get(e), m = l.createFramebuffer();
    a.state.bindFramebuffer(l.READ_FRAMEBUFFER, m);
    const _ = e.isCubeTexture ? l.TEXTURE_CUBE_MAP_POSITIVE_X + o : l.TEXTURE_2D;
    l.framebufferTexture2D(l.READ_FRAMEBUFFER, l.COLOR_ATTACHMENT0, _, u, 0);
    const y = this._getTypedArrayType(A), T = this._getBytesPerTexel(A, c), S = r * s * T, E = l.createBuffer();
    l.bindBuffer(l.PIXEL_PACK_BUFFER, E), l.bufferData(l.PIXEL_PACK_BUFFER, S, l.STREAM_READ), l.readPixels(t, n, r, s, c, A, 0), l.bindBuffer(l.PIXEL_PACK_BUFFER, null), await a.utils._clientWaitAsync();
    const R = new y(S / y.BYTES_PER_ELEMENT);
    return l.bindBuffer(l.PIXEL_PACK_BUFFER, E), l.getBufferSubData(l.PIXEL_PACK_BUFFER, 0, R), l.bindBuffer(l.PIXEL_PACK_BUFFER, null), a.state.bindFramebuffer(l.READ_FRAMEBUFFER, null), l.deleteFramebuffer(m), R;
  }
  /**
   * Returns the corresponding typed array type for the given WebGL data type.
   *
   * @private
   * @param {GLenum} glType - The WebGL data type.
   * @return {TypedArray.constructor} The typed array type.
   */
  _getTypedArrayType(e) {
    const { gl: t } = this;
    if (e === t.UNSIGNED_BYTE) return Uint8Array;
    if (e === t.UNSIGNED_SHORT_4_4_4_4 || e === t.UNSIGNED_SHORT_5_5_5_1 || e === t.UNSIGNED_SHORT_5_6_5 || e === t.UNSIGNED_SHORT) return Uint16Array;
    if (e === t.UNSIGNED_INT) return Uint32Array;
    if (e === t.HALF_FLOAT) return Uint16Array;
    if (e === t.FLOAT) return Float32Array;
    throw new Error(`Unsupported WebGL type: ${e}`);
  }
  /**
   * Returns the bytes-per-texel value for the given WebGL data type and texture format.
   *
   * @private
   * @param {GLenum} glType - The WebGL data type.
   * @param {GLenum} glFormat - The WebGL texture format.
   * @return {number} The bytes-per-texel.
   */
  _getBytesPerTexel(e, t) {
    const { gl: n } = this;
    let r = 0;
    if (e === n.UNSIGNED_BYTE && (r = 1), (e === n.UNSIGNED_SHORT_4_4_4_4 || e === n.UNSIGNED_SHORT_5_5_5_1 || e === n.UNSIGNED_SHORT_5_6_5 || e === n.UNSIGNED_SHORT || e === n.HALF_FLOAT) && (r = 2), (e === n.UNSIGNED_INT || e === n.FLOAT) && (r = 4), t === n.RGBA) return r * 4;
    if (t === n.RGB) return r * 3;
    if (t === n.ALPHA) return r;
  }
  /**
   * Frees the internal resources.
   */
  dispose() {
    const { gl: e } = this;
    this._srcFramebuffer !== null && e.deleteFramebuffer(this._srcFramebuffer), this._dstFramebuffer !== null && e.deleteFramebuffer(this._dstFramebuffer);
  }
}
function Eg(i) {
  return i.isDataTexture ? i.image.data : typeof HTMLImageElement < "u" && i instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && i instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && i instanceof ImageBitmap || typeof OffscreenCanvas < "u" && i instanceof OffscreenCanvas ? i : i.data;
}
class Iae {
  /**
   * Constructs a new utility object.
   *
   * @param {WebGLBackend} backend - The WebGL 2 backend.
   */
  constructor(e) {
    this.backend = e, this.gl = this.backend.gl, this.availableExtensions = this.gl.getSupportedExtensions(), this.extensions = {};
  }
  /**
   * Returns the extension object for the given extension name.
   *
   * @param {string} name - The extension name.
   * @return {Object} The extension object.
   */
  get(e) {
    let t = this.extensions[e];
    return t === void 0 && (t = this.gl.getExtension(e), this.extensions[e] = t), t;
  }
  /**
   * Returns `true` if the requested extension is available.
   *
   * @param {string} name - The extension name.
   * @return {boolean} Whether the given extension is available or not.
   */
  has(e) {
    return this.availableExtensions.includes(e);
  }
}
class Bae {
  /**
   * Constructs a new utility object.
   *
   * @param {WebGLBackend} backend - The WebGL 2 backend.
   */
  constructor(e) {
    this.backend = e, this.maxAnisotropy = null;
  }
  /**
   * Returns the maximum anisotropy texture filtering value. This value
   * depends on the device and is reported by the `EXT_texture_filter_anisotropic`
   * WebGL extension.
   *
   * @return {number} The maximum anisotropy texture filtering value.
   */
  getMaxAnisotropy() {
    if (this.maxAnisotropy !== null) return this.maxAnisotropy;
    const e = this.backend.gl, t = this.backend.extensions;
    if (t.has("EXT_texture_filter_anisotropic") === !0) {
      const n = t.get("EXT_texture_filter_anisotropic");
      this.maxAnisotropy = e.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else
      this.maxAnisotropy = 0;
    return this.maxAnisotropy;
  }
}
const SC = {
  WEBGL_multi_draw: "WEBGL_multi_draw",
  WEBGL_compressed_texture_astc: "texture-compression-astc",
  WEBGL_compressed_texture_etc: "texture-compression-etc2",
  WEBGL_compressed_texture_etc1: "texture-compression-etc1",
  WEBGL_compressed_texture_pvrtc: "texture-compression-pvrtc",
  WEBGL_compressed_texture_s3tc: "texture-compression-s3tc",
  EXT_texture_compression_bptc: "texture-compression-bc",
  EXT_disjoint_timer_query_webgl2: "timestamp-query",
  OVR_multiview2: "OVR_multiview2"
};
class Fae {
  constructor(e) {
    this.gl = e.gl, this.extensions = e.extensions, this.info = e.renderer.info, this.mode = null, this.index = 0, this.type = null, this.object = null;
  }
  render(e, t) {
    const { gl: n, mode: r, object: s, type: o, info: a, index: l } = this;
    l !== 0 ? n.drawElements(r, t, o, e) : n.drawArrays(r, e, t), a.update(s, t, 1);
  }
  renderInstances(e, t, n) {
    const { gl: r, mode: s, type: o, index: a, object: l, info: u } = this;
    n !== 0 && (a !== 0 ? r.drawElementsInstanced(s, t, o, e, n) : r.drawArraysInstanced(s, e, t, n), u.update(l, t, n));
  }
  renderMultiDraw(e, t, n) {
    const { extensions: r, mode: s, object: o, info: a } = this;
    if (n === 0) return;
    const l = r.get("WEBGL_multi_draw");
    if (l === null)
      for (let u = 0; u < n; u++)
        this.render(e[u], t[u]);
    else {
      this.index !== 0 ? l.multiDrawElementsWEBGL(s, t, 0, this.type, e, 0, n) : l.multiDrawArraysWEBGL(s, e, 0, t, 0, n);
      let u = 0;
      for (let c = 0; c < n; c++)
        u += t[c];
      a.update(o, u, 1);
    }
  }
  renderMultiDrawInstances(e, t, n, r) {
    const { extensions: s, mode: o, object: a, info: l } = this;
    if (n === 0) return;
    const u = s.get("WEBGL_multi_draw");
    if (u === null)
      for (let c = 0; c < n; c++)
        this.renderInstances(e[c], t[c], r[c]);
    else {
      this.index !== 0 ? u.multiDrawElementsInstancedWEBGL(o, t, 0, this.type, e, 0, r, 0, n) : u.multiDrawArraysInstancedWEBGL(o, e, 0, t, 0, r, 0, n);
      let c = 0;
      for (let A = 0; A < n; A++)
        c += t[A] * r[A];
      l.update(a, c, 1);
    }
  }
  //
}
class LI {
  /**
   * Creates a new timestamp query pool.
   *
   * @param {number} [maxQueries=256] - Maximum number of queries this pool can hold.
   */
  constructor(e = 256) {
    this.trackTimestamp = !0, this.maxQueries = e, this.currentQueryIndex = 0, this.queryOffsets = /* @__PURE__ */ new Map(), this.isDisposed = !1, this.lastValue = 0, this.frames = [], this.pendingResolve = !1, this.timestamps = /* @__PURE__ */ new Map();
  }
  /**
   * Returns all timestamp frames.
   *
   * @return {Array<number>} The timestamp frames.
   */
  getTimestampFrames() {
    return this.frames;
  }
  /**
   * Returns the timestamp for a given render context.
   *
   * @param {string} uid - A unique identifier for the render context.
   * @return {?number} The timestamp, or undefined if not available.
   */
  getTimestamp(e) {
    let t = this.timestamps.get(e);
    return t === void 0 && (Me(`TimestampQueryPool: No timestamp available for uid ${e}.`), t = 0), t;
  }
  /**
   * Returns whether a timestamp is available for a given render context.
   *
   * @param {string} uid - A unique identifier for the render context.
   * @return {boolean} True if a timestamp is available, false otherwise.
   */
  hasTimestamp(e) {
    return this.timestamps.has(e);
  }
  /**
   * Allocate queries for a specific uid.
   *
   * @abstract
   * @param {string} uid - A unique identifier for the render context.
   * @param {number} frameId - The current frame identifier.
   * @returns {?number}
   */
  allocateQueriesForContext() {
  }
  /**
   * Resolve all timestamps and return data (or process them).
   *
   * @abstract
   * @async
   * @returns {Promise<number>|number} The resolved timestamp value.
   */
  async resolveQueriesAsync() {
  }
  /**
   * Dispose of the query pool.
   *
   * @abstract
   */
  dispose() {
  }
}
class Uae extends LI {
  /**
   * Creates a new WebGL timestamp query pool.
   *
   * @param {WebGLRenderingContext|WebGL2RenderingContext} gl - The WebGL context.
   * @param {string} type - The type identifier for this query pool.
   * @param {number} [maxQueries=2048] - Maximum number of queries this pool can hold.
   */
  constructor(e, t, n = 2048) {
    if (super(n), this.gl = e, this.type = t, this.ext = e.getExtension("EXT_disjoint_timer_query_webgl2") || e.getExtension("EXT_disjoint_timer_query"), !this.ext) {
      Me("EXT_disjoint_timer_query not supported; timestamps will be disabled."), this.trackTimestamp = !1;
      return;
    }
    this.queries = [];
    for (let r = 0; r < this.maxQueries; r++)
      this.queries.push(e.createQuery());
    this.activeQuery = null, this.queryStates = /* @__PURE__ */ new Map();
  }
  /**
   * Allocates a pair of queries for a given render context.
   *
   * @param {string} uid - A unique identifier for the render context.
   * @returns {?number} The base offset for the allocated queries, or null if allocation failed.
   */
  allocateQueriesForContext(e) {
    if (!this.trackTimestamp) return null;
    if (this.currentQueryIndex + 2 > this.maxQueries)
      return li(`WebGPUTimestampQueryPool [${this.type}]: Maximum number of queries exceeded, when using trackTimestamp it is necessary to resolves the queries via renderer.resolveTimestampsAsync( THREE.TimestampQuery.${this.type.toUpperCase()} ).`), null;
    const t = this.currentQueryIndex;
    return this.currentQueryIndex += 2, this.queryStates.set(t, "inactive"), this.queryOffsets.set(e, t), t;
  }
  /**
   * Begins a timestamp query for the specified render context.
   *
   * @param {string} uid - A unique identifier for the render context.
   */
  beginQuery(e) {
    if (!this.trackTimestamp || this.isDisposed)
      return;
    const t = this.queryOffsets.get(e);
    if (t == null || this.activeQuery !== null)
      return;
    const n = this.queries[t];
    if (n)
      try {
        this.queryStates.get(t) === "inactive" && (this.gl.beginQuery(this.ext.TIME_ELAPSED_EXT, n), this.activeQuery = t, this.queryStates.set(t, "started"));
      } catch (r) {
        Ie("Error in beginQuery:", r), this.activeQuery = null, this.queryStates.set(t, "inactive");
      }
  }
  /**
   * Ends the active timestamp query for the specified render context.
   *
   * @param {string} uid - A unique identifier for the render context.
   */
  endQuery(e) {
    if (!this.trackTimestamp || this.isDisposed)
      return;
    const t = this.queryOffsets.get(e);
    if (t != null && this.activeQuery === t)
      try {
        this.gl.endQuery(this.ext.TIME_ELAPSED_EXT), this.queryStates.set(t, "ended"), this.activeQuery = null;
      } catch (n) {
        Ie("Error in endQuery:", n), this.queryStates.set(t, "inactive"), this.activeQuery = null;
      }
  }
  /**
   * Asynchronously resolves all completed queries and returns the total duration.
   *
   * @async
   * @returns {Promise<number>} The total duration in milliseconds, or the last valid value if resolution fails.
   */
  async resolveQueriesAsync() {
    if (!this.trackTimestamp || this.pendingResolve)
      return this.lastValue;
    this.pendingResolve = !0;
    try {
      const e = /* @__PURE__ */ new Map();
      for (const [s, o] of this.queryOffsets)
        if (this.queryStates.get(o) === "ended") {
          const l = this.queries[o];
          e.set(s, this.resolveQuery(l));
        }
      if (e.size === 0)
        return this.lastValue;
      const t = {}, n = [];
      for (const [s, o] of e) {
        const a = s.match(/^(.*):f(\d+)$/), l = parseInt(a[2]);
        n.includes(l) === !1 && n.push(l), t[l] === void 0 && (t[l] = 0);
        const u = await o;
        this.timestamps.set(s, u), t[l] += u;
      }
      const r = t[n[n.length - 1]];
      return this.lastValue = r, this.frames = n, this.currentQueryIndex = 0, this.queryOffsets.clear(), this.queryStates.clear(), this.activeQuery = null, r;
    } catch (e) {
      return Ie("Error resolving queries:", e), this.lastValue;
    } finally {
      this.pendingResolve = !1;
    }
  }
  /**
   * Resolves a single query, checking for completion and disjoint operation.
   *
   * @async
   * @param {WebGLQuery} query - The query object to resolve.
   * @returns {Promise<number>} The elapsed time in milliseconds.
   */
  async resolveQuery(e) {
    return new Promise((t) => {
      if (this.isDisposed) {
        t(this.lastValue);
        return;
      }
      let n, r = !1;
      const s = () => {
        n && (clearTimeout(n), n = null);
      }, o = (l) => {
        r || (r = !0, s(), t(l));
      }, a = () => {
        if (this.isDisposed) {
          o(this.lastValue);
          return;
        }
        try {
          if (this.gl.getParameter(this.ext.GPU_DISJOINT_EXT)) {
            o(this.lastValue);
            return;
          }
          if (!this.gl.getQueryParameter(e, this.gl.QUERY_RESULT_AVAILABLE)) {
            n = setTimeout(a, 1);
            return;
          }
          const c = this.gl.getQueryParameter(e, this.gl.QUERY_RESULT);
          t(Number(c) / 1e6);
        } catch (l) {
          Ie("Error checking query:", l), t(this.lastValue);
        }
      };
      a();
    });
  }
  /**
   * Releases all resources held by this query pool.
   * This includes deleting all query objects and clearing internal state.
   */
  dispose() {
    if (!this.isDisposed && (this.isDisposed = !0, !!this.trackTimestamp)) {
      for (const e of this.queries)
        this.gl.deleteQuery(e);
      this.queries = [], this.queryStates.clear(), this.queryOffsets.clear(), this.lastValue = 0, this.activeQuery = null;
    }
  }
}
class TC extends DI {
  /**
   * WebGLBackend options.
   *
   * @typedef {Object} WebGLBackend~Options
   * @property {boolean} [logarithmicDepthBuffer=false] - Whether logarithmic depth buffer is enabled or not.
   * @property {boolean} [alpha=true] - Whether the default framebuffer (which represents the final contents of the canvas) should be transparent or opaque.
   * @property {boolean} [depth=true] - Whether the default framebuffer should have a depth buffer or not.
   * @property {boolean} [stencil=false] - Whether the default framebuffer should have a stencil buffer or not.
   * @property {boolean} [antialias=false] - Whether MSAA as the default anti-aliasing should be enabled or not.
   * @property {number} [samples=0] - When `antialias` is `true`, `4` samples are used by default. Set this parameter to any other integer value than 0 to overwrite the default.
   * @property {boolean} [forceWebGL=false] - If set to `true`, the renderer uses a WebGL 2 backend no matter if WebGPU is supported or not.
   * @property {WebGL2RenderingContext} [context=undefined] - A WebGL 2 rendering context.
   */
  /**
   * Constructs a new WebGPU backend.
   *
   * @param {WebGLBackend~Options} [parameters] - The configuration parameter.
   */
  constructor(e = {}) {
    super(e), this.isWebGLBackend = !0, this.attributeUtils = null, this.extensions = null, this.capabilities = null, this.textureUtils = null, this.bufferRenderer = null, this.gl = null, this.state = null, this.utils = null, this.vaoCache = {}, this.transformFeedbackCache = {}, this.discard = !1, this.disjoint = null, this.parallel = null, this._currentContext = null, this._knownBindings = /* @__PURE__ */ new WeakSet(), this._supportsInvalidateFramebuffer = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent), this._xrFramebuffer = null;
  }
  /**
   * Initializes the backend so it is ready for usage.
   *
   * @param {Renderer} renderer - The renderer.
   */
  init(e) {
    super.init(e);
    const t = this.parameters, n = {
      antialias: e.currentSamples > 0,
      alpha: !0,
      // always true for performance reasons
      depth: e.depth,
      stencil: e.stencil
    }, r = t.context !== void 0 ? t.context : e.domElement.getContext("webgl2", n);
    function s(o) {
      o.preventDefault();
      const a = {
        api: "WebGL",
        message: o.statusMessage || "Unknown reason",
        reason: null,
        originalEvent: o
      };
      e.onDeviceLost(a);
    }
    this._onContextLost = s, e.domElement.addEventListener("webglcontextlost", s, !1), this.gl = r, this.extensions = new Iae(this), this.capabilities = new Bae(this), this.attributeUtils = new Pae(this), this.textureUtils = new Lae(this), this.bufferRenderer = new Fae(this), this.state = new Nae(this), this.utils = new Dae(this), this.extensions.get("EXT_color_buffer_float"), this.extensions.get("WEBGL_clip_cull_distance"), this.extensions.get("OES_texture_float_linear"), this.extensions.get("EXT_color_buffer_half_float"), this.extensions.get("WEBGL_multisampled_render_to_texture"), this.extensions.get("WEBGL_render_shared_exponent"), this.extensions.get("WEBGL_multi_draw"), this.extensions.get("OVR_multiview2"), this.disjoint = this.extensions.get("EXT_disjoint_timer_query_webgl2"), this.parallel = this.extensions.get("KHR_parallel_shader_compile"), this.drawBuffersIndexedExt = this.extensions.get("OES_draw_buffers_indexed");
  }
  /**
   * The coordinate system of the backend.
   *
   * @type {number}
   * @readonly
   */
  get coordinateSystem() {
    return jr;
  }
  /**
   * This method performs a readback operation by moving buffer data from
   * a storage buffer attribute from the GPU to the CPU.
   *
   * @async
   * @param {StorageBufferAttribute} attribute - The storage buffer attribute.
   * @return {Promise<ArrayBuffer>} A promise that resolves with the buffer data when the data are ready.
   */
  async getArrayBufferAsync(e) {
    return await this.attributeUtils.getArrayBufferAsync(e);
  }
  /**
   * Ensures the backend is XR compatible.
   *
   * @async
   * @return {Promise} A Promise that resolve when the renderer is XR compatible.
   */
  async makeXRCompatible() {
    this.gl.getContextAttributes().xrCompatible !== !0 && await this.gl.makeXRCompatible();
  }
  /**
   * Sets the XR rendering destination.
   *
   * @param {WebGLFramebuffer} xrFramebuffer - The XR framebuffer.
   */
  setXRTarget(e) {
    this._xrFramebuffer = e;
  }
  /**
   * Configures the given XR render target with external textures.
   *
   * This method is only relevant when using the WebXR Layers API.
   *
   * @param {XRRenderTarget} renderTarget - The XR render target.
   * @param {WebGLTexture} colorTexture - A native color texture.
   * @param {?WebGLTexture} [depthTexture=null] - A native depth texture.
   */
  setXRRenderTargetTextures(e, t, n = null) {
    const r = this.gl;
    if (this.set(e.texture, { textureGPU: t, glInternalFormat: r.RGBA8 }), n !== null) {
      const s = e.stencilBuffer ? r.DEPTH24_STENCIL8 : r.DEPTH_COMPONENT24;
      this.set(e.depthTexture, { textureGPU: n, glInternalFormat: s }), this.extensions.has("WEBGL_multisampled_render_to_texture") === !0 && e._autoAllocateDepthBuffer === !0 && e.multiview === !1 && Me("WebGLBackend: Render-to-texture extension was disabled because an external texture was provided"), e._autoAllocateDepthBuffer = !1;
    }
  }
  /**
   * Inits a time stamp query for the given render context.
   *
   * @param {string} type - The type of the timestamp query.
   * @param {string} uid - A unique identifier for the timestamp query.
   */
  initTimestampQuery(e, t) {
    if (!this.disjoint || !this.trackTimestamp) return;
    this.timestampQueryPool[e] || (this.timestampQueryPool[e] = new Uae(this.gl, e, 2048));
    const n = this.timestampQueryPool[e];
    n.allocateQueriesForContext(t) !== null && n.beginQuery(t);
  }
  // timestamp utils
  /**
   * Prepares the timestamp buffer.
   *
   * @param {string} type - The type of the timestamp query.
   * @param {string} uid - A unique identifier for the timestamp query.
   */
  prepareTimestampBuffer(e, t) {
    if (!this.disjoint || !this.trackTimestamp) return;
    this.timestampQueryPool[e].endQuery(t);
  }
  /**
   * Returns the backend's rendering context.
   *
   * @return {WebGL2RenderingContext} The rendering context.
   */
  getContext() {
    return this.gl;
  }
  /**
   * This method is executed at the beginning of a render call and prepares
   * the WebGL state for upcoming render calls
   *
   * @param {RenderContext} renderContext - The render context.
   */
  beginRender(e) {
    const { state: t } = this, n = this.get(e);
    if (e.viewport)
      this.updateViewport(e);
    else {
      const { width: s, height: o } = this.getDrawingBufferSize();
      t.viewport(0, 0, s, o);
    }
    if (e.scissor) {
      const { x: s, y: o, width: a, height: l } = e.scissorValue;
      t.scissor(s, e.height - l - o, a, l);
    }
    this.initTimestampQuery(pa.RENDER, this.getTimestampUID(e)), n.previousContext = this._currentContext, this._currentContext = e, this._setFramebuffer(e), this.clear(e.clearColor, e.clearDepth, e.clearStencil, e, !1);
    const r = e.occlusionQueryCount;
    r > 0 && (n.currentOcclusionQueries = n.occlusionQueries, n.currentOcclusionQueryObjects = n.occlusionQueryObjects, n.lastOcclusionObject = null, n.occlusionQueries = new Array(r), n.occlusionQueryObjects = new Array(r), n.occlusionQueryIndex = 0);
  }
  /**
   * This method is executed at the end of a render call and finalizes work
   * after draw calls.
   *
   * @param {RenderContext} renderContext - The render context.
   */
  finishRender(e) {
    const { gl: t, state: n } = this, r = this.get(e), s = r.previousContext;
    n.resetVertexState();
    const o = e.occlusionQueryCount;
    o > 0 && (o > r.occlusionQueryIndex && t.endQuery(t.ANY_SAMPLES_PASSED), this.resolveOccludedAsync(e));
    const a = e.textures;
    if (a !== null)
      for (let l = 0; l < a.length; l++) {
        const u = a[l];
        u.generateMipmaps && this.generateMipmaps(u);
      }
    if (this._currentContext = s, this._resolveRenderTarget(e), s !== null)
      if (this._setFramebuffer(s), s.viewport)
        this.updateViewport(s);
      else {
        const { width: l, height: u } = this.getDrawingBufferSize();
        n.viewport(0, 0, l, u);
      }
    this.prepareTimestampBuffer(pa.RENDER, this.getTimestampUID(e));
  }
  /**
   * This method processes the result of occlusion queries and writes it
   * into render context data.
   *
   * @async
   * @param {RenderContext} renderContext - The render context.
   */
  resolveOccludedAsync(e) {
    const t = this.get(e), { currentOcclusionQueries: n, currentOcclusionQueryObjects: r } = t;
    if (n && r) {
      const s = /* @__PURE__ */ new WeakSet(), { gl: o } = this;
      t.currentOcclusionQueryObjects = null, t.currentOcclusionQueries = null;
      const a = () => {
        let l = 0;
        for (let u = 0; u < n.length; u++) {
          const c = n[u];
          c !== null && o.getQueryParameter(c, o.QUERY_RESULT_AVAILABLE) && (o.getQueryParameter(c, o.QUERY_RESULT) === 0 && s.add(r[u]), n[u] = null, o.deleteQuery(c), l++);
        }
        l < n.length ? requestAnimationFrame(a) : t.occluded = s;
      };
      a();
    }
  }
  /**
   * Returns `true` if the given 3D object is fully occluded by other
   * 3D objects in the scene.
   *
   * @param {RenderContext} renderContext - The render context.
   * @param {Object3D} object - The 3D object to test.
   * @return {boolean} Whether the 3D object is fully occluded or not.
   */
  isOccluded(e, t) {
    const n = this.get(e);
    return n.occluded && n.occluded.has(t);
  }
  /**
   * Updates the viewport with the values from the given render context.
   *
   * @param {RenderContext} renderContext - The render context.
   */
  updateViewport(e) {
    const { state: t } = this, { x: n, y: r, width: s, height: o } = e.viewportValue;
    t.viewport(n, e.height - o - r, s, o);
  }
  /**
   * Defines the scissor test.
   *
   * @param {boolean} boolean - Whether the scissor test should be enabled or not.
   */
  setScissorTest(e) {
    this.state.setScissorTest(e);
  }
  /**
   * Returns the clear color and alpha into a single
   * color object.
   *
   * @return {Color4} The clear color.
   */
  getClearColor() {
    const e = super.getClearColor();
    return e.r *= e.a, e.g *= e.a, e.b *= e.a, e;
  }
  /**
   * Performs a clear operation.
   *
   * @param {boolean} color - Whether the color buffer should be cleared or not.
   * @param {boolean} depth - Whether the depth buffer should be cleared or not.
   * @param {boolean} stencil - Whether the stencil buffer should be cleared or not.
   * @param {?Object} [descriptor=null] - The render context of the current set render target.
   * @param {boolean} [setFrameBuffer=true] - Controls whether the intermediate framebuffer should be set or not.
   * @param {boolean} [resolveRenderTarget=true] - Controls whether an active render target should be resolved
   * or not. Only relevant for explicit clears.
   */
  clear(e, t, n, r = null, s = !0, o = !0) {
    const { gl: a, renderer: l } = this;
    r === null && (r = {
      textures: null,
      clearColorValue: this.getClearColor()
    });
    let u = 0;
    if (e && (u |= a.COLOR_BUFFER_BIT), t && (u |= a.DEPTH_BUFFER_BIT), n && (u |= a.STENCIL_BUFFER_BIT), u !== 0) {
      let c;
      r.clearColorValue ? c = r.clearColorValue : c = this.getClearColor();
      const A = l.getClearDepth(), m = l.getClearStencil();
      if (t && this.state.setDepthMask(!0), r.textures === null)
        a.clearColor(c.r, c.g, c.b, c.a), a.clear(u);
      else {
        if (s && this._setFramebuffer(r), e)
          for (let _ = 0; _ < r.textures.length; _++)
            _ === 0 ? a.clearBufferfv(a.COLOR, _, [c.r, c.g, c.b, c.a]) : a.clearBufferfv(a.COLOR, _, [0, 0, 0, 1]);
        t && n ? a.clearBufferfi(a.DEPTH_STENCIL, 0, A, m) : t ? a.clearBufferfv(a.DEPTH, 0, [A]) : n && a.clearBufferiv(a.STENCIL, 0, [m]), s && o && this._resolveRenderTarget(r);
      }
    }
  }
  /**
   * This method is executed at the beginning of a compute call and
   * prepares the state for upcoming compute tasks.
   *
   * @param {Node|Array<Node>} computeGroup - The compute node(s).
   */
  beginCompute(e) {
    const { state: t, gl: n } = this;
    t.bindFramebuffer(n.FRAMEBUFFER, null), this.initTimestampQuery(pa.COMPUTE, this.getTimestampUID(e));
  }
  /**
   * Executes a compute command for the given compute node.
   *
   * @param {Node|Array<Node>} computeGroup - The group of compute nodes of a compute call. Can be a single compute node.
   * @param {Node} computeNode - The compute node.
   * @param {Array<BindGroup>} bindings - The bindings.
   * @param {ComputePipeline} pipeline - The compute pipeline.
   * @param {?number} [count=null] - The count of compute invocations. If `null`, the count is determined by the compute node.
   */
  compute(e, t, n, r, s = null) {
    const { state: o, gl: a } = this;
    this.discard === !1 && (o.enable(a.RASTERIZER_DISCARD), this.discard = !0);
    const { programGPU: l, transformBuffers: u, attributes: c } = this.get(r), A = this._getVaoKey(c), m = this.vaoCache[A];
    m === void 0 ? this.vaoCache[A] = this._createVao(c) : o.setVertexState(m), o.useProgram(l), this._bindUniforms(n);
    const _ = this._getTransformFeedback(u);
    a.bindTransformFeedback(a.TRANSFORM_FEEDBACK, _), a.beginTransformFeedback(a.POINTS), s = s !== null ? s : t.count, Array.isArray(s) ? (li("WebGLBackend.compute(): The count parameter must be a single number, not an array."), s = s[0]) : s && typeof s == "object" && s.isIndirectStorageBufferAttribute && (li("WebGLBackend.compute(): The count parameter must be a single number, not IndirectStorageBufferAttribute"), s = t.count), c[0].isStorageInstancedBufferAttribute ? a.drawArraysInstanced(a.POINTS, 0, 1, s) : a.drawArrays(a.POINTS, 0, s), a.endTransformFeedback(), a.bindTransformFeedback(a.TRANSFORM_FEEDBACK, null);
    for (let y = 0; y < u.length; y++) {
      const T = u[y];
      T.pbo && this.has(T.pbo) && this.textureUtils.copyBufferToTexture(T.transformBuffer, T.pbo), T.switchBuffers();
    }
  }
  /**
   * This method is executed at the end of a compute call and
   * finalizes work after compute tasks.
   *
   * @param {Node|Array<Node>} computeGroup - The compute node(s).
   */
  finishCompute(e) {
    const { state: t, gl: n } = this;
    this.discard = !1, t.disable(n.RASTERIZER_DISCARD), this.prepareTimestampBuffer(pa.COMPUTE, this.getTimestampUID(e)), this._currentContext && this._setFramebuffer(this._currentContext);
  }
  /**
   * Internal to determine if the current render target is a render target array with depth 2D array texture.
   *
   * @param {RenderContext} renderContext - The render context.
   * @return {boolean} Whether the render target is a render target array with depth 2D array texture.
   *
   * @private
   */
  _isRenderCameraDepthArray(e) {
    return e.depthTexture && e.depthTexture.isArrayTexture && e.camera.isArrayCamera;
  }
  /**
   * Executes a draw command for the given render object.
   *
   * @param {RenderObject} renderObject - The render object to draw.
   * @param {Info} info - Holds a series of statistical information about the GPU memory and the rendering process.
   */
  draw(e) {
    const { object: t, pipeline: n, material: r, context: s, hardwareClippingPlanes: o } = e, { programGPU: a } = this.get(n), { gl: l, state: u } = this, c = this.get(s), A = e.getDrawParameters();
    if (A === null) return;
    this._bindUniforms(e.getBindings());
    const m = t.isMesh && t.matrixWorld.determinant() < 0;
    u.setMaterial(r, m, o), s.textures !== null && s.textures.length > 1 && u.setMRTBlending(s.textures), u.useProgram(a);
    const _ = e.getAttributes(), y = this.get(_);
    let T = y.vaoGPU;
    if (T === void 0) {
      const U = this._getVaoKey(_);
      T = this.vaoCache[U], T === void 0 && (T = this._createVao(_), this.vaoCache[U] = T, y.vaoGPU = T);
    }
    const b = e.getIndex(), S = b !== null ? this.get(b).bufferGPU : null;
    u.setVertexState(T, S);
    const E = c.lastOcclusionObject;
    if (E !== t && E !== void 0) {
      if (E !== null && E.occlusionTest === !0 && (l.endQuery(l.ANY_SAMPLES_PASSED), c.occlusionQueryIndex++), t.occlusionTest === !0) {
        const U = l.createQuery();
        l.beginQuery(l.ANY_SAMPLES_PASSED, U), c.occlusionQueries[c.occlusionQueryIndex] = U, c.occlusionQueryObjects[c.occlusionQueryIndex] = t;
      }
      c.lastOcclusionObject = t;
    }
    const R = this.bufferRenderer;
    t.isPoints ? R.mode = l.POINTS : t.isLineSegments ? R.mode = l.LINES : t.isLine ? R.mode = l.LINE_STRIP : t.isLineLoop ? R.mode = l.LINE_LOOP : r.wireframe === !0 ? (u.setLineWidth(r.wireframeLinewidth * this.renderer.getPixelRatio()), R.mode = l.LINES) : R.mode = l.TRIANGLES;
    const { vertexCount: C, instanceCount: L } = A;
    let { firstVertex: D } = A;
    if (R.object = t, b !== null) {
      D *= b.array.BYTES_PER_ELEMENT;
      const U = this.get(b);
      R.index = b.count, R.type = U.type;
    } else
      R.index = 0;
    const B = () => {
      t.isBatchedMesh ? t._multiDrawInstances !== null ? (li("WebGLBackend: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection."), R.renderMultiDrawInstances(t._multiDrawStarts, t._multiDrawCounts, t._multiDrawCount, t._multiDrawInstances)) : this.hasFeature("WEBGL_multi_draw") ? R.renderMultiDraw(t._multiDrawStarts, t._multiDrawCounts, t._multiDrawCount) : li("WebGLBackend: WEBGL_multi_draw not supported.") : L > 1 ? R.renderInstances(D, C, L) : R.render(D, C);
    };
    if (e.camera.isArrayCamera === !0 && e.camera.cameras.length > 0 && e.camera.isMultiViewCamera === !1) {
      const U = this.get(e.camera), N = e.camera.cameras, O = e.getBindingGroup("cameraIndex").bindings[0];
      if (U.indexesGPU === void 0 || U.indexesGPU.length !== N.length) {
        const ee = new Uint32Array([0, 0, 0, 0]), oe = [];
        for (let fe = 0, _e = N.length; fe < _e; fe++) {
          const Te = l.createBuffer();
          ee[0] = fe, l.bindBuffer(l.UNIFORM_BUFFER, Te), l.bufferData(l.UNIFORM_BUFFER, ee, l.STATIC_DRAW), oe.push(Te);
        }
        U.indexesGPU = oe;
      }
      const G = this.get(O), H = this.renderer.getPixelRatio(), Y = this._currentContext.renderTarget, K = this._isRenderCameraDepthArray(this._currentContext), X = this._currentContext.activeCubeFace;
      if (K) {
        const ee = this.get(Y.depthTexture);
        if (ee.clearedRenderId !== this.renderer._nodes.nodeFrame.renderId) {
          ee.clearedRenderId = this.renderer._nodes.nodeFrame.renderId;
          const { stencilBuffer: oe } = Y;
          for (let fe = 0, _e = N.length; fe < _e; fe++)
            this.renderer._activeCubeFace = fe, this._currentContext.activeCubeFace = fe, this._setFramebuffer(this._currentContext), this.clear(!1, !0, oe, this._currentContext, !1, !1);
          this.renderer._activeCubeFace = X, this._currentContext.activeCubeFace = X;
        }
      }
      for (let ee = 0, oe = N.length; ee < oe; ee++) {
        const fe = N[ee];
        if (t.layers.test(fe.layers)) {
          K && (this.renderer._activeCubeFace = ee, this._currentContext.activeCubeFace = ee, this._setFramebuffer(this._currentContext));
          const _e = fe.viewport;
          if (_e !== void 0) {
            const Te = _e.x * H, Ce = _e.y * H, Je = _e.width * H, Qe = _e.height * H;
            u.viewport(
              Math.floor(Te),
              Math.floor(e.context.height - Qe - Ce),
              Math.floor(Je),
              Math.floor(Qe)
            );
          }
          u.bindBufferBase(l.UNIFORM_BUFFER, G.index, U.indexesGPU[ee]), B();
        }
        this._currentContext.activeCubeFace = X, this.renderer._activeCubeFace = X;
      }
    } else
      B();
  }
  /**
   * Explain why always null is returned.
   *
   * @param {RenderObject} renderObject - The render object.
   * @return {boolean} Whether the render pipeline requires an update or not.
   */
  needsRenderUpdate() {
    return !1;
  }
  /**
   * Explain why no cache key is computed.
   *
   * @param {RenderObject} renderObject - The render object.
   * @return {string} The cache key.
   */
  getRenderCacheKey() {
    return "";
  }
  // textures
  /**
   * Creates a default texture for the given texture that can be used
   * as a placeholder until the actual texture is ready for usage.
   *
   * @param {Texture} texture - The texture to create a default texture for.
   */
  createDefaultTexture(e) {
    this.textureUtils.createDefaultTexture(e);
  }
  /**
   * Defines a texture on the GPU for the given texture object.
   *
   * @param {Texture} texture - The texture.
   * @param {Object} [options={}] - Optional configuration parameter.
   */
  createTexture(e, t) {
    this.textureUtils.createTexture(e, t);
  }
  /**
   * Uploads the updated texture data to the GPU.
   *
   * @param {Texture} texture - The texture.
   * @param {Object} [options={}] - Optional configuration parameter.
   */
  updateTexture(e, t) {
    this.textureUtils.updateTexture(e, t);
  }
  /**
   * Generates mipmaps for the given texture.
   *
   * @param {Texture} texture - The texture.
   */
  generateMipmaps(e) {
    this.textureUtils.generateMipmaps(e);
  }
  /**
   * Destroys the GPU data for the given texture object.
   *
   * @param {Texture} texture - The texture.
   * @param {boolean} [isDefaultTexture=false] - Whether the texture uses a default GPU texture or not.
   */
  destroyTexture(e, t = !1) {
    this.textureUtils.destroyTexture(e, t);
  }
  /**
   * Returns texture data as a typed array.
   *
   * @async
   * @param {Texture} texture - The texture to copy.
   * @param {number} x - The x coordinate of the copy origin.
   * @param {number} y - The y coordinate of the copy origin.
   * @param {number} width - The width of the copy.
   * @param {number} height - The height of the copy.
   * @param {number} faceIndex - The face index.
   * @return {Promise<TypedArray>} A Promise that resolves with a typed array when the copy operation has finished.
   */
  async copyTextureToBuffer(e, t, n, r, s, o) {
    return this.textureUtils.copyTextureToBuffer(e, t, n, r, s, o);
  }
  /**
   * This method does nothing since WebGL 2 has no concept of samplers.
   *
   * @param {Texture} texture - The texture to update the sampler for.
   * @return {string} The current sampler key.
   */
  updateSampler() {
    return "";
  }
  // node builder
  /**
   * Returns a node builder for the given render object.
   *
   * @param {RenderObject} object - The render object.
   * @param {Renderer} renderer - The renderer.
   * @return {GLSLNodeBuilder} The node builder.
   */
  createNodeBuilder(e, t) {
    return new Eae(e, t);
  }
  // program
  /**
   * Creates a shader program from the given programmable stage.
   *
   * @param {ProgrammableStage} program - The programmable stage.
   */
  createProgram(e) {
    const t = this.gl, { stage: n, code: r } = e, s = n === "fragment" ? t.createShader(t.FRAGMENT_SHADER) : t.createShader(t.VERTEX_SHADER);
    t.shaderSource(s, r), t.compileShader(s), this.set(e, {
      shaderGPU: s
    });
  }
  /**
   * Destroys the shader program of the given programmable stage.
   *
   * @param {ProgrammableStage} program - The programmable stage.
   */
  destroyProgram(e) {
    this.delete(e);
  }
  /**
   * Creates a render pipeline for the given render object.
   *
   * @param {RenderObject} renderObject - The render object.
   * @param {Array<Promise>} promises - An array of compilation promises which are used in `compileAsync()`.
   */
  createRenderPipeline(e, t) {
    const n = this.gl, r = e.pipeline, { fragmentProgram: s, vertexProgram: o } = r, a = n.createProgram(), l = this.get(s).shaderGPU, u = this.get(o).shaderGPU;
    if (n.attachShader(a, l), n.attachShader(a, u), n.linkProgram(a), this.set(r, {
      programGPU: a,
      fragmentShader: l,
      vertexShader: u
    }), t !== null && this.parallel) {
      const c = new Promise((A) => {
        const m = this.parallel, _ = () => {
          n.getProgramParameter(a, m.COMPLETION_STATUS_KHR) ? (this._completeCompile(e, r), A()) : requestAnimationFrame(_);
        };
        _();
      });
      t.push(c);
      return;
    }
    this._completeCompile(e, r);
  }
  /**
   * Formats the source code of error messages.
   *
   * @private
   * @param {string} string - The code.
   * @param {number} errorLine - The error line.
   * @return {string} The formatted code.
   */
  _handleSource(e, t) {
    const n = e.split(`
`), r = [], s = Math.max(t - 6, 0), o = Math.min(t + 6, n.length);
    for (let a = s; a < o; a++) {
      const l = a + 1;
      r.push(`${l === t ? ">" : " "} ${l}: ${n[a]}`);
    }
    return r.join(`
`);
  }
  /**
   * Gets the shader compilation errors from the info log.
   *
   * @private
   * @param {WebGL2RenderingContext} gl - The rendering context.
   * @param {WebGLShader} shader - The WebGL shader object.
   * @param {string} type - The shader type.
   * @return {string} The shader errors.
   */
  _getShaderErrors(e, t, n) {
    const r = e.getShaderParameter(t, e.COMPILE_STATUS), o = (e.getShaderInfoLog(t) || "").trim();
    if (r && o === "") return "";
    const a = /ERROR: 0:(\d+)/.exec(o);
    if (a) {
      const l = parseInt(a[1]);
      return n.toUpperCase() + `

` + o + `

` + this._handleSource(e.getShaderSource(t), l);
    } else
      return o;
  }
  /**
   * Logs shader compilation errors.
   *
   * @private
   * @param {WebGLProgram} programGPU - The WebGL program.
   * @param {WebGLShader} glFragmentShader - The fragment shader as a native WebGL shader object.
   * @param {WebGLShader} glVertexShader - The vertex shader as a native WebGL shader object.
   */
  _logProgramError(e, t, n) {
    if (this.renderer.debug.checkShaderErrors) {
      const r = this.gl, o = (r.getProgramInfoLog(e) || "").trim();
      if (r.getProgramParameter(e, r.LINK_STATUS) === !1)
        if (typeof this.renderer.debug.onShaderError == "function")
          this.renderer.debug.onShaderError(r, e, n, t);
        else {
          const a = this._getShaderErrors(r, n, "vertex"), l = this._getShaderErrors(r, t, "fragment");
          Ie(
            "THREE.WebGLProgram: Shader Error " + r.getError() + " - VALIDATE_STATUS " + r.getProgramParameter(e, r.VALIDATE_STATUS) + `

Program Info Log: ` + o + `
` + a + `
` + l
          );
        }
      else o !== "" && Me("WebGLProgram: Program Info Log:", o);
    }
  }
  /**
   * Completes the shader program setup for the given render object.
   *
   * @private
   * @param {RenderObject} renderObject - The render object.
   * @param {RenderPipeline} pipeline - The render pipeline.
   */
  _completeCompile(e, t) {
    const { state: n, gl: r } = this, s = this.get(t), { programGPU: o, fragmentShader: a, vertexShader: l } = s;
    r.getProgramParameter(o, r.LINK_STATUS) === !1 && this._logProgramError(o, a, l), n.useProgram(o);
    const u = e.getBindings();
    this._setupBindings(u, o), this.set(t, {
      programGPU: o
    });
  }
  /**
   * Creates a compute pipeline for the given compute node.
   *
   * @param {ComputePipeline} computePipeline - The compute pipeline.
   * @param {Array<BindGroup>} bindings - The bindings.
   */
  createComputePipeline(e, t) {
    const { state: n, gl: r } = this, s = {
      stage: "fragment",
      code: `#version 300 es
precision highp float;
void main() {}`
    };
    this.createProgram(s);
    const { computeProgram: o } = e, a = r.createProgram(), l = this.get(s).shaderGPU, u = this.get(o).shaderGPU, c = o.transforms, A = [], m = [];
    for (let b = 0; b < c.length; b++) {
      const S = c[b];
      A.push(S.varyingName), m.push(S.attributeNode);
    }
    r.attachShader(a, l), r.attachShader(a, u), r.transformFeedbackVaryings(
      a,
      A,
      r.SEPARATE_ATTRIBS
    ), r.linkProgram(a), r.getProgramParameter(a, r.LINK_STATUS) === !1 && this._logProgramError(a, l, u), n.useProgram(a), this._setupBindings(t, a);
    const _ = o.attributes, y = [], T = [];
    for (let b = 0; b < _.length; b++) {
      const S = _[b].node.attribute;
      y.push(S), this.has(S) || this.attributeUtils.createAttribute(S, r.ARRAY_BUFFER);
    }
    for (let b = 0; b < m.length; b++) {
      const S = m[b].attribute;
      this.has(S) || this.attributeUtils.createAttribute(S, r.ARRAY_BUFFER);
      const E = this.get(S);
      T.push(E);
    }
    this.set(e, {
      programGPU: a,
      transformBuffers: T,
      attributes: y
    });
  }
  /**
   * Creates bindings from the given bind group definition.
   *
   * @param {BindGroup} bindGroup - The bind group.
   * @param {Array<BindGroup>} bindings - Array of bind groups.
   * @param {number} cacheIndex - The cache index.
   * @param {number} version - The version.
   */
  createBindings(e, t) {
    if (this._knownBindings.has(t) === !1) {
      this._knownBindings.add(t);
      let n = 0, r = 0;
      for (const s of t) {
        this.set(s, {
          textures: r,
          uniformBuffers: n
        });
        for (const o of s.bindings)
          o.isUniformBuffer && n++, o.isSampledTexture && r++;
      }
    }
    this.updateBindings(e, t);
  }
  /**
   * Updates the given bind group definition.
   *
   * @param {BindGroup} bindGroup - The bind group.
   * @param {Array<BindGroup>} bindings - Array of bind groups.
   * @param {number} cacheIndex - The cache index.
   * @param {number} version - The version.
   */
  updateBindings(e) {
    const { gl: t } = this, n = this.get(e);
    let r = n.uniformBuffers, s = n.textures;
    for (const o of e.bindings) {
      const a = this.get(o);
      if (o.isUniformsGroup || o.isUniformBuffer) {
        const l = o.buffer;
        let { bufferGPU: u } = this.get(l);
        u === void 0 ? (u = t.createBuffer(), t.bindBuffer(t.UNIFORM_BUFFER, u), t.bufferData(t.UNIFORM_BUFFER, l.byteLength, t.DYNAMIC_DRAW), this.set(l, { bufferGPU: u })) : t.bindBuffer(t.UNIFORM_BUFFER, u);
        const c = o.updateRanges;
        if (t.bindBuffer(t.UNIFORM_BUFFER, u), c.length === 0)
          t.bufferData(t.UNIFORM_BUFFER, l, t.DYNAMIC_DRAW);
        else {
          const A = Uf(l), m = A ? 1 : l.BYTES_PER_ELEMENT;
          for (let _ = 0, y = c.length; _ < y; _++) {
            const T = c[_], b = T.start * m, S = T.count * m, E = b * (A ? l.BYTES_PER_ELEMENT : 1);
            t.bufferSubData(t.UNIFORM_BUFFER, E, l, b, S);
          }
        }
        a.index = r++, a.bufferGPU = u, this.set(o, a);
      } else if (o.isSampledTexture) {
        const { textureGPU: l, glTextureType: u } = this.get(o.texture);
        a.index = s++, a.textureGPU = l, a.glTextureType = u, this.set(o, a);
      }
    }
  }
  /**
   * Updates a buffer binding.
   *
   *  @param {Buffer} binding - The buffer binding to update.
   */
  updateBinding(e) {
    const t = this.gl;
    if (e.isUniformsGroup || e.isUniformBuffer) {
      const r = this.get(e).bufferGPU, s = e.buffer, o = e.updateRanges;
      if (t.bindBuffer(t.UNIFORM_BUFFER, r), o.length === 0)
        t.bufferData(t.UNIFORM_BUFFER, s, t.DYNAMIC_DRAW);
      else {
        const a = Uf(s), l = a ? 1 : s.BYTES_PER_ELEMENT;
        for (let u = 0, c = o.length; u < c; u++) {
          const A = o[u], m = A.start * l, _ = A.count * l, y = m * (a ? s.BYTES_PER_ELEMENT : 1);
          t.bufferSubData(t.UNIFORM_BUFFER, y, s, m, _);
        }
      }
    }
  }
  // attributes
  /**
   * Creates the GPU buffer of an indexed shader attribute.
   *
   * @param {BufferAttribute} attribute - The indexed buffer attribute.
   */
  createIndexAttribute(e) {
    const t = this.gl;
    this.attributeUtils.createAttribute(e, t.ELEMENT_ARRAY_BUFFER);
  }
  /**
   * Creates the GPU buffer of a shader attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute.
   */
  createAttribute(e) {
    if (this.has(e)) return;
    const t = this.gl;
    this.attributeUtils.createAttribute(e, t.ARRAY_BUFFER);
  }
  /**
   * Creates the GPU buffer of a storage attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute.
   */
  createStorageAttribute(e) {
    if (this.has(e)) return;
    const t = this.gl;
    this.attributeUtils.createAttribute(e, t.ARRAY_BUFFER);
  }
  /**
   * Updates the GPU buffer of a shader attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute to update.
   */
  updateAttribute(e) {
    this.attributeUtils.updateAttribute(e);
  }
  /**
   * Destroys the GPU buffer of a shader attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute to destroy.
   */
  destroyAttribute(e) {
    this.attributeUtils.destroyAttribute(e);
  }
  /**
   * Checks if the given feature is supported  by the backend.
   *
   * @param {string} name - The feature's name.
   * @return {boolean} Whether the feature is supported or not.
   */
  hasFeature(e) {
    const t = Object.keys(SC).filter((r) => SC[r] === e), n = this.extensions;
    for (let r = 0; r < t.length; r++)
      if (n.has(t[r])) return !0;
    return !1;
  }
  /**
   * Returns the maximum anisotropy texture filtering value.
   *
   * @return {number} The maximum anisotropy texture filtering value.
   */
  getMaxAnisotropy() {
    return this.capabilities.getMaxAnisotropy();
  }
  /**
   * Copies data of the given source texture to the given destination texture.
   *
   * @param {Texture} srcTexture - The source texture.
   * @param {Texture} dstTexture - The destination texture.
   * @param {?(Box3|Box2)} [srcRegion=null] - The region of the source texture to copy.
   * @param {?(Vector2|Vector3)} [dstPosition=null] - The destination position of the copy.
   * @param {number} [srcLevel=0] - The source mip level to copy from.
   * @param {number} [dstLevel=0] - The destination mip level to copy to.
   */
  copyTextureToTexture(e, t, n = null, r = null, s = 0, o = 0) {
    this.textureUtils.copyTextureToTexture(e, t, n, r, s, o);
  }
  /**
   * Copies the current bound framebuffer to the given texture.
   *
   * @param {Texture} texture - The destination texture.
   * @param {RenderContext} renderContext - The render context.
   * @param {Vector4} rectangle - A four dimensional vector defining the origin and dimension of the copy.
   */
  copyFramebufferToTexture(e, t, n) {
    this.textureUtils.copyFramebufferToTexture(e, t, n);
  }
  /**
   * Configures the active framebuffer from the given render context.
   *
   * @private
   * @param {RenderContext} descriptor - The render context.
   */
  _setFramebuffer(e) {
    const { gl: t, state: n } = this;
    let r = null;
    if (e.textures !== null) {
      const s = e.renderTarget, o = this.get(s), { samples: a, depthBuffer: l, stencilBuffer: u } = s, c = s.isWebGLCubeRenderTarget === !0, A = s.isRenderTarget3D === !0, m = s.depth > 1, _ = s.isXRRenderTarget === !0, y = _ === !0 && s._hasExternalTextures === !0;
      let T = o.msaaFrameBuffer, b = o.depthRenderbuffer;
      const S = this.extensions.get("WEBGL_multisampled_render_to_texture"), E = this.extensions.get("OVR_multiview2"), R = this._useMultisampledExtension(s), C = ML(e);
      let L;
      if (c ? (o.cubeFramebuffers || (o.cubeFramebuffers = {}), L = o.cubeFramebuffers[C]) : _ && y === !1 ? L = this._xrFramebuffer : (o.framebuffers || (o.framebuffers = {}), L = o.framebuffers[C]), L === void 0) {
        L = t.createFramebuffer(), n.bindFramebuffer(t.FRAMEBUFFER, L);
        const D = e.textures, B = [];
        if (c) {
          o.cubeFramebuffers[C] = L;
          const { textureGPU: N } = this.get(D[0]), O = this.renderer._activeCubeFace, G = this.renderer._activeMipmapLevel;
          t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_CUBE_MAP_POSITIVE_X + O, N, G);
        } else {
          o.framebuffers[C] = L;
          for (let N = 0; N < D.length; N++) {
            const O = D[N], G = this.get(O);
            G.renderTarget = e.renderTarget, G.cacheKey = C;
            const H = t.COLOR_ATTACHMENT0 + N;
            if (s.multiview)
              E.framebufferTextureMultisampleMultiviewOVR(t.FRAMEBUFFER, H, G.textureGPU, 0, a, 0, 2);
            else if (A || m) {
              const Y = this.renderer._activeCubeFace, K = this.renderer._activeMipmapLevel;
              t.framebufferTextureLayer(t.FRAMEBUFFER, H, G.textureGPU, K, Y);
            } else if (R)
              S.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER, H, t.TEXTURE_2D, G.textureGPU, 0, a);
            else {
              const Y = this.renderer._activeMipmapLevel;
              t.framebufferTexture2D(t.FRAMEBUFFER, H, t.TEXTURE_2D, G.textureGPU, Y);
            }
          }
        }
        const U = u ? t.DEPTH_STENCIL_ATTACHMENT : t.DEPTH_ATTACHMENT;
        if (s._autoAllocateDepthBuffer === !0) {
          const N = t.createRenderbuffer();
          this.textureUtils.setupRenderBufferStorage(N, e, 0, R), o.xrDepthRenderbuffer = N, B.push(u ? t.DEPTH_STENCIL_ATTACHMENT : t.DEPTH_ATTACHMENT), t.bindRenderbuffer(t.RENDERBUFFER, N), t.framebufferRenderbuffer(t.FRAMEBUFFER, U, t.RENDERBUFFER, N);
        } else if (e.depthTexture !== null) {
          B.push(u ? t.DEPTH_STENCIL_ATTACHMENT : t.DEPTH_ATTACHMENT);
          const N = this.get(e.depthTexture);
          if (N.renderTarget = e.renderTarget, N.cacheKey = C, s.multiview)
            E.framebufferTextureMultisampleMultiviewOVR(t.FRAMEBUFFER, U, N.textureGPU, 0, a, 0, 2);
          else if (y && R)
            S.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER, U, t.TEXTURE_2D, N.textureGPU, 0, a);
          else if (e.depthTexture.isArrayTexture) {
            const O = this.renderer._activeCubeFace;
            t.framebufferTextureLayer(t.FRAMEBUFFER, U, N.textureGPU, 0, O);
          } else if (e.depthTexture.isCubeTexture) {
            const O = this.renderer._activeCubeFace;
            t.framebufferTexture2D(t.FRAMEBUFFER, U, t.TEXTURE_CUBE_MAP_POSITIVE_X + O, N.textureGPU, 0);
          } else
            t.framebufferTexture2D(t.FRAMEBUFFER, U, t.TEXTURE_2D, N.textureGPU, 0);
        }
        o.depthInvalidationArray = B;
      } else {
        if (this._isRenderCameraDepthArray(e)) {
          n.bindFramebuffer(t.FRAMEBUFFER, L);
          const B = this.renderer._activeCubeFace, U = this.get(e.depthTexture), N = u ? t.DEPTH_STENCIL_ATTACHMENT : t.DEPTH_ATTACHMENT;
          t.framebufferTextureLayer(
            t.FRAMEBUFFER,
            N,
            U.textureGPU,
            0,
            B
          );
        }
        if ((_ || R || s.multiview) && s._isOpaqueFramebuffer !== !0) {
          n.bindFramebuffer(t.FRAMEBUFFER, L);
          const B = this.get(e.textures[0]);
          s.multiview ? E.framebufferTextureMultisampleMultiviewOVR(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, B.textureGPU, 0, a, 0, 2) : R ? S.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, B.textureGPU, 0, a) : t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, B.textureGPU, 0);
          const U = u ? t.DEPTH_STENCIL_ATTACHMENT : t.DEPTH_ATTACHMENT;
          if (s._autoAllocateDepthBuffer === !0) {
            const N = o.xrDepthRenderbuffer;
            t.bindRenderbuffer(t.RENDERBUFFER, N), t.framebufferRenderbuffer(t.FRAMEBUFFER, U, t.RENDERBUFFER, N);
          } else {
            const N = this.get(e.depthTexture);
            s.multiview ? E.framebufferTextureMultisampleMultiviewOVR(t.FRAMEBUFFER, U, N.textureGPU, 0, a, 0, 2) : R ? S.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER, U, t.TEXTURE_2D, N.textureGPU, 0, a) : t.framebufferTexture2D(t.FRAMEBUFFER, U, t.TEXTURE_2D, N.textureGPU, 0);
          }
        }
      }
      if (a > 0 && R === !1 && !s.multiview) {
        if (T === void 0) {
          const D = [];
          T = t.createFramebuffer(), n.bindFramebuffer(t.FRAMEBUFFER, T);
          const B = [], U = e.textures;
          for (let N = 0; N < U.length; N++) {
            B[N] = t.createRenderbuffer(), t.bindRenderbuffer(t.RENDERBUFFER, B[N]), D.push(t.COLOR_ATTACHMENT0 + N);
            const O = e.textures[N], G = this.get(O);
            t.renderbufferStorageMultisample(t.RENDERBUFFER, a, G.glInternalFormat, e.width, e.height), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0 + N, t.RENDERBUFFER, B[N]);
          }
          if (t.bindRenderbuffer(t.RENDERBUFFER, null), o.msaaFrameBuffer = T, o.msaaRenderbuffers = B, l && b === void 0) {
            b = t.createRenderbuffer(), this.textureUtils.setupRenderBufferStorage(b, e, a), o.depthRenderbuffer = b;
            const N = u ? t.DEPTH_STENCIL_ATTACHMENT : t.DEPTH_ATTACHMENT;
            D.push(N);
          }
          o.invalidationArray = D;
        }
        r = o.msaaFrameBuffer;
      } else
        r = L;
      n.drawBuffers(e, L);
    }
    n.bindFramebuffer(t.FRAMEBUFFER, r);
  }
  /**
   * Computes the VAO key for the given index and attributes.
   *
   * @private
   * @param {Array<BufferAttribute>} attributes - An array of buffer attributes.
   * @return {string} The VAO key.
   */
  _getVaoKey(e) {
    let t = "";
    for (let n = 0; n < e.length; n++) {
      const r = this.get(e[n]);
      t += ":" + r.id;
    }
    return t;
  }
  /**
   * Creates a VAO from the index and attributes.
   *
   * @private
   * @param {Array<BufferAttribute>} attributes - An array of buffer attributes.
   * @return {Object} The VAO data.
   */
  _createVao(e) {
    const { gl: t } = this, n = t.createVertexArray();
    t.bindVertexArray(n);
    for (let r = 0; r < e.length; r++) {
      const s = e[r], o = this.get(s);
      t.bindBuffer(t.ARRAY_BUFFER, o.bufferGPU), t.enableVertexAttribArray(r);
      let a, l;
      s.isInterleavedBufferAttribute === !0 ? (a = s.data.stride * o.bytesPerElement, l = s.offset * o.bytesPerElement) : (a = 0, l = 0), o.isInteger ? t.vertexAttribIPointer(r, s.itemSize, o.type, a, l) : t.vertexAttribPointer(r, s.itemSize, o.type, s.normalized, a, l), s.isInstancedBufferAttribute && !s.isInterleavedBufferAttribute ? t.vertexAttribDivisor(r, s.meshPerAttribute) : s.isInterleavedBufferAttribute && s.data.isInstancedInterleavedBuffer && t.vertexAttribDivisor(r, s.data.meshPerAttribute);
    }
    return t.bindBuffer(t.ARRAY_BUFFER, null), n;
  }
  /**
   * Creates a transform feedback from the given transform buffers.
   *
   * @private
   * @param {Array<DualAttributeData>} transformBuffers - The transform buffers.
   * @return {WebGLTransformFeedback} The transform feedback.
   */
  _getTransformFeedback(e) {
    let t = "";
    for (let s = 0; s < e.length; s++)
      t += ":" + e[s].id;
    let n = this.transformFeedbackCache[t];
    if (n !== void 0)
      return n;
    const { gl: r } = this;
    n = r.createTransformFeedback(), r.bindTransformFeedback(r.TRANSFORM_FEEDBACK, n);
    for (let s = 0; s < e.length; s++) {
      const o = e[s];
      r.bindBufferBase(r.TRANSFORM_FEEDBACK_BUFFER, s, o.transformBuffer);
    }
    return r.bindTransformFeedback(r.TRANSFORM_FEEDBACK, null), this.transformFeedbackCache[t] = n, n;
  }
  /**
   * Setups the given bindings.
   *
   * @private
   * @param {Array<BindGroup>} bindings - The bindings.
   * @param {WebGLProgram} programGPU - The WebGL program.
   */
  _setupBindings(e, t) {
    const n = this.gl;
    for (const r of e)
      for (const s of r.bindings) {
        const a = this.get(s).index;
        if (s.isUniformsGroup || s.isUniformBuffer) {
          const l = n.getUniformBlockIndex(t, s.name);
          n.uniformBlockBinding(t, l, a);
        } else if (s.isSampledTexture) {
          const l = n.getUniformLocation(t, s.name);
          n.uniform1i(l, a);
        }
      }
  }
  /**
   * Binds the given uniforms.
   *
   * @private
   * @param {Array<BindGroup>} bindings - The bindings.
   */
  _bindUniforms(e) {
    const { gl: t, state: n } = this;
    for (const r of e)
      for (const s of r.bindings) {
        const o = this.get(s), a = o.index;
        s.isUniformsGroup || s.isUniformBuffer ? n.bindBufferBase(t.UNIFORM_BUFFER, a, o.bufferGPU) : s.isSampledTexture && n.bindTexture(o.glTextureType, o.textureGPU, t.TEXTURE0 + a);
      }
  }
  /**
   * The method ensures multisampled render targets are resolved.
   *
   * @private
   * @param {RenderContext} renderContext - The render context.
   */
  _resolveRenderTarget(e) {
    const { gl: t, state: n } = this, r = e.renderTarget;
    if (e.textures !== null && r) {
      const s = this.get(r);
      if (r.samples > 0 && this._useMultisampledExtension(r) === !1) {
        const o = s.framebuffers[e.getCacheKey()];
        let a = t.COLOR_BUFFER_BIT;
        r.resolveDepthBuffer && (r.depthBuffer && (a |= t.DEPTH_BUFFER_BIT), r.stencilBuffer && r.resolveStencilBuffer && (a |= t.STENCIL_BUFFER_BIT));
        const l = s.msaaFrameBuffer, u = s.msaaRenderbuffers, c = e.textures, A = c.length > 1;
        if (n.bindFramebuffer(t.READ_FRAMEBUFFER, l), n.bindFramebuffer(t.DRAW_FRAMEBUFFER, o), A)
          for (let m = 0; m < c.length; m++)
            t.framebufferRenderbuffer(t.READ_FRAMEBUFFER, t.COLOR_ATTACHMENT0 + m, t.RENDERBUFFER, null), t.framebufferTexture2D(t.DRAW_FRAMEBUFFER, t.COLOR_ATTACHMENT0 + m, t.TEXTURE_2D, null, 0);
        for (let m = 0; m < c.length; m++) {
          if (A) {
            const { textureGPU: _ } = this.get(c[m]);
            t.framebufferRenderbuffer(t.READ_FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.RENDERBUFFER, u[m]), t.framebufferTexture2D(t.DRAW_FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, _, 0);
          }
          if (e.scissor) {
            const { x: _, y, width: T, height: b } = e.scissorValue, S = e.height - b - y;
            t.blitFramebuffer(_, S, _ + T, S + b, _, S, _ + T, S + b, a, t.NEAREST);
          } else
            t.blitFramebuffer(0, 0, e.width, e.height, 0, 0, e.width, e.height, a, t.NEAREST);
        }
        if (A)
          for (let m = 0; m < c.length; m++) {
            const { textureGPU: _ } = this.get(c[m]);
            t.framebufferRenderbuffer(t.READ_FRAMEBUFFER, t.COLOR_ATTACHMENT0 + m, t.RENDERBUFFER, u[m]), t.framebufferTexture2D(t.DRAW_FRAMEBUFFER, t.COLOR_ATTACHMENT0 + m, t.TEXTURE_2D, _, 0);
          }
        this._supportsInvalidateFramebuffer === !0 && t.invalidateFramebuffer(t.READ_FRAMEBUFFER, s.invalidationArray);
      } else if (r.resolveDepthBuffer === !1 && s.framebuffers) {
        const o = s.framebuffers[e.getCacheKey()];
        n.bindFramebuffer(t.DRAW_FRAMEBUFFER, o), t.invalidateFramebuffer(t.DRAW_FRAMEBUFFER, s.depthInvalidationArray);
      }
    }
  }
  /**
   * Returns `true` if the `WEBGL_multisampled_render_to_texture` extension
   * should be used when MSAA is enabled.
   *
   * @private
   * @param {RenderTarget} renderTarget - The render target that should be multisampled.
   * @return {boolean} Whether to use the `WEBGL_multisampled_render_to_texture` extension for MSAA or not.
   */
  _useMultisampledExtension(e) {
    return e.multiview === !0 ? !0 : e.samples > 0 && this.extensions.has("WEBGL_multisampled_render_to_texture") === !0 && e._autoAllocateDepthBuffer !== !1;
  }
  /**
   * Frees internal resources.
   */
  dispose() {
    this.textureUtils !== null && this.textureUtils.dispose();
    const e = this.extensions.get("WEBGL_lose_context");
    e && e.loseContext(), this.renderer.domElement.removeEventListener("webglcontextlost", this._onContextLost);
  }
}
const ff = {
  PointList: "point-list",
  LineList: "line-list",
  LineStrip: "line-strip",
  TriangleList: "triangle-list",
  TriangleStrip: "triangle-strip"
}, sh = typeof self < "u" ? self.GPUShaderStage : { VERTEX: 1, FRAGMENT: 2, COMPUTE: 4 }, Gr = {
  Never: "never",
  Less: "less",
  Equal: "equal",
  LessEqual: "less-equal",
  Greater: "greater",
  NotEqual: "not-equal",
  GreaterEqual: "greater-equal",
  Always: "always"
}, Ms = {
  Store: "store"
}, ti = {
  Load: "load",
  Clear: "clear"
}, wC = {
  CCW: "ccw",
  CW: "cw"
}, MC = {
  None: "none",
  Back: "back"
}, Kf = {
  Uint16: "uint16",
  Uint32: "uint32"
}, de = {
  // 8-bit formats
  R8Unorm: "r8unorm",
  R8Snorm: "r8snorm",
  R8Uint: "r8uint",
  R8Sint: "r8sint",
  // 16-bit formats
  R16Uint: "r16uint",
  R16Sint: "r16sint",
  R16Float: "r16float",
  RG8Unorm: "rg8unorm",
  RG8Snorm: "rg8snorm",
  RG8Uint: "rg8uint",
  RG8Sint: "rg8sint",
  // 32-bit formats
  R32Uint: "r32uint",
  R32Sint: "r32sint",
  R32Float: "r32float",
  RG16Uint: "rg16uint",
  RG16Sint: "rg16sint",
  RG16Float: "rg16float",
  RGBA8Unorm: "rgba8unorm",
  RGBA8UnormSRGB: "rgba8unorm-srgb",
  RGBA8Snorm: "rgba8snorm",
  RGBA8Uint: "rgba8uint",
  RGBA8Sint: "rgba8sint",
  BGRA8Unorm: "bgra8unorm",
  BGRA8UnormSRGB: "bgra8unorm-srgb",
  // Packed 32-bit formats
  RGB9E5UFloat: "rgb9e5ufloat",
  RGB10A2Unorm: "rgb10a2unorm",
  RG11B10UFloat: "rg11b10ufloat",
  // 64-bit formats
  RG32Uint: "rg32uint",
  RG32Sint: "rg32sint",
  RG32Float: "rg32float",
  RGBA16Uint: "rgba16uint",
  RGBA16Sint: "rgba16sint",
  RGBA16Float: "rgba16float",
  // 128-bit formats
  RGBA32Uint: "rgba32uint",
  RGBA32Sint: "rgba32sint",
  RGBA32Float: "rgba32float",
  Depth16Unorm: "depth16unorm",
  Depth24Plus: "depth24plus",
  Depth24PlusStencil8: "depth24plus-stencil8",
  Depth32Float: "depth32float",
  // 'depth32float-stencil8' extension
  Depth32FloatStencil8: "depth32float-stencil8",
  // BC compressed formats usable if 'texture-compression-bc' is both
  // supported by the device/user agent and enabled in requestDevice.
  BC1RGBAUnorm: "bc1-rgba-unorm",
  BC1RGBAUnormSRGB: "bc1-rgba-unorm-srgb",
  BC2RGBAUnorm: "bc2-rgba-unorm",
  BC2RGBAUnormSRGB: "bc2-rgba-unorm-srgb",
  BC3RGBAUnorm: "bc3-rgba-unorm",
  BC3RGBAUnormSRGB: "bc3-rgba-unorm-srgb",
  BC4RUnorm: "bc4-r-unorm",
  BC4RSnorm: "bc4-r-snorm",
  BC5RGUnorm: "bc5-rg-unorm",
  BC5RGSnorm: "bc5-rg-snorm",
  BC6HRGBUFloat: "bc6h-rgb-ufloat",
  BC6HRGBFloat: "bc6h-rgb-float",
  BC7RGBAUnorm: "bc7-rgba-unorm",
  BC7RGBAUnormSRGB: "bc7-rgba-unorm-srgb",
  // ETC2 compressed formats usable if 'texture-compression-etc2' is both
  // supported by the device/user agent and enabled in requestDevice.
  ETC2RGB8Unorm: "etc2-rgb8unorm",
  ETC2RGB8UnormSRGB: "etc2-rgb8unorm-srgb",
  ETC2RGB8A1Unorm: "etc2-rgb8a1unorm",
  ETC2RGB8A1UnormSRGB: "etc2-rgb8a1unorm-srgb",
  ETC2RGBA8Unorm: "etc2-rgba8unorm",
  ETC2RGBA8UnormSRGB: "etc2-rgba8unorm-srgb",
  EACR11Unorm: "eac-r11unorm",
  EACR11Snorm: "eac-r11snorm",
  EACRG11Unorm: "eac-rg11unorm",
  EACRG11Snorm: "eac-rg11snorm",
  // ASTC compressed formats usable if 'texture-compression-astc' is both
  // supported by the device/user agent and enabled in requestDevice.
  ASTC4x4Unorm: "astc-4x4-unorm",
  ASTC4x4UnormSRGB: "astc-4x4-unorm-srgb",
  ASTC5x4Unorm: "astc-5x4-unorm",
  ASTC5x4UnormSRGB: "astc-5x4-unorm-srgb",
  ASTC5x5Unorm: "astc-5x5-unorm",
  ASTC5x5UnormSRGB: "astc-5x5-unorm-srgb",
  ASTC6x5Unorm: "astc-6x5-unorm",
  ASTC6x5UnormSRGB: "astc-6x5-unorm-srgb",
  ASTC6x6Unorm: "astc-6x6-unorm",
  ASTC6x6UnormSRGB: "astc-6x6-unorm-srgb",
  ASTC8x5Unorm: "astc-8x5-unorm",
  ASTC8x5UnormSRGB: "astc-8x5-unorm-srgb",
  ASTC8x6Unorm: "astc-8x6-unorm",
  ASTC8x6UnormSRGB: "astc-8x6-unorm-srgb",
  ASTC8x8Unorm: "astc-8x8-unorm",
  ASTC8x8UnormSRGB: "astc-8x8-unorm-srgb",
  ASTC10x5Unorm: "astc-10x5-unorm",
  ASTC10x5UnormSRGB: "astc-10x5-unorm-srgb",
  ASTC10x6Unorm: "astc-10x6-unorm",
  ASTC10x6UnormSRGB: "astc-10x6-unorm-srgb",
  ASTC10x8Unorm: "astc-10x8-unorm",
  ASTC10x8UnormSRGB: "astc-10x8-unorm-srgb",
  ASTC10x10Unorm: "astc-10x10-unorm",
  ASTC10x10UnormSRGB: "astc-10x10-unorm-srgb",
  ASTC12x10Unorm: "astc-12x10-unorm",
  ASTC12x10UnormSRGB: "astc-12x10-unorm-srgb",
  ASTC12x12Unorm: "astc-12x12-unorm",
  ASTC12x12UnormSRGB: "astc-12x12-unorm-srgb"
}, _v = {
  ClampToEdge: "clamp-to-edge",
  Repeat: "repeat",
  MirrorRepeat: "mirror-repeat"
}, $c = {
  Linear: "linear",
  Nearest: "nearest"
}, kn = {
  Zero: "zero",
  One: "one",
  Src: "src",
  OneMinusSrc: "one-minus-src",
  SrcAlpha: "src-alpha",
  OneMinusSrcAlpha: "one-minus-src-alpha",
  Dst: "dst",
  OneMinusDst: "one-minus-dst",
  DstAlpha: "dst-alpha",
  OneMinusDstAlpha: "one-minus-dst-alpha",
  SrcAlphaSaturated: "src-alpha-saturated",
  Constant: "constant",
  OneMinusConstant: "one-minus-constant"
}, Uc = {
  Add: "add",
  Subtract: "subtract",
  ReverseSubtract: "reverse-subtract",
  Min: "min",
  Max: "max"
}, EC = {
  None: 0,
  All: 15
}, yu = {
  Keep: "keep",
  Zero: "zero",
  Replace: "replace",
  Invert: "invert",
  IncrementClamp: "increment-clamp",
  DecrementClamp: "decrement-clamp",
  IncrementWrap: "increment-wrap",
  DecrementWrap: "decrement-wrap"
}, xv = {
  Storage: "storage",
  ReadOnlyStorage: "read-only-storage"
}, yv = {
  WriteOnly: "write-only",
  ReadOnly: "read-only",
  ReadWrite: "read-write"
}, RC = {
  NonFiltering: "non-filtering",
  Comparison: "comparison"
}, Oc = {
  Float: "float",
  UnfilterableFloat: "unfilterable-float",
  Depth: "depth",
  SInt: "sint",
  UInt: "uint"
}, CC = {
  TwoD: "2d",
  ThreeD: "3d"
}, cr = {
  TwoD: "2d",
  TwoDArray: "2d-array",
  Cube: "cube",
  ThreeD: "3d"
}, Oae = {
  All: "all"
}, Rg = {
  Vertex: "vertex",
  Instance: "instance"
}, t3 = {
  CoreFeaturesAndLimits: "core-features-and-limits",
  DepthClipControl: "depth-clip-control",
  Depth32FloatStencil8: "depth32float-stencil8",
  TextureCompressionBC: "texture-compression-bc",
  TextureCompressionBCSliced3D: "texture-compression-bc-sliced-3d",
  TextureCompressionETC2: "texture-compression-etc2",
  TextureCompressionASTC: "texture-compression-astc",
  TextureCompressionASTCSliced3D: "texture-compression-astc-sliced-3d",
  TimestampQuery: "timestamp-query",
  IndirectFirstInstance: "indirect-first-instance",
  ShaderF16: "shader-f16",
  RG11B10UFloat: "rg11b10ufloat-renderable",
  BGRA8UNormStorage: "bgra8unorm-storage",
  Float32Filterable: "float32-filterable",
  Float32Blendable: "float32-blendable",
  ClipDistances: "clip-distances",
  DualSourceBlending: "dual-source-blending",
  Subgroups: "subgroups",
  TextureFormatsTier1: "texture-formats-tier1",
  TextureFormatsTier2: "texture-formats-tier2"
}, PC = {
  "texture-compression-s3tc": "texture-compression-bc",
  "texture-compression-etc1": "texture-compression-etc2"
};
class kae extends PI {
  /**
   * Constructs a new node-based sampler.
   *
   * @param {string} name - The samplers's name.
   * @param {TextureNode} textureNode - The texture node.
   * @param {UniformGroupNode} groupNode - The uniform group node.
   */
  constructor(e, t, n) {
    super(e, t ? t.value : null), this.textureNode = t, this.groupNode = n;
  }
  /**
   * Updates the texture value of this sampler.
   *
   * @return {boolean} Whether the sampler needs an update or not.
   */
  update() {
    const { textureNode: e } = this;
    return this.texture !== e.value ? (this.texture = e.value, !0) : super.update();
  }
}
class Vae extends MI {
  /**
   * Constructs a new uniform buffer.
   *
   * @param {string} name - The buffer's name.
   * @param {BufferAttribute} attribute - The buffer attribute.
   */
  constructor(e, t) {
    super(e, t ? t.array : null), this.attribute = t, this.isStorageBuffer = !0;
  }
}
let Gae = 0;
class zae extends Vae {
  /**
   * Constructs a new node-based storage buffer.
   *
   * @param {StorageBufferNode} nodeUniform - The storage buffer node.
   * @param {UniformGroupNode} groupNode - The uniform group node.
   */
  constructor(e, t) {
    super("StorageBuffer_" + Gae++, e ? e.value : null), this.nodeUniform = e, this.access = e ? e.access : Xr.READ_WRITE, this.groupNode = t;
  }
  /**
   * The storage buffer.
   *
   * @type {BufferAttribute}
   */
  get buffer() {
    return this.nodeUniform.value;
  }
}
class qae extends ac {
  /**
   * Constructs a new utility object.
   *
   * @param {GPUDevice} device - The WebGPU device.
   */
  constructor(e) {
    super(), this.device = e;
    const t = `
struct VarysStruct {
	@builtin( position ) Position: vec4<f32>,
	@location( 0 ) vTex : vec2<f32>
};

@vertex
fn main( @builtin( vertex_index ) vertexIndex : u32 ) -> VarysStruct {

	var Varys : VarysStruct;

	var pos = array< vec2<f32>, 4 >(
		vec2<f32>( -1.0,  1.0 ),
		vec2<f32>(  1.0,  1.0 ),
		vec2<f32>( -1.0, -1.0 ),
		vec2<f32>(  1.0, -1.0 )
	);

	var tex = array< vec2<f32>, 4 >(
		vec2<f32>( 0.0, 0.0 ),
		vec2<f32>( 1.0, 0.0 ),
		vec2<f32>( 0.0, 1.0 ),
		vec2<f32>( 1.0, 1.0 )
	);

	Varys.vTex = tex[ vertexIndex ];
	Varys.Position = vec4<f32>( pos[ vertexIndex ], 0.0, 1.0 );

	return Varys;

}
`, n = `
@group( 0 ) @binding( 0 )
var imgSampler : sampler;

@group( 0 ) @binding( 1 )
var img : texture_2d<f32>;

@fragment
fn main( @location( 0 ) vTex : vec2<f32> ) -> @location( 0 ) vec4<f32> {

	return textureSample( img, imgSampler, vTex );

}
`, r = `
@group( 0 ) @binding( 0 )
var imgSampler : sampler;

@group( 0 ) @binding( 1 )
var img : texture_2d<f32>;

@fragment
fn main( @location( 0 ) vTex : vec2<f32> ) -> @location( 0 ) vec4<f32> {

	return textureSample( img, imgSampler, vec2( vTex.x, 1.0 - vTex.y ) );

}
`;
    this.mipmapSampler = e.createSampler({ minFilter: $c.Linear }), this.flipYSampler = e.createSampler({ minFilter: $c.Nearest }), this.transferPipelines = {}, this.flipYPipelines = {}, this.mipmapVertexShaderModule = e.createShaderModule({
      label: "mipmapVertex",
      code: t
    }), this.mipmapFragmentShaderModule = e.createShaderModule({
      label: "mipmapFragment",
      code: n
    }), this.flipYFragmentShaderModule = e.createShaderModule({
      label: "flipYFragment",
      code: r
    });
  }
  /**
   * Returns a render pipeline for the internal copy render pass. The pass
   * requires a unique render pipeline for each texture format.
   *
   * @param {string} format - The GPU texture format
   * @return {GPURenderPipeline} The GPU render pipeline.
   */
  getTransferPipeline(e) {
    let t = this.transferPipelines[e];
    return t === void 0 && (t = this.device.createRenderPipeline({
      label: `mipmap-${e}`,
      vertex: {
        module: this.mipmapVertexShaderModule,
        entryPoint: "main"
      },
      fragment: {
        module: this.mipmapFragmentShaderModule,
        entryPoint: "main",
        targets: [{ format: e }]
      },
      primitive: {
        topology: ff.TriangleStrip,
        stripIndexFormat: Kf.Uint32
      },
      layout: "auto"
    }), this.transferPipelines[e] = t), t;
  }
  /**
   * Returns a render pipeline for the flipY render pass. The pass
   * requires a unique render pipeline for each texture format.
   *
   * @param {string} format - The GPU texture format
   * @return {GPURenderPipeline} The GPU render pipeline.
   */
  getFlipYPipeline(e) {
    let t = this.flipYPipelines[e];
    return t === void 0 && (t = this.device.createRenderPipeline({
      label: `flipY-${e}`,
      vertex: {
        module: this.mipmapVertexShaderModule,
        entryPoint: "main"
      },
      fragment: {
        module: this.flipYFragmentShaderModule,
        entryPoint: "main",
        targets: [{ format: e }]
      },
      primitive: {
        topology: ff.TriangleStrip,
        stripIndexFormat: Kf.Uint32
      },
      layout: "auto"
    }), this.flipYPipelines[e] = t), t;
  }
  /**
   * Flip the contents of the given GPU texture along its vertical axis.
   *
   * @param {GPUTexture} textureGPU - The GPU texture object.
   * @param {Object} textureGPUDescriptor - The texture descriptor.
   * @param {number} [baseArrayLayer=0] - The index of the first array layer accessible to the texture view.
   */
  flipY(e, t, n = 0) {
    const r = t.format, { width: s, height: o } = t.size, a = this.getTransferPipeline(r), l = this.getFlipYPipeline(r), u = this.device.createTexture({
      size: { width: s, height: o, depthOrArrayLayers: 1 },
      format: r,
      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING
    }), c = e.createView({
      baseMipLevel: 0,
      mipLevelCount: 1,
      dimension: cr.TwoD,
      baseArrayLayer: n
    }), A = u.createView({
      baseMipLevel: 0,
      mipLevelCount: 1,
      dimension: cr.TwoD,
      baseArrayLayer: 0
    }), m = this.device.createCommandEncoder({}), _ = (y, T, b) => {
      const S = y.getBindGroupLayout(0), E = this.device.createBindGroup({
        layout: S,
        entries: [{
          binding: 0,
          resource: this.flipYSampler
        }, {
          binding: 1,
          resource: T
        }]
      }), R = m.beginRenderPass({
        colorAttachments: [{
          view: b,
          loadOp: ti.Clear,
          storeOp: Ms.Store,
          clearValue: [0, 0, 0, 0]
        }]
      });
      R.setPipeline(y), R.setBindGroup(0, E), R.draw(4, 1, 0, 0), R.end();
    };
    _(a, c, A), _(l, A, c), this.device.queue.submit([m.finish()]), u.destroy();
  }
  /**
   * Generates mipmaps for the given GPU texture.
   *
   * @param {GPUTexture} textureGPU - The GPU texture object.
   * @param {Object} textureGPUDescriptor - The texture descriptor.
   * @param {number} [baseArrayLayer=0] - The index of the first array layer accessible to the texture view.
   * @param {?GPUCommandEncoder} [encoder=null] - An optional command encoder used to generate mipmaps.
   */
  generateMipmaps(e, t, n = 0, r = null) {
    const s = this.get(e);
    s.layers === void 0 && (s.layers = []);
    const o = s.layers[n] || this._mipmapCreateBundles(e, t, n), a = r || this.device.createCommandEncoder({ label: "mipmapEncoder" });
    this._mipmapRunBundles(a, o), r === null && this.device.queue.submit([a.finish()]), s.layers[n] = o;
  }
  /**
   * Since multiple copy render passes are required to generate mipmaps, the passes
   * are managed as render bundles to improve performance.
   *
   * @param {GPUTexture} textureGPU - The GPU texture object.
   * @param {Object} textureGPUDescriptor - The texture descriptor.
   * @param {number} baseArrayLayer - The index of the first array layer accessible to the texture view.
   * @return {Array<Object>} An array of render bundles.
   */
  _mipmapCreateBundles(e, t, n) {
    const r = this.getTransferPipeline(t.format), s = r.getBindGroupLayout(0);
    let o = e.createView({
      baseMipLevel: 0,
      mipLevelCount: 1,
      dimension: cr.TwoD,
      baseArrayLayer: n
    });
    const a = [];
    for (let l = 1; l < t.mipLevelCount; l++) {
      const u = this.device.createBindGroup({
        layout: s,
        entries: [{
          binding: 0,
          resource: this.mipmapSampler
        }, {
          binding: 1,
          resource: o
        }]
      }), c = e.createView({
        baseMipLevel: l,
        mipLevelCount: 1,
        dimension: cr.TwoD,
        baseArrayLayer: n
      }), A = {
        colorAttachments: [{
          view: c,
          loadOp: ti.Clear,
          storeOp: Ms.Store,
          clearValue: [0, 0, 0, 0]
        }]
      }, m = this.device.createRenderBundleEncoder({
        colorFormats: [t.format]
      });
      m.setPipeline(r), m.setBindGroup(0, u), m.draw(4, 1, 0, 0), a.push({
        renderBundles: [m.finish()],
        passDescriptor: A
      }), o = c;
    }
    return a;
  }
  /**
   * Executes the render bundles.
   *
   * @param {GPUCommandEncoder} commandEncoder - The GPU command encoder.
   * @param {Array<Object>} passes - An array of render bundles.
   */
  _mipmapRunBundles(e, t) {
    const n = t.length;
    for (let r = 0; r < n; r++) {
      const s = t[r], o = e.beginRenderPass(s.passDescriptor);
      o.executeBundles(s.renderBundles), o.end();
    }
  }
}
const Hae = {
  [G_]: "never",
  [iA]: "less",
  [z_]: "equal",
  [rA]: "less-equal",
  [q_]: "greater",
  [sA]: "greater-equal",
  [W_]: "always",
  [H_]: "not-equal"
}, Wae = [0, 1, 3, 2, 4, 5];
class $ae {
  /**
   * Constructs a new utility object.
   *
   * @param {WebGPUBackend} backend - The WebGPU backend.
   */
  constructor(e) {
    this.backend = e, this._passUtils = null, this.defaultTexture = {}, this.defaultCubeTexture = {}, this.defaultVideoFrame = null, this._samplerCache = /* @__PURE__ */ new Map();
  }
  /**
   * Creates a GPU sampler for the given texture.
   *
   * @param {Texture} texture - The texture to create the sampler for.
   * @return {string} The current sampler key.
   */
  updateSampler(e) {
    const t = this.backend, n = e.minFilter + "-" + e.magFilter + "-" + e.wrapS + "-" + e.wrapT + "-" + (e.wrapR || "0") + "-" + e.anisotropy + "-" + (e.compareFunction || 0);
    let r = this._samplerCache.get(n);
    if (r === void 0) {
      const o = {
        addressModeU: this._convertAddressMode(e.wrapS),
        addressModeV: this._convertAddressMode(e.wrapT),
        addressModeW: this._convertAddressMode(e.wrapR),
        magFilter: this._convertFilterMode(e.magFilter),
        minFilter: this._convertFilterMode(e.minFilter),
        mipmapFilter: this._convertFilterMode(e.minFilter),
        maxAnisotropy: 1
      };
      o.magFilter === $c.Linear && o.minFilter === $c.Linear && o.mipmapFilter === $c.Linear && (o.maxAnisotropy = e.anisotropy), e.isDepthTexture && e.compareFunction !== null && (o.compare = Hae[e.compareFunction]), r = { sampler: t.device.createSampler(o), usedTimes: 0 }, this._samplerCache.set(n, r);
    }
    const s = t.get(e);
    if (s.sampler !== r.sampler) {
      if (s.sampler !== void 0) {
        const o = this._samplerCache.get(s.samplerKey);
        o.usedTimes--, o.usedTimes === 0 && this._samplerCache.delete(s.samplerKey);
      }
      s.samplerKey = n, s.sampler = r.sampler, r.usedTimes++;
    }
    return n;
  }
  /**
   * Creates a default texture for the given texture that can be used
   * as a placeholder until the actual texture is ready for usage.
   *
   * @param {Texture} texture - The texture to create a default texture for.
   */
  createDefaultTexture(e) {
    let t;
    const n = n3(e);
    e.isCubeTexture ? t = this._getDefaultCubeTextureGPU(n) : t = this._getDefaultTextureGPU(n), this.backend.get(e).texture = t;
  }
  /**
   * Defines a texture on the GPU for the given texture object.
   *
   * @param {Texture} texture - The texture.
   * @param {Object} [options={}] - Optional configuration parameter.
   */
  createTexture(e, t = {}) {
    const n = this.backend, r = n.get(e);
    if (r.initialized)
      throw new Error("WebGPUTextureUtils: Texture already initialized.");
    if (e.isExternalTexture) {
      r.texture = e.sourceTexture, r.initialized = !0;
      return;
    }
    t.needsMipmaps === void 0 && (t.needsMipmaps = !1), t.levels === void 0 && (t.levels = 1), t.depth === void 0 && (t.depth = 1);
    const { width: s, height: o, depth: a, levels: l } = t;
    e.isFramebufferTexture && (t.renderTarget ? t.format = this.backend.utils.getCurrentColorFormat(t.renderTarget) : t.format = this.backend.utils.getPreferredCanvasFormat());
    const u = this._getDimension(e), c = e.internalFormat || t.format || n3(e, n.device);
    r.format = c;
    const { samples: A, primarySamples: m, isMSAA: _ } = n.utils.getTextureSampleData(e);
    let y = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC;
    e.isStorageTexture === !0 && (y |= GPUTextureUsage.STORAGE_BINDING), e.isCompressedTexture !== !0 && e.isCompressedArrayTexture !== !0 && c !== de.RGB9E5UFloat && (y |= GPUTextureUsage.RENDER_ATTACHMENT);
    const T = {
      label: e.name,
      size: {
        width: s,
        height: o,
        depthOrArrayLayers: a
      },
      mipLevelCount: l,
      sampleCount: m,
      dimension: u,
      format: c,
      usage: y
    };
    if (c === void 0) {
      Me("WebGPURenderer: Texture format not supported."), this.createDefaultTexture(e);
      return;
    }
    if (e.isCubeTexture && (T.textureBindingViewDimension = cr.Cube), r.texture = n.device.createTexture(T), _) {
      const b = Object.assign({}, T);
      b.label = b.label + "-msaa", b.sampleCount = A, b.mipLevelCount = 1, r.msaaTexture = n.device.createTexture(b);
    }
    r.initialized = !0, r.textureDescriptorGPU = T;
  }
  /**
   * Destroys the GPU data for the given texture object.
   *
   * @param {Texture} texture - The texture.
   * @param {boolean} [isDefaultTexture=false] - Whether the texture uses a default GPU texture or not.
   */
  destroyTexture(e, t = !1) {
    const n = this.backend, r = n.get(e);
    r.texture !== void 0 && t === !1 && r.texture.destroy(), r.msaaTexture !== void 0 && r.msaaTexture.destroy(), n.delete(e);
  }
  /**
   * Generates mipmaps for the given texture.
   *
   * @param {Texture} texture - The texture.
   * @param {?GPUCommandEncoder} [encoder=null] - An optional command encoder used to generate mipmaps.
   */
  generateMipmaps(e, t = null) {
    const n = this.backend.get(e);
    if (e.isCubeTexture)
      for (let r = 0; r < 6; r++)
        this._generateMipmaps(n.texture, n.textureDescriptorGPU, r, t);
    else {
      const r = e.image.depth || 1;
      for (let s = 0; s < r; s++)
        this._generateMipmaps(n.texture, n.textureDescriptorGPU, s, t);
    }
  }
  /**
   * Returns the color buffer representing the color
   * attachment of the default framebuffer.
   *
   * @return {GPUTexture} The color buffer.
   */
  getColorBuffer() {
    const e = this.backend, t = e.renderer.getCanvasTarget(), { width: n, height: r } = e.getDrawingBufferSize(), s = e.renderer.currentSamples, o = t.colorTexture, a = e.get(o);
    if (o.width === n && o.height === r && o.samples === s)
      return a.texture;
    let l = a.texture;
    return l && l.destroy(), l = e.device.createTexture({
      label: "colorBuffer",
      size: {
        width: n,
        height: r,
        depthOrArrayLayers: 1
      },
      sampleCount: e.utils.getSampleCount(e.renderer.currentSamples),
      format: e.utils.getPreferredCanvasFormat(),
      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC
    }), o.source.width = n, o.source.height = r, o.samples = s, a.texture = l, l;
  }
  /**
   * Returns the depth buffer representing the depth
   * attachment of the default framebuffer.
   *
   * @param {boolean} [depth=true] - Whether depth is enabled or not.
   * @param {boolean} [stencil=false] -  Whether stencil is enabled or not.
   * @return {GPUTexture} The depth buffer.
   */
  getDepthBuffer(e = !0, t = !1) {
    const n = this.backend, r = n.renderer.getCanvasTarget(), { width: s, height: o } = n.getDrawingBufferSize(), a = n.renderer.currentSamples, l = r.depthTexture;
    if (l.width === s && l.height === o && l.samples === a && l.depth === e && l.stencil === t)
      return n.get(l).texture;
    const u = n.get(l).texture;
    let c, A;
    if (t ? (c = ds, A = Js) : e && (c = Lr, A = Jn), u !== void 0) {
      if (l.image.width === s && l.image.height === o && l.format === c && l.type === A && l.samples === a)
        return u;
      this.destroyTexture(l);
    }
    return l.name = "depthBuffer", l.format = c, l.type = A, l.image.width = s, l.image.height = o, l.samples = a, this.createTexture(l, { width: s, height: o }), n.get(l).texture;
  }
  /**
   * Uploads the updated texture data to the GPU.
   *
   * @param {Texture} texture - The texture.
   * @param {Object} [options={}] - Optional configuration parameter.
   */
  updateTexture(e, t) {
    const n = this.backend.get(e), r = e.mipmaps, { textureDescriptorGPU: s } = n;
    if (!(e.isRenderTargetTexture || s === void 0)) {
      if (e.isDataTexture)
        if (r.length > 0)
          for (let o = 0, a = r.length; o < a; o++) {
            const l = r[o];
            this._copyBufferToTexture(l, n.texture, s, 0, e.flipY, 0, o);
          }
        else
          this._copyBufferToTexture(t.image, n.texture, s, 0, e.flipY);
      else if (e.isArrayTexture || e.isDataArrayTexture || e.isData3DTexture)
        for (let o = 0; o < t.image.depth; o++)
          this._copyBufferToTexture(t.image, n.texture, s, o, e.flipY, o);
      else if (e.isCompressedTexture || e.isCompressedArrayTexture)
        this._copyCompressedBufferToTexture(e.mipmaps, n.texture, s);
      else if (e.isCubeTexture)
        this._copyCubeMapToTexture(e, n.texture, s);
      else if (r.length > 0)
        for (let o = 0, a = r.length; o < a; o++) {
          const l = r[o];
          this._copyImageToTexture(l, n.texture, s, 0, e.flipY, e.premultiplyAlpha, o);
        }
      else
        this._copyImageToTexture(t.image, n.texture, s, 0, e.flipY, e.premultiplyAlpha);
      n.version = e.version;
    }
  }
  /**
   * Returns texture data as a typed array.
   *
   * @async
   * @param {Texture} texture - The texture to copy.
   * @param {number} x - The x coordinate of the copy origin.
   * @param {number} y - The y coordinate of the copy origin.
   * @param {number} width - The width of the copy.
   * @param {number} height - The height of the copy.
   * @param {number} faceIndex - The face index.
   * @return {Promise<TypedArray>} A Promise that resolves with a typed array when the copy operation has finished.
   */
  async copyTextureToBuffer(e, t, n, r, s, o) {
    const a = this.backend.device, l = this.backend.get(e), u = l.texture, c = l.textureDescriptorGPU.format, A = this._getBytesPerTexel(c);
    let m = r * A;
    m = Math.ceil(m / 256) * 256;
    const _ = a.createBuffer(
      {
        size: (s - 1) * m + r * A,
        // see https://github.com/mrdoob/three.js/issues/31658#issuecomment-3229442010
        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
      }
    ), y = a.createCommandEncoder();
    y.copyTextureToBuffer(
      {
        texture: u,
        origin: { x: t, y: n, z: o }
      },
      {
        buffer: _,
        bytesPerRow: m
      },
      {
        width: r,
        height: s
      }
    );
    const T = this._getTypedArrayType(c);
    a.queue.submit([y.finish()]), await _.mapAsync(GPUMapMode.READ);
    const b = _.getMappedRange();
    return new T(b);
  }
  /**
   * Frees all internal resources.
   */
  dispose() {
    this._samplerCache.clear();
  }
  /**
   * Returns the default GPU texture for the given format.
   *
   * @private
   * @param {string} format - The GPU format.
   * @return {GPUTexture} The GPU texture.
   */
  _getDefaultTextureGPU(e) {
    let t = this.defaultTexture[e];
    if (t === void 0) {
      const n = new Ii();
      n.minFilter = ei, n.magFilter = ei, this.createTexture(n, { width: 1, height: 1, format: e }), this.defaultTexture[e] = t = n;
    }
    return this.backend.get(t).texture;
  }
  /**
   * Returns the default GPU cube texture for the given format.
   *
   * @private
   * @param {string} format - The GPU format.
   * @return {GPUTexture} The GPU texture.
   */
  _getDefaultCubeTextureGPU(e) {
    let t = this.defaultCubeTexture[e];
    if (t === void 0) {
      const n = new Ju();
      n.minFilter = ei, n.magFilter = ei, this.createTexture(n, { width: 1, height: 1, depth: 6 }), this.defaultCubeTexture[e] = t = n;
    }
    return this.backend.get(t).texture;
  }
  /**
   * Uploads cube texture image data to the GPU memory.
   *
   * @private
   * @param {CubeTexture} texture - The cube texture.
   * @param {GPUTexture} textureGPU - The GPU texture.
   * @param {Object} textureDescriptorGPU - The GPU texture descriptor.
   */
  _copyCubeMapToTexture(e, t, n) {
    const r = e.images, s = e.mipmaps;
    for (let o = 0; o < 6; o++) {
      const a = r[o], l = e.flipY === !0 ? Wae[o] : o;
      a.isDataTexture ? this._copyBufferToTexture(a.image, t, n, l, e.flipY) : this._copyImageToTexture(a, t, n, l, e.flipY, e.premultiplyAlpha);
      for (let u = 0; u < s.length; u++) {
        const A = s[u].images[o];
        A.isDataTexture ? this._copyBufferToTexture(A.image, t, n, l, e.flipY, 0, u + 1) : this._copyImageToTexture(A, t, n, l, e.flipY, e.premultiplyAlpha, u + 1);
      }
    }
  }
  /**
   * Uploads texture image data to the GPU memory.
   *
   * @private
   * @param {HTMLImageElement|ImageBitmap|HTMLCanvasElement} image - The image data.
   * @param {GPUTexture} textureGPU - The GPU texture.
   * @param {Object} textureDescriptorGPU - The GPU texture descriptor.
   * @param {number} originDepth - The origin depth.
   * @param {boolean} flipY - Whether to flip texture data along their vertical axis or not.
   * @param {boolean} premultiplyAlpha - Whether the texture should have its RGB channels premultiplied by the alpha channel or not.
   * @param {number} [mipLevel=0] - The mip level where the data should be copied to.
   */
  _copyImageToTexture(e, t, n, r, s, o, a = 0) {
    const l = this.backend.device, u = a > 0 ? e.width : n.size.width, c = a > 0 ? e.height : n.size.height;
    try {
      l.queue.copyExternalImageToTexture(
        {
          source: e,
          flipY: s
        },
        {
          texture: t,
          mipLevel: a,
          origin: { x: 0, y: 0, z: r },
          premultipliedAlpha: o
        },
        {
          width: u,
          height: c,
          depthOrArrayLayers: 1
        }
      );
    } catch {
    }
  }
  /**
   * Returns the pass utils singleton.
   *
   * @private
   * @return {WebGPUTexturePassUtils} The utils instance.
   */
  _getPassUtils() {
    let e = this._passUtils;
    return e === null && (this._passUtils = e = new qae(this.backend.device)), e;
  }
  /**
   * Generates mipmaps for the given GPU texture.
   *
   * @private
   * @param {GPUTexture} textureGPU - The GPU texture object.
   * @param {Object} textureDescriptorGPU - The texture descriptor.
   * @param {number} [baseArrayLayer=0] - The index of the first array layer accessible to the texture view.
   * @param {?GPUCommandEncoder} [encoder=null] - An optional command encoder used to generate mipmaps.
   */
  _generateMipmaps(e, t, n = 0, r = null) {
    this._getPassUtils().generateMipmaps(e, t, n, r);
  }
  /**
   * Flip the contents of the given GPU texture along its vertical axis.
   *
   * @private
   * @param {GPUTexture} textureGPU - The GPU texture object.
   * @param {Object} textureDescriptorGPU - The texture descriptor.
   * @param {number} [originDepth=0] - The origin depth.
   */
  _flipY(e, t, n = 0) {
    this._getPassUtils().flipY(e, t, n);
  }
  /**
   * Uploads texture buffer data to the GPU memory.
   *
   * @private
   * @param {Object} image - An object defining the image buffer data.
   * @param {GPUTexture} textureGPU - The GPU texture.
   * @param {Object} textureDescriptorGPU - The GPU texture descriptor.
   * @param {number} originDepth - The origin depth.
   * @param {boolean} flipY - Whether to flip texture data along their vertical axis or not.
   * @param {number} [depth=0] - The depth offset when copying array or 3D texture data.
   * @param {number} [mipLevel=0] - The mip level where the data should be copied to.
   */
  _copyBufferToTexture(e, t, n, r, s, o = 0, a = 0) {
    const l = this.backend.device, u = e.data, c = this._getBytesPerTexel(n.format), A = e.width * c;
    l.queue.writeTexture(
      {
        texture: t,
        mipLevel: a,
        origin: { x: 0, y: 0, z: r }
      },
      u,
      {
        offset: e.width * e.height * c * o,
        bytesPerRow: A
      },
      {
        width: e.width,
        height: e.height,
        depthOrArrayLayers: 1
      }
    ), s === !0 && this._flipY(t, n, r);
  }
  /**
   * Uploads compressed texture data to the GPU memory.
   *
   * @private
   * @param {Array<Object>} mipmaps - An array with mipmap data.
   * @param {GPUTexture} textureGPU - The GPU texture.
   * @param {Object} textureDescriptorGPU - The GPU texture descriptor.
   */
  _copyCompressedBufferToTexture(e, t, n) {
    const r = this.backend.device, s = this._getBlockData(n.format), o = n.size.depthOrArrayLayers > 1;
    for (let a = 0; a < e.length; a++) {
      const l = e[a], u = l.width, c = l.height, A = o ? n.size.depthOrArrayLayers : 1, m = Math.ceil(u / s.width) * s.byteLength, _ = m * Math.ceil(c / s.height);
      for (let y = 0; y < A; y++)
        r.queue.writeTexture(
          {
            texture: t,
            mipLevel: a,
            origin: { x: 0, y: 0, z: y }
          },
          l.data,
          {
            offset: y * _,
            bytesPerRow: m,
            rowsPerImage: Math.ceil(c / s.height)
          },
          {
            width: Math.ceil(u / s.width) * s.width,
            height: Math.ceil(c / s.height) * s.height,
            depthOrArrayLayers: 1
          }
        );
    }
  }
  /**
   * This method is only relevant for compressed texture formats. It returns a block
   * data descriptor for the given GPU compressed texture format.
   *
   * @private
   * @param {string} format - The GPU compressed texture format.
   * @return {Object} The block data descriptor.
   */
  _getBlockData(e) {
    if (e === de.BC1RGBAUnorm || e === de.BC1RGBAUnormSRGB) return { byteLength: 8, width: 4, height: 4 };
    if (e === de.BC2RGBAUnorm || e === de.BC2RGBAUnormSRGB) return { byteLength: 16, width: 4, height: 4 };
    if (e === de.BC3RGBAUnorm || e === de.BC3RGBAUnormSRGB) return { byteLength: 16, width: 4, height: 4 };
    if (e === de.BC4RUnorm || e === de.BC4RSnorm) return { byteLength: 8, width: 4, height: 4 };
    if (e === de.BC5RGUnorm || e === de.BC5RGSnorm) return { byteLength: 16, width: 4, height: 4 };
    if (e === de.BC6HRGBUFloat || e === de.BC6HRGBFloat) return { byteLength: 16, width: 4, height: 4 };
    if (e === de.BC7RGBAUnorm || e === de.BC7RGBAUnormSRGB) return { byteLength: 16, width: 4, height: 4 };
    if (e === de.ETC2RGB8Unorm || e === de.ETC2RGB8UnormSRGB) return { byteLength: 8, width: 4, height: 4 };
    if (e === de.ETC2RGB8A1Unorm || e === de.ETC2RGB8A1UnormSRGB) return { byteLength: 8, width: 4, height: 4 };
    if (e === de.ETC2RGBA8Unorm || e === de.ETC2RGBA8UnormSRGB) return { byteLength: 16, width: 4, height: 4 };
    if (e === de.EACR11Unorm) return { byteLength: 8, width: 4, height: 4 };
    if (e === de.EACR11Snorm) return { byteLength: 8, width: 4, height: 4 };
    if (e === de.EACRG11Unorm) return { byteLength: 16, width: 4, height: 4 };
    if (e === de.EACRG11Snorm) return { byteLength: 16, width: 4, height: 4 };
    if (e === de.ASTC4x4Unorm || e === de.ASTC4x4UnormSRGB) return { byteLength: 16, width: 4, height: 4 };
    if (e === de.ASTC5x4Unorm || e === de.ASTC5x4UnormSRGB) return { byteLength: 16, width: 5, height: 4 };
    if (e === de.ASTC5x5Unorm || e === de.ASTC5x5UnormSRGB) return { byteLength: 16, width: 5, height: 5 };
    if (e === de.ASTC6x5Unorm || e === de.ASTC6x5UnormSRGB) return { byteLength: 16, width: 6, height: 5 };
    if (e === de.ASTC6x6Unorm || e === de.ASTC6x6UnormSRGB) return { byteLength: 16, width: 6, height: 6 };
    if (e === de.ASTC8x5Unorm || e === de.ASTC8x5UnormSRGB) return { byteLength: 16, width: 8, height: 5 };
    if (e === de.ASTC8x6Unorm || e === de.ASTC8x6UnormSRGB) return { byteLength: 16, width: 8, height: 6 };
    if (e === de.ASTC8x8Unorm || e === de.ASTC8x8UnormSRGB) return { byteLength: 16, width: 8, height: 8 };
    if (e === de.ASTC10x5Unorm || e === de.ASTC10x5UnormSRGB) return { byteLength: 16, width: 10, height: 5 };
    if (e === de.ASTC10x6Unorm || e === de.ASTC10x6UnormSRGB) return { byteLength: 16, width: 10, height: 6 };
    if (e === de.ASTC10x8Unorm || e === de.ASTC10x8UnormSRGB) return { byteLength: 16, width: 10, height: 8 };
    if (e === de.ASTC10x10Unorm || e === de.ASTC10x10UnormSRGB) return { byteLength: 16, width: 10, height: 10 };
    if (e === de.ASTC12x10Unorm || e === de.ASTC12x10UnormSRGB) return { byteLength: 16, width: 12, height: 10 };
    if (e === de.ASTC12x12Unorm || e === de.ASTC12x12UnormSRGB) return { byteLength: 16, width: 12, height: 12 };
  }
  /**
   * Converts the three.js uv wrapping constants to GPU address mode constants.
   *
   * @private
   * @param {number} value - The three.js constant defining a uv wrapping mode.
   * @return {string} The GPU address mode.
   */
  _convertAddressMode(e) {
    let t = _v.ClampToEdge;
    return e === zl ? t = _v.Repeat : e === ql && (t = _v.MirrorRepeat), t;
  }
  /**
   * Converts the three.js filter constants to GPU filter constants.
   *
   * @private
   * @param {number} value - The three.js constant defining a filter mode.
   * @return {string} The GPU filter mode.
   */
  _convertFilterMode(e) {
    let t = $c.Linear;
    return (e === ei || e === p0 || e === Aa) && (t = $c.Nearest), t;
  }
  /**
   * Returns the bytes-per-texel value for the given GPU texture format.
   *
   * @private
   * @param {string} format - The GPU texture format.
   * @return {number} The bytes-per-texel.
   */
  _getBytesPerTexel(e) {
    if (e === de.R8Unorm || e === de.R8Snorm || e === de.R8Uint || e === de.R8Sint) return 1;
    if (e === de.R16Uint || e === de.R16Sint || e === de.R16Float || e === de.RG8Unorm || e === de.RG8Snorm || e === de.RG8Uint || e === de.RG8Sint) return 2;
    if (e === de.R32Uint || e === de.R32Sint || e === de.R32Float || e === de.RG16Uint || e === de.RG16Sint || e === de.RG16Float || e === de.RGBA8Unorm || e === de.RGBA8UnormSRGB || e === de.RGBA8Snorm || e === de.RGBA8Uint || e === de.RGBA8Sint || e === de.BGRA8Unorm || e === de.BGRA8UnormSRGB || // Packed 32-bit formats
    e === de.RGB9E5UFloat || e === de.RGB10A2Unorm || e === de.RG11B10UFloat || e === de.Depth32Float || e === de.Depth24Plus || e === de.Depth24PlusStencil8 || e === de.Depth32FloatStencil8) return 4;
    if (e === de.RG32Uint || e === de.RG32Sint || e === de.RG32Float || e === de.RGBA16Uint || e === de.RGBA16Sint || e === de.RGBA16Float) return 8;
    if (e === de.RGBA32Uint || e === de.RGBA32Sint || e === de.RGBA32Float) return 16;
  }
  /**
   * Returns the corresponding typed array type for the given GPU texture format.
   *
   * @private
   * @param {string} format - The GPU texture format.
   * @return {TypedArray.constructor} The typed array type.
   */
  _getTypedArrayType(e) {
    if (e === de.R8Uint) return Uint8Array;
    if (e === de.R8Sint) return Int8Array;
    if (e === de.R8Unorm) return Uint8Array;
    if (e === de.R8Snorm) return Int8Array;
    if (e === de.RG8Uint) return Uint8Array;
    if (e === de.RG8Sint) return Int8Array;
    if (e === de.RG8Unorm) return Uint8Array;
    if (e === de.RG8Snorm) return Int8Array;
    if (e === de.RGBA8Uint) return Uint8Array;
    if (e === de.RGBA8Sint) return Int8Array;
    if (e === de.RGBA8Unorm || e === de.RGBA8UnormSRGB) return Uint8Array;
    if (e === de.RGBA8Snorm) return Int8Array;
    if (e === de.R16Uint) return Uint16Array;
    if (e === de.R16Sint) return Int16Array;
    if (e === de.RG16Uint) return Uint16Array;
    if (e === de.RG16Sint) return Int16Array;
    if (e === de.RGBA16Uint) return Uint16Array;
    if (e === de.RGBA16Sint) return Int16Array;
    if (e === de.R16Float || e === de.RG16Float || e === de.RGBA16Float) return Uint16Array;
    if (e === de.R32Uint) return Uint32Array;
    if (e === de.R32Sint) return Int32Array;
    if (e === de.R32Float) return Float32Array;
    if (e === de.RG32Uint) return Uint32Array;
    if (e === de.RG32Sint) return Int32Array;
    if (e === de.RG32Float) return Float32Array;
    if (e === de.RGBA32Uint) return Uint32Array;
    if (e === de.RGBA32Sint) return Int32Array;
    if (e === de.RGBA32Float) return Float32Array;
    if (e === de.BGRA8Unorm || e === de.BGRA8UnormSRGB) return Uint8Array;
    if (e === de.RGB10A2Unorm || e === de.RGB9E5UFloat || e === de.RG11B10UFloat) return Uint32Array;
    if (e === de.Depth32Float) return Float32Array;
    if (e === de.Depth24Plus || e === de.Depth24PlusStencil8) return Uint32Array;
    if (e === de.Depth32FloatStencil8) return Float32Array;
  }
  /**
   * Returns the GPU dimensions for the given texture.
   *
   * @private
   * @param {Texture} texture - The texture.
   * @return {string} The GPU dimension.
   */
  _getDimension(e) {
    let t;
    return e.is3DTexture || e.isData3DTexture ? t = CC.ThreeD : t = CC.TwoD, t;
  }
}
function n3(i, e = null) {
  const t = i.format, n = i.type, r = i.colorSpace, s = Xt.getTransfer(r);
  let o;
  if (i.isCompressedTexture === !0 || i.isCompressedArrayTexture === !0)
    switch (t) {
      case Rl:
      case Cl:
        o = s === vt ? de.BC1RGBAUnormSRGB : de.BC1RGBAUnorm;
        break;
      case Pl:
        o = s === vt ? de.BC2RGBAUnormSRGB : de.BC2RGBAUnorm;
        break;
      case Nl:
        o = s === vt ? de.BC3RGBAUnormSRGB : de.BC3RGBAUnorm;
        break;
      case Uh:
        o = de.BC4RUnorm;
        break;
      case Oh:
        o = de.BC4RSnorm;
        break;
      case Hu:
        o = de.BC5RGUnorm;
        break;
      case kh:
        o = de.BC5RGSnorm;
        break;
      case Fh:
        o = s === vt ? de.BC7RGBAUnormSRGB : de.BC7RGBAUnorm;
        break;
      case gh:
      case mh:
        o = s === vt ? de.ETC2RGB8UnormSRGB : de.ETC2RGB8Unorm;
        break;
      case _h:
        o = s === vt ? de.ETC2RGBA8UnormSRGB : de.ETC2RGBA8Unorm;
        break;
      case xh:
        o = de.EACR11Unorm;
        break;
      case yh:
        o = de.EACR11Snorm;
        break;
      case qu:
        o = de.EACRG11Unorm;
        break;
      case vh:
        o = de.EACRG11Snorm;
        break;
      case bh:
        o = s === vt ? de.ASTC4x4UnormSRGB : de.ASTC4x4Unorm;
        break;
      case Sh:
        o = s === vt ? de.ASTC5x4UnormSRGB : de.ASTC5x4Unorm;
        break;
      case Th:
        o = s === vt ? de.ASTC5x5UnormSRGB : de.ASTC5x5Unorm;
        break;
      case wh:
        o = s === vt ? de.ASTC6x5UnormSRGB : de.ASTC6x5Unorm;
        break;
      case Mh:
        o = s === vt ? de.ASTC6x6UnormSRGB : de.ASTC6x6Unorm;
        break;
      case Eh:
        o = s === vt ? de.ASTC8x5UnormSRGB : de.ASTC8x5Unorm;
        break;
      case Rh:
        o = s === vt ? de.ASTC8x6UnormSRGB : de.ASTC8x6Unorm;
        break;
      case Ch:
        o = s === vt ? de.ASTC8x8UnormSRGB : de.ASTC8x8Unorm;
        break;
      case Ph:
        o = s === vt ? de.ASTC10x5UnormSRGB : de.ASTC10x5Unorm;
        break;
      case Nh:
        o = s === vt ? de.ASTC10x6UnormSRGB : de.ASTC10x6Unorm;
        break;
      case Dh:
        o = s === vt ? de.ASTC10x8UnormSRGB : de.ASTC10x8Unorm;
        break;
      case Lh:
        o = s === vt ? de.ASTC10x10UnormSRGB : de.ASTC10x10Unorm;
        break;
      case Ih:
        o = s === vt ? de.ASTC12x10UnormSRGB : de.ASTC12x10Unorm;
        break;
      case Bh:
        o = s === vt ? de.ASTC12x12UnormSRGB : de.ASTC12x12Unorm;
        break;
      case Pi:
        o = s === vt ? de.RGBA8UnormSRGB : de.RGBA8Unorm;
        break;
      default:
        Ie("WebGPURenderer: Unsupported texture format.", t);
    }
  else
    switch (t) {
      case Pi:
        switch (n) {
          case Ou:
            o = de.RGBA8Snorm;
            break;
          case ku:
            o = de.RGBA16Sint;
            break;
          case Oo:
            o = de.RGBA16Uint;
            break;
          case Jn:
            o = de.RGBA32Uint;
            break;
          case _r:
            o = de.RGBA32Sint;
            break;
          case Mi:
            o = s === vt ? de.RGBA8UnormSRGB : de.RGBA8Unorm;
            break;
          case Ri:
            o = de.RGBA16Float;
            break;
          case Ei:
            o = de.RGBA32Float;
            break;
          default:
            Ie("WebGPURenderer: Unsupported texture type with RGBAFormat.", n);
        }
        break;
      case nA:
        switch (n) {
          case _0:
            o = de.RGB9E5UFloat;
            break;
          case x0:
            o = de.RG11B10UFloat;
            break;
          default:
            Ie("WebGPURenderer: Unsupported texture type with RGBFormat.", n);
        }
        break;
      case Yh:
        switch (n) {
          case Ou:
            o = de.R8Snorm;
            break;
          case ku:
            o = de.R16Sint;
            break;
          case Oo:
            o = de.R16Uint;
            break;
          case Jn:
            o = de.R32Uint;
            break;
          case _r:
            o = de.R32Sint;
            break;
          case Mi:
            o = de.R8Unorm;
            break;
          case Ri:
            o = de.R16Float;
            break;
          case Ei:
            o = de.R32Float;
            break;
          default:
            Ie("WebGPURenderer: Unsupported texture type with RedFormat.", n);
        }
        break;
      case fs:
        switch (n) {
          case Ou:
            o = de.RG8Snorm;
            break;
          case ku:
            o = de.RG16Sint;
            break;
          case Oo:
            o = de.RG16Uint;
            break;
          case Jn:
            o = de.RG32Uint;
            break;
          case _r:
            o = de.RG32Sint;
            break;
          case Mi:
            o = de.RG8Unorm;
            break;
          case Ri:
            o = de.RG16Float;
            break;
          case Ei:
            o = de.RG32Float;
            break;
          default:
            Ie("WebGPURenderer: Unsupported texture type with RGFormat.", n);
        }
        break;
      case Lr:
        switch (n) {
          case Oo:
            o = de.Depth16Unorm;
            break;
          case Jn:
            o = de.Depth24Plus;
            break;
          case Ei:
            o = de.Depth32Float;
            break;
          default:
            Ie("WebGPURenderer: Unsupported texture type with DepthFormat.", n);
        }
        break;
      case ds:
        switch (n) {
          case Js:
            o = de.Depth24PlusStencil8;
            break;
          case Ei:
            e && e.features.has(t3.Depth32FloatStencil8) === !1 && Ie('WebGPURenderer: Depth textures with DepthStencilFormat + FloatType can only be used with the "depth32float-stencil8" GPU feature.'), o = de.Depth32FloatStencil8;
            break;
          default:
            Ie("WebGPURenderer: Unsupported texture type with DepthStencilFormat.", n);
        }
        break;
      case Zu:
        switch (n) {
          case _r:
            o = de.R32Sint;
            break;
          case Jn:
            o = de.R32Uint;
            break;
          default:
            Ie("WebGPURenderer: Unsupported texture type with RedIntegerFormat.", n);
        }
        break;
      case Qh:
        switch (n) {
          case _r:
            o = de.RG32Sint;
            break;
          case Jn:
            o = de.RG32Uint;
            break;
          default:
            Ie("WebGPURenderer: Unsupported texture type with RGIntegerFormat.", n);
        }
        break;
      case Kh:
        switch (n) {
          case _r:
            o = de.RGBA32Sint;
            break;
          case Jn:
            o = de.RGBA32Uint;
            break;
          default:
            Ie("WebGPURenderer: Unsupported texture type with RGBAIntegerFormat.", n);
        }
        break;
      default:
        Ie("WebGPURenderer: Unsupported texture format.", t);
    }
  return o;
}
const jae = /^[fn]*\s*([a-z_0-9]+)?\s*\(([\s\S]*?)\)\s*[\-\>]*\s*([a-z_0-9]+(?:<[\s\S]+?>)?)/i, Xae = /([a-z_0-9]+)\s*:\s*([a-z_0-9]+(?:<[\s\S]+?>)?)/ig, NC = {
  f32: "float",
  i32: "int",
  u32: "uint",
  bool: "bool",
  "vec2<f32>": "vec2",
  "vec2<i32>": "ivec2",
  "vec2<u32>": "uvec2",
  "vec2<bool>": "bvec2",
  vec2f: "vec2",
  vec2i: "ivec2",
  vec2u: "uvec2",
  vec2b: "bvec2",
  "vec3<f32>": "vec3",
  "vec3<i32>": "ivec3",
  "vec3<u32>": "uvec3",
  "vec3<bool>": "bvec3",
  vec3f: "vec3",
  vec3i: "ivec3",
  vec3u: "uvec3",
  vec3b: "bvec3",
  "vec4<f32>": "vec4",
  "vec4<i32>": "ivec4",
  "vec4<u32>": "uvec4",
  "vec4<bool>": "bvec4",
  vec4f: "vec4",
  vec4i: "ivec4",
  vec4u: "uvec4",
  vec4b: "bvec4",
  "mat2x2<f32>": "mat2",
  mat2x2f: "mat2",
  "mat3x3<f32>": "mat3",
  mat3x3f: "mat3",
  "mat4x4<f32>": "mat4",
  mat4x4f: "mat4",
  sampler: "sampler",
  texture_1d: "texture",
  texture_2d: "texture",
  texture_2d_array: "texture",
  texture_multisampled_2d: "cubeTexture",
  texture_depth_2d: "depthTexture",
  texture_depth_2d_array: "depthTexture",
  texture_depth_multisampled_2d: "depthTexture",
  texture_depth_cube: "depthTexture",
  texture_depth_cube_array: "depthTexture",
  texture_3d: "texture3D",
  texture_cube: "cubeTexture",
  texture_cube_array: "cubeTexture",
  texture_storage_1d: "storageTexture",
  texture_storage_2d: "storageTexture",
  texture_storage_2d_array: "storageTexture",
  texture_storage_3d: "storageTexture"
}, Yae = (i) => {
  i = i.trim();
  const e = i.match(jae);
  if (e !== null && e.length === 4) {
    const t = e[2], n = [];
    let r = null;
    for (; (r = Xae.exec(t)) !== null; )
      n.push({ name: r[1], type: r[2] });
    const s = [];
    for (let c = 0; c < n.length; c++) {
      const { name: A, type: m } = n[c];
      let _ = m;
      _.startsWith("ptr") ? _ = "pointer" : (_.startsWith("texture") && (_ = m.split("<")[0]), _ = NC[_]), s.push(new aw(_, A));
    }
    const o = i.substring(e[0].length), a = e[3] || "void", l = e[1] !== void 0 ? e[1] : "";
    return {
      type: NC[a] || a,
      inputs: s,
      name: l,
      inputsCode: t,
      blockCode: o,
      outputType: a
    };
  } else
    throw new Error("FunctionNode: Function is not a WGSL code.");
};
class Qae extends uw {
  /**
   * Constructs a new WGSL node function.
   *
   * @param {string} source - The WGSL source.
   */
  constructor(e) {
    const { type: t, inputs: n, name: r, inputsCode: s, blockCode: o, outputType: a } = Yae(e);
    super(t, n, r), this.inputsCode = s, this.blockCode = o, this.outputType = a;
  }
  /**
   * This method returns the WGSL code of the node function.
   *
   * @param {string} [name=this.name] - The function's name.
   * @return {string} The shader code.
   */
  getCode(e = this.name) {
    const t = this.outputType !== "void" ? "-> " + this.outputType : "";
    return `fn ${e} ( ${this.inputsCode.trim()} ) ${t}` + this.blockCode;
  }
}
class Kae extends SI {
  /**
   * The method parses the given WGSL code an returns a node function.
   *
   * @param {string} source - The WGSL code.
   * @return {WGSLNodeFunction} A node function.
   */
  parseFunction(e) {
    return new Qae(e);
  }
}
const Zae = {
  [Xr.READ_ONLY]: "read",
  [Xr.WRITE_ONLY]: "write",
  [Xr.READ_WRITE]: "read_write"
}, DC = {
  [zl]: "repeat",
  [xr]: "clamp",
  [ql]: "mirror"
}, Cg = {
  vertex: sh.VERTEX,
  fragment: sh.FRAGMENT,
  compute: sh.COMPUTE
}, LC = {
  instance: !0,
  swizzleAssign: !1,
  storageBuffer: !0
}, Jae = {
  "^^": "tsl_xor"
}, ele = {
  float: "f32",
  int: "i32",
  uint: "u32",
  bool: "bool",
  color: "vec3<f32>",
  vec2: "vec2<f32>",
  ivec2: "vec2<i32>",
  uvec2: "vec2<u32>",
  bvec2: "vec2<bool>",
  vec3: "vec3<f32>",
  ivec3: "vec3<i32>",
  uvec3: "vec3<u32>",
  bvec3: "vec3<bool>",
  vec4: "vec4<f32>",
  ivec4: "vec4<i32>",
  uvec4: "vec4<u32>",
  bvec4: "vec4<bool>",
  mat2: "mat2x2<f32>",
  mat3: "mat3x3<f32>",
  mat4: "mat4x4<f32>"
}, IC = {}, rp = {
  tsl_xor: new Cr("fn tsl_xor( a : bool, b : bool ) -> bool { return ( a || b ) && !( a && b ); }"),
  mod_float: new Cr("fn tsl_mod_float( x : f32, y : f32 ) -> f32 { return x - y * floor( x / y ); }"),
  mod_vec2: new Cr("fn tsl_mod_vec2( x : vec2f, y : vec2f ) -> vec2f { return x - y * floor( x / y ); }"),
  mod_vec3: new Cr("fn tsl_mod_vec3( x : vec3f, y : vec3f ) -> vec3f { return x - y * floor( x / y ); }"),
  mod_vec4: new Cr("fn tsl_mod_vec4( x : vec4f, y : vec4f ) -> vec4f { return x - y * floor( x / y ); }"),
  equals_bool: new Cr("fn tsl_equals_bool( a : bool, b : bool ) -> bool { return a == b; }"),
  equals_bvec2: new Cr("fn tsl_equals_bvec2( a : vec2f, b : vec2f ) -> vec2<bool> { return vec2<bool>( a.x == b.x, a.y == b.y ); }"),
  equals_bvec3: new Cr("fn tsl_equals_bvec3( a : vec3f, b : vec3f ) -> vec3<bool> { return vec3<bool>( a.x == b.x, a.y == b.y, a.z == b.z ); }"),
  equals_bvec4: new Cr("fn tsl_equals_bvec4( a : vec4f, b : vec4f ) -> vec4<bool> { return vec4<bool>( a.x == b.x, a.y == b.y, a.z == b.z, a.w == b.w ); }"),
  repeatWrapping_float: new Cr("fn tsl_repeatWrapping_float( coord: f32 ) -> f32 { return fract( coord ); }"),
  mirrorWrapping_float: new Cr("fn tsl_mirrorWrapping_float( coord: f32 ) -> f32 { let mirrored = fract( coord * 0.5 ) * 2.0; return 1.0 - abs( 1.0 - mirrored ); }"),
  clampWrapping_float: new Cr("fn tsl_clampWrapping_float( coord: f32 ) -> f32 { return clamp( coord, 0.0, 1.0 ); }"),
  biquadraticTexture: new Cr(
    /* wgsl */
    `
fn tsl_biquadraticTexture( map : texture_2d<f32>, coord : vec2f, iRes : vec2u, level : u32 ) -> vec4f {

	let res = vec2f( iRes );

	let uvScaled = coord * res;
	let uvWrapping = ( ( uvScaled % res ) + res ) % res;

	// https://www.shadertoy.com/view/WtyXRy

	let uv = uvWrapping - 0.5;
	let iuv = floor( uv );
	let f = fract( uv );

	let rg1 = textureLoad( map, vec2u( iuv + vec2( 0.5, 0.5 ) ) % iRes, level );
	let rg2 = textureLoad( map, vec2u( iuv + vec2( 1.5, 0.5 ) ) % iRes, level );
	let rg3 = textureLoad( map, vec2u( iuv + vec2( 0.5, 1.5 ) ) % iRes, level );
	let rg4 = textureLoad( map, vec2u( iuv + vec2( 1.5, 1.5 ) ) % iRes, level );

	return mix( mix( rg1, rg2, f.x ), mix( rg3, rg4, f.x ), f.y );

}
`
  )
}, tle = {
  dFdx: "dpdx",
  dFdy: "- dpdy",
  mod_float: "tsl_mod_float",
  mod_vec2: "tsl_mod_vec2",
  mod_vec3: "tsl_mod_vec3",
  mod_vec4: "tsl_mod_vec4",
  equals_bool: "tsl_equals_bool",
  equals_bvec2: "tsl_equals_bvec2",
  equals_bvec3: "tsl_equals_bvec3",
  equals_bvec4: "tsl_equals_bvec4",
  inversesqrt: "inverseSqrt",
  bitcast: "bitcast<f32>",
  floatpack_snorm_2x16: "pack2x16snorm",
  floatpack_unorm_2x16: "pack2x16unorm",
  floatpack_float16_2x16: "pack2x16float",
  floatunpack_snorm_2x16: "unpack2x16snorm",
  floatunpack_unorm_2x16: "unpack2x16unorm",
  floatunpack_float16_2x16: "unpack2x16float"
};
let II = "";
(typeof navigator < "u" && /Firefox|Deno/g.test(navigator.userAgent)) !== !0 && (II += `diagnostic( off, derivative_uniformity );
`);
class nle extends bI {
  /**
   * Constructs a new WGSL node builder renderer.
   *
   * @param {Object3D} object - The 3D object.
   * @param {Renderer} renderer - The renderer.
   */
  constructor(e, t) {
    super(e, t, new Kae()), this.uniformGroups = {}, this.builtins = {}, this.directives = {}, this.scopedArrays = /* @__PURE__ */ new Map();
  }
  /**
   * Generates the WGSL snippet for sampled textures.
   *
   * @private
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The name of the texture uniform in the shader.
   * @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.
   * @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.
   * @param {?string} offsetSnippet - A WGSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.
   * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.
   * @return {string} The WGSL snippet.
   */
  _generateTextureSample(e, t, n, r, s, o = this.shaderStage) {
    return o === "fragment" ? r ? s ? `textureSample( ${t}, ${t}_sampler, ${n}, ${r}, ${s} )` : `textureSample( ${t}, ${t}_sampler, ${n}, ${r} )` : s ? `textureSample( ${t}, ${t}_sampler, ${n}, ${s} )` : `textureSample( ${t}, ${t}_sampler, ${n} )` : this.generateTextureSampleLevel(e, t, n, "0", r);
  }
  /**
   * Generates the WGSL snippet when sampling textures with explicit mip level.
   *
   * @private
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The name of the texture uniform in the shader.
   * @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.
   * @param {string} levelSnippet - A WGSL snippet that represents the mip level, with level 0 containing a full size version of the texture.
   * @param {string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.
   * @param {?string} offsetSnippet - A WGSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.
   * @return {string} The WGSL snippet.
   */
  generateTextureSampleLevel(e, t, n, r, s, o) {
    return this.isUnfilterable(e) === !1 ? o ? `textureSampleLevel( ${t}, ${t}_sampler, ${n}, ${r}, ${o} )` : `textureSampleLevel( ${t}, ${t}_sampler, ${n}, ${r} )` : this.isFilteredTexture(e) ? this.generateFilteredTexture(e, t, n, o, r) : this.generateTextureLod(e, t, n, s, o, r);
  }
  /**
   * Generates a wrap function used in context of textures.
   *
   * @param {Texture} texture - The texture to generate the function for.
   * @return {string} The name of the generated function.
   */
  generateWrapFunction(e) {
    const t = `tsl_coord_${DC[e.wrapS]}S_${DC[e.wrapT]}_${e.is3DTexture || e.isData3DTexture ? "3d" : "2d"}T`;
    let n = IC[t];
    if (n === void 0) {
      const r = [], s = e.is3DTexture || e.isData3DTexture ? "vec3f" : "vec2f";
      let o = `fn ${t}( coord : ${s} ) -> ${s} {

	return ${s}(
`;
      const a = (l, u) => {
        l === zl ? (r.push(rp.repeatWrapping_float), o += `		tsl_repeatWrapping_float( coord.${u} )`) : l === xr ? (r.push(rp.clampWrapping_float), o += `		tsl_clampWrapping_float( coord.${u} )`) : l === ql ? (r.push(rp.mirrorWrapping_float), o += `		tsl_mirrorWrapping_float( coord.${u} )`) : (o += `		coord.${u}`, Me(`WebGPURenderer: Unsupported texture wrap type "${l}" for vertex shader.`));
      };
      a(e.wrapS, "x"), o += `,
`, a(e.wrapT, "y"), (e.is3DTexture || e.isData3DTexture) && (o += `,
`, a(e.wrapR, "z")), o += `
	);

}
`, IC[t] = n = new Cr(o, r);
    }
    return n.build(this), t;
  }
  /**
   * Generates the array declaration string.
   *
   * @param {string} type - The type.
   * @param {?number} [count] - The count.
   * @return {string} The generated value as a shader string.
   */
  generateArrayDeclaration(e, t) {
    return `array< ${this.getType(e)}, ${t} >`;
  }
  /**
   * Generates a WGSL variable that holds the texture dimension of the given texture.
   * It also returns information about the number of layers (elements) of an arrayed
   * texture as well as the cube face count of cube textures.
   *
   * @param {Texture} texture - The texture to generate the function for.
   * @param {string} textureProperty - The name of the video texture uniform in the shader.
   * @param {string} levelSnippet - A WGSL snippet that represents the mip level, with level 0 containing a full size version of the texture.
   * @return {string} The name of the dimension variable.
   */
  generateTextureDimension(e, t, n) {
    const r = this.getDataFromNode(e, this.shaderStage, this.globalCache);
    r.dimensionsSnippet === void 0 && (r.dimensionsSnippet = {});
    let s = r.dimensionsSnippet[n];
    if (r.dimensionsSnippet[n] === void 0) {
      let o, a;
      const { primarySamples: l } = this.renderer.backend.utils.getTextureSampleData(e), u = l > 1;
      e.is3DTexture || e.isData3DTexture ? a = "vec3<u32>" : a = "vec2<u32>", u || e.isStorageTexture ? o = t : o = `${t}${n ? `, u32( ${n} )` : ""}`, s = new n1(new i1(`textureDimensions( ${o} )`, a)), r.dimensionsSnippet[n] = s, (e.isArrayTexture || e.isDataArrayTexture || e.is3DTexture || e.isData3DTexture) && (r.arrayLayerCount = new n1(
        new i1(
          `textureNumLayers(${t})`,
          "u32"
        )
      )), e.isTextureCube && (r.cubeFaceCount = new n1(
        new i1("6u", "u32")
      ));
    }
    return s.build(this);
  }
  /**
   * Generates the WGSL snippet for a manual filtered texture.
   *
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The name of the texture uniform in the shader.
   * @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.
   * @param {?string} offsetSnippet - A WGSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.
   * @param {string} [levelSnippet='0u'] - A WGSL snippet that represents the mip level, with level 0 containing a full size version of the texture.
   * @return {string} The WGSL snippet.
   */
  generateFilteredTexture(e, t, n, r, s = "0u") {
    this._include("biquadraticTexture");
    const o = this.generateWrapFunction(e), a = this.generateTextureDimension(e, t, s);
    return r && (n = `${n} + vec2<f32>(${r}) / ${a}`), `tsl_biquadraticTexture( ${t}, ${o}( ${n} ), ${a}, u32( ${s} ) )`;
  }
  /**
   * Generates the WGSL snippet for a texture lookup with explicit level-of-detail.
   * Since it's a lookup, no sampling or filtering is applied.
   *
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The name of the texture uniform in the shader.
   * @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.
   * @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.
   * @param {?string} offsetSnippet - A WGSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.
   * @param {string} [levelSnippet='0u'] - A WGSL snippet that represents the mip level, with level 0 containing a full size version of the texture.
   * @return {string} The WGSL snippet.
   */
  generateTextureLod(e, t, n, r, s, o = "0u") {
    const a = this.generateWrapFunction(e), l = this.generateTextureDimension(e, t, o), u = e.is3DTexture || e.isData3DTexture ? "vec3" : "vec2";
    s && (n = `${n} + ${u}<f32>(${s}) / ${u}<f32>( ${l} )`);
    const c = `${u}<u32>( ${a}( ${n} ) * ${u}<f32>( ${l} ) )`;
    return this.generateTextureLoad(e, t, c, o, r, null);
  }
  /**
   * Generates the WGSL snippet that reads a single texel from a texture without sampling or filtering.
   *
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The name of the texture uniform in the shader.
   * @param {string} uvIndexSnippet - A WGSL snippet that represents texture coordinates used for sampling.
   * @param {?string} levelSnippet - A WGSL snippet that represents the mip level, with level 0 containing a full size version of the texture.
   * @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.
   * @param {?string} offsetSnippet - A WGSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.
   * @return {string} The WGSL snippet.
   */
  generateTextureLoad(e, t, n, r, s, o) {
    r === null && (r = "0u"), o && (n = `${n} + ${o}`);
    let a;
    return s ? a = `textureLoad( ${t}, ${n}, ${s}, u32( ${r} ) )` : (a = `textureLoad( ${t}, ${n}, u32( ${r} ) )`, this.renderer.backend.compatibilityMode && e.isDepthTexture && (a += ".x")), a;
  }
  /**
   * Generates the WGSL snippet that writes a single texel to a texture.
   *
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The name of the texture uniform in the shader.
   * @param {string} uvIndexSnippet - A WGSL snippet that represents texture coordinates used for sampling.
   * @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.
   * @param {string} valueSnippet - A WGSL snippet that represent the new texel value.
   * @return {string} The WGSL snippet.
   */
  generateTextureStore(e, t, n, r, s) {
    let o;
    return r ? o = `textureStore( ${t}, ${n}, ${r}, ${s} )` : o = `textureStore( ${t}, ${n}, ${s} )`, o;
  }
  /**
   * Returns `true` if the sampled values of the given texture should be compared against a reference value.
   *
   * @param {Texture} texture - The texture.
   * @return {boolean} Whether the sampled values of the given texture should be compared against a reference value or not.
   */
  isSampleCompare(e) {
    return e.isDepthTexture === !0 && e.compareFunction !== null;
  }
  /**
   * Returns `true` if the given texture is unfilterable.
   *
   * @param {Texture} texture - The texture.
   * @return {boolean} Whether the given texture is unfilterable or not.
   */
  isUnfilterable(e) {
    return this.getComponentTypeFromTexture(e) !== "float" || !this.isAvailable("float32Filterable") && e.isDataTexture === !0 && e.type === Ei || this.isSampleCompare(e) === !1 && e.minFilter === ei && e.magFilter === ei || this.renderer.backend.utils.getTextureSampleData(e).primarySamples > 1;
  }
  /**
   * Generates the WGSL snippet for sampling/loading the given texture.
   *
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The name of the texture uniform in the shader.
   * @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.
   * @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.
   * @param {?string} offsetSnippet - A WGSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.
   * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.
   * @return {string} The WGSL snippet.
   */
  generateTexture(e, t, n, r, s, o = this.shaderStage) {
    let a = null;
    return this.isUnfilterable(e) ? a = this.generateTextureLod(e, t, n, r, s, "0", o) : a = this._generateTextureSample(e, t, n, r, s, o), a;
  }
  /**
   * Generates the WGSL snippet for sampling/loading the given texture using explicit gradients.
   *
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The name of the texture uniform in the shader.
   * @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.
   * @param {Array<string>} gradSnippet - An array holding both gradient WGSL snippets.
   * @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.
   * @param {?string} offsetSnippet - A WGSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.
   * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.
   * @return {string} The WGSL snippet.
   */
  generateTextureGrad(e, t, n, r, s, o, a = this.shaderStage) {
    if (a === "fragment")
      return o ? `textureSampleGrad( ${t}, ${t}_sampler, ${n},  ${r[0]}, ${r[1]}, ${o} )` : `textureSampleGrad( ${t}, ${t}_sampler, ${n},  ${r[0]}, ${r[1]} )`;
    Ie(`WebGPURenderer: THREE.TextureNode.gradient() does not support ${a} shader.`);
  }
  /**
   * Generates the WGSL snippet for sampling a depth texture and comparing the sampled depth values
   * against a reference value.
   *
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The name of the texture uniform in the shader.
   * @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.
   * @param {string} compareSnippet -  A WGSL snippet that represents the reference value.
   * @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.
   * @param {?string} offsetSnippet - A WGSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.
   * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.
   * @return {string} The WGSL snippet.
   */
  generateTextureCompare(e, t, n, r, s, o, a = this.shaderStage) {
    if (a === "fragment")
      return e.isDepthTexture === !0 && e.isArrayTexture === !0 ? o ? `textureSampleCompare( ${t}, ${t}_sampler, ${n}, ${s}, ${r}, ${o} )` : `textureSampleCompare( ${t}, ${t}_sampler, ${n}, ${s}, ${r} )` : o ? `textureSampleCompare( ${t}, ${t}_sampler, ${n}, ${r}, ${o} )` : `textureSampleCompare( ${t}, ${t}_sampler, ${n}, ${r} )`;
    Ie(`WebGPURenderer: THREE.DepthTexture.compareFunction() does not support ${a} shader.`);
  }
  /**
   * Generates the WGSL snippet when sampling textures with explicit mip level.
   *
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The name of the texture uniform in the shader.
   * @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.
   * @param {string} levelSnippet - A WGSL snippet that represents the mip level, with level 0 containing a full size version of the texture.
   * @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.
   * @param {?string} offsetSnippet - A WGSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.
   * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.
   * @return {string} The WGSL snippet.
   */
  generateTextureLevel(e, t, n, r, s, o) {
    return this.isUnfilterable(e) === !1 ? o ? `textureSampleLevel( ${t}, ${t}_sampler, ${n}, ${r}, ${o} )` : `textureSampleLevel( ${t}, ${t}_sampler, ${n}, ${r} )` : this.isFilteredTexture(e) ? this.generateFilteredTexture(e, t, n, o, r) : this.generateTextureLod(e, t, n, s, o, r);
  }
  /**
   * Generates the WGSL snippet when sampling textures with a bias to the mip level.
   *
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The name of the texture uniform in the shader.
   * @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.
   * @param {string} biasSnippet - A WGSL snippet that represents the bias to apply to the mip level before sampling.
   * @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.
   * @param {?string} offsetSnippet - A WGSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.
   * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.
   * @return {string} The WGSL snippet.
   */
  generateTextureBias(e, t, n, r, s, o, a = this.shaderStage) {
    if (a === "fragment")
      return o ? `textureSampleBias( ${t}, ${t}_sampler, ${n}, ${r}, ${o} )` : `textureSampleBias( ${t}, ${t}_sampler, ${n}, ${r} )`;
    Ie(`WebGPURenderer: THREE.TextureNode.biasNode does not support ${a} shader.`);
  }
  /**
   * Returns a WGSL snippet that represents the property name of the given node.
   *
   * @param {Node} node - The node.
   * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.
   * @return {string} The property name.
   */
  getPropertyName(e, t = this.shaderStage) {
    if (e.isNodeVarying === !0 && e.needsInterpolation === !0) {
      if (t === "vertex")
        return `varyings.${e.name}`;
    } else if (e.isNodeUniform === !0) {
      const n = e.name, r = e.type;
      return r === "texture" || r === "cubeTexture" || r === "cubeDepthTexture" || r === "storageTexture" || r === "texture3D" ? n : r === "buffer" || r === "storageBuffer" || r === "indirectStorageBuffer" ? this.isCustomStruct(e) ? n : n + ".value" : e.groupNode.name + "." + n;
    }
    return super.getPropertyName(e);
  }
  /**
   * Returns the output struct name.
   *
   * @return {string} The name of the output struct.
   */
  getOutputStructName() {
    return "output";
  }
  /**
   * Returns the native shader operator name for a given generic name.
   *
   * @param {string} op - The operator name to resolve.
   * @return {?string} The resolved operator name.
   */
  getFunctionOperator(e) {
    const t = Jae[e];
    return t !== void 0 ? (this._include(t), t) : null;
  }
  /**
   * Returns the node access for the given node and shader stage.
   *
   * @param {StorageTextureNode|StorageBufferNode} node - The storage node.
   * @param {string} shaderStage - The shader stage.
   * @return {string} The node access.
   */
  getNodeAccess(e, t) {
    return t !== "compute" ? e.isAtomic === !0 ? (Me("WebGPURenderer: Atomic operations are only supported in compute shaders."), Xr.READ_WRITE) : Xr.READ_ONLY : e.access;
  }
  /**
   * Returns A WGSL snippet representing the storage access.
   *
   * @param {StorageTextureNode|StorageBufferNode} node - The storage node.
   * @param {string} shaderStage - The shader stage.
   * @return {string} The WGSL snippet representing the storage access.
   */
  getStorageAccess(e, t) {
    return Zae[this.getNodeAccess(e, t)];
  }
  /**
   * This method is one of the more important ones since it's responsible
   * for generating a matching binding instance for the given uniform node.
   *
   * These bindings are later used in the renderer to create bind groups
   * and layouts.
   *
   * @param {UniformNode} node - The uniform node.
   * @param {string} type - The node data type.
   * @param {string} shaderStage - The shader stage.
   * @param {?string} [name=null] - An optional uniform name.
   * @return {NodeUniform} The node uniform object.
   */
  getUniformFromNode(e, t, n, r = null) {
    const s = super.getUniformFromNode(e, t, n, r), o = this.getDataFromNode(e, n, this.globalCache);
    if (o.uniformGPU === void 0) {
      let a;
      const l = e.groupNode, u = l.name, c = this.getBindGroupArray(u, n);
      if (t === "texture" || t === "cubeTexture" || t === "cubeDepthTexture" || t === "storageTexture" || t === "texture3D") {
        let A = null;
        const m = this.getNodeAccess(e, n);
        if (t === "texture" || t === "storageTexture" ? e.value.is3DTexture === !0 ? A = new e3(s.name, s.node, l, m) : A = new rx(s.name, s.node, l, m) : t === "cubeTexture" || t === "cubeDepthTexture" ? A = new NI(s.name, s.node, l, m) : t === "texture3D" && (A = new e3(s.name, s.node, l, m)), A.store = e.isStorageTextureNode === !0, A.mipLevel = A.store ? e.mipLevel : 0, A.setVisibility(Cg[n]), this.isUnfilterable(e.value) === !1 && A.store === !1) {
          const _ = new kae(`${s.name}_sampler`, s.node, l);
          _.setVisibility(Cg[n]), c.push(_, A), a = [_, A];
        } else
          c.push(A), a = [A];
      } else if (t === "buffer" || t === "storageBuffer" || t === "indirectStorageBuffer") {
        const A = this.getSharedDataFromNode(e);
        let m = A.buffer;
        if (m === void 0) {
          const _ = t === "buffer" ? RI : zae;
          m = new _(e, l), A.buffer = m;
        }
        m.setVisibility(m.getVisibility() | Cg[n]), c.push(m), a = m, s.name = r || "NodeBuffer_" + s.id;
      } else {
        const A = this.uniformGroups[n] || (this.uniformGroups[n] = {});
        let m = A[u];
        m === void 0 && (m = new CI(u, l), m.setVisibility(Cg[n]), A[u] = m, c.push(m)), a = this.getNodeUniform(s, t), m.addUniform(a);
      }
      o.uniformGPU = a;
    }
    return s;
  }
  /**
   * This method should be used whenever builtins are required in nodes.
   * The internal builtins data structure will make sure builtins are
   * defined in the WGSL source.
   *
   * @param {string} name - The builtin name.
   * @param {string} property - The property name.
   * @param {string} type - The node data type.
   * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.
   * @return {string} The property name.
   */
  getBuiltin(e, t, n, r = this.shaderStage) {
    const s = this.builtins[r] || (this.builtins[r] = /* @__PURE__ */ new Map());
    return s.has(e) === !1 && s.set(e, {
      name: e,
      property: t,
      type: n
    }), t;
  }
  /**
   * Returns `true` if the given builtin is defined in the given shader stage.
   *
   * @param {string} name - The builtin name.
   * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.
   * @return {boolean} Whether the given builtin is defined in the given shader stage or not.
   */
  hasBuiltin(e, t = this.shaderStage) {
    return this.builtins[t] !== void 0 && this.builtins[t].has(e);
  }
  /**
   * Returns the vertex index builtin.
   *
   * @return {string} The vertex index.
   */
  getVertexIndex() {
    return this.shaderStage === "vertex" ? this.getBuiltin("vertex_index", "vertexIndex", "u32", "attribute") : "vertexIndex";
  }
  /**
   * Builds the given shader node.
   *
   * @param {ShaderNodeInternal} shaderNode - The shader node.
   * @return {string} The WGSL function code.
   */
  buildFunctionCode(e) {
    const t = e.layout, n = this.flowShaderNode(e), r = [];
    for (const o of t.inputs)
      r.push(o.name + " : " + this.getType(o.type));
    let s = `fn ${t.name}( ${r.join(", ")} ) -> ${this.getType(t.type)} {
${n.vars}
${n.code}
`;
    return n.result && (s += `	return ${n.result};
`), s += `
}
`, s;
  }
  /**
   * Contextually returns either the vertex stage instance index builtin
   * or the linearized index of an compute invocation within a grid of workgroups.
   *
   * @return {string} The instance index.
   */
  getInstanceIndex() {
    return this.shaderStage === "vertex" ? this.getBuiltin("instance_index", "instanceIndex", "u32", "attribute") : "instanceIndex";
  }
  /**
   * Returns a builtin representing the index of a compute invocation within the scope of a workgroup load.
   *
   * @return {string} The invocation local index.
   */
  getInvocationLocalIndex() {
    return this.getBuiltin("local_invocation_index", "invocationLocalIndex", "u32", "attribute");
  }
  /**
   * Returns a builtin representing the size of a subgroup within the current shader.
   *
   * @return {string} The subgroup size.
   */
  getSubgroupSize() {
    return this.enableSubGroups(), this.getBuiltin("subgroup_size", "subgroupSize", "u32", "attribute");
  }
  /**
   * Returns a builtin representing the index of a compute invocation within the scope of a subgroup.
   *
   * @return {string} The invocation subgroup index.
   */
  getInvocationSubgroupIndex() {
    return this.enableSubGroups(), this.getBuiltin("subgroup_invocation_id", "invocationSubgroupIndex", "u32", "attribute");
  }
  /**
   * Returns a builtin representing the index of a compute invocation's subgroup within its workgroup.
   *
   * @return {string} The subgroup index.
   */
  getSubgroupIndex() {
    return this.enableSubGroups(), this.getBuiltin("subgroup_id", "subgroupIndex", "u32", "attribute");
  }
  /**
   * Overwritten as a NOP since this method is intended for the WebGL 2 backend.
   *
   * @return {null} Null.
   */
  getDrawIndex() {
    return null;
  }
  /**
   * Returns the front facing builtin.
   *
   * @return {string} The front facing builtin.
   */
  getFrontFacing() {
    return this.getBuiltin("front_facing", "isFront", "bool");
  }
  /**
   * Returns the frag coord builtin.
   *
   * @return {string} The frag coord builtin.
   */
  getFragCoord() {
    return this.getBuiltin("position", "fragCoord", "vec4<f32>") + ".xy";
  }
  /**
   * Returns the frag depth builtin.
   *
   * @return {string} The frag depth builtin.
   */
  getFragDepth() {
    return "output." + this.getBuiltin("frag_depth", "depth", "f32", "output");
  }
  /**
   * Returns the clip distances builtin.
   *
   * @return {string} The clip distances builtin.
   */
  getClipDistance() {
    return "varyings.hw_clip_distances";
  }
  /**
   * Whether to flip texture data along its vertical axis or not.
   *
   * @return {boolean} Returns always `false` in context of WGSL.
   */
  isFlipY() {
    return !1;
  }
  /**
   * Enables the given directive for the given shader stage.
   *
   * @param {string} name - The directive name.
   * @param {string} [shaderStage=this.shaderStage] - The shader stage to enable the directive for.
   */
  enableDirective(e, t = this.shaderStage) {
    (this.directives[t] || (this.directives[t] = /* @__PURE__ */ new Set())).add(e);
  }
  /**
   * Returns the directives of the given shader stage as a WGSL string.
   *
   * @param {string} shaderStage - The shader stage.
   * @return {string} A WGSL snippet that enables the directives of the given stage.
   */
  getDirectives(e) {
    const t = [], n = this.directives[e];
    if (n !== void 0)
      for (const r of n)
        t.push(`enable ${r};`);
    return t.join(`
`);
  }
  /**
   * Enables the 'subgroups' directive.
   */
  enableSubGroups() {
    this.enableDirective("subgroups");
  }
  /**
   * Enables the 'subgroups-f16' directive.
   */
  enableSubgroupsF16() {
    this.enableDirective("subgroups-f16");
  }
  /**
   * Enables the 'clip_distances' directive.
   */
  enableClipDistances() {
    this.enableDirective("clip_distances");
  }
  /**
   * Enables the 'f16' directive.
   */
  enableShaderF16() {
    this.enableDirective("f16");
  }
  /**
   * Enables the 'dual_source_blending' directive.
   */
  enableDualSourceBlending() {
    this.enableDirective("dual_source_blending");
  }
  /**
   * Enables hardware clipping.
   *
   * @param {string} planeCount - The clipping plane count.
   */
  enableHardwareClipping(e) {
    this.enableClipDistances(), this.getBuiltin("clip_distances", "hw_clip_distances", `array<f32, ${e} >`, "vertex");
  }
  /**
   * Returns the builtins of the given shader stage as a WGSL string.
   *
   * @param {string} shaderStage - The shader stage.
   * @return {string} A WGSL snippet that represents the builtins of the given stage.
   */
  getBuiltins(e) {
    const t = [], n = this.builtins[e];
    if (n !== void 0)
      for (const { name: r, property: s, type: o } of n.values())
        t.push(`@builtin( ${r} ) ${s} : ${o}`);
    return t.join(`,
	`);
  }
  /**
   * This method should be used when a new scoped buffer is used in context of
   * compute shaders. It adds the array to the internal data structure which is
   * later used to generate the respective WGSL.
   *
   * @param {string} name - The array name.
   * @param {string} scope - The scope.
   * @param {string} bufferType - The buffer type.
   * @param {string} bufferCount - The buffer count.
   * @return {string} The array name.
   */
  getScopedArray(e, t, n, r) {
    return this.scopedArrays.has(e) === !1 && this.scopedArrays.set(e, {
      name: e,
      scope: t,
      bufferType: n,
      bufferCount: r
    }), e;
  }
  /**
   * Returns the scoped arrays of the given shader stage as a WGSL string.
   *
   * @param {string} shaderStage - The shader stage.
   * @return {string|undefined} The WGSL snippet that defines the scoped arrays.
   * Returns `undefined` when used in the vertex or fragment stage.
   */
  getScopedArrays(e) {
    if (e !== "compute")
      return;
    const t = [];
    for (const { name: n, scope: r, bufferType: s, bufferCount: o } of this.scopedArrays.values()) {
      const a = this.getType(s);
      t.push(`var<${r}> ${n}: array< ${a}, ${o} >;`);
    }
    return t.join(`
`);
  }
  /**
   * Returns the shader attributes of the given shader stage as a WGSL string.
   *
   * @param {string} shaderStage - The shader stage.
   * @return {string} The WGSL snippet that defines the shader attributes.
   */
  getAttributes(e) {
    const t = [];
    if (e === "compute" && (this.getBuiltin("global_invocation_id", "globalId", "vec3<u32>", "attribute"), this.getBuiltin("workgroup_id", "workgroupId", "vec3<u32>", "attribute"), this.getBuiltin("local_invocation_id", "localId", "vec3<u32>", "attribute"), this.getBuiltin("num_workgroups", "numWorkgroups", "vec3<u32>", "attribute"), this.renderer.hasFeature("subgroups") && (this.enableDirective("subgroups", e), this.getBuiltin("subgroup_size", "subgroupSize", "u32", "attribute"))), e === "vertex" || e === "compute") {
      const n = this.getBuiltins("attribute");
      n && t.push(n);
      const r = this.getAttributesArray();
      for (let s = 0, o = r.length; s < o; s++) {
        const a = r[s], l = a.name, u = this.getType(a.type);
        t.push(`@location( ${s} ) ${l} : ${u}`);
      }
    }
    return t.join(`,
	`);
  }
  /**
   * Returns the members of the given struct type node as a WGSL string.
   *
   * @param {StructTypeNode} struct - The struct type node.
   * @return {string} The WGSL snippet that defines the struct members.
   */
  getStructMembers(e) {
    const t = [];
    for (const n of e.members) {
      const r = e.output ? "@location( " + n.index + " ) " : "";
      let s = this.getType(n.type);
      n.atomic && (s = "atomic< " + s + " >"), t.push(`	${r + n.name} : ${s}`);
    }
    return e.output && t.push(`	${this.getBuiltins("output")}`), t.join(`,
`);
  }
  /**
   * Returns the structs of the given shader stage as a WGSL string.
   *
   * @param {string} shaderStage - The shader stage.
   * @return {string} The WGSL snippet that defines the structs.
   */
  getStructs(e) {
    let t = "";
    const n = this.structs[e];
    if (n.length > 0) {
      const r = [];
      for (const s of n) {
        let o = `struct ${s.name} {
`;
        o += this.getStructMembers(s), o += `
};`, r.push(o);
      }
      t = `
` + r.join(`

`) + `
`;
    }
    return t;
  }
  /**
   * Returns a WGSL string representing a variable.
   *
   * @param {string} type - The variable's type.
   * @param {string} name - The variable's name.
   * @param {?number} [count=null] - The array length.
   * @return {string} The WGSL snippet that defines a variable.
   */
  getVar(e, t, n = null) {
    let r = `var ${t} : `;
    return n !== null ? r += this.generateArrayDeclaration(e, n) : r += this.getType(e), r;
  }
  /**
   * Returns the variables of the given shader stage as a WGSL string.
   *
   * @param {string} shaderStage - The shader stage.
   * @return {string} The WGSL snippet that defines the variables.
   */
  getVars(e) {
    const t = [], n = this.vars[e];
    if (n !== void 0)
      for (const r of n)
        t.push(`	${this.getVar(r.type, r.name, r.count)};`);
    return `
${t.join(`
`)}
`;
  }
  /**
   * Returns the varyings of the given shader stage as a WGSL string.
   *
   * @param {string} shaderStage - The shader stage.
   * @return {string} The WGSL snippet that defines the varyings.
   */
  getVaryings(e) {
    const t = [];
    if (e === "vertex" && this.getBuiltin("position", "Vertex", "vec4<f32>", "vertex"), e === "vertex" || e === "fragment") {
      const s = this.varyings, o = this.vars[e];
      for (let a = 0; a < s.length; a++) {
        const l = s[a];
        if (l.needsInterpolation) {
          let u = `@location( ${a} )`;
          if (l.interpolationType) {
            const c = l.interpolationSampling !== null ? `, ${l.interpolationSampling} )` : " )";
            u += ` @interpolate( ${l.interpolationType}${c}`;
          } else /^(int|uint|ivec|uvec)/.test(l.type) && (u += ` @interpolate( ${this.renderer.backend.compatibilityMode ? "flat, either" : "flat"} )`);
          t.push(`${u} ${l.name} : ${this.getType(l.type)}`);
        } else e === "vertex" && o.includes(l) === !1 && o.push(l);
      }
    }
    const n = this.getBuiltins(e);
    n && t.push(n);
    const r = t.join(`,
	`);
    return e === "vertex" ? this._getWGSLStruct("VaryingsStruct", "	" + r) : r;
  }
  isCustomStruct(e) {
    const t = e.value, n = e.node, r = (t.isBufferAttribute || t.isInstancedBufferAttribute) && n.structTypeNode !== null, s = n.value && n.value.array && typeof n.value.itemSize == "number" && n.value.array.length > n.value.itemSize;
    return r && !s;
  }
  /**
   * Returns the uniforms of the given shader stage as a WGSL string.
   *
   * @param {string} shaderStage - The shader stage.
   * @return {string} The WGSL snippet that defines the uniforms.
   */
  getUniforms(e) {
    const t = this.uniforms[e], n = [], r = [], s = [], o = {};
    for (const l of t) {
      const u = l.groupNode.name, c = this.bindingsIndexes[u];
      if (l.type === "texture" || l.type === "cubeTexture" || l.type === "cubeDepthTexture" || l.type === "storageTexture" || l.type === "texture3D") {
        const A = l.node.value;
        this.isUnfilterable(A) === !1 && l.node.isStorageTextureNode !== !0 && (this.isSampleCompare(A) ? n.push(`@binding( ${c.binding++} ) @group( ${c.group} ) var ${l.name}_sampler : sampler_comparison;`) : n.push(`@binding( ${c.binding++} ) @group( ${c.group} ) var ${l.name}_sampler : sampler;`));
        let m, _ = "";
        const { primarySamples: y } = this.renderer.backend.utils.getTextureSampleData(A);
        if (y > 1 && (_ = "_multisampled"), A.isCubeTexture === !0 && A.isDepthTexture === !0)
          m = "texture_depth_cube";
        else if (A.isCubeTexture === !0)
          m = "texture_cube<f32>";
        else if (A.isDepthTexture === !0)
          this.renderer.backend.compatibilityMode && A.compareFunction === null ? m = `texture${_}_2d<f32>` : m = `texture_depth${_}_2d${A.isArrayTexture === !0 ? "_array" : ""}`;
        else if (l.node.isStorageTextureNode === !0) {
          const T = n3(A), b = this.getStorageAccess(l.node, e), S = l.node.value.is3DTexture, E = l.node.value.isArrayTexture;
          m = `texture_storage_${S ? "3d" : `2d${E ? "_array" : ""}`}<${T}, ${b}>`;
        } else if (A.isArrayTexture === !0 || A.isDataArrayTexture === !0 || A.isCompressedArrayTexture === !0)
          m = "texture_2d_array<f32>";
        else if (A.is3DTexture === !0 || A.isData3DTexture === !0)
          m = "texture_3d<f32>";
        else {
          const T = this.getComponentTypeFromTexture(A).charAt(0);
          m = `texture${_}_2d<${T}32>`;
        }
        n.push(`@binding( ${c.binding++} ) @group( ${c.group} ) var ${l.name} : ${m};`);
      } else if (l.type === "buffer" || l.type === "storageBuffer" || l.type === "indirectStorageBuffer") {
        const A = l.node, m = this.getType(A.getNodeType(this)), _ = A.bufferCount, y = _ > 0 && l.type === "buffer" ? ", " + _ : "", T = A.isStorageBufferNode ? `storage, ${this.getStorageAccess(A, e)}` : "uniform";
        if (this.isCustomStruct(l))
          r.push(`@binding( ${c.binding++} ) @group( ${c.group} ) var<${T}> ${l.name} : ${m};`);
        else {
          const S = `	value : array< ${A.isAtomic ? `atomic<${m}>` : `${m}`}${y} >`;
          r.push(this._getWGSLStructBinding(l.name, S, T, c.binding++, c.group));
        }
      } else {
        const A = this.getType(this.getVectorType(l.type)), m = l.groupNode.name;
        (o[m] || (o[m] = {
          index: c.binding++,
          id: c.group,
          snippets: []
        })).snippets.push(`	${l.name} : ${A}`);
      }
    }
    for (const l in o) {
      const u = o[l];
      s.push(this._getWGSLStructBinding(l, u.snippets.join(`,
`), "uniform", u.index, u.id));
    }
    return [...n, ...r, ...s].join(`
`);
  }
  /**
   * Controls the code build of the shader stages.
   */
  buildCode() {
    const e = this.material !== null ? { fragment: {}, vertex: {} } : { compute: {} };
    this.sortBindingGroups();
    for (const t in e) {
      this.shaderStage = t;
      const n = e[t];
      n.uniforms = this.getUniforms(t), n.attributes = this.getAttributes(t), n.varyings = this.getVaryings(t), n.structs = this.getStructs(t), n.vars = this.getVars(t), n.codes = this.getCodes(t), n.directives = this.getDirectives(t), n.scopedArrays = this.getScopedArrays(t);
      let r = `// code

`;
      r += this.flowCode[t];
      const s = this.flowNodes[t], o = s[s.length - 1], a = o.outputNode, l = a !== void 0 && a.isOutputStructNode === !0;
      for (const u of s) {
        const c = this.getFlowData(
          u
          /*, shaderStage*/
        ), A = u.name;
        if (A && (r.length > 0 && (r += `
`), r += `	// flow -> ${A}
`), r += `${c.code}
	`, u === o && t !== "compute") {
          if (r += `// result

	`, t === "vertex")
            r += `varyings.Vertex = ${c.result};`;
          else if (t === "fragment")
            if (l)
              n.returnType = a.getNodeType(this), n.structs += "var<private> output : " + n.returnType + ";", r += `return ${c.result};`;
            else {
              let m = "	@location(0) color: vec4<f32>";
              const _ = this.getBuiltins("output");
              _ && (m += `,
	` + _), n.returnType = "OutputStruct", n.structs += this._getWGSLStruct("OutputStruct", m), n.structs += `
var<private> output : OutputStruct;`, r += `output.color = ${c.result};

	return output;`;
            }
        }
      }
      n.flow = r;
    }
    if (this.shaderStage = null, this.material !== null)
      this.vertexShader = this._getWGSLVertexCode(e.vertex), this.fragmentShader = this._getWGSLFragmentCode(e.fragment);
    else {
      const t = this.object.workgroupSize;
      this.computeShader = this._getWGSLComputeCode(e.compute, t);
    }
  }
  /**
   * Returns the native shader method name for a given generic name.
   *
   * @param {string} method - The method name to resolve.
   * @param {?string} [output=null] - An optional output.
   * @return {string} The resolved WGSL method name.
   */
  getMethod(e, t = null) {
    let n;
    return t !== null && (n = this._getWGSLMethod(e + "_" + t)), n === void 0 && (n = this._getWGSLMethod(e)), n || e;
  }
  /**
   * Returns the bitcast method name for a given input and outputType.
   *
   * @param {string} type - The output type to bitcast to.
   * @return {string} The resolved WGSL bitcast invocation.
   */
  getBitcastMethod(e) {
    return `bitcast<${this.getType(e)}>`;
  }
  /**
   * Returns the float packing method name for a given numeric encoding.
   *
   * @param {string} encoding - The numeric encoding that describes how the float values are mapped to the integer range.
   * @returns {string} The resolve WGSL float packing method name.
   */
  getFloatPackingMethod(e) {
    return this.getMethod(`floatpack_${e}_2x16`);
  }
  /**
   * Returns the float unpacking method name for a given numeric encoding.
   *
   * @param {string} encoding - The numeric encoding that describes how the integer values are mapped to the float range.
   * @returns {string} The resolve WGSL float unpacking method name.
   */
  getFloatUnpackingMethod(e) {
    return this.getMethod(`floatunpack_${e}_2x16`);
  }
  /**
   * Returns the native snippet for a ternary operation.
   *
   * @param {string} condSnippet - The condition determining which expression gets resolved.
   * @param {string} ifSnippet - The expression to resolve to if the condition is true.
   * @param {string} elseSnippet - The expression to resolve to if the condition is false.
   * @return {string} The resolved method name.
   */
  getTernary(e, t, n) {
    return `select( ${n}, ${t}, ${e} )`;
  }
  /**
   * Returns the WGSL type of the given node data type.
   *
   * @param {string} type - The node data type.
   * @return {string} The WGSL type.
   */
  getType(e) {
    return ele[e] || e;
  }
  /**
   * Whether the requested feature is available or not.
   *
   * @param {string} name - The requested feature.
   * @return {boolean} Whether the requested feature is supported or not.
   */
  isAvailable(e) {
    let t = LC[e];
    return t === void 0 && (e === "float32Filterable" ? t = this.renderer.hasFeature("float32-filterable") : e === "clipDistance" && (t = this.renderer.hasFeature("clip-distances")), LC[e] = t), t;
  }
  /**
   * Returns the native shader method name for a given generic name.
   *
   * @private
   * @param {string} method - The method name to resolve.
   * @return {string} The resolved WGSL method name.
   */
  _getWGSLMethod(e) {
    return rp[e] !== void 0 && this._include(e), tle[e];
  }
  /**
   * Includes the given method name into the current
   * function node.
   *
   * @private
   * @param {string} name - The method name to include.
   * @return {CodeNode} The respective code node.
   */
  _include(e) {
    const t = rp[e];
    return t.build(this), this.addInclude(t), t;
  }
  /**
   * Returns a WGSL vertex shader based on the given shader data.
   *
   * @private
   * @param {Object} shaderData - The shader data.
   * @return {string} The vertex shader.
   */
  _getWGSLVertexCode(e) {
    return `${this.getSignature()}
// directives
${e.directives}

// structs
${e.structs}

// uniforms
${e.uniforms}

// varyings
${e.varyings}
var<private> varyings : VaryingsStruct;

// codes
${e.codes}

@vertex
fn main( ${e.attributes} ) -> VaryingsStruct {

	// vars
	${e.vars}

	// flow
	${e.flow}

	return varyings;

}
`;
  }
  /**
   * Returns a WGSL fragment shader based on the given shader data.
   *
   * @private
   * @param {Object} shaderData - The shader data.
   * @return {string} The vertex shader.
   */
  _getWGSLFragmentCode(e) {
    return `${this.getSignature()}
// global
${II}

// structs
${e.structs}

// uniforms
${e.uniforms}

// codes
${e.codes}

@fragment
fn main( ${e.varyings} ) -> ${e.returnType} {

	// vars
	${e.vars}

	// flow
	${e.flow}

}
`;
  }
  /**
   * Returns a WGSL compute shader based on the given shader data.
   *
   * @private
   * @param {Object} shaderData - The shader data.
   * @param {string} workgroupSize - The workgroup size.
   * @return {string} The vertex shader.
   */
  _getWGSLComputeCode(e, t) {
    const [n, r, s] = t;
    return `${this.getSignature()}
// directives
${e.directives}

// system
var<private> instanceIndex : u32;

// locals
${e.scopedArrays}

// structs
${e.structs}

// uniforms
${e.uniforms}

// codes
${e.codes}

@compute @workgroup_size( ${n}, ${r}, ${s} )
fn main( ${e.attributes} ) {

	// system
	instanceIndex = globalId.x
		+ globalId.y * ( ${n} * numWorkgroups.x )
		+ globalId.z * ( ${n} * numWorkgroups.x ) * ( ${r} * numWorkgroups.y );

	// vars
	${e.vars}

	// flow
	${e.flow}

}
`;
  }
  /**
   * Returns a WGSL struct based on the given name and variables.
   *
   * @private
   * @param {string} name - The struct name.
   * @param {string} vars - The struct variables.
   * @return {string} The WGSL snippet representing a struct.
   */
  _getWGSLStruct(e, t) {
    return `
struct ${e} {
${t}
};`;
  }
  /**
   * Returns a WGSL struct binding.
   *
   * @private
   * @param {string} name - The struct name.
   * @param {string} vars - The struct variables.
   * @param {string} access - The access.
   * @param {number} [binding=0] - The binding index.
   * @param {number} [group=0] - The group index.
   * @return {string} The WGSL snippet representing a struct binding.
   */
  _getWGSLStructBinding(e, t, n, r = 0, s = 0) {
    const o = e + "Struct";
    return `${this._getWGSLStruct(o, t)}
@binding( ${r} ) @group( ${s} )
var<${n}> ${e} : ${o};`;
  }
}
class ile {
  /**
   * Constructs a new utility object.
   *
   * @param {WebGPUBackend} backend - The WebGPU backend.
   */
  constructor(e) {
    this.backend = e;
  }
  /**
   * Returns the depth/stencil GPU format for the given render context.
   *
   * @param {RenderContext} renderContext - The render context.
   * @return {string} The depth/stencil GPU texture format.
   */
  getCurrentDepthStencilFormat(e) {
    let t;
    return e.depthTexture !== null ? t = this.getTextureFormatGPU(e.depthTexture) : e.depth && e.stencil ? t = de.Depth24PlusStencil8 : e.depth && (t = de.Depth24Plus), t;
  }
  /**
   * Returns the GPU format for the given texture.
   *
   * @param {Texture} texture - The texture.
   * @return {string} The GPU texture format.
   */
  getTextureFormatGPU(e) {
    return this.backend.get(e).format;
  }
  /**
   * Returns an object that defines the multi-sampling state of the given texture.
   *
   * @param {Texture} texture - The texture.
   * @return {Object} The multi-sampling state.
   */
  getTextureSampleData(e) {
    let t;
    if (e.isFramebufferTexture)
      t = 1;
    else if (e.isDepthTexture && !e.renderTarget) {
      const s = this.backend.renderer, o = s.getRenderTarget();
      t = o ? o.samples : s.currentSamples;
    } else e.renderTarget && (t = e.renderTarget.samples);
    t = t || 1;
    const n = t > 1 && e.renderTarget !== null && e.isDepthTexture !== !0 && e.isFramebufferTexture !== !0;
    return { samples: t, primarySamples: n ? 1 : t, isMSAA: n };
  }
  /**
   * Returns the default color attachment's GPU format of the current render context.
   *
   * @param {RenderContext} renderContext - The render context.
   * @return {string} The GPU texture format of the default color attachment.
   */
  getCurrentColorFormat(e) {
    let t;
    return e.textures !== null ? t = this.getTextureFormatGPU(e.textures[0]) : t = this.getPreferredCanvasFormat(), t;
  }
  /**
   * Returns the GPU formats of all color attachments of the current render context.
   *
   * @param {RenderContext} renderContext - The render context.
   * @return {Array<string>} The GPU texture formats of all color attachments.
   */
  getCurrentColorFormats(e) {
    return e.textures !== null ? e.textures.map((t) => this.getTextureFormatGPU(t)) : [this.getPreferredCanvasFormat()];
  }
  /**
   * Returns the output color space of the current render context.
   *
   * @param {RenderContext} renderContext - The render context.
   * @return {string} The output color space.
   */
  getCurrentColorSpace(e) {
    return e.textures !== null ? e.textures[0].colorSpace : this.backend.renderer.outputColorSpace;
  }
  /**
   * Returns GPU primitive topology for the given object and material.
   *
   * @param {Object3D} object - The 3D object.
   * @param {Material} material - The material.
   * @return {string} The GPU primitive topology.
   */
  getPrimitiveTopology(e, t) {
    if (e.isPoints) return ff.PointList;
    if (e.isLineSegments || e.isMesh && t.wireframe === !0) return ff.LineList;
    if (e.isLine) return ff.LineStrip;
    if (e.isMesh) return ff.TriangleList;
  }
  /**
   * Returns a modified sample count from the given sample count value.
   *
   * That is required since WebGPU only supports either 1 or 4.
   *
   * @param {number} sampleCount - The input sample count.
   * @return {number} The (potentially updated) output sample count.
   */
  getSampleCount(e) {
    return e >= 4 ? 4 : 1;
  }
  /**
   * Returns the sample count of the given render context.
   *
   * @param {RenderContext} renderContext - The render context.
   * @return {number} The sample count.
   */
  getSampleCountRenderContext(e) {
    return e.textures !== null ? this.getSampleCount(e.sampleCount) : this.getSampleCount(this.backend.renderer.currentSamples);
  }
  /**
   * Returns the preferred canvas format.
   *
   * There is a separate method for this so it's possible to
   * honor edge cases for specific devices.
   *
   * @return {string} The GPU texture format of the canvas.
   */
  getPreferredCanvasFormat() {
    const t = this.backend.parameters.outputType;
    if (t === void 0)
      return navigator.gpu.getPreferredCanvasFormat();
    if (t === Mi)
      return de.BGRA8Unorm;
    if (t === Ri)
      return de.RGBA16Float;
    throw new Error("Unsupported output buffer type.");
  }
}
const BI = /* @__PURE__ */ new Map([
  [Int8Array, ["sint8", "snorm8"]],
  [Uint8Array, ["uint8", "unorm8"]],
  [Int16Array, ["sint16", "snorm16"]],
  [Uint16Array, ["uint16", "unorm16"]],
  [Int32Array, ["sint32", "snorm32"]],
  [Uint32Array, ["uint32", "unorm32"]],
  [Float32Array, ["float32"]]
]);
typeof Float16Array < "u" && BI.set(Float16Array, ["float16"]);
const rle = /* @__PURE__ */ new Map([
  [N3, ["float16"]]
]), sle = /* @__PURE__ */ new Map([
  [Int32Array, "sint32"],
  [Int16Array, "sint32"],
  // patch for INT16
  [Uint32Array, "uint32"],
  [Uint16Array, "uint32"],
  // patch for UINT16
  [Float32Array, "float32"]
]);
class ole {
  /**
   * Constructs a new utility object.
   *
   * @param {WebGPUBackend} backend - The WebGPU backend.
   */
  constructor(e) {
    this.backend = e;
  }
  /**
   * Creates the GPU buffer for the given buffer attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute.
   * @param {GPUBufferUsage} usage - A flag that indicates how the buffer may be used after its creation.
   */
  createAttribute(e, t) {
    const n = this._getBufferAttribute(e), r = this.backend, s = r.get(n);
    let o = s.buffer;
    if (o === void 0) {
      const a = r.device;
      let l = n.array;
      if (e.normalized === !1) {
        if (l.constructor === Int16Array || l.constructor === Int8Array)
          l = new Int32Array(l);
        else if ((l.constructor === Uint16Array || l.constructor === Uint8Array) && (l = new Uint32Array(l), t & GPUBufferUsage.INDEX))
          for (let A = 0; A < l.length; A++)
            l[A] === 65535 && (l[A] = 4294967295);
      }
      if (n.array = l, (n.isStorageBufferAttribute || n.isStorageInstancedBufferAttribute) && n.itemSize === 3) {
        l = new l.constructor(n.count * 4);
        for (let A = 0; A < n.count; A++)
          l.set(n.array.subarray(A * 3, A * 3 + 3), A * 4);
        n.itemSize = 4, n.array = l, s._force3to4BytesAlignment = !0;
      }
      const u = l.byteLength, c = u + (4 - u % 4) % 4;
      o = a.createBuffer({
        label: n.name,
        size: c,
        usage: t,
        mappedAtCreation: !0
      }), new l.constructor(o.getMappedRange()).set(l), o.unmap(), s.buffer = o;
    }
  }
  /**
   * Updates the GPU buffer of the given buffer attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute.
   */
  updateAttribute(e) {
    const t = this._getBufferAttribute(e), n = this.backend, r = n.device, s = n.get(t), o = n.get(t).buffer;
    let a = t.array;
    if (s._force3to4BytesAlignment === !0) {
      a = new a.constructor(t.count * 4);
      for (let u = 0; u < t.count; u++)
        a.set(t.array.subarray(u * 3, u * 3 + 3), u * 4);
      t.array = a;
    }
    const l = t.updateRanges;
    if (l.length === 0)
      r.queue.writeBuffer(
        o,
        0,
        a,
        0
      );
    else {
      const u = Uf(a), c = u ? 1 : a.BYTES_PER_ELEMENT;
      for (let A = 0, m = l.length; A < m; A++) {
        const _ = l[A];
        let y, T;
        if (s._force3to4BytesAlignment === !0) {
          const S = Math.floor(_.start / 3), E = Math.ceil(_.count / 3);
          y = S * 4 * c, T = E * 4 * c;
        } else
          y = _.start * c, T = _.count * c;
        const b = y * (u ? a.BYTES_PER_ELEMENT : 1);
        r.queue.writeBuffer(
          o,
          b,
          a,
          y,
          T
        );
      }
      t.clearUpdateRanges();
    }
  }
  /**
   * This method creates the vertex buffer layout data which are
   * require when creating a render pipeline for the given render object.
   *
   * @param {RenderObject} renderObject - The render object.
   * @return {Array<Object>} An array holding objects which describe the vertex buffer layout.
   */
  createShaderVertexBuffers(e) {
    const t = e.getAttributes(), n = /* @__PURE__ */ new Map();
    for (let r = 0; r < t.length; r++) {
      const s = t[r], o = s.array.BYTES_PER_ELEMENT, a = this._getBufferAttribute(s);
      let l = n.get(a);
      if (l === void 0) {
        let A, m;
        s.isInterleavedBufferAttribute === !0 ? (A = s.data.stride * o, m = s.data.isInstancedInterleavedBuffer ? Rg.Instance : Rg.Vertex) : (A = s.itemSize * o, m = s.isInstancedBufferAttribute ? Rg.Instance : Rg.Vertex), s.normalized === !1 && (s.array.constructor === Int16Array || s.array.constructor === Uint16Array) && (A = 4), l = {
          arrayStride: A,
          attributes: [],
          stepMode: m
        }, n.set(a, l);
      }
      const u = this._getVertexFormat(s), c = s.isInterleavedBufferAttribute === !0 ? s.offset * o : 0;
      l.attributes.push({
        shaderLocation: r,
        offset: c,
        format: u
      });
    }
    return Array.from(n.values());
  }
  /**
   * Destroys the GPU buffer of the given buffer attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute.
   */
  destroyAttribute(e) {
    const t = this.backend;
    t.get(this._getBufferAttribute(e)).buffer.destroy(), t.delete(e);
  }
  /**
   * This method performs a readback operation by moving buffer data from
   * a storage buffer attribute from the GPU to the CPU.
   *
   * @async
   * @param {StorageBufferAttribute} attribute - The storage buffer attribute.
   * @return {Promise<ArrayBuffer>} A promise that resolves with the buffer data when the data are ready.
   */
  async getArrayBufferAsync(e) {
    const t = this.backend, n = t.device, s = t.get(this._getBufferAttribute(e)).buffer, o = s.size, a = n.createBuffer({
      label: `${e.name}_readback`,
      size: o,
      usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
    }), l = n.createCommandEncoder({
      label: `readback_encoder_${e.name}`
    });
    l.copyBufferToBuffer(
      s,
      0,
      a,
      0,
      o
    );
    const u = l.finish();
    n.queue.submit([u]), await a.mapAsync(GPUMapMode.READ);
    const c = a.getMappedRange(), A = new e.array.constructor(c.slice(0));
    return a.unmap(), A.buffer;
  }
  /**
   * Returns the vertex format of the given buffer attribute.
   *
   * @private
   * @param {BufferAttribute} geometryAttribute - The buffer attribute.
   * @return {string|undefined} The vertex format (e.g. 'float32x3').
   */
  _getVertexFormat(e) {
    const { itemSize: t, normalized: n } = e, r = e.array.constructor, s = e.constructor;
    let o;
    if (t === 1)
      o = sle.get(r);
    else {
      const l = (rle.get(s) || BI.get(r))[n ? 1 : 0];
      if (l) {
        const u = r.BYTES_PER_ELEMENT * t, A = Math.floor((u + 3) / 4) * 4 / r.BYTES_PER_ELEMENT;
        if (A % 1)
          throw new Error("THREE.WebGPUAttributeUtils: Bad vertex format item size.");
        o = `${l}x${A}`;
      }
    }
    return o || Ie("WebGPUAttributeUtils: Vertex format not supported yet."), o;
  }
  /**
   * Utility method for handling interleaved buffer attributes correctly.
   * To process them, their `InterleavedBuffer` is returned.
   *
   * @private
   * @param {BufferAttribute} attribute - The attribute.
   * @return {BufferAttribute|InterleavedBuffer}
   */
  _getBufferAttribute(e) {
    return e.isInterleavedBufferAttribute && (e = e.data), e;
  }
}
class ale {
  /**
   * Constructs a new layout.
   *
   * @param {GPUBindGroupLayout} layoutGPU - A GPU Bind Group Layout.
   */
  constructor(e) {
    this.layoutGPU = e, this.usedTimes = 0;
  }
}
class lle {
  /**
   * Constructs a new utility object.
   *
   * @param {WebGPUBackend} backend - The WebGPU backend.
   */
  constructor(e) {
    this.backend = e, this._bindGroupLayoutCache = /* @__PURE__ */ new Map();
  }
  /**
   * Creates a GPU bind group layout for the given bind group.
   *
   * @param {BindGroup} bindGroup - The bind group.
   * @return {GPUBindGroupLayout} The GPU bind group layout.
   */
  createBindingsLayout(e) {
    const t = this.backend, n = t.device, r = t.get(e);
    if (r.layout)
      return r.layout.layoutGPU;
    const s = this._createLayoutEntries(e), o = JSON.stringify(s);
    let a = this._bindGroupLayoutCache.get(o);
    return a === void 0 && (a = new ale(n.createBindGroupLayout({ entries: s })), this._bindGroupLayoutCache.set(o, a)), a.usedTimes++, r.layout = a, r.layoutKey = o, a.layoutGPU;
  }
  /**
   * Creates bindings from the given bind group definition.
   *
   * @param {BindGroup} bindGroup - The bind group.
   * @param {Array<BindGroup>} bindings - Array of bind groups.
   * @param {number} cacheIndex - The cache index.
   * @param {number} version - The version.
   */
  createBindings(e, t, n, r = 0) {
    const { backend: s } = this, o = s.get(e), a = this.createBindingsLayout(e);
    let l;
    n > 0 && (o.groups === void 0 && (o.groups = [], o.versions = []), o.versions[n] === r && (l = o.groups[n])), l === void 0 && (l = this.createBindGroup(e, a), n > 0 && (o.groups[n] = l, o.versions[n] = r)), o.group = l;
  }
  /**
   * Updates a buffer binding.
   *
   *  @param {Buffer} binding - The buffer binding to update.
   */
  updateBinding(e) {
    const t = this.backend, n = t.device, r = e.buffer, s = t.get(e).buffer, o = e.updateRanges;
    if (o.length === 0)
      n.queue.writeBuffer(
        s,
        0,
        r,
        0
      );
    else {
      const a = Uf(r), l = a ? 1 : r.BYTES_PER_ELEMENT;
      for (let u = 0, c = o.length; u < c; u++) {
        const A = o[u], m = A.start * l, _ = A.count * l, y = m * (a ? r.BYTES_PER_ELEMENT : 1);
        n.queue.writeBuffer(
          s,
          y,
          r,
          m,
          _
        );
      }
      e.clearUpdateRanges();
    }
  }
  /**
   * Creates a GPU bind group for the camera index.
   *
   * @param {Uint32Array} data - The index data.
   * @param {GPUBindGroupLayout} layoutGPU - The GPU bind group layout.
   * @return {GPUBindGroup} The GPU bind group.
   */
  createBindGroupIndex(e, t) {
    const r = this.backend.device, s = GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST, o = e[0], a = r.createBuffer({
      label: "bindingCameraIndex_" + o,
      size: 16,
      // uint(4) * 4
      usage: s
    });
    r.queue.writeBuffer(a, 0, e, 0);
    const l = [{ binding: 0, resource: { buffer: a } }];
    return r.createBindGroup({
      label: "bindGroupCameraIndex_" + o,
      layout: t,
      entries: l
    });
  }
  /**
   * Creates a GPU bind group for the given bind group and GPU layout.
   *
   * @param {BindGroup} bindGroup - The bind group.
   * @param {GPUBindGroupLayout} layoutGPU - The GPU bind group layout.
   * @return {GPUBindGroup} The GPU bind group.
   */
  createBindGroup(e, t) {
    const n = this.backend, r = n.device;
    let s = 0;
    const o = [];
    for (const a of e.bindings) {
      if (a.isUniformBuffer) {
        const l = n.get(a);
        if (l.buffer === void 0) {
          const u = a.byteLength, c = GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST, A = [];
          a.visibility & sh.VERTEX && A.push("vertex"), a.visibility & sh.FRAGMENT && A.push("fragment"), a.visibility & sh.COMPUTE && A.push("compute");
          const m = `(${A.join(",")})`, _ = r.createBuffer({
            label: `bindingBuffer${a.id}_${a.name}_${m}`,
            size: u,
            usage: c
          });
          l.buffer = _;
        }
        o.push({ binding: s, resource: { buffer: l.buffer } });
      } else if (a.isStorageBuffer) {
        const l = n.get(a);
        if (l.buffer === void 0) {
          const u = a.attribute;
          l.buffer = n.get(u).buffer;
        }
        o.push({ binding: s, resource: { buffer: l.buffer } });
      } else if (a.isSampledTexture) {
        const l = n.get(a.texture);
        let u;
        if (l.externalTexture !== void 0)
          u = r.importExternalTexture({ source: l.externalTexture });
        else {
          const c = a.store ? 1 : l.texture.mipLevelCount, A = a.store ? a.mipLevel : 0;
          let m = `view-${l.texture.width}-${l.texture.height}`;
          if (l.texture.depthOrArrayLayers > 1 && (m += `-${l.texture.depthOrArrayLayers}`), m += `-${c}-${A}`, u = l[m], u === void 0) {
            const _ = Oae.All;
            let y;
            a.isSampledCubeTexture ? y = cr.Cube : a.isSampledTexture3D ? y = cr.ThreeD : a.texture.isArrayTexture || a.texture.isDataArrayTexture || a.texture.isCompressedArrayTexture ? y = cr.TwoDArray : y = cr.TwoD, u = l[m] = l.texture.createView({ aspect: _, dimension: y, mipLevelCount: c, baseMipLevel: A });
          }
        }
        o.push({ binding: s, resource: u });
      } else if (a.isSampler) {
        const l = n.get(a.texture);
        o.push({ binding: s, resource: l.sampler });
      }
      s++;
    }
    return r.createBindGroup({
      label: "bindGroup_" + e.name,
      layout: t,
      entries: o
    });
  }
  /**
   * Creates a GPU bind group layout entries for the given bind group.
   *
   * @private
   * @param {BindGroup} bindGroup - The bind group.
   * @return {Array<GPUBindGroupLayoutEntry>} The GPU bind group layout entries.
   */
  _createLayoutEntries(e) {
    const t = [];
    let n = 0;
    for (const r of e.bindings) {
      const s = this.backend, o = {
        binding: n,
        visibility: r.visibility
      };
      if (r.isUniformBuffer || r.isStorageBuffer) {
        const a = {};
        r.isStorageBuffer && (r.visibility & sh.COMPUTE && (r.access === Xr.READ_WRITE || r.access === Xr.WRITE_ONLY) ? a.type = xv.Storage : a.type = xv.ReadOnlyStorage), o.buffer = a;
      } else if (r.isSampledTexture && r.store) {
        const a = {};
        a.format = this.backend.get(r.texture).texture.format;
        const l = r.access;
        l === Xr.READ_WRITE ? a.access = yv.ReadWrite : l === Xr.WRITE_ONLY ? a.access = yv.WriteOnly : a.access = yv.ReadOnly, r.texture.isArrayTexture ? a.viewDimension = cr.TwoDArray : r.texture.is3DTexture && (a.viewDimension = cr.ThreeD), o.storageTexture = a;
      } else if (r.isSampledTexture) {
        const a = {}, { primarySamples: l } = s.utils.getTextureSampleData(r.texture);
        if (l > 1 && (a.multisampled = !0, r.texture.isDepthTexture || (a.sampleType = Oc.UnfilterableFloat)), r.texture.isDepthTexture)
          s.compatibilityMode && r.texture.compareFunction === null ? a.sampleType = Oc.UnfilterableFloat : a.sampleType = Oc.Depth;
        else if (r.texture.isDataTexture || r.texture.isDataArrayTexture || r.texture.isData3DTexture) {
          const u = r.texture.type;
          u === _r ? a.sampleType = Oc.SInt : u === Jn ? a.sampleType = Oc.UInt : u === Ei && (this.backend.hasFeature("float32-filterable") ? a.sampleType = Oc.Float : a.sampleType = Oc.UnfilterableFloat);
        }
        r.isSampledCubeTexture ? a.viewDimension = cr.Cube : r.texture.isArrayTexture || r.texture.isDataArrayTexture || r.texture.isCompressedArrayTexture ? a.viewDimension = cr.TwoDArray : r.isSampledTexture3D && (a.viewDimension = cr.ThreeD), o.texture = a;
      } else if (r.isSampler) {
        const a = {};
        r.texture.isDepthTexture && (r.texture.compareFunction !== null ? a.type = RC.Comparison : s.compatibilityMode && (a.type = RC.NonFiltering)), o.sampler = a;
      } else
        Ie(`WebGPUBindingUtils: Unsupported binding "${r}".`);
      t.push(o), n++;
    }
    return t;
  }
  /**
   * Delete the data associated with a bind group.
   *
   * @param {BindGroup} bindGroup - The bind group.
   */
  deleteBindGroupData(e) {
    const { backend: t } = this, n = t.get(e);
    n.layout && (n.layout.usedTimes--, n.layout.usedTimes === 0 && this._bindGroupLayoutCache.delete(n.layoutKey), n.layout = void 0, n.layoutKey = void 0);
  }
  /**
   * Frees internal resources.
   */
  dispose() {
    this._bindGroupLayoutCache.clear();
  }
}
class ule {
  /**
   * Constructs a new utility object.
   *
   * @param {WebGPUBackend} backend - The WebGPU backend.
   */
  constructor(e) {
    this.backend = e, this._activePipelines = /* @__PURE__ */ new WeakMap();
  }
  /**
   * Sets the given pipeline for the given pass. The method makes sure to only set the
   * pipeline when necessary.
   *
   * @param {(GPURenderPassEncoder|GPUComputePassEncoder)} pass - The pass encoder.
   * @param {(GPURenderPipeline|GPUComputePipeline)} pipeline - The pipeline.
   */
  setPipeline(e, t) {
    this._activePipelines.get(e) !== t && (e.setPipeline(t), this._activePipelines.set(e, t));
  }
  /**
   * Returns the sample count derived from the given render context.
   *
   * @private
   * @param {RenderContext} renderContext - The render context.
   * @return {number} The sample count.
   */
  _getSampleCount(e) {
    return this.backend.utils.getSampleCountRenderContext(e);
  }
  /**
   * Creates a render pipeline for the given render object.
   *
   * @param {RenderObject} renderObject - The render object.
   * @param {Array<Promise>} promises - An array of compilation promises which are used in `compileAsync()`.
   */
  createRenderPipeline(e, t) {
    const { object: n, material: r, geometry: s, pipeline: o } = e, { vertexProgram: a, fragmentProgram: l } = o, u = this.backend, c = u.device, A = u.utils, m = u.get(o), _ = [];
    for (const Y of e.getBindings()) {
      const K = u.get(Y), { layoutGPU: X } = K.layout;
      _.push(X);
    }
    const y = u.attributeUtils.createShaderVertexBuffers(e);
    let T;
    r.blending !== ms && (r.blending !== gs || r.transparent !== !1) && (T = this._getBlending(r));
    let b = {};
    r.stencilWrite === !0 && (b = {
      compare: this._getStencilCompare(r),
      failOp: this._getStencilOperation(r.stencilFail),
      depthFailOp: this._getStencilOperation(r.stencilZFail),
      passOp: this._getStencilOperation(r.stencilZPass)
    });
    const S = this._getColorWriteMask(r), E = [];
    if (e.context.textures !== null) {
      const Y = e.context.textures;
      for (let K = 0; K < Y.length; K++) {
        const X = A.getTextureFormatGPU(Y[K]);
        K === 0 ? E.push({
          format: X,
          blend: T,
          writeMask: S
        }) : E.push({
          format: X,
          writeMask: S
        });
      }
    } else {
      const Y = A.getCurrentColorFormat(e.context);
      E.push({
        format: Y,
        blend: T,
        writeMask: S
      });
    }
    const R = u.get(a).module, C = u.get(l).module, L = this._getPrimitiveState(n, s, r), D = this._getDepthCompare(r), B = A.getCurrentDepthStencilFormat(e.context), U = this._getSampleCount(e.context), N = {
      label: `renderPipeline_${r.name || r.type}_${r.id}`,
      vertex: Object.assign({}, R, { buffers: y }),
      fragment: Object.assign({}, C, { targets: E }),
      primitive: L,
      multisample: {
        count: U,
        alphaToCoverageEnabled: r.alphaToCoverage && U > 1
      },
      layout: c.createPipelineLayout({
        bindGroupLayouts: _
      })
    }, O = {}, G = e.context.depth, H = e.context.stencil;
    if ((G === !0 || H === !0) && (G === !0 && (O.format = B, O.depthWriteEnabled = r.depthWrite, O.depthCompare = D), H === !0 && (O.stencilFront = b, O.stencilBack = {}, O.stencilReadMask = r.stencilFuncMask, O.stencilWriteMask = r.stencilWriteMask), r.polygonOffset === !0 && (O.depthBias = r.polygonOffsetUnits, O.depthBiasSlopeScale = r.polygonOffsetFactor, O.depthBiasClamp = 0), N.depthStencil = O), c.pushErrorScope("validation"), t === null)
      m.pipeline = c.createRenderPipeline(N), c.popErrorScope().then((Y) => {
        Y !== null && (m.error = !0, Ie(Y.message));
      });
    else {
      const Y = new Promise(async (K) => {
        try {
          m.pipeline = await c.createRenderPipelineAsync(N);
        } catch {
        }
        const X = await c.popErrorScope();
        X !== null && (m.error = !0, Ie(X.message)), K();
      });
      t.push(Y);
    }
  }
  /**
   * Creates GPU render bundle encoder for the given render context.
   *
   * @param {RenderContext} renderContext - The render context.
   * @param {?string} [label='renderBundleEncoder'] - The label.
   * @return {GPURenderBundleEncoder} The GPU render bundle encoder.
   */
  createBundleEncoder(e, t = "renderBundleEncoder") {
    const n = this.backend, { utils: r, device: s } = n, o = r.getCurrentDepthStencilFormat(e), a = r.getCurrentColorFormats(e), l = this._getSampleCount(e), u = {
      label: t,
      colorFormats: a,
      depthStencilFormat: o,
      sampleCount: l
    };
    return s.createRenderBundleEncoder(u);
  }
  /**
   * Creates a compute pipeline for the given compute node.
   *
   * @param {ComputePipeline} pipeline - The compute pipeline.
   * @param {Array<BindGroup>} bindings - The bindings.
   */
  createComputePipeline(e, t) {
    const n = this.backend, r = n.device, s = n.get(e.computeProgram).module, o = n.get(e), a = [];
    for (const l of t) {
      const u = n.get(l), { layoutGPU: c } = u.layout;
      a.push(c);
    }
    o.pipeline = r.createComputePipeline({
      compute: s,
      layout: r.createPipelineLayout({
        bindGroupLayouts: a
      })
    });
  }
  /**
   * Returns the blending state as a descriptor object required
   * for the pipeline creation.
   *
   * @private
   * @param {Material} material - The material.
   * @return {Object} The blending state.
   */
  _getBlending(e) {
    let t, n;
    const r = e.blending, s = e.blendSrc, o = e.blendDst, a = e.blendEquation;
    if (r === oh) {
      const l = e.blendSrcAlpha !== null ? e.blendSrcAlpha : s, u = e.blendDstAlpha !== null ? e.blendDstAlpha : o, c = e.blendEquationAlpha !== null ? e.blendEquationAlpha : a;
      t = {
        srcFactor: this._getBlendFactor(s),
        dstFactor: this._getBlendFactor(o),
        operation: this._getBlendOperation(a)
      }, n = {
        srcFactor: this._getBlendFactor(l),
        dstFactor: this._getBlendFactor(u),
        operation: this._getBlendOperation(c)
      };
    } else {
      const l = e.premultipliedAlpha, u = (c, A, m, _) => {
        t = {
          srcFactor: c,
          dstFactor: A,
          operation: Uc.Add
        }, n = {
          srcFactor: m,
          dstFactor: _,
          operation: Uc.Add
        };
      };
      if (l)
        switch (r) {
          case gs:
            u(kn.One, kn.OneMinusSrcAlpha, kn.One, kn.OneMinusSrcAlpha);
            break;
          case fh:
            u(kn.One, kn.One, kn.One, kn.One);
            break;
          case Ah:
            u(kn.Zero, kn.OneMinusSrc, kn.Zero, kn.One);
            break;
          case ph:
            u(kn.Dst, kn.OneMinusSrcAlpha, kn.Zero, kn.One);
            break;
        }
      else
        switch (r) {
          case gs:
            u(kn.SrcAlpha, kn.OneMinusSrcAlpha, kn.One, kn.OneMinusSrcAlpha);
            break;
          case fh:
            u(kn.SrcAlpha, kn.One, kn.One, kn.One);
            break;
          case Ah:
            Ie("WebGPURenderer: SubtractiveBlending requires material.premultipliedAlpha = true");
            break;
          case ph:
            Ie("WebGPURenderer: MultiplyBlending requires material.premultipliedAlpha = true");
            break;
        }
    }
    if (t !== void 0 && n !== void 0)
      return { color: t, alpha: n };
    Ie("WebGPURenderer: Invalid blending: ", r);
  }
  /**
   * Returns the GPU blend factor which is required for the pipeline creation.
   *
   * @private
   * @param {number} blend - The blend factor as a three.js constant.
   * @return {string} The GPU blend factor.
   */
  _getBlendFactor(e) {
    let t;
    switch (e) {
      case Ga:
        t = kn.Zero;
        break;
      case w_:
        t = kn.One;
        break;
      case M_:
        t = kn.Src;
        break;
      case E_:
        t = kn.OneMinusSrc;
        break;
      case Tf:
        t = kn.SrcAlpha;
        break;
      case wf:
        t = kn.OneMinusSrcAlpha;
        break;
      case P_:
        t = kn.Dst;
        break;
      case N_:
        t = kn.OneMinusDst;
        break;
      case R_:
        t = kn.DstAlpha;
        break;
      case C_:
        t = kn.OneMinusDstAlpha;
        break;
      case D_:
        t = kn.SrcAlphaSaturated;
        break;
      case tte:
        t = kn.Constant;
        break;
      case nte:
        t = kn.OneMinusConstant;
        break;
      default:
        Ie("WebGPURenderer: Blend factor not supported.", e);
    }
    return t;
  }
  /**
   * Returns the GPU stencil compare function which is required for the pipeline creation.
   *
   * @private
   * @param {Material} material - The material.
   * @return {string} The GPU stencil compare function.
   */
  _getStencilCompare(e) {
    let t;
    const n = e.stencilFunc;
    switch (n) {
      case U5:
        t = Gr.Never;
        break;
      case p1:
        t = Gr.Always;
        break;
      case O5:
        t = Gr.Less;
        break;
      case V5:
        t = Gr.LessEqual;
        break;
      case k5:
        t = Gr.Equal;
        break;
      case q5:
        t = Gr.GreaterEqual;
        break;
      case G5:
        t = Gr.Greater;
        break;
      case z5:
        t = Gr.NotEqual;
        break;
      default:
        Ie("WebGPURenderer: Invalid stencil function.", n);
    }
    return t;
  }
  /**
   * Returns the GPU stencil operation which is required for the pipeline creation.
   *
   * @private
   * @param {number} op - A three.js constant defining the stencil operation.
   * @return {string} The GPU stencil operation.
   */
  _getStencilOperation(e) {
    let t;
    switch (e) {
      case Tu:
        t = yu.Keep;
        break;
      case P5:
        t = yu.Zero;
        break;
      case N5:
        t = yu.Replace;
        break;
      case F5:
        t = yu.Invert;
        break;
      case D5:
        t = yu.IncrementClamp;
        break;
      case L5:
        t = yu.DecrementClamp;
        break;
      case I5:
        t = yu.IncrementWrap;
        break;
      case B5:
        t = yu.DecrementWrap;
        break;
      default:
        Ie("WebGPURenderer: Invalid stencil operation.", t);
    }
    return t;
  }
  /**
   * Returns the GPU blend operation which is required for the pipeline creation.
   *
   * @private
   * @param {number} blendEquation - A three.js constant defining the blend equation.
   * @return {string} The GPU blend operation.
   */
  _getBlendOperation(e) {
    let t;
    switch (e) {
      case Wr:
        t = Uc.Add;
        break;
      case S_:
        t = Uc.Subtract;
        break;
      case T_:
        t = Uc.ReverseSubtract;
        break;
      case y3:
        t = Uc.Min;
        break;
      case v3:
        t = Uc.Max;
        break;
      default:
        Ie("WebGPUPipelineUtils: Blend equation not supported.", e);
    }
    return t;
  }
  /**
   * Returns the primitive state as a descriptor object required
   * for the pipeline creation.
   *
   * @private
   * @param {Object3D} object - The 3D object.
   * @param {BufferGeometry} geometry - The geometry.
   * @param {Material} material - The material.
   * @return {Object} The primitive state.
   */
  _getPrimitiveState(e, t, n) {
    const r = {}, s = this.backend.utils;
    r.topology = s.getPrimitiveTopology(e, n), t.index !== null && e.isLine === !0 && e.isLineSegments !== !0 && (r.stripIndexFormat = t.index.array instanceof Uint16Array ? Kf.Uint16 : Kf.Uint32);
    let o = n.side === si;
    return e.isMesh && e.matrixWorld.determinant() < 0 && (o = !o), r.frontFace = o === !0 ? wC.CW : wC.CCW, r.cullMode = n.side === er ? MC.None : MC.Back, r;
  }
  /**
   * Returns the GPU color write mask which is required for the pipeline creation.
   *
   * @private
   * @param {Material} material - The material.
   * @return {number} The GPU color write mask.
   */
  _getColorWriteMask(e) {
    return e.colorWrite === !0 ? EC.All : EC.None;
  }
  /**
   * Returns the GPU depth compare function which is required for the pipeline creation.
   *
   * @private
   * @param {Material} material - The material.
   * @return {string} The GPU depth compare function.
   */
  _getDepthCompare(e) {
    let t;
    if (e.depthTest === !1)
      t = Gr.Always;
    else {
      const n = e.depthFunc;
      switch (n) {
        case Mf:
          t = Gr.Never;
          break;
        case Ef:
          t = Gr.Always;
          break;
        case Rf:
          t = Gr.Less;
          break;
        case Vl:
          t = Gr.LessEqual;
          break;
        case Cf:
          t = Gr.Equal;
          break;
        case Pf:
          t = Gr.GreaterEqual;
          break;
        case Nf:
          t = Gr.Greater;
          break;
        case Df:
          t = Gr.NotEqual;
          break;
        default:
          Ie("WebGPUPipelineUtils: Invalid depth function.", n);
      }
    }
    return t;
  }
}
class cle extends LI {
  /**
   * Creates a new WebGPU timestamp query pool.
   *
   * @param {GPUDevice} device - The WebGPU device to create queries on.
   * @param {string} type - The type identifier for this query pool.
   * @param {number} [maxQueries=2048] - Maximum number of queries this pool can hold.
   */
  constructor(e, t, n = 2048) {
    super(n), this.device = e, this.type = t, this.querySet = this.device.createQuerySet({
      type: "timestamp",
      count: this.maxQueries,
      label: `queryset_global_timestamp_${t}`
    });
    const r = this.maxQueries * 8;
    this.resolveBuffer = this.device.createBuffer({
      label: `buffer_timestamp_resolve_${t}`,
      size: r,
      usage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC
    }), this.resultBuffer = this.device.createBuffer({
      label: `buffer_timestamp_result_${t}`,
      size: r,
      usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
    });
  }
  /**
   * Allocates a pair of queries for a given render context.
   *
   * @param {string} uid - A unique identifier for the render context.
   * @returns {?number} The base offset for the allocated queries, or null if allocation failed.
   */
  allocateQueriesForContext(e) {
    if (!this.trackTimestamp || this.isDisposed) return null;
    if (this.currentQueryIndex + 2 > this.maxQueries)
      return li(`WebGPUTimestampQueryPool [${this.type}]: Maximum number of queries exceeded, when using trackTimestamp it is necessary to resolves the queries via renderer.resolveTimestampsAsync( THREE.TimestampQuery.${this.type.toUpperCase()} ).`), null;
    const t = this.currentQueryIndex;
    return this.currentQueryIndex += 2, this.queryOffsets.set(e, t), t;
  }
  /**
   * Asynchronously resolves all pending queries and returns the total duration.
   * If there's already a pending resolve operation, returns that promise instead.
   *
   * @async
   * @returns {Promise<number>} The total duration in milliseconds, or the last valid value if resolution fails.
   */
  async resolveQueriesAsync() {
    if (!this.trackTimestamp || this.currentQueryIndex === 0 || this.isDisposed)
      return this.lastValue;
    if (this.pendingResolve)
      return this.pendingResolve;
    this.pendingResolve = this._resolveQueries();
    try {
      return await this.pendingResolve;
    } finally {
      this.pendingResolve = null;
    }
  }
  /**
   * Internal method to resolve queries and calculate total duration.
   *
   * @async
   * @private
   * @returns {Promise<number>} The total duration in milliseconds.
   */
  async _resolveQueries() {
    if (this.isDisposed)
      return this.lastValue;
    try {
      if (this.resultBuffer.mapState !== "unmapped")
        return this.lastValue;
      const e = new Map(this.queryOffsets), t = this.currentQueryIndex, n = t * 8;
      this.currentQueryIndex = 0, this.queryOffsets.clear();
      const r = this.device.createCommandEncoder();
      r.resolveQuerySet(
        this.querySet,
        0,
        t,
        this.resolveBuffer,
        0
      ), r.copyBufferToBuffer(
        this.resolveBuffer,
        0,
        this.resultBuffer,
        0,
        n
      );
      const s = r.finish();
      if (this.device.queue.submit([s]), this.resultBuffer.mapState !== "unmapped")
        return this.lastValue;
      if (await this.resultBuffer.mapAsync(GPUMapMode.READ, 0, n), this.isDisposed)
        return this.resultBuffer.mapState === "mapped" && this.resultBuffer.unmap(), this.lastValue;
      const o = new BigUint64Array(this.resultBuffer.getMappedRange(0, n)), a = {}, l = [];
      for (const [c, A] of e) {
        const m = c.match(/^(.*):f(\d+)$/), _ = parseInt(m[2]);
        l.includes(_) === !1 && l.push(_), a[_] === void 0 && (a[_] = 0);
        const y = o[A], T = o[A + 1], b = Number(T - y) / 1e6;
        this.timestamps.set(c, b), a[_] += b;
      }
      const u = a[l[l.length - 1]];
      return this.resultBuffer.unmap(), this.lastValue = u, this.frames = l, u;
    } catch (e) {
      return Ie("Error resolving queries:", e), this.resultBuffer.mapState === "mapped" && this.resultBuffer.unmap(), this.lastValue;
    }
  }
  /**
   * Dispose of the query pool.
   *
   * @async
   * @returns {Promise} A Promise that resolves when the dispose has been executed.
   */
  async dispose() {
    if (!this.isDisposed) {
      if (this.isDisposed = !0, this.pendingResolve)
        try {
          await this.pendingResolve;
        } catch (e) {
          Ie("Error waiting for pending resolve:", e);
        }
      if (this.resultBuffer && this.resultBuffer.mapState === "mapped")
        try {
          this.resultBuffer.unmap();
        } catch (e) {
          Ie("Error unmapping buffer:", e);
        }
      this.querySet && (this.querySet.destroy(), this.querySet = null), this.resolveBuffer && (this.resolveBuffer.destroy(), this.resolveBuffer = null), this.resultBuffer && (this.resultBuffer.destroy(), this.resultBuffer = null), this.queryOffsets.clear(), this.pendingResolve = null;
    }
  }
}
class hle extends DI {
  /**
   * WebGPUBackend options.
   *
   * @typedef {Object} WebGPUBackend~Options
   * @property {boolean} [logarithmicDepthBuffer=false] - Whether logarithmic depth buffer is enabled or not.
   * @property {boolean} [alpha=true] - Whether the default framebuffer (which represents the final contents of the canvas) should be transparent or opaque.
   * @property {boolean} [compatibilityMode=false] - Whether the backend should be in compatibility mode or not.
   * @property {boolean} [depth=true] - Whether the default framebuffer should have a depth buffer or not.
   * @property {boolean} [stencil=false] - Whether the default framebuffer should have a stencil buffer or not.
   * @property {boolean} [antialias=false] - Whether MSAA as the default anti-aliasing should be enabled or not.
   * @property {number} [samples=0] - When `antialias` is `true`, `4` samples are used by default. Set this parameter to any other integer value than 0 to overwrite the default.
   * @property {boolean} [forceWebGL=false] - If set to `true`, the renderer uses a WebGL 2 backend no matter if WebGPU is supported or not.
   * @property {boolean} [trackTimestamp=false] - Whether to track timestamps with a Timestamp Query API or not.
   * @property {string} [powerPreference=undefined] - The power preference.
   * @property {Object} [requiredLimits=undefined] - Specifies the limits that are required by the device request. The request will fail if the adapter cannot provide these limits.
   * @property {GPUDevice} [device=undefined] - If there is an existing GPU device on app level, it can be passed to the renderer as a parameter.
   * @property {number} [outputType=undefined] - Texture type for output to canvas. By default, device's preferred format is used; other formats may incur overhead.
   */
  /**
   * Constructs a new WebGPU backend.
   *
   * @param {WebGPUBackend~Options} [parameters] - The configuration parameter.
   */
  constructor(e = {}) {
    super(e), this.isWebGPUBackend = !0, this.parameters.alpha = e.alpha === void 0 ? !0 : e.alpha, this.parameters.compatibilityMode = e.compatibilityMode === void 0 ? !1 : e.compatibilityMode, this.parameters.requiredLimits = e.requiredLimits === void 0 ? {} : e.requiredLimits, this.compatibilityMode = this.parameters.compatibilityMode, this.device = null, this.defaultRenderPassdescriptor = null, this.utils = new ile(this), this.attributeUtils = new ole(this), this.bindingUtils = new lle(this), this.pipelineUtils = new ule(this), this.textureUtils = new $ae(this), this.occludedResolveCache = /* @__PURE__ */ new Map();
  }
  /**
   * Initializes the backend so it is ready for usage.
   *
   * @async
   * @param {Renderer} renderer - The renderer.
   * @return {Promise} A Promise that resolves when the backend has been initialized.
   */
  async init(e) {
    await super.init(e);
    const t = this.parameters;
    let n;
    if (t.device === void 0) {
      const r = {
        powerPreference: t.powerPreference,
        featureLevel: t.compatibilityMode ? "compatibility" : void 0
      }, s = typeof navigator < "u" ? await navigator.gpu.requestAdapter(r) : null;
      if (s === null)
        throw new Error("WebGPUBackend: Unable to create WebGPU adapter.");
      const o = Object.values(t3), a = [];
      for (const u of o)
        s.features.has(u) && a.push(u);
      const l = {
        requiredFeatures: a,
        requiredLimits: t.requiredLimits
      };
      n = await s.requestDevice(l);
    } else
      n = t.device;
    n.lost.then((r) => {
      if (r.reason === "destroyed") return;
      const s = {
        api: "WebGPU",
        message: r.message || "Unknown reason",
        reason: r.reason || null,
        originalEvent: r
      };
      e.onDeviceLost(s);
    }), this.device = n, this.trackTimestamp = this.trackTimestamp && this.hasFeature(t3.TimestampQuery), this.updateSize();
  }
  /**
   * A reference to the context.
   *
   * @type {?GPUCanvasContext}
   * @default null
   */
  get context() {
    const e = this.renderer.getCanvasTarget(), t = this.get(e);
    let n = t.context;
    if (n === void 0) {
      const r = this.parameters;
      e.isDefaultCanvasTarget === !0 && r.context !== void 0 ? n = r.context : n = e.domElement.getContext("webgpu"), "setAttribute" in e.domElement && e.domElement.setAttribute("data-engine", `three.js r${Ku} webgpu`);
      const s = r.alpha ? "premultiplied" : "opaque", o = r.outputType === Ri ? "extended" : "standard";
      n.configure({
        device: this.device,
        format: this.utils.getPreferredCanvasFormat(),
        usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,
        alphaMode: s,
        toneMapping: {
          mode: o
        }
      }), t.context = n;
    }
    return n;
  }
  /**
   * The coordinate system of the backend.
   *
   * @type {number}
   * @readonly
   */
  get coordinateSystem() {
    return io;
  }
  /**
   * This method performs a readback operation by moving buffer data from
   * a storage buffer attribute from the GPU to the CPU.
   *
   * @async
   * @param {StorageBufferAttribute} attribute - The storage buffer attribute.
   * @return {Promise<ArrayBuffer>} A promise that resolves with the buffer data when the data are ready.
   */
  async getArrayBufferAsync(e) {
    return await this.attributeUtils.getArrayBufferAsync(e);
  }
  /**
   * Returns the backend's rendering context.
   *
   * @return {GPUCanvasContext} The rendering context.
   */
  getContext() {
    return this.context;
  }
  /**
   * Returns the default render pass descriptor.
   *
   * In WebGPU, the default framebuffer must be configured
   * like custom framebuffers so the backend needs a render
   * pass descriptor even when rendering directly to screen.
   *
   * @private
   * @return {Object} The render pass descriptor.
   */
  _getDefaultRenderPassDescriptor() {
    const e = this.renderer, t = e.getCanvasTarget(), n = this.get(t), r = e.currentSamples;
    let s = n.descriptor;
    if (s === void 0 || n.samples !== r) {
      s = {
        colorAttachments: [{
          view: null
        }]
      }, (e.depth === !0 || e.stencil === !0) && (s.depthStencilAttachment = {
        view: this.textureUtils.getDepthBuffer(e.depth, e.stencil).createView()
      });
      const a = s.colorAttachments[0];
      r > 0 ? a.view = this.textureUtils.getColorBuffer().createView() : a.resolveTarget = void 0, n.descriptor = s, n.samples = r;
    }
    const o = s.colorAttachments[0];
    return r > 0 ? o.resolveTarget = this.context.getCurrentTexture().createView() : o.view = this.context.getCurrentTexture().createView(), s;
  }
  /**
   * Internal to determine if the current render target is a render target array with depth 2D array texture.
   *
   * @param {RenderContext} renderContext - The render context.
   * @return {boolean} Whether the render target is a render target array with depth 2D array texture.
   *
   * @private
   */
  _isRenderCameraDepthArray(e) {
    return e.depthTexture && e.depthTexture.image.depth > 1 && e.camera.isArrayCamera;
  }
  /**
   * Returns the render pass descriptor for the given render context.
   *
   * @private
   * @param {RenderContext} renderContext - The render context.
   * @param {Object} colorAttachmentsConfig - Configuration object for the color attachments.
   * @return {Object} The render pass descriptor.
   */
  _getRenderPassDescriptor(e, t = {}) {
    const n = e.renderTarget, r = this.get(n);
    let s = r.descriptors;
    (s === void 0 || r.width !== n.width || r.height !== n.height || r.samples !== n.samples) && (s = {}, r.descriptors = s);
    const o = e.getCacheKey();
    let a = s[o];
    if (a === void 0) {
      const u = e.textures, c = [];
      let A;
      const m = this._isRenderCameraDepthArray(e);
      for (let _ = 0; _ < u.length; _++) {
        const y = this.get(u[_]), T = {
          label: `colorAttachment_${_}`,
          baseMipLevel: e.activeMipmapLevel,
          mipLevelCount: 1,
          baseArrayLayer: e.activeCubeFace,
          arrayLayerCount: 1,
          dimension: cr.TwoD
        };
        if (n.isRenderTarget3D)
          A = e.activeCubeFace, T.baseArrayLayer = 0, T.dimension = cr.ThreeD, T.depthOrArrayLayers = u[_].image.depth;
        else if (n.isRenderTarget && u[_].image.depth > 1)
          if (m === !0) {
            const b = e.camera.cameras;
            for (let S = 0; S < b.length; S++) {
              const E = {
                ...T,
                baseArrayLayer: S,
                arrayLayerCount: 1,
                dimension: cr.TwoD
              }, R = y.texture.createView(E);
              c.push({
                view: R,
                resolveTarget: void 0,
                depthSlice: void 0
              });
            }
          } else
            T.dimension = cr.TwoDArray, T.depthOrArrayLayers = u[_].image.depth;
        if (m !== !0) {
          const b = y.texture.createView(T);
          let S, E;
          y.msaaTexture !== void 0 ? (S = y.msaaTexture.createView(), E = b) : (S = b, E = void 0), c.push({
            view: S,
            resolveTarget: E,
            depthSlice: A
          });
        }
      }
      if (a = { textureViews: c }, e.depth) {
        const _ = this.get(e.depthTexture), y = {};
        (e.depthTexture.isArrayTexture || e.depthTexture.isCubeTexture) && (y.dimension = cr.TwoD, y.arrayLayerCount = 1, y.baseArrayLayer = e.activeCubeFace), a.depthStencilView = _.texture.createView(y);
      }
      s[o] = a, r.width = n.width, r.height = n.height, r.samples = n.samples, r.activeMipmapLevel = e.activeMipmapLevel, r.activeCubeFace = e.activeCubeFace;
    }
    const l = {
      colorAttachments: []
    };
    for (let u = 0; u < a.textureViews.length; u++) {
      const c = a.textureViews[u];
      let A = { r: 0, g: 0, b: 0, a: 1 };
      u === 0 && t.clearValue && (A = t.clearValue), l.colorAttachments.push({
        view: c.view,
        depthSlice: c.depthSlice,
        resolveTarget: c.resolveTarget,
        loadOp: t.loadOp || ti.Load,
        storeOp: t.storeOp || Ms.Store,
        clearValue: A
      });
    }
    return a.depthStencilView && (l.depthStencilAttachment = {
      view: a.depthStencilView
    }), l;
  }
  /**
   * This method is executed at the beginning of a render call and prepares
   * the WebGPU state for upcoming render calls
   *
   * @param {RenderContext} renderContext - The render context.
   */
  beginRender(e) {
    const t = this.get(e), n = this.device, r = e.occlusionQueryCount;
    let s;
    r > 0 && (t.currentOcclusionQuerySet && t.currentOcclusionQuerySet.destroy(), t.currentOcclusionQueryBuffer && t.currentOcclusionQueryBuffer.destroy(), t.currentOcclusionQuerySet = t.occlusionQuerySet, t.currentOcclusionQueryBuffer = t.occlusionQueryBuffer, t.currentOcclusionQueryObjects = t.occlusionQueryObjects, s = n.createQuerySet({ type: "occlusion", count: r, label: `occlusionQuerySet_${e.id}` }), t.occlusionQuerySet = s, t.occlusionQueryIndex = 0, t.occlusionQueryObjects = new Array(r), t.lastOcclusionObject = null);
    let o;
    e.textures === null ? o = this._getDefaultRenderPassDescriptor() : o = this._getRenderPassDescriptor(e, { loadOp: ti.Load }), this.initTimestampQuery(pa.RENDER, this.getTimestampUID(e), o), o.occlusionQuerySet = s;
    const a = o.depthStencilAttachment;
    if (e.textures !== null) {
      const u = o.colorAttachments;
      for (let c = 0; c < u.length; c++) {
        const A = u[c];
        e.clearColor ? (A.clearValue = c === 0 ? e.clearColorValue : { r: 0, g: 0, b: 0, a: 1 }, A.loadOp = ti.Clear) : A.loadOp = ti.Load, A.storeOp = Ms.Store;
      }
    } else {
      const u = o.colorAttachments[0];
      e.clearColor ? (u.clearValue = e.clearColorValue, u.loadOp = ti.Clear) : u.loadOp = ti.Load, u.storeOp = Ms.Store;
    }
    e.depth && (e.clearDepth ? (a.depthClearValue = e.clearDepthValue, a.depthLoadOp = ti.Clear) : a.depthLoadOp = ti.Load, a.depthStoreOp = Ms.Store), e.stencil && (e.clearStencil ? (a.stencilClearValue = e.clearStencilValue, a.stencilLoadOp = ti.Clear) : a.stencilLoadOp = ti.Load, a.stencilStoreOp = Ms.Store);
    const l = n.createCommandEncoder({ label: "renderContext_" + e.id });
    if (this._isRenderCameraDepthArray(e) === !0) {
      const u = e.camera.cameras;
      !t.layerDescriptors || t.layerDescriptors.length !== u.length ? this._createDepthLayerDescriptors(e, t, o, u) : this._updateDepthLayerDescriptors(e, t, u), t.bundleEncoders = [], t.bundleSets = [];
      for (let c = 0; c < u.length; c++) {
        const A = this.pipelineUtils.createBundleEncoder(
          e,
          "renderBundleArrayCamera_" + c
        ), m = {
          attributes: {},
          bindingGroups: [],
          pipeline: null,
          index: null
        };
        t.bundleEncoders.push(A), t.bundleSets.push(m);
      }
      t.currentPass = null;
    } else {
      const u = l.beginRenderPass(o);
      t.currentPass = u, e.viewport && this.updateViewport(e), e.scissor && this.updateScissor(e);
    }
    t.descriptor = o, t.encoder = l, t.currentSets = { attributes: {}, bindingGroups: [], pipeline: null, index: null }, t.renderBundles = [];
  }
  /**
   * This method creates layer descriptors for each camera in an array camera
   * to prepare for rendering to a depth array texture.
   *
   * @param {RenderContext} renderContext - The render context.
   * @param {Object} renderContextData - The render context data.
   * @param {Object} descriptor  - The render pass descriptor.
   * @param {ArrayCamera} cameras - The array camera.
   *
   * @private
   */
  _createDepthLayerDescriptors(e, t, n, r) {
    const s = n.depthStencilAttachment;
    t.layerDescriptors = [];
    const o = this.get(e.depthTexture);
    o.viewCache || (o.viewCache = []);
    for (let a = 0; a < r.length; a++) {
      const l = {
        ...n,
        colorAttachments: [{
          ...n.colorAttachments[0],
          view: n.colorAttachments[a].view
        }]
      };
      if (n.depthStencilAttachment) {
        const u = a;
        o.viewCache[u] || (o.viewCache[u] = o.texture.createView({
          dimension: cr.TwoD,
          baseArrayLayer: a,
          arrayLayerCount: 1
        })), l.depthStencilAttachment = {
          view: o.viewCache[u],
          depthLoadOp: s.depthLoadOp || ti.Clear,
          depthStoreOp: s.depthStoreOp || Ms.Store,
          depthClearValue: s.depthClearValue || 1
        }, e.stencil && (l.depthStencilAttachment.stencilLoadOp = s.stencilLoadOp, l.depthStencilAttachment.stencilStoreOp = s.stencilStoreOp, l.depthStencilAttachment.stencilClearValue = s.stencilClearValue);
      } else
        l.depthStencilAttachment = { ...s };
      t.layerDescriptors.push(l);
    }
  }
  /**
   * This method updates the layer descriptors for each camera in an array camera
   * to prepare for rendering to a depth array texture.
   *
   * @param {RenderContext} renderContext - The render context.
   * @param {Object} renderContextData - The render context data.
   * @param {ArrayCamera} cameras - The array camera.
   *
   */
  _updateDepthLayerDescriptors(e, t, n) {
    for (let r = 0; r < n.length; r++) {
      const s = t.layerDescriptors[r];
      if (s.depthStencilAttachment) {
        const o = s.depthStencilAttachment;
        e.depth && (e.clearDepth ? (o.depthClearValue = e.clearDepthValue, o.depthLoadOp = ti.Clear) : o.depthLoadOp = ti.Load), e.stencil && (e.clearStencil ? (o.stencilClearValue = e.clearStencilValue, o.stencilLoadOp = ti.Clear) : o.stencilLoadOp = ti.Load);
      }
    }
  }
  /**
   * This method is executed at the end of a render call and finalizes work
   * after draw calls.
   *
   * @param {RenderContext} renderContext - The render context.
   */
  finishRender(e) {
    const t = this.get(e), n = e.occlusionQueryCount;
    t.renderBundles.length > 0 && t.currentPass.executeBundles(t.renderBundles), n > t.occlusionQueryIndex && t.currentPass.endOcclusionQuery();
    const r = t.encoder;
    if (this._isRenderCameraDepthArray(e) === !0) {
      const s = [];
      for (let o = 0; o < t.bundleEncoders.length; o++) {
        const a = t.bundleEncoders[o];
        s.push(a.finish());
      }
      for (let o = 0; o < t.layerDescriptors.length; o++)
        if (o < s.length) {
          const a = t.layerDescriptors[o], l = r.beginRenderPass(a);
          if (e.viewport) {
            const { x: u, y: c, width: A, height: m, minDepth: _, maxDepth: y } = e.viewportValue;
            l.setViewport(u, c, A, m, _, y);
          }
          if (e.scissor) {
            const { x: u, y: c, width: A, height: m } = e.scissorValue;
            l.setScissorRect(u, c, A, m);
          }
          l.executeBundles([s[o]]), l.end();
        }
    } else t.currentPass && t.currentPass.end();
    if (n > 0) {
      const s = n * 8;
      let o = this.occludedResolveCache.get(s);
      o === void 0 && (o = this.device.createBuffer(
        {
          size: s,
          usage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC
        }
      ), this.occludedResolveCache.set(s, o));
      const a = this.device.createBuffer(
        {
          size: s,
          usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
        }
      );
      t.encoder.resolveQuerySet(t.occlusionQuerySet, 0, n, o, 0), t.encoder.copyBufferToBuffer(o, 0, a, 0, s), t.occlusionQueryBuffer = a, this.resolveOccludedAsync(e);
    }
    if (this.device.queue.submit([t.encoder.finish()]), e.textures !== null) {
      const s = e.textures;
      for (let o = 0; o < s.length; o++) {
        const a = s[o];
        a.generateMipmaps === !0 && this.textureUtils.generateMipmaps(a);
      }
    }
  }
  /**
   * Returns `true` if the given 3D object is fully occluded by other
   * 3D objects in the scene.
   *
   * @param {RenderContext} renderContext - The render context.
   * @param {Object3D} object - The 3D object to test.
   * @return {boolean} Whether the 3D object is fully occluded or not.
   */
  isOccluded(e, t) {
    const n = this.get(e);
    return n.occluded && n.occluded.has(t);
  }
  /**
   * This method processes the result of occlusion queries and writes it
   * into render context data.
   *
   * @async
   * @param {RenderContext} renderContext - The render context.
   * @return {Promise} A Promise that resolves when the occlusion query results have been processed.
   */
  async resolveOccludedAsync(e) {
    const t = this.get(e), { currentOcclusionQueryBuffer: n, currentOcclusionQueryObjects: r } = t;
    if (n && r) {
      const s = /* @__PURE__ */ new WeakSet();
      t.currentOcclusionQueryObjects = null, t.currentOcclusionQueryBuffer = null, await n.mapAsync(GPUMapMode.READ);
      const o = n.getMappedRange(), a = new BigUint64Array(o);
      for (let l = 0; l < r.length; l++)
        a[l] === BigInt(0) && s.add(r[l]);
      n.destroy(), t.occluded = s;
    }
  }
  /**
   * Updates the viewport with the values from the given render context.
   *
   * @param {RenderContext} renderContext - The render context.
   */
  updateViewport(e) {
    const { currentPass: t } = this.get(e), { x: n, y: r, width: s, height: o, minDepth: a, maxDepth: l } = e.viewportValue;
    t.setViewport(n, r, s, o, a, l);
  }
  /**
   * Updates the scissor with the values from the given render context.
   *
   * @param {RenderContext} renderContext - The render context.
   */
  updateScissor(e) {
    const { currentPass: t } = this.get(e), { x: n, y: r, width: s, height: o } = e.scissorValue;
    t.setScissorRect(n, r, s, o);
  }
  /**
   * Returns the clear color and alpha into a single
   * color object.
   *
   * @return {Color4} The clear color.
   */
  getClearColor() {
    const e = super.getClearColor();
    return this.renderer.alpha === !0 && (e.r *= e.a, e.g *= e.a, e.b *= e.a), e;
  }
  /**
   * Performs a clear operation.
   *
   * @param {boolean} color - Whether the color buffer should be cleared or not.
   * @param {boolean} depth - Whether the depth buffer should be cleared or not.
   * @param {boolean} stencil - Whether the stencil buffer should be cleared or not.
   * @param {?RenderContext} [renderTargetContext=null] - The render context of the current set render target.
   */
  clear(e, t, n, r = null) {
    const s = this.device, o = this.renderer;
    let a = [], l, u, c, A;
    if (e) {
      const y = this.getClearColor();
      u = { r: y.r, g: y.g, b: y.b, a: y.a };
    }
    if (r === null) {
      c = o.depth, A = o.stencil;
      const y = this._getDefaultRenderPassDescriptor();
      if (e) {
        a = y.colorAttachments;
        const T = a[0];
        T.clearValue = u, T.loadOp = ti.Clear, T.storeOp = Ms.Store;
      }
      (c || A) && (l = y.depthStencilAttachment);
    } else {
      c = r.depth, A = r.stencil;
      const y = {
        loadOp: e ? ti.Clear : ti.Load,
        clearValue: e ? u : void 0
      };
      c && (y.depthLoadOp = t ? ti.Clear : ti.Load, y.depthClearValue = t ? o.getClearDepth() : void 0, y.depthStoreOp = Ms.Store), A && (y.stencilLoadOp = n ? ti.Clear : ti.Load, y.stencilClearValue = n ? o.getClearStencil() : void 0, y.stencilStoreOp = Ms.Store);
      const T = this._getRenderPassDescriptor(r, y);
      a = T.colorAttachments, l = T.depthStencilAttachment;
    }
    c && l && (t ? (l.depthLoadOp = ti.Clear, l.depthClearValue = o.getClearDepth(), l.depthStoreOp = Ms.Store) : (l.depthLoadOp = ti.Load, l.depthStoreOp = Ms.Store)), A && l && (n ? (l.stencilLoadOp = ti.Clear, l.stencilClearValue = o.getClearStencil(), l.stencilStoreOp = Ms.Store) : (l.stencilLoadOp = ti.Load, l.stencilStoreOp = Ms.Store));
    const m = s.createCommandEncoder({ label: "clear" });
    m.beginRenderPass({
      colorAttachments: a,
      depthStencilAttachment: l
    }).end(), s.queue.submit([m.finish()]);
  }
  // compute
  /**
   * This method is executed at the beginning of a compute call and
   * prepares the state for upcoming compute tasks.
   *
   * @param {Node|Array<Node>} computeGroup - The compute node(s).
   */
  beginCompute(e) {
    const t = this.get(e), n = {
      label: "computeGroup_" + e.id
    };
    this.initTimestampQuery(pa.COMPUTE, this.getTimestampUID(e), n), t.cmdEncoderGPU = this.device.createCommandEncoder({ label: "computeGroup_" + e.id }), t.passEncoderGPU = t.cmdEncoderGPU.beginComputePass(n);
  }
  /**
   * Executes a compute command for the given compute node.
   *
   * @param {Node|Array<Node>} computeGroup - The group of compute nodes of a compute call. Can be a single compute node.
   * @param {Node} computeNode - The compute node.
   * @param {Array<BindGroup>} bindings - The bindings.
   * @param {ComputePipeline} pipeline - The compute pipeline.
   * @param {number|Array<number>|IndirectStorageBufferAttribute} [dispatchSize=null]
   * - A single number representing count, or
   * - An array [x, y, z] representing dispatch size, or
   * - A IndirectStorageBufferAttribute for indirect dispatch size.
   */
  compute(e, t, n, r, s = null) {
    const o = this.get(t), { passEncoderGPU: a } = this.get(e), l = this.get(r).pipeline;
    this.pipelineUtils.setPipeline(a, l);
    for (let u = 0, c = n.length; u < c; u++) {
      const A = n[u], m = this.get(A);
      a.setBindGroup(u, m.group);
    }
    if (s === null && (s = t.count), s && typeof s == "object" && s.isIndirectStorageBufferAttribute) {
      const u = this.get(s).buffer;
      a.dispatchWorkgroupsIndirect(u, 0);
      return;
    }
    if (typeof s == "number") {
      const u = s;
      if (o.dispatchSize === void 0 || o.count !== u) {
        o.dispatchSize = [0, 1, 1], o.count = u;
        const c = t.workgroupSize;
        let A = c[0];
        for (let y = 1; y < c.length; y++)
          A *= c[y];
        const m = Math.ceil(u / A), _ = this.device.limits.maxComputeWorkgroupsPerDimension;
        s = [m, 1, 1], m > _ && (s[0] = Math.min(m, _), s[1] = Math.ceil(m / _)), o.dispatchSize = s;
      }
      s = o.dispatchSize;
    }
    a.dispatchWorkgroups(
      s[0],
      s[1] || 1,
      s[2] || 1
    );
  }
  /**
   * This method is executed at the end of a compute call and
   * finalizes work after compute tasks.
   *
   * @param {Node|Array<Node>} computeGroup - The compute node(s).
   */
  finishCompute(e) {
    const t = this.get(e);
    t.passEncoderGPU.end(), this.device.queue.submit([t.cmdEncoderGPU.finish()]);
  }
  // render object
  /**
   * Executes a draw command for the given render object.
   *
   * @param {RenderObject} renderObject - The render object to draw.
   * @param {Info} info - Holds a series of statistical information about the GPU memory and the rendering process.
   */
  draw(e, t) {
    const { object: n, material: r, context: s, pipeline: o } = e, a = e.getBindings(), l = this.get(s), u = this.get(o), c = u.pipeline;
    if (u.error === !0) return;
    const A = e.getIndex(), m = A !== null, _ = e.getDrawParameters();
    if (_ === null) return;
    const y = (b, S) => {
      this.pipelineUtils.setPipeline(b, c), S.pipeline = c;
      const E = S.bindingGroups;
      for (let C = 0, L = a.length; C < L; C++) {
        const D = a[C], B = this.get(D);
        E[D.index] !== D.id && (b.setBindGroup(D.index, B.group), E[D.index] = D.id);
      }
      if (m === !0 && S.index !== A) {
        const C = this.get(A).buffer, L = A.array instanceof Uint16Array ? Kf.Uint16 : Kf.Uint32;
        b.setIndexBuffer(C, L), S.index = A;
      }
      const R = e.getVertexBuffers();
      for (let C = 0, L = R.length; C < L; C++) {
        const D = R[C];
        if (S.attributes[C] !== D) {
          const B = this.get(D).buffer;
          b.setVertexBuffer(C, B), S.attributes[C] = D;
        }
      }
      s.stencil === !0 && r.stencilWrite === !0 && l.currentStencilRef !== r.stencilRef && (b.setStencilReference(r.stencilRef), l.currentStencilRef = r.stencilRef);
    }, T = (b, S) => {
      if (y(b, S), n.isBatchedMesh === !0) {
        const E = n._multiDrawStarts, R = n._multiDrawCounts, C = n._multiDrawCount, L = n._multiDrawInstances;
        L !== null && li("WebGPUBackend: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection.");
        for (let D = 0; D < C; D++) {
          const B = L ? L[D] : 1, U = B > 1 ? 0 : D;
          m === !0 ? b.drawIndexed(R[D], B, E[D] / A.array.BYTES_PER_ELEMENT, 0, U) : b.draw(R[D], B, E[D], U), t.update(n, R[D], B);
        }
      } else if (m === !0) {
        const { vertexCount: E, instanceCount: R, firstVertex: C } = _, L = e.getIndirect();
        if (L !== null) {
          const D = this.get(L).buffer, B = e.getIndirectOffset(), U = Array.isArray(B) ? B : [B];
          for (let N = 0; N < U.length; N++)
            b.drawIndexedIndirect(D, U[N]);
        } else
          b.drawIndexed(E, R, C, 0, 0);
        t.update(n, E, R);
      } else {
        const { vertexCount: E, instanceCount: R, firstVertex: C } = _, L = e.getIndirect();
        if (L !== null) {
          const D = this.get(L).buffer, B = e.getIndirectOffset(), U = Array.isArray(B) ? B : [B];
          for (let N = 0; N < U.length; N++)
            b.drawIndirect(D, U[N]);
        } else
          b.draw(E, R, C, 0);
        t.update(n, E, R);
      }
    };
    if (e.camera.isArrayCamera && e.camera.cameras.length > 0) {
      const b = this.get(e.camera), S = e.camera.cameras, E = e.getBindingGroup("cameraIndex");
      if (b.indexesGPU === void 0 || b.indexesGPU.length !== S.length) {
        const C = this.get(E), L = [], D = new Uint32Array([0, 0, 0, 0]);
        for (let B = 0, U = S.length; B < U; B++) {
          D[0] = B;
          const { layoutGPU: N } = C.layout, O = this.bindingUtils.createBindGroupIndex(D, N);
          L.push(O);
        }
        b.indexesGPU = L;
      }
      const R = this.renderer.getPixelRatio();
      for (let C = 0, L = S.length; C < L; C++) {
        const D = S[C];
        if (n.layers.test(D.layers)) {
          const B = D.viewport;
          let U = l.currentPass, N = l.currentSets;
          if (l.bundleEncoders) {
            const O = l.bundleEncoders[C], G = l.bundleSets[C];
            U = O, N = G;
          }
          B && U.setViewport(
            Math.floor(B.x * R),
            Math.floor(B.y * R),
            Math.floor(B.width * R),
            Math.floor(B.height * R),
            s.viewportValue.minDepth,
            s.viewportValue.maxDepth
          ), E && b.indexesGPU && (U.setBindGroup(E.index, b.indexesGPU[C]), N.bindingGroups[E.index] = E.id), T(U, N);
        }
      }
    } else if (l.currentPass) {
      if (l.occlusionQuerySet !== void 0) {
        const b = l.lastOcclusionObject;
        b !== n && (b !== null && b.occlusionTest === !0 && (l.currentPass.endOcclusionQuery(), l.occlusionQueryIndex++), n.occlusionTest === !0 && (l.currentPass.beginOcclusionQuery(l.occlusionQueryIndex), l.occlusionQueryObjects[l.occlusionQueryIndex] = n), l.lastOcclusionObject = n);
      }
      T(l.currentPass, l.currentSets);
    }
  }
  // cache key
  /**
   * Returns `true` if the render pipeline requires an update.
   *
   * @param {RenderObject} renderObject - The render object.
   * @return {boolean} Whether the render pipeline requires an update or not.
   */
  needsRenderUpdate(e) {
    const t = this.get(e), { object: n, material: r } = e, s = this.utils, o = s.getSampleCountRenderContext(e.context), a = s.getCurrentColorSpace(e.context), l = s.getCurrentColorFormat(e.context), u = s.getCurrentDepthStencilFormat(e.context), c = s.getPrimitiveTopology(n, r);
    let A = !1;
    return (t.material !== r || t.materialVersion !== r.version || t.transparent !== r.transparent || t.blending !== r.blending || t.premultipliedAlpha !== r.premultipliedAlpha || t.blendSrc !== r.blendSrc || t.blendDst !== r.blendDst || t.blendEquation !== r.blendEquation || t.blendSrcAlpha !== r.blendSrcAlpha || t.blendDstAlpha !== r.blendDstAlpha || t.blendEquationAlpha !== r.blendEquationAlpha || t.colorWrite !== r.colorWrite || t.depthWrite !== r.depthWrite || t.depthTest !== r.depthTest || t.depthFunc !== r.depthFunc || t.stencilWrite !== r.stencilWrite || t.stencilFunc !== r.stencilFunc || t.stencilFail !== r.stencilFail || t.stencilZFail !== r.stencilZFail || t.stencilZPass !== r.stencilZPass || t.stencilFuncMask !== r.stencilFuncMask || t.stencilWriteMask !== r.stencilWriteMask || t.side !== r.side || t.alphaToCoverage !== r.alphaToCoverage || t.sampleCount !== o || t.colorSpace !== a || t.colorFormat !== l || t.depthStencilFormat !== u || t.primitiveTopology !== c || t.clippingContextCacheKey !== e.clippingContextCacheKey) && (t.material = r, t.materialVersion = r.version, t.transparent = r.transparent, t.blending = r.blending, t.premultipliedAlpha = r.premultipliedAlpha, t.blendSrc = r.blendSrc, t.blendDst = r.blendDst, t.blendEquation = r.blendEquation, t.blendSrcAlpha = r.blendSrcAlpha, t.blendDstAlpha = r.blendDstAlpha, t.blendEquationAlpha = r.blendEquationAlpha, t.colorWrite = r.colorWrite, t.depthWrite = r.depthWrite, t.depthTest = r.depthTest, t.depthFunc = r.depthFunc, t.stencilWrite = r.stencilWrite, t.stencilFunc = r.stencilFunc, t.stencilFail = r.stencilFail, t.stencilZFail = r.stencilZFail, t.stencilZPass = r.stencilZPass, t.stencilFuncMask = r.stencilFuncMask, t.stencilWriteMask = r.stencilWriteMask, t.side = r.side, t.alphaToCoverage = r.alphaToCoverage, t.sampleCount = o, t.colorSpace = a, t.colorFormat = l, t.depthStencilFormat = u, t.primitiveTopology = c, t.clippingContextCacheKey = e.clippingContextCacheKey, A = !0), A;
  }
  /**
   * Returns a cache key that is used to identify render pipelines.
   *
   * @param {RenderObject} renderObject - The render object.
   * @return {string} The cache key.
   */
  getRenderCacheKey(e) {
    const { object: t, material: n } = e, r = this.utils, s = e.context, o = t.isMesh && t.matrixWorld.determinant() < 0;
    return [
      n.transparent,
      n.blending,
      n.premultipliedAlpha,
      n.blendSrc,
      n.blendDst,
      n.blendEquation,
      n.blendSrcAlpha,
      n.blendDstAlpha,
      n.blendEquationAlpha,
      n.colorWrite,
      n.depthWrite,
      n.depthTest,
      n.depthFunc,
      n.stencilWrite,
      n.stencilFunc,
      n.stencilFail,
      n.stencilZFail,
      n.stencilZPass,
      n.stencilFuncMask,
      n.stencilWriteMask,
      n.side,
      o,
      r.getSampleCountRenderContext(s),
      r.getCurrentColorSpace(s),
      r.getCurrentColorFormat(s),
      r.getCurrentDepthStencilFormat(s),
      r.getPrimitiveTopology(t, n),
      e.getGeometryCacheKey(),
      e.clippingContextCacheKey
    ].join();
  }
  // textures
  /**
   * Updates a GPU sampler for the given texture.
   *
   * @param {Texture} texture - The texture to update the sampler for.
   * @return {string} The current sampler key.
   */
  updateSampler(e) {
    return this.textureUtils.updateSampler(e);
  }
  /**
   * Creates a default texture for the given texture that can be used
   * as a placeholder until the actual texture is ready for usage.
   *
   * @param {Texture} texture - The texture to create a default texture for.
   * @return {boolean} Whether the sampler has been updated or not.
   */
  createDefaultTexture(e) {
    return this.textureUtils.createDefaultTexture(e);
  }
  /**
   * Defines a texture on the GPU for the given texture object.
   *
   * @param {Texture} texture - The texture.
   * @param {Object} [options={}] - Optional configuration parameter.
   */
  createTexture(e, t) {
    this.textureUtils.createTexture(e, t);
  }
  /**
   * Uploads the updated texture data to the GPU.
   *
   * @param {Texture} texture - The texture.
   * @param {Object} [options={}] - Optional configuration parameter.
   */
  updateTexture(e, t) {
    this.textureUtils.updateTexture(e, t);
  }
  /**
   * Generates mipmaps for the given texture.
   *
   * @param {Texture} texture - The texture.
   */
  generateMipmaps(e) {
    this.textureUtils.generateMipmaps(e);
  }
  /**
   * Destroys the GPU data for the given texture object.
   *
   * @param {Texture} texture - The texture.
   * @param {boolean} [isDefaultTexture=false] - Whether the texture uses a default GPU texture or not.
   */
  destroyTexture(e, t = !1) {
    this.textureUtils.destroyTexture(e, t);
  }
  /**
   * Returns texture data as a typed array.
   *
   * @async
   * @param {Texture} texture - The texture to copy.
   * @param {number} x - The x coordinate of the copy origin.
   * @param {number} y - The y coordinate of the copy origin.
   * @param {number} width - The width of the copy.
   * @param {number} height - The height of the copy.
   * @param {number} faceIndex - The face index.
   * @return {Promise<TypedArray>} A Promise that resolves with a typed array when the copy operation has finished.
   */
  async copyTextureToBuffer(e, t, n, r, s, o) {
    return this.textureUtils.copyTextureToBuffer(e, t, n, r, s, o);
  }
  /**
   * Inits a time stamp query for the given render context.
   *
   * @param {string} type - The type of the timestamp query (e.g. 'render', 'compute').
   * @param {number} uid - Unique id for the context (e.g. render context id).
   * @param {Object} descriptor - The query descriptor.
   */
  initTimestampQuery(e, t, n) {
    if (!this.trackTimestamp) return;
    this.timestampQueryPool[e] || (this.timestampQueryPool[e] = new cle(this.device, e, 2048));
    const r = this.timestampQueryPool[e], s = r.allocateQueriesForContext(t);
    n.timestampWrites = {
      querySet: r.querySet,
      beginningOfPassWriteIndex: s,
      endOfPassWriteIndex: s + 1
    };
  }
  // node builder
  /**
   * Returns a node builder for the given render object.
   *
   * @param {RenderObject} object - The render object.
   * @param {Renderer} renderer - The renderer.
   * @return {WGSLNodeBuilder} The node builder.
   */
  createNodeBuilder(e, t) {
    return new nle(e, t);
  }
  // program
  /**
   * Creates a shader program from the given programmable stage.
   *
   * @param {ProgrammableStage} program - The programmable stage.
   */
  createProgram(e) {
    const t = this.get(e);
    t.module = {
      module: this.device.createShaderModule({ code: e.code, label: e.stage + (e.name !== "" ? `_${e.name}` : "") }),
      entryPoint: "main"
    };
  }
  /**
   * Destroys the shader program of the given programmable stage.
   *
   * @param {ProgrammableStage} program - The programmable stage.
   */
  destroyProgram(e) {
    this.delete(e);
  }
  // pipelines
  /**
   * Creates a render pipeline for the given render object.
   *
   * @param {RenderObject} renderObject - The render object.
   * @param {Array<Promise>} promises - An array of compilation promises which are used in `compileAsync()`.
   */
  createRenderPipeline(e, t) {
    this.pipelineUtils.createRenderPipeline(e, t);
  }
  /**
   * Creates a compute pipeline for the given compute node.
   *
   * @param {ComputePipeline} computePipeline - The compute pipeline.
   * @param {Array<BindGroup>} bindings - The bindings.
   */
  createComputePipeline(e, t) {
    this.pipelineUtils.createComputePipeline(e, t);
  }
  /**
   * Prepares the state for encoding render bundles.
   *
   * @param {RenderContext} renderContext - The render context.
   */
  beginBundle(e) {
    const t = this.get(e);
    t._currentPass = t.currentPass, t._currentSets = t.currentSets, t.currentSets = { attributes: {}, bindingGroups: [], pipeline: null, index: null }, t.currentPass = this.pipelineUtils.createBundleEncoder(e);
  }
  /**
   * After processing render bundles this method finalizes related work.
   *
   * @param {RenderContext} renderContext - The render context.
   * @param {RenderBundle} bundle - The render bundle.
   */
  finishBundle(e, t) {
    const n = this.get(e), s = n.currentPass.finish();
    this.get(t).bundleGPU = s, n.currentSets = n._currentSets, n.currentPass = n._currentPass;
  }
  /**
   * Adds a render bundle to the render context data.
   *
   * @param {RenderContext} renderContext - The render context.
   * @param {RenderBundle} bundle - The render bundle to add.
   */
  addBundle(e, t) {
    this.get(e).renderBundles.push(this.get(t).bundleGPU);
  }
  // bindings
  /**
   * Creates bindings from the given bind group definition.
   *
   * @param {BindGroup} bindGroup - The bind group.
   * @param {Array<BindGroup>} bindings - Array of bind groups.
   * @param {number} cacheIndex - The cache index.
   * @param {number} version - The version.
   */
  createBindings(e, t, n, r) {
    this.bindingUtils.createBindings(e, t, n, r);
  }
  /**
   * Updates the given bind group definition.
   *
   * @param {BindGroup} bindGroup - The bind group.
   * @param {Array<BindGroup>} bindings - Array of bind groups.
   * @param {number} cacheIndex - The cache index.
   * @param {number} version - The version.
   */
  updateBindings(e, t, n, r) {
    this.bindingUtils.createBindings(e, t, n, r);
  }
  /**
   * Updates a buffer binding.
   *
   *  @param {Buffer} binding - The buffer binding to update.
   */
  updateBinding(e) {
    this.bindingUtils.updateBinding(e);
  }
  /**
   * Delete data associated with the current bind group.
   *
   * @param {BindGroup} bindGroup - The bind group.
   */
  deleteBindGroupData(e) {
    this.bindingUtils.deleteBindGroupData(e);
  }
  // attributes
  /**
   * Creates the buffer of an indexed shader attribute.
   *
   * @param {BufferAttribute} attribute - The indexed buffer attribute.
   */
  createIndexAttribute(e) {
    let t = GPUBufferUsage.INDEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST;
    (e.isStorageBufferAttribute || e.isStorageInstancedBufferAttribute) && (t |= GPUBufferUsage.STORAGE), this.attributeUtils.createAttribute(e, t);
  }
  /**
   * Creates the GPU buffer of a shader attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute.
   */
  createAttribute(e) {
    this.attributeUtils.createAttribute(e, GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST);
  }
  /**
   * Creates the GPU buffer of a storage attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute.
   */
  createStorageAttribute(e) {
    this.attributeUtils.createAttribute(e, GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST);
  }
  /**
   * Creates the GPU buffer of an indirect storage attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute.
   */
  createIndirectStorageAttribute(e) {
    this.attributeUtils.createAttribute(e, GPUBufferUsage.STORAGE | GPUBufferUsage.INDIRECT | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST);
  }
  /**
   * Updates the GPU buffer of a shader attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute to update.
   */
  updateAttribute(e) {
    this.attributeUtils.updateAttribute(e);
  }
  /**
   * Destroys the GPU buffer of a shader attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute to destroy.
   */
  destroyAttribute(e) {
    this.attributeUtils.destroyAttribute(e);
  }
  // canvas
  /**
   * Triggers an update of the default render pass descriptor.
   */
  updateSize() {
    this.delete(this.renderer.getCanvasTarget());
  }
  // utils public
  /**
   * Returns the maximum anisotropy texture filtering value.
   *
   * @return {number} The maximum anisotropy texture filtering value.
   */
  getMaxAnisotropy() {
    return 16;
  }
  /**
   * Checks if the given feature is supported by the backend.
   *
   * @param {string} name - The feature's name.
   * @return {boolean} Whether the feature is supported or not.
   */
  hasFeature(e) {
    return PC[e] !== void 0 && (e = PC[e]), this.device.features.has(e);
  }
  /**
   * Copies data of the given source texture to the given destination texture.
   *
   * @param {Texture} srcTexture - The source texture.
   * @param {Texture} dstTexture - The destination texture.
   * @param {?(Box3|Box2)} [srcRegion=null] - The region of the source texture to copy.
   * @param {?(Vector2|Vector3)} [dstPosition=null] - The destination position of the copy.
   * @param {number} [srcLevel=0] - The mipmap level to copy.
   * @param {number} [dstLevel=0] - The destination mip level to copy to.
   */
  copyTextureToTexture(e, t, n = null, r = null, s = 0, o = 0) {
    let a = 0, l = 0, u = 0, c = 0, A = 0, m = 0, _ = e.image.width, y = e.image.height, T = 1;
    n !== null && (n.isBox3 === !0 ? (c = n.min.x, A = n.min.y, m = n.min.z, _ = n.max.x - n.min.x, y = n.max.y - n.min.y, T = n.max.z - n.min.z) : (c = n.min.x, A = n.min.y, _ = n.max.x - n.min.x, y = n.max.y - n.min.y, T = 1)), r !== null && (a = r.x, l = r.y, u = r.z || 0);
    const b = this.device.createCommandEncoder({ label: "copyTextureToTexture_" + e.id + "_" + t.id }), S = this.get(e).texture, E = this.get(t).texture;
    b.copyTextureToTexture(
      {
        texture: S,
        mipLevel: s,
        origin: { x: c, y: A, z: m }
      },
      {
        texture: E,
        mipLevel: o,
        origin: { x: a, y: l, z: u }
      },
      [
        _,
        y,
        T
      ]
    ), this.device.queue.submit([b.finish()]), o === 0 && t.generateMipmaps && this.textureUtils.generateMipmaps(t);
  }
  /**
   * Copies the current bound framebuffer to the given texture.
   *
   * @param {Texture} texture - The destination texture.
   * @param {RenderContext} renderContext - The render context.
   * @param {Vector4} rectangle - A four dimensional vector defining the origin and dimension of the copy.
   */
  copyFramebufferToTexture(e, t, n) {
    const r = this.get(t);
    let s = null;
    t.renderTarget ? e.isDepthTexture ? s = this.get(t.depthTexture).texture : s = this.get(t.textures[0]).texture : e.isDepthTexture ? s = this.textureUtils.getDepthBuffer(t.depth, t.stencil) : s = this.context.getCurrentTexture();
    const o = this.get(e).texture;
    if (s.format !== o.format) {
      Ie("WebGPUBackend: copyFramebufferToTexture: Source and destination formats do not match.", s.format, o.format);
      return;
    }
    let a;
    if (r.currentPass ? (r.currentPass.end(), a = r.encoder) : a = this.device.createCommandEncoder({ label: "copyFramebufferToTexture_" + e.id }), a.copyTextureToTexture(
      {
        texture: s,
        origin: [n.x, n.y, 0]
      },
      {
        texture: o
      },
      [
        n.z,
        n.w
      ]
    ), e.generateMipmaps && this.textureUtils.generateMipmaps(e, a), r.currentPass) {
      const { descriptor: l } = r;
      for (let u = 0; u < l.colorAttachments.length; u++)
        l.colorAttachments[u].loadOp = ti.Load;
      t.depth && (l.depthStencilAttachment.depthLoadOp = ti.Load), t.stencil && (l.depthStencilAttachment.stencilLoadOp = ti.Load), r.currentPass = a.beginRenderPass(l), r.currentSets = { attributes: {}, bindingGroups: [], pipeline: null, index: null }, t.viewport && this.updateViewport(t), t.scissor && this.updateScissor(t);
    } else
      this.device.queue.submit([a.finish()]);
  }
  dispose() {
    if (this.bindingUtils.dispose(), this.textureUtils.dispose(), this.occludedResolveCache) {
      for (const e of this.occludedResolveCache.values())
        e.destroy();
      this.occludedResolveCache.clear();
    }
    if (this.timestampQueryPool)
      for (const e of Object.values(this.timestampQueryPool))
        e !== null && e.dispose();
    this.parameters.device === void 0 && this.device !== null && this.device.destroy();
  }
}
class dle extends N0 {
  /**
   * Constructs a new IES spot light.
   *
   * @param {(number|Color|string)} [color=0xffffff] - The light's color.
   * @param {number} [intensity=1] - The light's strength/intensity measured in candela (cd).
   * @param {number} [distance=0] - Maximum range of the light. `0` means no limit.
   * @param {number} [angle=Math.PI/3] - Maximum angle of light dispersion from its direction whose upper bound is `Math.PI/2`.
   * @param {number} [penumbra=0] - Percent of the spotlight cone that is attenuated due to penumbra. Value range is `[0,1]`.
   * @param {number} [decay=2] - The amount the light dims along the distance of the light.
   */
  constructor(e, t, n, r, s, o) {
    super(e, t, n, r, s, o), this.iesMap = null;
  }
  copy(e, t) {
    return super.copy(e, t), this.iesMap = e.iesMap, this;
  }
}
class fle extends N0 {
  /**
   * Constructs a new projector light.
   *
   * @param {(number|Color|string)} [color=0xffffff] - The light's color.
   * @param {number} [intensity=1] - The light's strength/intensity measured in candela (cd).
   * @param {number} [distance=0] - Maximum range of the light. `0` means no limit.
   * @param {number} [angle=Math.PI/3] - Maximum angle of light dispersion from its direction whose upper bound is `Math.PI/2`.
   * @param {number} [penumbra=0] - Percent of the spotlight cone that is attenuated due to penumbra. Value range is `[0,1]`.
   * @param {number} [decay=2] - The amount the light dims along the distance of the light.
   */
  constructor(e, t, n, r, s, o) {
    super(e, t, n, r, s, o), this.aspect = null;
  }
  copy(e, t) {
    return super.copy(e, t), this.aspect = e.aspect, this;
  }
}
class Ale extends TI {
  /**
   * Constructs a new standard node library.
   */
  constructor() {
    super(), this.addMaterial(qJ, "MeshPhongMaterial"), this.addMaterial(vL, "MeshStandardMaterial"), this.addMaterial(Iee, "MeshPhysicalMaterial"), this.addMaterial(Oee, "MeshToonMaterial"), this.addMaterial(FJ, "MeshBasicMaterial"), this.addMaterial(GJ, "MeshLambertMaterial"), this.addMaterial(NJ, "MeshNormalMaterial"), this.addMaterial(Vee, "MeshMatcapMaterial"), this.addMaterial(wJ, "LineBasicMaterial"), this.addMaterial(EJ, "LineDashedMaterial"), this.addMaterial(Wee, "PointsMaterial"), this.addMaterial(SL, "SpriteMaterial"), this.addMaterial(Yee, "ShadowMaterial"), this.addLight(Dre, oS), this.addLight(qoe, p2), this.addLight(Hoe, aS), this.addLight(lw, N0), this.addLight(Xoe, m2), this.addLight(Yoe, rS), this.addLight(Qoe, uS), this.addLight(Woe, dle), this.addLight(joe, fle), this.addToneMapping(GL, L_), this.addToneMapping(zL, I_), this.addToneMapping(qL, B_), this.addToneMapping(HL, F_), this.addToneMapping(WL, U_), this.addToneMapping($L, O_);
  }
}
class FI extends mae {
  /**
   * WebGPURenderer options.
   *
   * @typedef {Object} WebGPURenderer~Options
   * @property {boolean} [logarithmicDepthBuffer=false] - Whether logarithmic depth buffer is enabled or not.
   * @property {boolean} [alpha=true] - Whether the default framebuffer (which represents the final contents of the canvas) should be transparent or opaque.
   * @property {boolean} [depth=true] - Whether the default framebuffer should have a depth buffer or not.
   * @property {boolean} [stencil=false] - Whether the default framebuffer should have a stencil buffer or not.
   * @property {boolean} [antialias=false] - Whether MSAA as the default anti-aliasing should be enabled or not.
   * @property {number} [samples=0] - When `antialias` is `true`, `4` samples are used by default. Set this parameter to any other integer value than 0 to overwrite the default.
   * @property {boolean} [forceWebGL=false] - If set to `true`, the renderer uses a WebGL 2 backend no matter if WebGPU is supported or not.
   * @property {boolean} [multiview=false] - If set to `true`, the renderer will use multiview during WebXR rendering if supported.
   * @property {number} [outputType=undefined] - Texture type for output to canvas. By default, device's preferred format is used; other formats may incur overhead.
   * @property {number} [outputBufferType=HalfFloatType] - Defines the type of output buffers. The default `HalfFloatType` is recommend for best
   * quality. To save memory and bandwidth, `UnsignedByteType` might be used. This will reduce rendering quality though.
   */
  /**
   * Constructs a new WebGPU renderer.
   *
   * @param {WebGPURenderer~Options} [parameters] - The configuration parameter.
   */
  constructor(e = {}) {
    let t;
    e.forceWebGL ? t = TC : (t = hle, e.getFallback = () => (Me("WebGPURenderer: WebGPU is not available, running under WebGL2 backend."), new TC(e)));
    const n = new t(e);
    super(n, e), this.library = new Ale(), this.isWebGPURenderer = !0, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
}
F.BRDF_GGX;
F.BRDF_Lambert;
F.BasicPointShadowFilter;
F.BasicShadowFilter;
F.Break;
F.Const;
F.Continue;
F.DFGLUT;
F.D_GGX;
F.Discard;
F.EPSILON;
F.F_Schlick;
const ple = F.Fn;
F.INFINITY;
const mle = F.If, gle = F.Loop;
F.NodeAccess;
F.NodeShaderStage;
F.NodeType;
F.NodeUpdateType;
F.PCFShadowFilter;
F.PCFSoftShadowFilter;
F.PI;
F.PI2;
F.TWO_PI;
F.HALF_PI;
F.PointShadowFilter;
F.Return;
F.Schlick_to_F0;
F.ScriptableNodeResources;
F.ShaderNode;
F.Stack;
F.Switch;
F.TBNViewMatrix;
F.VSMShadowFilter;
F.V_GGX_SmithCorrelated;
F.Var;
F.VarIntent;
F.abs;
F.acesFilmicToneMapping;
F.acos;
F.add;
F.addMethodChaining;
F.addNodeElement;
F.agxToneMapping;
F.all;
F.alphaT;
F.and;
F.anisotropy;
F.anisotropyB;
F.anisotropyT;
F.any;
F.append;
F.array;
F.arrayBuffer;
const _le = F.asin;
F.assign;
F.atan;
F.atan2;
F.atomicAdd;
F.atomicAnd;
F.atomicFunc;
F.atomicLoad;
F.atomicMax;
F.atomicMin;
F.atomicOr;
F.atomicStore;
F.atomicSub;
F.atomicXor;
F.attenuationColor;
F.attenuationDistance;
F.attribute;
F.attributeArray;
F.backgroundBlurriness;
F.backgroundIntensity;
F.backgroundRotation;
F.batch;
F.bentNormalView;
F.billboarding;
F.bitAnd;
F.bitNot;
F.bitOr;
F.bitXor;
F.bitangentGeometry;
F.bitangentLocal;
F.bitangentView;
F.bitangentWorld;
F.bitcast;
F.blendBurn;
F.blendColor;
F.blendDodge;
F.blendOverlay;
F.blendScreen;
F.blur;
F.bool;
F.buffer;
F.bufferAttribute;
F.bumpMap;
F.burn;
F.builtin;
F.builtinAOContext;
F.builtinShadowContext;
F.bvec2;
F.bvec3;
F.bvec4;
F.bypass;
F.cache;
F.call;
F.cameraFar;
F.cameraIndex;
F.cameraNear;
F.cameraNormalMatrix;
F.cameraPosition;
F.cameraProjectionMatrix;
F.cameraProjectionMatrixInverse;
F.cameraViewMatrix;
F.cameraViewport;
F.cameraWorldMatrix;
F.cbrt;
F.cdl;
F.ceil;
F.checker;
F.cineonToneMapping;
F.clamp;
F.clearcoat;
F.clearcoatNormalView;
F.clearcoatRoughness;
F.code;
F.color;
F.colorSpaceToWorking;
F.colorToDirection;
F.compute;
F.computeKernel;
F.computeSkinning;
F.context;
F.convert;
F.convertColorSpace;
F.convertToTexture;
F.countLeadingZeros;
F.countOneBits;
F.countTrailingZeros;
const xle = F.cos;
F.cross;
F.cubeTexture;
F.cubeTextureBase;
F.dFdx;
F.dFdy;
F.dashSize;
F.debug;
F.decrement;
F.decrementBefore;
F.defaultBuildStages;
F.defaultShaderStages;
F.defined;
F.degrees;
F.deltaTime;
F.densityFog;
F.densityFogFactor;
F.depth;
F.depthPass;
F.determinant;
F.difference;
F.diffuseColor;
F.directPointLight;
F.directionToColor;
F.directionToFaceDirection;
F.dispersion;
F.distance;
F.div;
F.dodge;
F.dot;
F.drawIndex;
F.dynamicBufferAttribute;
F.element;
F.emissive;
F.equal;
F.equals;
F.equirectUV;
const yle = F.exp;
F.exp2;
F.expression;
F.faceDirection;
F.faceForward;
F.faceforward;
const vle = F.float;
F.floatBitsToInt;
F.floatBitsToUint;
F.floor;
F.fog;
F.fract;
F.frameGroup;
F.frameId;
F.frontFacing;
F.fwidth;
F.gain;
F.gapSize;
F.getConstNodeType;
F.getCurrentStack;
F.getDirection;
F.getDistanceAttenuation;
F.getGeometryRoughness;
F.getNormalFromDepth;
F.interleavedGradientNoise;
F.vogelDiskSample;
F.getParallaxCorrectNormal;
F.getRoughness;
F.getScreenPosition;
F.getShIrradianceAt;
F.getShadowMaterial;
F.getShadowRenderObjectFunction;
F.getTextureIndex;
F.getViewPosition;
F.globalId;
F.glsl;
F.glslFn;
F.grayscale;
F.greaterThan;
F.greaterThanEqual;
F.hash;
F.highpModelNormalViewMatrix;
F.highpModelViewMatrix;
F.hue;
F.increment;
F.incrementBefore;
F.instance;
const ble = F.instanceIndex;
F.instancedArray;
F.instancedBufferAttribute;
F.instancedDynamicBufferAttribute;
F.instancedMesh;
F.int;
F.intBitsToFloat;
F.inverse;
F.inverseSqrt;
F.inversesqrt;
F.invocationLocalIndex;
F.invocationSubgroupIndex;
F.ior;
F.iridescence;
F.iridescenceIOR;
F.iridescenceThickness;
F.ivec2;
F.ivec3;
F.ivec4;
F.js;
F.label;
F.length;
F.lengthSq;
F.lessThan;
F.lessThanEqual;
F.lightPosition;
F.lightProjectionUV;
F.lightShadowMatrix;
F.lightTargetDirection;
F.lightTargetPosition;
F.lightViewPosition;
F.lightingContext;
F.lights;
F.linearDepth;
F.linearToneMapping;
F.localId;
F.log;
F.log2;
F.logarithmicDepthToViewZ;
F.luminance;
F.mat2;
F.mat3;
F.mat4;
F.matcapUV;
F.materialAO;
F.materialAlphaTest;
F.materialAnisotropy;
F.materialAnisotropyVector;
F.materialAttenuationColor;
F.materialAttenuationDistance;
F.materialClearcoat;
F.materialClearcoatNormal;
F.materialClearcoatRoughness;
F.materialColor;
F.materialDispersion;
F.materialEmissive;
F.materialEnvIntensity;
F.materialEnvRotation;
F.materialIOR;
F.materialIridescence;
F.materialIridescenceIOR;
F.materialIridescenceThickness;
F.materialLightMap;
F.materialLineDashOffset;
F.materialLineDashSize;
F.materialLineGapSize;
F.materialLineScale;
F.materialLineWidth;
F.materialMetalness;
F.materialNormal;
F.materialOpacity;
F.materialPointSize;
F.materialReference;
F.materialReflectivity;
F.materialRefractionRatio;
F.materialRotation;
F.materialRoughness;
F.materialSheen;
F.materialSheenRoughness;
F.materialShininess;
F.materialSpecular;
F.materialSpecularColor;
F.materialSpecularIntensity;
F.materialSpecularStrength;
F.materialThickness;
F.materialTransmission;
F.max;
F.maxMipLevel;
F.mediumpModelViewMatrix;
F.metalness;
F.min;
F.mix;
F.mixElement;
F.mod;
F.modInt;
F.modelDirection;
F.modelNormalMatrix;
F.modelPosition;
F.modelRadius;
F.modelScale;
F.modelViewMatrix;
F.modelViewPosition;
F.modelViewProjection;
F.modelWorldMatrix;
F.modelWorldMatrixInverse;
F.morphReference;
F.mrt;
F.mul;
F.mx_aastep;
F.mx_add;
F.mx_atan2;
F.mx_cell_noise_float;
F.mx_contrast;
F.mx_divide;
F.mx_fractal_noise_float;
F.mx_fractal_noise_vec2;
F.mx_fractal_noise_vec3;
F.mx_fractal_noise_vec4;
F.mx_frame;
F.mx_heighttonormal;
F.mx_hsvtorgb;
F.mx_ifequal;
F.mx_ifgreater;
F.mx_ifgreatereq;
F.mx_invert;
F.mx_modulo;
F.mx_multiply;
F.mx_noise_float;
F.mx_noise_vec3;
F.mx_noise_vec4;
F.mx_place2d;
F.mx_power;
F.mx_ramp4;
F.mx_ramplr;
F.mx_ramptb;
F.mx_rgbtohsv;
F.mx_rotate2d;
F.mx_rotate3d;
F.mx_safepower;
F.mx_separate;
F.mx_splitlr;
F.mx_splittb;
F.mx_srgb_texture_to_lin_rec709;
F.mx_subtract;
F.mx_timer;
F.mx_transform_uv;
F.mx_unifiednoise2d;
F.mx_unifiednoise3d;
F.mx_worley_noise_float;
F.mx_worley_noise_vec2;
F.mx_worley_noise_vec3;
const Sle = F.negate;
F.neutralToneMapping;
F.nodeArray;
F.nodeImmutable;
F.nodeObject;
F.nodeObjectIntent;
F.nodeObjects;
F.nodeProxy;
F.nodeProxyIntent;
F.normalFlat;
F.normalGeometry;
F.normalLocal;
F.normalMap;
F.normalView;
F.normalViewGeometry;
F.normalWorld;
F.normalWorldGeometry;
F.normalize;
F.not;
F.notEqual;
F.numWorkgroups;
F.objectDirection;
F.objectGroup;
F.objectPosition;
F.objectRadius;
F.objectScale;
F.objectViewPosition;
F.objectWorldMatrix;
F.OnBeforeObjectUpdate;
F.OnBeforeMaterialUpdate;
F.OnObjectUpdate;
F.OnMaterialUpdate;
F.oneMinus;
F.or;
F.orthographicDepthToViewZ;
F.oscSawtooth;
F.oscSine;
F.oscSquare;
F.oscTriangle;
F.output;
F.outputStruct;
F.overlay;
F.overloadingFn;
F.packHalf2x16;
F.packSnorm2x16;
F.packUnorm2x16;
F.parabola;
F.parallaxDirection;
F.parallaxUV;
F.parameter;
F.pass;
F.passTexture;
F.pcurve;
F.perspectiveDepthToViewZ;
F.pmremTexture;
F.pointShadow;
F.pointUV;
F.pointWidth;
F.positionGeometry;
F.positionLocal;
F.positionPrevious;
F.positionView;
F.positionViewDirection;
F.positionWorld;
F.positionWorldDirection;
F.posterize;
F.pow;
F.pow2;
F.pow3;
F.pow4;
F.premultiplyAlpha;
F.property;
F.radians;
F.rand;
F.range;
F.rangeFog;
F.rangeFogFactor;
F.reciprocal;
F.reference;
F.referenceBuffer;
F.reflect;
F.reflectVector;
F.reflectView;
F.reflector;
F.refract;
F.refractVector;
F.refractView;
F.reinhardToneMapping;
F.remap;
F.remapClamp;
F.renderGroup;
F.renderOutput;
F.rendererReference;
F.replaceDefaultUV;
F.rotate;
F.rotateUV;
F.roughness;
F.round;
F.rtt;
F.sRGBTransferEOTF;
F.sRGBTransferOETF;
F.sample;
F.sampler;
F.samplerComparison;
F.saturate;
F.saturation;
F.screen;
F.screenCoordinate;
F.screenDPR;
F.screenSize;
F.screenUV;
F.scriptable;
F.scriptableValue;
F.select;
F.setCurrentStack;
F.setName;
F.shaderStages;
F.shadow;
F.shadowPositionWorld;
F.shapeCircle;
F.sharedUniformGroup;
F.sheen;
F.sheenRoughness;
F.shiftLeft;
F.shiftRight;
F.shininess;
F.sign;
const Tle = F.sin;
F.sinc;
F.skinning;
F.smoothstep;
F.smoothstepElement;
F.specularColor;
F.specularF90;
F.spherizeUV;
F.split;
F.spritesheetUV;
const wle = F.sqrt;
F.stack;
F.step;
F.stepElement;
const Mle = F.storage;
F.storageBarrier;
F.storageObject;
F.storageTexture;
F.string;
F.struct;
F.sub;
F.subgroupAdd;
F.subgroupAll;
F.subgroupAnd;
F.subgroupAny;
F.subgroupBallot;
F.subgroupBroadcast;
F.subgroupBroadcastFirst;
F.subBuild;
F.subgroupElect;
F.subgroupExclusiveAdd;
F.subgroupExclusiveMul;
F.subgroupInclusiveAdd;
F.subgroupInclusiveMul;
F.subgroupIndex;
F.subgroupMax;
F.subgroupMin;
F.subgroupMul;
F.subgroupOr;
F.subgroupShuffle;
F.subgroupShuffleDown;
F.subgroupShuffleUp;
F.subgroupShuffleXor;
F.subgroupSize;
F.subgroupXor;
F.tan;
F.tangentGeometry;
F.tangentLocal;
F.tangentView;
F.tangentWorld;
F.texture;
F.texture3D;
F.textureBarrier;
F.textureBicubic;
F.textureBicubicLevel;
F.textureCubeUV;
F.textureLoad;
F.textureSize;
F.textureLevel;
F.textureStore;
F.thickness;
F.time;
F.toneMapping;
F.toneMappingExposure;
F.toonOutlinePass;
F.transformDirection;
F.transformNormal;
F.transformNormalToView;
F.transformedClearcoatNormalView;
F.transformedNormalView;
F.transformedNormalWorld;
F.transmission;
F.transpose;
F.triNoise3D;
F.triplanarTexture;
F.triplanarTextures;
F.trunc;
F.uint;
F.uintBitsToFloat;
const Ele = F.uniform;
F.uniformArray;
F.uniformCubeTexture;
F.uniformGroup;
F.uniformFlow;
F.uniformTexture;
F.unpackHalf2x16;
F.unpackSnorm2x16;
F.unpackUnorm2x16;
F.unpremultiplyAlpha;
F.userData;
F.uv;
F.uvec2;
F.uvec3;
F.uvec4;
F.varying;
F.varyingProperty;
F.vec2;
F.vec3;
F.vec4;
F.vectorComponents;
F.velocity;
F.vertexColor;
F.vertexIndex;
F.vertexStage;
F.vibrance;
F.viewZToLogarithmicDepth;
F.viewZToOrthographicDepth;
F.viewZToPerspectiveDepth;
F.viewport;
F.viewportCoordinate;
F.viewportDepthTexture;
F.viewportLinearDepth;
F.viewportMipTexture;
F.viewportResolution;
F.viewportSafeUV;
F.viewportSharedTexture;
F.viewportSize;
F.viewportTexture;
F.viewportUV;
F.wgsl;
F.wgslFn;
F.workgroupArray;
F.workgroupBarrier;
F.workgroupId;
F.workingToColorSpace;
F.xor;
const BC = new dr(), Pg = new j();
class UI extends cS {
  /**
   * Constructs a new line segments geometry.
   */
  constructor() {
    super(), this.isLineSegmentsGeometry = !0, this.type = "LineSegmentsGeometry";
    const e = [-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0], t = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2], n = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5];
    this.setIndex(n), this.setAttribute("position", new xt(e, 3)), this.setAttribute("uv", new xt(t, 2));
  }
  /**
   * Applies the given 4x4 transformation matrix to the geometry.
   *
   * @param {Matrix4} matrix - The matrix to apply.
   * @return {LineSegmentsGeometry} A reference to this instance.
   */
  applyMatrix4(e) {
    const t = this.attributes.instanceStart, n = this.attributes.instanceEnd;
    return t !== void 0 && (t.applyMatrix4(e), n.applyMatrix4(e), t.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  /**
   * Sets the given line positions for this geometry. The length must be a multiple of six since
   * each line segment is defined by a start end vertex in the pattern `(xyz xyz)`.
   *
   * @param {Float32Array|Array<number>} array - The position data to set.
   * @return {LineSegmentsGeometry} A reference to this geometry.
   */
  setPositions(e) {
    let t;
    e instanceof Float32Array ? t = e : Array.isArray(e) && (t = new Float32Array(e));
    const n = new $p(t, 6, 1);
    return this.setAttribute("instanceStart", new Bs(n, 3, 0)), this.setAttribute("instanceEnd", new Bs(n, 3, 3)), this.instanceCount = this.attributes.instanceStart.count, this.computeBoundingBox(), this.computeBoundingSphere(), this;
  }
  /**
   * Sets the given line colors for this geometry. The length must be a multiple of six since
   * each line segment is defined by a start end color in the pattern `(rgb rgb)`.
   *
   * @param {Float32Array|Array<number>} array - The position data to set.
   * @return {LineSegmentsGeometry} A reference to this geometry.
   */
  setColors(e) {
    let t;
    e instanceof Float32Array ? t = e : Array.isArray(e) && (t = new Float32Array(e));
    const n = new $p(t, 6, 1);
    return this.setAttribute("instanceColorStart", new Bs(n, 3, 0)), this.setAttribute("instanceColorEnd", new Bs(n, 3, 3)), this;
  }
  /**
   * Setups this line segments geometry from the given wireframe geometry.
   *
   * @param {WireframeGeometry} geometry - The geometry that should be used as a data source for this geometry.
   * @return {LineSegmentsGeometry} A reference to this geometry.
   */
  fromWireframeGeometry(e) {
    return this.setPositions(e.attributes.position.array), this;
  }
  /**
   * Setups this line segments geometry from the given edges geometry.
   *
   * @param {EdgesGeometry} geometry - The geometry that should be used as a data source for this geometry.
   * @return {LineSegmentsGeometry} A reference to this geometry.
   */
  fromEdgesGeometry(e) {
    return this.setPositions(e.attributes.position.array), this;
  }
  /**
   * Setups this line segments geometry from the given mesh.
   *
   * @param {Mesh} mesh - The mesh geometry that should be used as a data source for this geometry.
   * @return {LineSegmentsGeometry} A reference to this geometry.
   */
  fromMesh(e) {
    return this.fromWireframeGeometry(new H3(e.geometry)), this;
  }
  /**
   * Setups this line segments geometry from the given line segments.
   *
   * @param {LineSegments} lineSegments - The line segments that should be used as a data source for this geometry.
   * Assumes the source geometry is not using indices.
   * @return {LineSegmentsGeometry} A reference to this geometry.
   */
  fromLineSegments(e) {
    const t = e.geometry;
    return this.setPositions(t.attributes.position.array), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new dr());
    const e = this.attributes.instanceStart, t = this.attributes.instanceEnd;
    e !== void 0 && t !== void 0 && (this.boundingBox.setFromBufferAttribute(e), BC.setFromBufferAttribute(t), this.boundingBox.union(BC));
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new fr()), this.boundingBox === null && this.computeBoundingBox();
    const e = this.attributes.instanceStart, t = this.attributes.instanceEnd;
    if (e !== void 0 && t !== void 0) {
      const n = this.boundingSphere.center;
      this.boundingBox.getCenter(n);
      let r = 0;
      for (let s = 0, o = e.count; s < o; s++)
        Pg.fromBufferAttribute(e, s), r = Math.max(r, n.distanceToSquared(Pg)), Pg.fromBufferAttribute(t, s), r = Math.max(r, n.distanceToSquared(Pg));
      this.boundingSphere.radius = Math.sqrt(r), isNaN(this.boundingSphere.radius) && console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.", this);
    }
  }
  toJSON() {
  }
}
gt.line = {
  worldUnits: { value: 1 },
  linewidth: { value: 1 },
  resolution: { value: new Le(1, 1) },
  dashOffset: { value: 0 },
  dashScale: { value: 1 },
  dashSize: { value: 1 },
  gapSize: { value: 1 }
  // todo FIX - maybe change to totalSize
};
Es.line = {
  uniforms: v0.merge([
    gt.common,
    gt.fog,
    gt.line
  ]),
  vertexShader: (
    /* glsl */
    `
		#include <common>
		#include <color_pars_vertex>
		#include <fog_pars_vertex>
		#include <logdepthbuf_pars_vertex>
		#include <clipping_planes_pars_vertex>

		uniform float linewidth;
		uniform vec2 resolution;

		attribute vec3 instanceStart;
		attribute vec3 instanceEnd;

		attribute vec3 instanceColorStart;
		attribute vec3 instanceColorEnd;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#ifdef USE_DASH

			uniform float dashScale;
			attribute float instanceDistanceStart;
			attribute float instanceDistanceEnd;
			varying float vLineDistance;

		#endif

		void trimSegment( const in vec4 start, inout vec4 end ) {

			// trim end segment so it terminates between the camera plane and the near plane

			// conservative estimate of the near plane
			float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
			float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
			float nearEstimate = - 0.5 * b / a;

			float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

			end.xyz = mix( start.xyz, end.xyz, alpha );

		}

		void main() {

			#ifdef USE_COLOR

				vColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;

			#endif

			#ifdef USE_DASH

				vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;
				vUv = uv;

			#endif

			float aspect = resolution.x / resolution.y;

			// camera space
			vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );
			vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );

			#ifdef WORLD_UNITS

				worldStart = start.xyz;
				worldEnd = end.xyz;

			#else

				vUv = uv;

			#endif

			// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
			// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
			// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
			// perhaps there is a more elegant solution -- WestLangley

			bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

			if ( perspective ) {

				if ( start.z < 0.0 && end.z >= 0.0 ) {

					trimSegment( start, end );

				} else if ( end.z < 0.0 && start.z >= 0.0 ) {

					trimSegment( end, start );

				}

			}

			// clip space
			vec4 clipStart = projectionMatrix * start;
			vec4 clipEnd = projectionMatrix * end;

			// ndc space
			vec3 ndcStart = clipStart.xyz / clipStart.w;
			vec3 ndcEnd = clipEnd.xyz / clipEnd.w;

			// direction
			vec2 dir = ndcEnd.xy - ndcStart.xy;

			// account for clip-space aspect ratio
			dir.x *= aspect;
			dir = normalize( dir );

			#ifdef WORLD_UNITS

				vec3 worldDir = normalize( end.xyz - start.xyz );
				vec3 tmpFwd = normalize( mix( start.xyz, end.xyz, 0.5 ) );
				vec3 worldUp = normalize( cross( worldDir, tmpFwd ) );
				vec3 worldFwd = cross( worldDir, worldUp );
				worldPos = position.y < 0.5 ? start: end;

				// height offset
				float hw = linewidth * 0.5;
				worldPos.xyz += position.x < 0.0 ? hw * worldUp : - hw * worldUp;

				// don't extend the line if we're rendering dashes because we
				// won't be rendering the endcaps
				#ifndef USE_DASH

					// cap extension
					worldPos.xyz += position.y < 0.5 ? - hw * worldDir : hw * worldDir;

					// add width to the box
					worldPos.xyz += worldFwd * hw;

					// endcaps
					if ( position.y > 1.0 || position.y < 0.0 ) {

						worldPos.xyz -= worldFwd * 2.0 * hw;

					}

				#endif

				// project the worldpos
				vec4 clip = projectionMatrix * worldPos;

				// shift the depth of the projected points so the line
				// segments overlap neatly
				vec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;
				clip.z = clipPose.z * clip.w;

			#else

				vec2 offset = vec2( dir.y, - dir.x );
				// undo aspect ratio adjustment
				dir.x /= aspect;
				offset.x /= aspect;

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				// endcaps
				if ( position.y < 0.0 ) {

					offset += - dir;

				} else if ( position.y > 1.0 ) {

					offset += dir;

				}

				// adjust for linewidth
				offset *= linewidth;

				// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
				offset /= resolution.y;

				// select end
				vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;

				// back to clip space
				offset *= clip.w;

				clip.xy += offset;

			#endif

			gl_Position = clip;

			vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation

			#include <logdepthbuf_vertex>
			#include <clipping_planes_vertex>
			#include <fog_vertex>

		}
		`
  ),
  fragmentShader: (
    /* glsl */
    `
		uniform vec3 diffuse;
		uniform float opacity;
		uniform float linewidth;

		#ifdef USE_DASH

			uniform float dashOffset;
			uniform float dashSize;
			uniform float gapSize;

		#endif

		varying float vLineDistance;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#include <common>
		#include <color_pars_fragment>
		#include <fog_pars_fragment>
		#include <logdepthbuf_pars_fragment>
		#include <clipping_planes_pars_fragment>

		vec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {

			float mua;
			float mub;

			vec3 p13 = p1 - p3;
			vec3 p43 = p4 - p3;

			vec3 p21 = p2 - p1;

			float d1343 = dot( p13, p43 );
			float d4321 = dot( p43, p21 );
			float d1321 = dot( p13, p21 );
			float d4343 = dot( p43, p43 );
			float d2121 = dot( p21, p21 );

			float denom = d2121 * d4343 - d4321 * d4321;

			float numer = d1343 * d4321 - d1321 * d4343;

			mua = numer / denom;
			mua = clamp( mua, 0.0, 1.0 );
			mub = ( d1343 + d4321 * ( mua ) ) / d4343;
			mub = clamp( mub, 0.0, 1.0 );

			return vec2( mua, mub );

		}

		void main() {

			float alpha = opacity;
			vec4 diffuseColor = vec4( diffuse, alpha );

			#include <clipping_planes_fragment>

			#ifdef USE_DASH

				if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps

				if ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX

			#endif

			#ifdef WORLD_UNITS

				// Find the closest points on the view ray and the line segment
				vec3 rayEnd = normalize( worldPos.xyz ) * 1e5;
				vec3 lineDir = worldEnd - worldStart;
				vec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );

				vec3 p1 = worldStart + lineDir * params.x;
				vec3 p2 = rayEnd * params.y;
				vec3 delta = p1 - p2;
				float len = length( delta );
				float norm = len / linewidth;

				#ifndef USE_DASH

					#ifdef USE_ALPHA_TO_COVERAGE

						float dnorm = fwidth( norm );
						alpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );

					#else

						if ( norm > 0.5 ) {

							discard;

						}

					#endif

				#endif

			#else

				#ifdef USE_ALPHA_TO_COVERAGE

					// artifacts appear on some hardware if a derivative is taken within a conditional
					float a = vUv.x;
					float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
					float len2 = a * a + b * b;
					float dlen = fwidth( len2 );

					if ( abs( vUv.y ) > 1.0 ) {

						alpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );

					}

				#else

					if ( abs( vUv.y ) > 1.0 ) {

						float a = vUv.x;
						float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
						float len2 = a * a + b * b;

						if ( len2 > 1.0 ) discard;

					}

				#endif

			#endif

			#include <logdepthbuf_fragment>
			#include <color_fragment>

			gl_FragColor = vec4( diffuseColor.rgb, alpha );

			#include <tonemapping_fragment>
			#include <colorspace_fragment>
			#include <fog_fragment>
			#include <premultiplied_alpha_fragment>

		}
		`
  )
};
class cw extends Fr {
  /**
   * Constructs a new line segments geometry.
   *
   * @param {Object} [parameters] - An object with one or more properties
   * defining the material's appearance. Any property of the material
   * (including any property from inherited materials) can be passed
   * in here. Color values can be passed any type of value accepted
   * by {@link Color#set}.
   */
  constructor(e) {
    super({
      type: "LineMaterial",
      uniforms: v0.clone(Es.line.uniforms),
      vertexShader: Es.line.vertexShader,
      fragmentShader: Es.line.fragmentShader,
      clipping: !0
      // required for clipping support
    }), this.isLineMaterial = !0, this.setValues(e);
  }
  /**
   * The material's color.
   *
   * @type {Color}
   * @default (1,1,1)
   */
  get color() {
    return this.uniforms.diffuse.value;
  }
  set color(e) {
    this.uniforms.diffuse.value = e;
  }
  /**
   * Whether the material's sizes (width, dash gaps) are in world units.
   *
   * @type {boolean}
   * @default false
   */
  get worldUnits() {
    return "WORLD_UNITS" in this.defines;
  }
  set worldUnits(e) {
    e === !0 ? this.defines.WORLD_UNITS = "" : delete this.defines.WORLD_UNITS;
  }
  /**
   * Controls line thickness in CSS pixel units when `worldUnits` is `false` (default),
   * or in world units when `worldUnits` is `true`.
   *
   * @type {number}
   * @default 1
   */
  get linewidth() {
    return this.uniforms.linewidth.value;
  }
  set linewidth(e) {
    this.uniforms.linewidth && (this.uniforms.linewidth.value = e);
  }
  /**
   * Whether the line is dashed, or solid.
   *
   * @type {boolean}
   * @default false
   */
  get dashed() {
    return "USE_DASH" in this.defines;
  }
  set dashed(e) {
    e === !0 !== this.dashed && (this.needsUpdate = !0), e === !0 ? this.defines.USE_DASH = "" : delete this.defines.USE_DASH;
  }
  /**
   * The scale of the dashes and gaps.
   *
   * @type {number}
   * @default 1
   */
  get dashScale() {
    return this.uniforms.dashScale.value;
  }
  set dashScale(e) {
    this.uniforms.dashScale.value = e;
  }
  /**
   * The size of the dash.
   *
   * @type {number}
   * @default 1
   */
  get dashSize() {
    return this.uniforms.dashSize.value;
  }
  set dashSize(e) {
    this.uniforms.dashSize.value = e;
  }
  /**
   * Where in the dash cycle the dash starts.
   *
   * @type {number}
   * @default 0
   */
  get dashOffset() {
    return this.uniforms.dashOffset.value;
  }
  set dashOffset(e) {
    this.uniforms.dashOffset.value = e;
  }
  /**
   * The size of the gap.
   *
   * @type {number}
   * @default 0
   */
  get gapSize() {
    return this.uniforms.gapSize.value;
  }
  set gapSize(e) {
    this.uniforms.gapSize.value = e;
  }
  /**
   * The opacity.
   *
   * @type {number}
   * @default 1
   */
  get opacity() {
    return this.uniforms.opacity.value;
  }
  set opacity(e) {
    this.uniforms && (this.uniforms.opacity.value = e);
  }
  /**
   * The size of the viewport, in screen pixels. This must be kept updated to make
   * screen-space rendering accurate.The `LineSegments2.onBeforeRender` callback
   * performs the update for visible objects.
   *
   * @type {Vector2}
   */
  get resolution() {
    return this.uniforms.resolution.value;
  }
  set resolution(e) {
    this.uniforms.resolution.value.copy(e);
  }
  /**
   * Whether to use alphaToCoverage or not. When enabled, this can improve the
   * anti-aliasing of line edges when using MSAA.
   *
   * @type {boolean}
   */
  get alphaToCoverage() {
    return "USE_ALPHA_TO_COVERAGE" in this.defines;
  }
  set alphaToCoverage(e) {
    this.defines && (e === !0 !== this.alphaToCoverage && (this.needsUpdate = !0), e === !0 ? this.defines.USE_ALPHA_TO_COVERAGE = "" : delete this.defines.USE_ALPHA_TO_COVERAGE);
  }
}
const vv = new Kt(), FC = new j(), UC = new j(), zr = new Kt(), qr = new Kt(), Oa = new Kt(), bv = new j(), Sv = new Mt(), Hr = new v8(), OC = new j(), Ng = new dr(), Dg = new fr(), ka = new Kt();
let Wa, dh;
function kC(i, e, t) {
  return ka.set(0, 0, -e, 1).applyMatrix4(i.projectionMatrix), ka.multiplyScalar(1 / ka.w), ka.x = dh / t.width, ka.y = dh / t.height, ka.applyMatrix4(i.projectionMatrixInverse), ka.multiplyScalar(1 / ka.w), Math.abs(Math.max(ka.x, ka.y));
}
function Rle(i, e) {
  const t = i.matrixWorld, n = i.geometry, r = n.attributes.instanceStart, s = n.attributes.instanceEnd, o = Math.min(n.instanceCount, r.count);
  for (let a = 0, l = o; a < l; a++) {
    Hr.start.fromBufferAttribute(r, a), Hr.end.fromBufferAttribute(s, a), Hr.applyMatrix4(t);
    const u = new j(), c = new j();
    Wa.distanceSqToSegment(Hr.start, Hr.end, c, u), c.distanceTo(u) < dh * 0.5 && e.push({
      point: c,
      pointOnLine: u,
      distance: Wa.origin.distanceTo(c),
      object: i,
      face: null,
      faceIndex: a,
      uv: null,
      uv1: null
    });
  }
}
function Cle(i, e, t) {
  const n = e.projectionMatrix, s = i.material.resolution, o = i.matrixWorld, a = i.geometry, l = a.attributes.instanceStart, u = a.attributes.instanceEnd, c = Math.min(a.instanceCount, l.count), A = -e.near;
  Wa.at(1, Oa), Oa.w = 1, Oa.applyMatrix4(e.matrixWorldInverse), Oa.applyMatrix4(n), Oa.multiplyScalar(1 / Oa.w), Oa.x *= s.x / 2, Oa.y *= s.y / 2, Oa.z = 0, bv.copy(Oa), Sv.multiplyMatrices(e.matrixWorldInverse, o);
  for (let m = 0, _ = c; m < _; m++) {
    if (zr.fromBufferAttribute(l, m), qr.fromBufferAttribute(u, m), zr.w = 1, qr.w = 1, zr.applyMatrix4(Sv), qr.applyMatrix4(Sv), zr.z > A && qr.z > A)
      continue;
    if (zr.z > A) {
      const R = zr.z - qr.z, C = (zr.z - A) / R;
      zr.lerp(qr, C);
    } else if (qr.z > A) {
      const R = qr.z - zr.z, C = (qr.z - A) / R;
      qr.lerp(zr, C);
    }
    zr.applyMatrix4(n), qr.applyMatrix4(n), zr.multiplyScalar(1 / zr.w), qr.multiplyScalar(1 / qr.w), zr.x *= s.x / 2, zr.y *= s.y / 2, qr.x *= s.x / 2, qr.y *= s.y / 2, Hr.start.copy(zr), Hr.start.z = 0, Hr.end.copy(qr), Hr.end.z = 0;
    const T = Hr.closestPointToPointParameter(bv, !0);
    Hr.at(T, OC);
    const b = zh.lerp(zr.z, qr.z, T), S = b >= -1 && b <= 1, E = bv.distanceTo(OC) < dh * 0.5;
    if (S && E) {
      Hr.start.fromBufferAttribute(l, m), Hr.end.fromBufferAttribute(u, m), Hr.start.applyMatrix4(o), Hr.end.applyMatrix4(o);
      const R = new j(), C = new j();
      Wa.distanceSqToSegment(Hr.start, Hr.end, C, R), t.push({
        point: C,
        pointOnLine: R,
        distance: Wa.origin.distanceTo(C),
        object: i,
        face: null,
        faceIndex: m,
        uv: null,
        uv1: null
      });
    }
  }
}
class Ple extends Tn {
  /**
   * Constructs a new wide line.
   *
   * @param {LineSegmentsGeometry} [geometry] - The line geometry.
   * @param {LineMaterial} [material] - The line material.
   */
  constructor(e = new UI(), t = new cw({ color: Math.random() * 16777215 })) {
    super(e, t), this.isLineSegments2 = !0, this.type = "LineSegments2";
  }
  /**
   * Computes an array of distance values which are necessary for rendering dashed lines.
   * For each vertex in the geometry, the method calculates the cumulative length from the
   * current point to the very beginning of the line.
   *
   * @return {LineSegments2} A reference to this instance.
   */
  computeLineDistances() {
    const e = this.geometry, t = e.attributes.instanceStart, n = e.attributes.instanceEnd, r = new Float32Array(2 * t.count);
    for (let o = 0, a = 0, l = t.count; o < l; o++, a += 2)
      FC.fromBufferAttribute(t, o), UC.fromBufferAttribute(n, o), r[a] = a === 0 ? 0 : r[a - 1], r[a + 1] = r[a] + FC.distanceTo(UC);
    const s = new $p(r, 2, 1);
    return e.setAttribute("instanceDistanceStart", new Bs(s, 1, 0)), e.setAttribute("instanceDistanceEnd", new Bs(s, 1, 1)), this;
  }
  /**
   * Computes intersection points between a casted ray and this instance.
   *
   * @param {Raycaster} raycaster - The raycaster.
   * @param {Array<Object>} intersects - The target array that holds the intersection points.
   */
  raycast(e, t) {
    const n = this.material.worldUnits, r = e.camera;
    r === null && !n && console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.');
    const s = e.params.Line2 !== void 0 && e.params.Line2.threshold || 0;
    Wa = e.ray;
    const o = this.matrixWorld, a = this.geometry, l = this.material;
    dh = l.linewidth + s, a.boundingSphere === null && a.computeBoundingSphere(), Dg.copy(a.boundingSphere).applyMatrix4(o);
    let u;
    if (n)
      u = dh * 0.5;
    else {
      const A = Math.max(r.near, Dg.distanceToPoint(Wa.origin));
      u = kC(r, A, l.resolution);
    }
    if (Dg.radius += u, Wa.intersectsSphere(Dg) === !1)
      return;
    a.boundingBox === null && a.computeBoundingBox(), Ng.copy(a.boundingBox).applyMatrix4(o);
    let c;
    if (n)
      c = dh * 0.5;
    else {
      const A = Math.max(r.near, Ng.distanceToPoint(Wa.origin));
      c = kC(r, A, l.resolution);
    }
    Ng.expandByScalar(c), Wa.intersectsBox(Ng) !== !1 && (n ? Rle(this, t) : Cle(this, r, t));
  }
  onBeforeRender(e) {
    const t = this.material.uniforms;
    t && t.resolution && (e.getViewport(vv), this.material.uniforms.resolution.value.set(vv.z, vv.w));
  }
}
class OI extends UI {
  /**
   * Constructs a new line geometry.
   */
  constructor() {
    super(), this.isLineGeometry = !0, this.type = "LineGeometry";
  }
  /**
   * Sets the given line positions for this geometry.
   *
   * @param {Float32Array|Array<number>} array - The position data to set.
   * @return {LineGeometry} A reference to this geometry.
   */
  setPositions(e) {
    const t = e.length - 3, n = new Float32Array(2 * t);
    for (let r = 0; r < t; r += 3)
      n[2 * r] = e[r], n[2 * r + 1] = e[r + 1], n[2 * r + 2] = e[r + 2], n[2 * r + 3] = e[r + 3], n[2 * r + 4] = e[r + 4], n[2 * r + 5] = e[r + 5];
    return super.setPositions(n), this;
  }
  /**
   * Sets the given line colors for this geometry.
   *
   * @param {Float32Array|Array<number>} array - The position data to set.
   * @return {LineGeometry} A reference to this geometry.
   */
  setColors(e) {
    const t = e.length - 3, n = new Float32Array(2 * t);
    for (let r = 0; r < t; r += 3)
      n[2 * r] = e[r], n[2 * r + 1] = e[r + 1], n[2 * r + 2] = e[r + 2], n[2 * r + 3] = e[r + 3], n[2 * r + 4] = e[r + 4], n[2 * r + 5] = e[r + 5];
    return super.setColors(n), this;
  }
  /**
   * Setups this line segments geometry from the given sequence of points.
   *
   * @param {Array<Vector3|Vector2>} points - An array of points in 2D or 3D space.
   * @return {LineGeometry} A reference to this geometry.
   */
  setFromPoints(e) {
    const t = e.length - 1, n = new Float32Array(6 * t);
    for (let r = 0; r < t; r++)
      n[6 * r] = e[r].x, n[6 * r + 1] = e[r].y, n[6 * r + 2] = e[r].z || 0, n[6 * r + 3] = e[r + 1].x, n[6 * r + 4] = e[r + 1].y, n[6 * r + 5] = e[r + 1].z || 0;
    return super.setPositions(n), this;
  }
  /**
   * Setups this line segments geometry from the given line.
   *
   * @param {Line} line - The line that should be used as a data source for this geometry.
   * @return {LineGeometry} A reference to this geometry.
   */
  fromLine(e) {
    const t = e.geometry;
    return this.setPositions(t.attributes.position.array), this;
  }
}
class Nle extends Ple {
  /**
   * Constructs a new wide line.
   *
   * @param {LineGeometry} [geometry] - The line geometry.
   * @param {LineMaterial} [material] - The line material.
   */
  constructor(e = new OI(), t = new cw({ color: Math.random() * 16777215 })) {
    super(e, t), this.isLine2 = !0, this.type = "Line2";
  }
}
class VC extends w0 {
  /**
   * Constructs a new text geometry.
   *
   * @param {string} text - The text that should be transformed into a geometry.
   * @param {TextGeometry~Options} [parameters] - The text settings.
   */
  constructor(e, t = {}) {
    const n = t.font;
    if (n === void 0)
      super();
    else {
      const r = n.generateShapes(e, t.size, t.direction);
      t.depth === void 0 && (t.depth = 50), t.bevelThickness === void 0 && (t.bevelThickness = 10), t.bevelSize === void 0 && (t.bevelSize = 8), t.bevelEnabled === void 0 && (t.bevelEnabled = !1), super(r, t);
    }
    this.type = "TextGeometry";
  }
}
class Dle {
  /**
   * Constructs a new font.
   *
   * @param {Object} data - The font data as JSON.
   */
  constructor(e) {
    this.isFont = !0, this.type = "Font", this.data = e;
  }
  /**
   * Generates geometry shapes from the given text and size. The result of this method
   * should be used with {@link ShapeGeometry} to generate the actual geometry data.
   *
   * @param {string} text - The text.
   * @param {number} [size=100] - The text size.
   * @param {string} [direction='ltr'] - Char direction: ltr(left to right), rtl(right to left) & tb(top bottom).
   * @return {Array<Shape>} An array of shapes representing the text.
   */
  generateShapes(e, t = 100, n = "ltr") {
    const r = [], s = Lle(e, t, this.data, n);
    for (let o = 0, a = s.length; o < a; o++)
      r.push(...s[o].toShapes());
    return r;
  }
}
function Lle(i, e, t, n) {
  const r = Array.from(i), s = e / t.resolution, o = (t.boundingBox.yMax - t.boundingBox.yMin + t.underlineThickness) * s, a = [];
  let l = 0, u = 0;
  (n == "rtl" || n == "tb") && r.reverse();
  for (let c = 0; c < r.length; c++) {
    const A = r[c];
    if (A === `
`)
      l = 0, u -= o;
    else {
      const m = Ile(A, s, l, u, t);
      n == "tb" ? (l = 0, u += t.ascender * s) : l += m.offsetX, a.push(m.path);
    }
  }
  return a;
}
function Ile(i, e, t, n, r) {
  const s = r.glyphs[i] || r.glyphs["?"];
  if (!s) {
    console.error('THREE.Font: character "' + i + '" does not exists in font family ' + r.familyName + ".");
    return;
  }
  const o = new S8();
  let a, l, u, c, A, m, _, y;
  if (s.o) {
    const T = s._cachedOutline || (s._cachedOutline = s.o.split(" "));
    for (let b = 0, S = T.length; b < S; )
      switch (T[b++]) {
        case "m":
          a = T[b++] * e + t, l = T[b++] * e + n, o.moveTo(a, l);
          break;
        case "l":
          a = T[b++] * e + t, l = T[b++] * e + n, o.lineTo(a, l);
          break;
        case "q":
          u = T[b++] * e + t, c = T[b++] * e + n, A = T[b++] * e + t, m = T[b++] * e + n, o.quadraticCurveTo(A, m, u, c);
          break;
        case "b":
          u = T[b++] * e + t, c = T[b++] * e + n, A = T[b++] * e + t, m = T[b++] * e + n, _ = T[b++] * e + t, y = T[b++] * e + n, o.bezierCurveTo(A, m, _, y, u, c);
          break;
      }
  }
  return { offsetX: s.ha * e, path: o };
}
function i3(i, e) {
  (e == null || e > i.length) && (e = i.length);
  for (var t = 0, n = Array(e); t < e; t++) n[t] = i[t];
  return n;
}
function Ble(i) {
  if (Array.isArray(i)) return i;
}
function Fle(i) {
  if (Array.isArray(i)) return i3(i);
}
function kI(i, e, t) {
  if (typeof i == "function" ? i === e : i.has(e)) return arguments.length < 3 ? e : t;
  throw new TypeError("Private element is not present on this object");
}
function Ule(i) {
  if (i === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return i;
}
function GC(i, e, t, n, r, s, o) {
  try {
    var a = i[s](o), l = a.value;
  } catch (u) {
    return void t(u);
  }
  a.done ? e(l) : Promise.resolve(l).then(n, r);
}
function Ole(i) {
  return function() {
    var e = this, t = arguments;
    return new Promise(function(n, r) {
      var s = i.apply(e, t);
      function o(l) {
        GC(s, n, r, o, a, "next", l);
      }
      function a(l) {
        GC(s, n, r, o, a, "throw", l);
      }
      o(void 0);
    });
  };
}
function sx(i, e, t) {
  return e = Zf(e), jle(i, dw() ? Reflect.construct(e, t || [], Zf(i).constructor) : e.apply(i, t));
}
function kle(i, e) {
  if (e.has(i)) throw new TypeError("Cannot initialize the same private elements twice on an object");
}
function ox(i, e) {
  if (!(i instanceof e)) throw new TypeError("Cannot call a class as a function");
}
function sp(i, e) {
  return i.get(kI(i, e));
}
function Tv(i, e, t) {
  kle(i, e), e.set(i, t);
}
function wv(i, e, t) {
  return i.set(kI(i, e), t), t;
}
function hw(i, e, t) {
  if (dw()) return Reflect.construct.apply(null, arguments);
  var n = [null];
  n.push.apply(n, e);
  var r = new (i.bind.apply(i, n))();
  return r;
}
function Vle(i, e) {
  for (var t = 0; t < e.length; t++) {
    var n = e[t];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(i, VI(n.key), n);
  }
}
function ax(i, e, t) {
  return e && Vle(i.prototype, e), Object.defineProperty(i, "prototype", {
    writable: !1
  }), i;
}
function Ur(i, e, t) {
  return (e = VI(e)) in i ? Object.defineProperty(i, e, {
    value: t,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : i[e] = t, i;
}
function r3() {
  return r3 = typeof Reflect < "u" && Reflect.get ? Reflect.get.bind() : function(i, e, t) {
    var n = Xle(i, e);
    if (n) {
      var r = Object.getOwnPropertyDescriptor(n, e);
      return r.get ? r.get.call(arguments.length < 3 ? i : t) : r.value;
    }
  }, r3.apply(null, arguments);
}
function Zf(i) {
  return Zf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e) {
    return e.__proto__ || Object.getPrototypeOf(e);
  }, Zf(i);
}
function lx(i, e) {
  if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function");
  i.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: i,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(i, "prototype", {
    writable: !1
  }), e && o3(i, e);
}
function dw() {
  try {
    var i = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (dw = function() {
    return !!i;
  })();
}
function Gle(i) {
  if (typeof Symbol < "u" && i[Symbol.iterator] != null || i["@@iterator"] != null) return Array.from(i);
}
function zle(i, e) {
  var t = i == null ? null : typeof Symbol < "u" && i[Symbol.iterator] || i["@@iterator"];
  if (t != null) {
    var n, r, s, o, a = [], l = !0, u = !1;
    try {
      if (s = (t = t.call(i)).next, e === 0) {
        if (Object(t) !== t) return;
        l = !1;
      } else for (; !(l = (n = s.call(t)).done) && (a.push(n.value), a.length !== e); l = !0) ;
    } catch (c) {
      u = !0, r = c;
    } finally {
      try {
        if (!l && t.return != null && (o = t.return(), Object(o) !== o)) return;
      } finally {
        if (u) throw r;
      }
    }
    return a;
  }
}
function qle() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Hle() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function zC(i, e) {
  var t = Object.keys(i);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(i);
    e && (n = n.filter(function(r) {
      return Object.getOwnPropertyDescriptor(i, r).enumerable;
    })), t.push.apply(t, n);
  }
  return t;
}
function ai(i) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? zC(Object(t), !0).forEach(function(n) {
      Ur(i, n, t[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(i, Object.getOwnPropertyDescriptors(t)) : zC(Object(t)).forEach(function(n) {
      Object.defineProperty(i, n, Object.getOwnPropertyDescriptor(t, n));
    });
  }
  return i;
}
function Wle(i, e) {
  if (i == null) return {};
  var t, n, r = $le(i, e);
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(i);
    for (n = 0; n < s.length; n++) t = s[n], e.indexOf(t) === -1 && {}.propertyIsEnumerable.call(i, t) && (r[t] = i[t]);
  }
  return r;
}
function $le(i, e) {
  if (i == null) return {};
  var t = {};
  for (var n in i) if ({}.hasOwnProperty.call(i, n)) {
    if (e.indexOf(n) !== -1) continue;
    t[n] = i[n];
  }
  return t;
}
function jle(i, e) {
  if (e && (typeof e == "object" || typeof e == "function")) return e;
  if (e !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
  return Ule(i);
}
function s3() {
  var i, e, t = typeof Symbol == "function" ? Symbol : {}, n = t.iterator || "@@iterator", r = t.toStringTag || "@@toStringTag";
  function s(_, y, T, b) {
    var S = y && y.prototype instanceof a ? y : a, E = Object.create(S.prototype);
    return _o(E, "_invoke", (function(R, C, L) {
      var D, B, U, N = 0, O = L || [], G = !1, H = {
        p: 0,
        n: 0,
        v: i,
        a: Y,
        f: Y.bind(i, 4),
        d: function(K, X) {
          return D = K, B = 0, U = i, H.n = X, o;
        }
      };
      function Y(K, X) {
        for (B = K, U = X, e = 0; !G && N && !ee && e < O.length; e++) {
          var ee, oe = O[e], fe = H.p, _e = oe[2];
          K > 3 ? (ee = _e === X) && (U = oe[(B = oe[4]) ? 5 : (B = 3, 3)], oe[4] = oe[5] = i) : oe[0] <= fe && ((ee = K < 2 && fe < oe[1]) ? (B = 0, H.v = X, H.n = oe[1]) : fe < _e && (ee = K < 3 || oe[0] > X || X > _e) && (oe[4] = K, oe[5] = X, H.n = _e, B = 0));
        }
        if (ee || K > 1) return o;
        throw G = !0, X;
      }
      return function(K, X, ee) {
        if (N > 1) throw TypeError("Generator is already running");
        for (G && X === 1 && Y(X, ee), B = X, U = ee; (e = B < 2 ? i : U) || !G; ) {
          D || (B ? B < 3 ? (B > 1 && (H.n = -1), Y(B, U)) : H.n = U : H.v = U);
          try {
            if (N = 2, D) {
              if (B || (K = "next"), e = D[K]) {
                if (!(e = e.call(D, U))) throw TypeError("iterator result is not an object");
                if (!e.done) return e;
                U = e.value, B < 2 && (B = 0);
              } else B === 1 && (e = D.return) && e.call(D), B < 2 && (U = TypeError("The iterator does not provide a '" + K + "' method"), B = 1);
              D = i;
            } else if ((e = (G = H.n < 0) ? U : R.call(C, H)) !== o) break;
          } catch (oe) {
            D = i, B = 1, U = oe;
          } finally {
            N = 1;
          }
        }
        return {
          value: e,
          done: G
        };
      };
    })(_, T, b), !0), E;
  }
  var o = {};
  function a() {
  }
  function l() {
  }
  function u() {
  }
  e = Object.getPrototypeOf;
  var c = [][n] ? e(e([][n]())) : (_o(e = {}, n, function() {
    return this;
  }), e), A = u.prototype = a.prototype = Object.create(c);
  function m(_) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(_, u) : (_.__proto__ = u, _o(_, r, "GeneratorFunction")), _.prototype = Object.create(A), _;
  }
  return l.prototype = u, _o(A, "constructor", u), _o(u, "constructor", l), l.displayName = "GeneratorFunction", _o(u, r, "GeneratorFunction"), _o(A), _o(A, r, "Generator"), _o(A, n, function() {
    return this;
  }), _o(A, "toString", function() {
    return "[object Generator]";
  }), (s3 = function() {
    return {
      w: s,
      m
    };
  })();
}
function _o(i, e, t, n) {
  var r = Object.defineProperty;
  try {
    r({}, "", {});
  } catch {
    r = 0;
  }
  _o = function(s, o, a, l) {
    function u(c, A) {
      _o(s, c, function(m) {
        return this._invoke(c, A, m);
      });
    }
    o ? r ? r(s, o, {
      value: a,
      enumerable: !l,
      configurable: !l,
      writable: !l
    }) : s[o] = a : (u("next", 0), u("throw", 1), u("return", 2));
  }, _o(i, e, t, n);
}
function o3(i, e) {
  return o3 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, n) {
    return t.__proto__ = n, t;
  }, o3(i, e);
}
function Li(i, e) {
  return Ble(i) || zle(i, e) || GI(i, e) || qle();
}
function Xle(i, e) {
  for (; !{}.hasOwnProperty.call(i, e) && (i = Zf(i)) !== null; ) ;
  return i;
}
function Mv(i, e, t, n) {
  var r = r3(Zf(i.prototype), e, t);
  return typeof r == "function" ? function(s) {
    return r.apply(t, s);
  } : r;
}
function _i(i) {
  return Fle(i) || Gle(i) || GI(i) || Hle();
}
function Yle(i, e) {
  if (typeof i != "object" || !i) return i;
  var t = i[Symbol.toPrimitive];
  if (t !== void 0) {
    var n = t.call(i, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(i);
}
function VI(i) {
  var e = Yle(i, "string");
  return typeof e == "symbol" ? e : e + "";
}
function GI(i, e) {
  if (i) {
    if (typeof i == "string") return i3(i, e);
    var t = {}.toString.call(i).slice(8, -1);
    return t === "Object" && i.constructor && (t = i.constructor.name), t === "Map" || t === "Set" ? Array.from(i) : t === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? i3(i, e) : void 0;
  }
}
var zI = function(e) {
  e instanceof Array ? e.forEach(zI) : (e.map && e.map.dispose(), e.dispose());
}, fw = function(e) {
  e.geometry && e.geometry.dispose(), e.material && zI(e.material), e.texture && e.texture.dispose(), e.children && e.children.forEach(fw);
}, bi = function(e) {
  if (e && e.children) for (; e.children.length; ) {
    var t = e.children[0];
    e.remove(t), fw(t);
  }
};
function Us(i, e) {
  var t = new e();
  return {
    linkProp: function(r) {
      return {
        default: t[r](),
        onChange: function(o, a) {
          a[i][r](o);
        },
        triggerUpdate: !1
      };
    },
    linkMethod: function(r) {
      return function(s) {
        for (var o = s[i], a = arguments.length, l = new Array(a > 1 ? a - 1 : 0), u = 1; u < a; u++)
          l[u - 1] = arguments[u];
        var c = o[r].apply(o, l);
        return c === o ? this : c;
      };
    }
  };
}
var Ci = 100;
function qC() {
  return Ci;
}
function Xo(i, e) {
  var t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, n = (90 - i) * Math.PI / 180, r = (90 - e) * Math.PI / 180, s = Ci * (1 + t), o = Math.sin(n);
  return {
    x: s * o * Math.cos(r),
    y: s * Math.cos(n),
    z: s * o * Math.sin(r)
  };
}
function qI(i) {
  var e = i.x, t = i.y, n = i.z, r = Math.sqrt(e * e + t * t + n * n), s = Math.acos(t / r), o = Math.atan2(n, e);
  return {
    lat: 90 - s * 180 / Math.PI,
    lng: 90 - o * 180 / Math.PI - (o < -Math.PI / 2 ? 360 : 0),
    // keep within [-180, 180] boundaries
    altitude: r / Ci - 1
  };
}
function jc(i) {
  return i * Math.PI / 180;
}
var h0 = window.THREE ? window.THREE : {
  BackSide: si,
  BufferAttribute: Dn,
  Color: ct,
  Mesh: Tn,
  ShaderMaterial: Fr
}, Qle = `
uniform float hollowRadius;

varying vec3 vVertexWorldPosition;
varying vec3 vVertexNormal;
varying float vCameraDistanceToObjCenter;
varying float vVertexAngularDistanceToHollowRadius;

void main() {
  vVertexNormal	= normalize(normalMatrix * normal);
  vVertexWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;

  vec4 objCenterViewPosition = modelViewMatrix * vec4(0.0, 0.0, 0.0, 1.0);
  vCameraDistanceToObjCenter = length(objCenterViewPosition);

  float edgeAngle = atan(hollowRadius / vCameraDistanceToObjCenter);
  float vertexAngle = acos(dot(normalize(modelViewMatrix * vec4(position, 1.0)), normalize(objCenterViewPosition)));
  vVertexAngularDistanceToHollowRadius = vertexAngle - edgeAngle;

  gl_Position	= projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}`, Kle = `
uniform vec3 color;
uniform float coefficient;
uniform float power;
uniform float hollowRadius;

varying vec3 vVertexNormal;
varying vec3 vVertexWorldPosition;
varying float vCameraDistanceToObjCenter;
varying float vVertexAngularDistanceToHollowRadius;

void main() {
  if (vCameraDistanceToObjCenter < hollowRadius) discard; // inside the hollowRadius
  if (vVertexAngularDistanceToHollowRadius < 0.0) discard; // frag position is within the hollow radius

  vec3 worldCameraToVertex = vVertexWorldPosition - cameraPosition;
  vec3 viewCameraToVertex	= (viewMatrix * vec4(worldCameraToVertex, 0.0)).xyz;
  viewCameraToVertex = normalize(viewCameraToVertex);
  float intensity	= pow(
    coefficient + dot(vVertexNormal, viewCameraToVertex),
    power
  );
  gl_FragColor = vec4(color, intensity);
}`;
function Zle(i, e, t, n) {
  return new h0.ShaderMaterial({
    depthWrite: !1,
    transparent: !0,
    vertexShader: Qle,
    fragmentShader: Kle,
    uniforms: {
      coefficient: {
        value: i
      },
      color: {
        value: new h0.Color(e)
      },
      power: {
        value: t
      },
      hollowRadius: {
        value: n
      }
    }
  });
}
function Jle(i, e) {
  for (var t = i.clone(), n = new Float32Array(i.attributes.position.count * 3), r = 0, s = n.length; r < s; r++) {
    var o = i.attributes.normal.array[r], a = i.attributes.position.array[r];
    n[r] = a + o * e;
  }
  return t.setAttribute("position", new h0.BufferAttribute(n, 3)), t;
}
var eue = /* @__PURE__ */ (function(i) {
  function e(t) {
    var n, r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, s = r.color, o = s === void 0 ? "gold" : s, a = r.size, l = a === void 0 ? 2 : a, u = r.coefficient, c = u === void 0 ? 0.5 : u, A = r.power, m = A === void 0 ? 1 : A, _ = r.hollowRadius, y = _ === void 0 ? 0 : _, T = r.backside, b = T === void 0 ? !0 : T;
    ox(this, e), n = sx(this, e);
    var S = Jle(t, l), E = Zle(c, o, m, y);
    return b && (E.side = h0.BackSide), n.geometry = S, n.material = E, n;
  }
  return lx(e, i), ax(e);
})(h0.Mesh), Va = window.THREE ? window.THREE : {
  Color: ct,
  Group: As,
  LineBasicMaterial: br,
  LineSegments: Qo,
  Mesh: Tn,
  MeshPhongMaterial: A2,
  SphereGeometry: Co,
  SRGBColorSpace: gr,
  TextureLoader: P0
}, HI = Sr({
  props: {
    globeImageUrl: {},
    bumpImageUrl: {},
    showGlobe: {
      default: !0,
      onChange: function(e, t) {
        t.globeGroup.visible = !!e;
      },
      triggerUpdate: !1
    },
    showGraticules: {
      default: !1,
      onChange: function(e, t) {
        t.graticulesObj.visible = !!e;
      },
      triggerUpdate: !1
    },
    showAtmosphere: {
      default: !0,
      onChange: function(e, t) {
        t.atmosphereObj && (t.atmosphereObj.visible = !!e);
      },
      triggerUpdate: !1
    },
    atmosphereColor: {
      default: "lightskyblue"
    },
    atmosphereAltitude: {
      default: 0.15
    },
    globeCurvatureResolution: {
      default: 4
    },
    globeTileEngineUrl: {
      onChange: function(e, t) {
        t.tileEngine.tileUrl = e;
      }
    },
    globeTileEngineMaxLevel: {
      default: 17,
      onChange: function(e, t) {
        t.tileEngine.maxLevel = e;
      },
      triggerUpdate: !1
    },
    updatePov: {
      onChange: function(e, t) {
        t.tileEngine.updatePov(e);
      },
      triggerUpdate: !1
    },
    onReady: {
      default: function() {
      },
      triggerUpdate: !1
    }
  },
  methods: {
    globeMaterial: function(e, t) {
      return t !== void 0 ? (e.globeObj.material = t || e.defaultGlobeMaterial, this) : e.globeObj.material;
    },
    globeTileEngineClearCache: function(e) {
      e.tileEngine.clearTiles();
    },
    _destructor: function(e) {
      bi(e.globeObj), bi(e.tileEngine), bi(e.graticulesObj);
    }
  },
  stateInit: function() {
    var e = new Va.MeshPhongMaterial({
      color: 0
    }), t = new Va.Mesh(void 0, e);
    t.rotation.y = -Math.PI / 2;
    var n = new nj(Ci), r = new Va.Group();
    r.__globeObjType = "globe", r.add(t), r.add(n);
    var s = new Va.LineSegments(new RP(y$(), Ci, 2), new Va.LineBasicMaterial({
      color: "lightgrey",
      transparent: !0,
      opacity: 0.1
    }));
    return {
      globeGroup: r,
      globeObj: t,
      graticulesObj: s,
      defaultGlobeMaterial: e,
      tileEngine: n
    };
  },
  init: function(e, t) {
    bi(e), t.scene = e, t.scene.add(t.globeGroup), t.scene.add(t.graticulesObj), t.ready = !1;
  },
  update: function(e, t) {
    var n = e.globeObj.material;
    if (e.tileEngine.visible = !(e.globeObj.visible = !e.globeTileEngineUrl), t.hasOwnProperty("globeCurvatureResolution")) {
      var r;
      (r = e.globeObj.geometry) === null || r === void 0 || r.dispose();
      var s = Math.max(4, Math.round(360 / e.globeCurvatureResolution));
      e.globeObj.geometry = new Va.SphereGeometry(Ci, s, s / 2), e.tileEngine.curvatureResolution = e.globeCurvatureResolution;
    }
    if (t.hasOwnProperty("globeImageUrl") && (e.globeImageUrl ? new Va.TextureLoader().load(e.globeImageUrl, function(a) {
      a.colorSpace = Va.SRGBColorSpace, n.map = a, n.color = null, n.needsUpdate = !0, !e.ready && (e.ready = !0) && setTimeout(e.onReady);
    }) : !n.color && (n.color = new Va.Color(0))), t.hasOwnProperty("bumpImageUrl") && (e.bumpImageUrl ? e.bumpImageUrl && new Va.TextureLoader().load(e.bumpImageUrl, function(a) {
      n.bumpMap = a, n.needsUpdate = !0;
    }) : (n.bumpMap = null, n.needsUpdate = !0)), (t.hasOwnProperty("atmosphereColor") || t.hasOwnProperty("atmosphereAltitude")) && (e.atmosphereObj && (e.scene.remove(e.atmosphereObj), bi(e.atmosphereObj)), e.atmosphereColor && e.atmosphereAltitude)) {
      var o = e.atmosphereObj = new eue(e.globeObj.geometry, {
        color: e.atmosphereColor,
        size: Ci * e.atmosphereAltitude,
        hollowRadius: Ci,
        coefficient: 0.1,
        power: 3.5
        // dispersion
      });
      o.visible = !!e.showAtmosphere, o.__globeObjType = "atmosphere", e.scene.add(o);
    }
    !e.ready && (!e.globeImageUrl || e.globeTileEngineUrl) && (e.ready = !0, e.onReady());
  }
}), al = function(e) {
  return isNaN(e) ? parseInt(Zt(e).toHex(), 16) : e;
}, ya = function(e) {
  return e && isNaN(e) ? Hh(e).opacity : 1;
}, Qu = function(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, r, s = 1, o = /^rgba\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*([\d.eE+-]+)\s*\)$/.exec(e.trim().toLowerCase());
  if (o) {
    var a = o.slice(1), l = Li(a, 4), u = l[0], c = l[1], A = l[2], m = l[3];
    r = new ct("rgb(".concat(+u, ",").concat(+c, ",").concat(+A, ")")), s = Math.min(+m, 1);
  } else
    r = new ct(e);
  n && r.convertLinearToSRGB();
  var _ = r.toArray();
  return t ? [].concat(_i(_), [s]) : _;
};
function tue(i, e, t) {
  return i.opacity = e, i.transparent = e < 1, i.depthWrite = e >= 1, i;
}
var HC = window.THREE ? window.THREE : {
  BufferAttribute: Dn
};
function ll(i) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1, t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Float32Array;
  if (e === 1)
    return new HC.BufferAttribute(new t(i), e);
  for (var n = new HC.BufferAttribute(new t(i.length * e), e), r = 0, s = i.length; r < s; r++)
    n.set(i[r], r * e);
  return n;
}
function nue(i) {
  for (var e = i.itemSize, t = [], n = 0; n < i.count; n++)
    t.push(i.array.slice(n * e, (n + 1) * e));
  return t;
}
var Ev = /* @__PURE__ */ new WeakMap(), Lg = /* @__PURE__ */ new WeakMap(), Ig = /* @__PURE__ */ new WeakMap(), co = /* @__PURE__ */ (function(i) {
  function e(t) {
    var n, r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, s = r.dataBindAttr, o = s === void 0 ? "__data" : s, a = r.objBindAttr, l = a === void 0 ? "__threeObj" : a, u = r.removeDelay, c = u === void 0 ? 0 : u;
    return ox(this, e), n = sx(this, e), Ur(n, "scene", void 0), Tv(n, Ev, void 0), Tv(n, Lg, void 0), Tv(n, Ig, void 0), n.scene = t, wv(Ev, n, o), wv(Lg, n, l), wv(Ig, n, c), n.onRemoveObj(function() {
    }), n;
  }
  return lx(e, i), ax(e, [{
    key: "onCreateObj",
    value: function(n) {
      var r = this;
      return Mv(e, "onCreateObj", this)([function(s) {
        var o = n(s);
        return s[sp(Lg, r)] = o, o[sp(Ev, r)] = s, r.scene.add(o), o;
      }]), this;
    }
  }, {
    key: "onRemoveObj",
    value: function(n) {
      var r = this;
      return Mv(e, "onRemoveObj", this)([function(s, o) {
        var a = Mv(e, "getData", r)([s]);
        n(s, o);
        var l = function() {
          r.scene.remove(s), bi(s), delete a[sp(Lg, r)];
        };
        sp(Ig, r) ? setTimeout(l, sp(Ig, r)) : l();
      }]), this;
    }
  }]);
})(NX), oa = window.THREE ? window.THREE : {
  BufferGeometry: Yt,
  CylinderGeometry: ed,
  Matrix4: Mt,
  Mesh: Tn,
  MeshLambertMaterial: Ea,
  Object3D: Vn,
  Vector3: j
}, WC = Object.assign({}, ES), $C = WC.BufferGeometryUtils || WC, WI = Sr({
  props: {
    pointsData: {
      default: []
    },
    pointLat: {
      default: "lat"
    },
    pointLng: {
      default: "lng"
    },
    pointColor: {
      default: function() {
        return "#ffffaa";
      }
    },
    pointAltitude: {
      default: 0.1
    },
    // in units of globe radius
    pointRadius: {
      default: 0.25
    },
    // in deg
    pointResolution: {
      default: 12,
      triggerUpdate: !1
    },
    // how many slice segments in the cylinder's circumference
    pointsMerge: {
      default: !1
    },
    // boolean. Whether to merge all points into a single mesh for rendering performance
    pointsTransitionDuration: {
      default: 1e3,
      triggerUpdate: !1
    }
    // ms
  },
  init: function(e, t, n) {
    var r = n.tweenGroup;
    bi(e), t.scene = e, t.tweenGroup = r, t.dataMapper = new co(e, {
      objBindAttr: "__threeObjPoint"
    });
  },
  update: function(e, t) {
    var n = je(e.pointLat), r = je(e.pointLng), s = je(e.pointAltitude), o = je(e.pointRadius), a = je(e.pointColor), l = new oa.CylinderGeometry(1, 1, 1, e.pointResolution);
    l.applyMatrix4(new oa.Matrix4().makeRotationX(Math.PI / 2)), l.applyMatrix4(new oa.Matrix4().makeTranslation(0, 0, -0.5));
    var u = 2 * Math.PI * Ci / 360, c = {};
    if (!e.pointsMerge && t.hasOwnProperty("pointsMerge") && bi(e.scene), e.dataMapper.scene = e.pointsMerge ? new oa.Object3D() : e.scene, e.dataMapper.onCreateObj(_).onUpdateObj(y).digest(e.pointsData), e.pointsMerge) {
      var A = e.pointsData.length ? ($C.mergeGeometries || $C.mergeBufferGeometries)(e.pointsData.map(function(T) {
        var b = e.dataMapper.getObj(T), S = b.geometry.clone();
        b.updateMatrix(), S.applyMatrix4(b.matrix);
        var E = Qu(a(T));
        return S.setAttribute("color", ll(Array(S.getAttribute("position").count).fill(E), 4)), S;
      })) : new oa.BufferGeometry(), m = new oa.Mesh(A, new oa.MeshLambertMaterial({
        color: 16777215,
        transparent: !0,
        vertexColors: !0
      }));
      m.__globeObjType = "points", m.__data = e.pointsData, e.dataMapper.clear(), bi(e.scene), e.scene.add(m);
    }
    function _() {
      var T = new oa.Mesh(l);
      return T.__globeObjType = "point", T;
    }
    function y(T, b) {
      var S = function(U) {
        var N = T.__currentTargetD = U, O = N.r, G = N.alt, H = N.lat, Y = N.lng;
        Object.assign(T.position, Xo(H, Y));
        var K = e.pointsMerge ? new oa.Vector3(0, 0, 0) : e.scene.localToWorld(new oa.Vector3(0, 0, 0));
        T.lookAt(K), T.scale.x = T.scale.y = Math.min(30, O) * u, T.scale.z = Math.max(G * Ci, 0.1);
      }, E = {
        alt: +s(b),
        r: +o(b),
        lat: +n(b),
        lng: +r(b)
      }, R = T.__currentTargetD || Object.assign({}, E, {
        alt: -1e-3
      });
      if (Object.keys(E).some(function(B) {
        return R[B] !== E[B];
      }) && (e.pointsMerge || !e.pointsTransitionDuration || e.pointsTransitionDuration < 0 ? S(E) : e.tweenGroup.add(new xs(R).to(E, e.pointsTransitionDuration).easing(Ar.Quadratic.InOut).onUpdate(S).start())), !e.pointsMerge) {
        var C = a(b), L = C ? ya(C) : 0, D = !!L;
        T.visible = D, D && (c.hasOwnProperty(C) || (c[C] = new oa.MeshLambertMaterial({
          color: al(C),
          transparent: L < 1,
          opacity: L
        })), T.material = c[C]);
      }
    }
  }
}), $I = function() {
  return {
    uniforms: {
      // dash param defaults, all relative to full length
      dashOffset: {
        value: 0
      },
      dashSize: {
        value: 1
      },
      gapSize: {
        value: 0
      },
      dashTranslate: {
        value: 0
      }
      // used for animating the dash
    },
    vertexShader: `
    `.concat(_n.common, `
    `).concat(_n.logdepthbuf_pars_vertex, `

    uniform float dashTranslate;

    attribute vec4 color;
    varying vec4 vColor;

    attribute float relDistance;
    varying float vRelDistance;

    void main() {
      // pass through colors and distances
      vColor = color;
      vRelDistance = relDistance + dashTranslate;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);

      `).concat(_n.logdepthbuf_vertex, `
    }
  `),
    fragmentShader: `
    `.concat(_n.logdepthbuf_pars_fragment, `

    uniform float dashOffset;
    uniform float dashSize;
    uniform float gapSize;

    varying vec4 vColor;
    varying float vRelDistance;

    void main() {
      // ignore pixels in the gap
      if (vRelDistance < dashOffset) discard;
      if (mod(vRelDistance - dashOffset, dashSize + gapSize) > dashSize) discard;

      // set px color: [r, g, b, a], interpolated between vertices
      gl_FragColor = vColor;

      `).concat(_n.logdepthbuf_fragment, `
    }
  `)
  };
}, a3 = function(e) {
  return e.uniforms.uSurfaceRadius = {
    type: "float",
    value: 0
  }, e.vertexShader = (`attribute float surfaceRadius;
varying float vSurfaceRadius;
varying vec3 vPos;
` + e.vertexShader).replace("void main() {", ["void main() {", "vSurfaceRadius = surfaceRadius;", "vPos = position;"].join(`
`)), e.fragmentShader = (`uniform float uSurfaceRadius;
varying float vSurfaceRadius;
varying vec3 vPos;
` + e.fragmentShader).replace("void main() {", ["void main() {", "if (length(vPos) < max(uSurfaceRadius, vSurfaceRadius)) discard;"].join(`
`)), e;
}, iue = function(e) {
  return e.vertexShader = `
    attribute float r;

    const float PI = 3.1415926535897932384626433832795;
    float toRad(in float a) {
      return a * PI / 180.0;
    }

    vec3 Polar2Cartesian(in vec3 c) { // [lat, lng, r]
      float phi = toRad(90.0 - c.x);
      float theta = toRad(90.0 - c.y);
      float r = c.z;
      return vec3( // x,y,z
        r * sin(phi) * cos(theta),
        r * cos(phi),
        r * sin(phi) * sin(theta)
      );
    }

    vec2 Cartesian2Polar(in vec3 p) {
      float r = sqrt(p.x * p.x + p.y * p.y + p.z * p.z);
      float phi = acos(p.y / r);
      float theta = atan(p.z, p.x);
      return vec2( // lat,lng
        90.0 - phi * 180.0 / PI,
        90.0 - theta * 180.0 / PI - (theta < -PI / 2.0 ? 360.0 : 0.0)
      );
    }
    `.concat(e.vertexShader.replace("}", `
        vec3 pos = Polar2Cartesian(vec3(Cartesian2Polar(position), r));
        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
      }
    `), `
  `), e;
}, Aw = function(e, t) {
  return e.onBeforeCompile = function(n) {
    e.userData.shader = t(n);
  }, e;
}, rue = function(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : function(r) {
    return r;
  };
  if (e.userData.shader)
    t(e.userData.shader.uniforms);
  else {
    var n = e.onBeforeCompile;
    e.onBeforeCompile = function(r) {
      n(r), t(r.uniforms);
    };
  }
}, sue = ["stroke"], aa = window.THREE ? window.THREE : {
  BufferGeometry: Yt,
  CubicBezierCurve3: k3,
  Curve: Ko,
  Group: As,
  Line: va,
  Mesh: Tn,
  NormalBlending: gs,
  ShaderMaterial: Fr,
  TubeGeometry: E0,
  Vector3: j
}, oue = $f.default || $f, jI = Sr({
  props: {
    arcsData: {
      default: []
    },
    arcStartLat: {
      default: "startLat"
    },
    arcStartLng: {
      default: "startLng"
    },
    arcStartAltitude: {
      default: 0
    },
    arcEndLat: {
      default: "endLat"
    },
    arcEndLng: {
      default: "endLng"
    },
    arcEndAltitude: {
      default: 0
    },
    arcColor: {
      default: function() {
        return "#ffffaa";
      }
    },
    // single color, array of colors or color interpolation fn
    arcAltitude: {},
    // in units of globe radius
    arcAltitudeAutoScale: {
      default: 0.5
    },
    // scale altitude proportional to great-arc distance between the two points
    arcStroke: {},
    // in deg
    arcCurveResolution: {
      default: 64,
      triggerUpdate: !1
    },
    // how many straight segments in the curve
    arcCircularResolution: {
      default: 6,
      triggerUpdate: !1
    },
    // how many slice segments in the tube's circumference
    arcDashLength: {
      default: 1
    },
    // in units of line length
    arcDashGap: {
      default: 0
    },
    arcDashInitialGap: {
      default: 0
    },
    arcDashAnimateTime: {
      default: 0
    },
    // ms
    arcsTransitionDuration: {
      default: 1e3,
      triggerUpdate: !1
    }
    // ms
  },
  methods: {
    pauseAnimation: function(e) {
      var t;
      (t = e.ticker) === null || t === void 0 || t.pause();
    },
    resumeAnimation: function(e) {
      var t;
      (t = e.ticker) === null || t === void 0 || t.resume();
    },
    _destructor: function(e) {
      var t;
      e.sharedMaterial.dispose(), (t = e.ticker) === null || t === void 0 || t.dispose();
    }
  },
  stateInit: function(e) {
    var t = e.tweenGroup;
    return {
      tweenGroup: t,
      ticker: new oue(),
      sharedMaterial: new aa.ShaderMaterial(ai(ai({}, $I()), {}, {
        transparent: !0,
        blending: aa.NormalBlending
      }))
    };
  },
  init: function(e, t) {
    bi(e), t.scene = e, t.dataMapper = new co(e, {
      objBindAttr: "__threeObjArc"
    }).onCreateObj(function() {
      var n = new aa.Group();
      return n.__globeObjType = "arc", n;
    }), t.ticker.onTick.add(function(n, r) {
      t.dataMapper.entries().map(function(s) {
        var o = Li(s, 2), a = o[1];
        return a;
      }).filter(function(s) {
        return s.children.length && s.children[0].material && s.children[0].__dashAnimateStep;
      }).forEach(function(s) {
        var o = s.children[0], a = o.__dashAnimateStep * r, l = o.material.uniforms.dashTranslate.value % 1e9;
        o.material.uniforms.dashTranslate.value = l + a;
      });
    });
  },
  update: function(e) {
    var t = je(e.arcStartLat), n = je(e.arcStartLng), r = je(e.arcStartAltitude), s = je(e.arcEndLat), o = je(e.arcEndLng), a = je(e.arcEndAltitude), l = je(e.arcAltitude), u = je(e.arcAltitudeAutoScale), c = je(e.arcStroke), A = je(e.arcColor), m = je(e.arcDashLength), _ = je(e.arcDashGap), y = je(e.arcDashInitialGap), T = je(e.arcDashAnimateTime);
    e.dataMapper.onUpdateObj(function(R, C) {
      var L = c(C), D = L != null;
      if (!R.children.length || D !== (R.children[0].type === "Mesh")) {
        bi(R);
        var B = D ? new aa.Mesh() : new aa.Line(new aa.BufferGeometry());
        B.material = e.sharedMaterial.clone(), R.add(B);
      }
      var U = R.children[0];
      Object.assign(U.material.uniforms, {
        dashSize: {
          value: m(C)
        },
        gapSize: {
          value: _(C)
        },
        dashOffset: {
          value: y(C)
        }
      });
      var N = T(C);
      U.__dashAnimateStep = N > 0 ? 1e3 / N : 0;
      var O = S(
        A(C),
        // single, array of colors or interpolator
        e.arcCurveResolution,
        // numSegments
        D ? e.arcCircularResolution + 1 : 1
        // num vertices per segment
      ), G = E(
        e.arcCurveResolution,
        // numSegments
        D ? e.arcCircularResolution + 1 : 1,
        // num vertices per segment
        !0
        // run from end to start, to animate in the correct direction
      );
      U.geometry.setAttribute("color", O), U.geometry.setAttribute("relDistance", G);
      var H = function(ee) {
        var oe = R.__currentTargetD = ee, fe = oe.stroke, _e = Wle(oe, sue), Te = b(_e);
        D ? (U.geometry && U.geometry.dispose(), U.geometry = new aa.TubeGeometry(Te, e.arcCurveResolution, fe / 2, e.arcCircularResolution), U.geometry.setAttribute("color", O), U.geometry.setAttribute("relDistance", G)) : U.geometry.setFromPoints(Te.getPoints(e.arcCurveResolution));
      }, Y = {
        stroke: L,
        alt: l(C),
        altAutoScale: +u(C),
        startLat: +t(C),
        startLng: +n(C),
        startAlt: +r(C),
        endLat: +s(C),
        endLng: +o(C),
        endAlt: +a(C)
      }, K = R.__currentTargetD || Object.assign({}, Y, {
        altAutoScale: -1e-3
      });
      Object.keys(Y).some(function(X) {
        return K[X] !== Y[X];
      }) && (!e.arcsTransitionDuration || e.arcsTransitionDuration < 0 ? H(Y) : e.tweenGroup.add(new xs(K).to(Y, e.arcsTransitionDuration).easing(Ar.Quadratic.InOut).onUpdate(H).start()));
    }).digest(e.arcsData);
    function b(R) {
      var C = R.alt, L = R.altAutoScale, D = R.startLat, B = R.startLng, U = R.startAlt, N = R.endLat, O = R.endLng, G = R.endAlt, H = function(Pe) {
        var ke = Li(Pe, 3), at = ke[0], wt = ke[1], ot = ke[2], Wt = Xo(wt, at, ot), en = Wt.x, z = Wt.y, ue = Wt.z;
        return new aa.Vector3(en, z, ue);
      }, Y = [B, D], K = [O, N], X = C;
      if (X == null && // by default set altitude proportional to the great-arc distance
      (X = ju(Y, K) / 2 * L + Math.max(U, G)), X || U || G) {
        var ee = bS(Y, K), oe = function(Pe, ke) {
          return ke + (ke - Pe) * (Pe < ke ? 0.5 : 0.25);
        }, fe = [0.25, 0.75].map(function(Tt) {
          return [].concat(_i(ee(Tt)), [oe(Tt < 0.5 ? U : G, X)]);
        }), _e = Li(fe, 2), Te = _e[0], Ce = _e[1], Je = hw(aa.CubicBezierCurve3, _i([[].concat(Y, [U]), Te, Ce, [].concat(K, [G])].map(H)));
        return Je;
      } else {
        var Qe = 1e-3;
        return zt.apply(void 0, _i([[].concat(Y, [Qe]), [].concat(K, [Qe])].map(H)));
      }
      function zt(Tt, Pe) {
        var ke = Tt.angleTo(Pe), at = ke === 0 ? function() {
          return Tt.clone();
        } : function(ot) {
          return new aa.Vector3().addVectors(Tt.clone().multiplyScalar(Math.sin((1 - ot) * ke)), Pe.clone().multiplyScalar(Math.sin(ot * ke))).divideScalar(Math.sin(ke));
        }, wt = new aa.Curve();
        return wt.getPoint = at, wt;
      }
    }
    function S(R, C) {
      var L = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1, D = C + 1, B;
      if (R instanceof Array || R instanceof Function) {
        var U = R instanceof Array ? $l().domain(R.map(function(X, ee) {
          return ee / (R.length - 1);
        })).range(R) : R;
        B = function(ee) {
          return Qu(U(ee), !0, !0);
        };
      } else {
        var N = Qu(R, !0, !0);
        B = function() {
          return N;
        };
      }
      for (var O = [], G = 0, H = D; G < H; G++)
        for (var Y = B(G / (H - 1)), K = 0; K < L; K++)
          O.push(Y);
      return ll(O, 4);
    }
    function E(R) {
      for (var C = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1, L = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, D = R + 1, B = [], U = 0, N = D; U < N; U++)
        for (var O = U / (N - 1), G = 0; G < C; G++)
          B.push(O);
      return L && B.reverse(), ll(B, 1);
    }
  }
}), vu = window.THREE ? window.THREE : {
  BufferGeometry: Yt,
  DoubleSide: er,
  Mesh: Tn,
  MeshLambertMaterial: Ea,
  Object3D: Vn
}, jC = Object.assign({}, ES), XC = jC.BufferGeometryUtils || jC, XI = Sr({
  props: {
    hexBinPointsData: {
      default: []
    },
    hexBinPointLat: {
      default: "lat"
    },
    hexBinPointLng: {
      default: "lng"
    },
    hexBinPointWeight: {
      default: 1
    },
    hexBinResolution: {
      default: 4
    },
    // 0-15. Level 0 partitions the earth in 122 (mostly) hexagonal cells. Each subsequent level sub-divides the previous in roughly 7 hexagons.
    hexMargin: {
      default: 0.2
    },
    // in fraction of diameter
    hexTopCurvatureResolution: {
      default: 5
    },
    // in angular degrees
    hexTopColor: {
      default: function() {
        return "#ffffaa";
      }
    },
    hexSideColor: {
      default: function() {
        return "#ffffaa";
      }
    },
    hexAltitude: {
      default: function(e) {
        var t = e.sumWeight;
        return t * 0.01;
      }
    },
    // in units of globe radius
    hexBinMerge: {
      default: !1
    },
    // boolean. Whether to merge all hex geometries into a single mesh for rendering performance
    hexTransitionDuration: {
      default: 1e3,
      triggerUpdate: !1
    }
    // ms
  },
  init: function(e, t, n) {
    var r = n.tweenGroup;
    bi(e), t.scene = e, t.tweenGroup = r, t.dataMapper = new co(e, {
      objBindAttr: "__threeObjHexbin"
    });
  },
  update: function(e, t) {
    var n = je(e.hexBinPointLat), r = je(e.hexBinPointLng), s = je(e.hexBinPointWeight), o = je(e.hexAltitude), a = je(e.hexTopColor), l = je(e.hexSideColor), u = je(e.hexMargin), c = eQ(e.hexBinPointsData.map(function(E) {
      return ai(ai({}, E), {}, {
        h3Idx: kQ(n(E), r(E), e.hexBinResolution)
      });
    }), "h3Idx"), A = Object.entries(c).map(function(E) {
      var R = Li(E, 2), C = R[0], L = R[1];
      return {
        h3Idx: C,
        points: L,
        sumWeight: L.reduce(function(D, B) {
          return D + +s(B);
        }, 0)
      };
    }), m = {};
    if (!e.hexBinMerge && t.hasOwnProperty("hexBinMerge") && bi(e.scene), e.dataMapper.scene = e.hexBinMerge ? new vu.Object3D() : e.scene, e.dataMapper.id(function(E) {
      return E.h3Idx;
    }).onCreateObj(b).onUpdateObj(S).digest(A), e.hexBinMerge) {
      var _ = A.length ? (XC.mergeGeometries || XC.mergeBufferGeometries)(A.map(function(E) {
        var R = e.dataMapper.getObj(E), C = R.geometry.toNonIndexed();
        R.updateMatrix(), C.applyMatrix4(R.matrix);
        var L = Qu(a(E)), D = Qu(l(E)), B = C.getAttribute("position").count, U = C.groups[0].count;
        return C.setAttribute("color", ll(_i(new Array(B)).map(function(N, O) {
          return O >= U ? L : D;
        }), 4)), C;
      })) : new vu.BufferGeometry(), y = new vu.MeshLambertMaterial({
        color: 16777215,
        transparent: !0,
        vertexColors: !0,
        side: vu.DoubleSide
      });
      y.onBeforeCompile = function(E) {
        y.userData.shader = a3(E);
      };
      var T = new vu.Mesh(_, y);
      T.__globeObjType = "hexBinPoints", T.__data = A, e.dataMapper.clear(), bi(e.scene), e.scene.add(T);
    }
    function b(E) {
      var R = new vu.Mesh();
      R.__hexCenter = jP(E.h3Idx), R.__hexGeoJson = XP(E.h3Idx, !0).reverse();
      var C = R.__hexCenter[1];
      return R.__hexGeoJson.forEach(function(L) {
        var D = L[0];
        Math.abs(C - D) > 170 && (L[0] += C > D ? 360 : -360);
      }), R.__globeObjType = "hexbin", R;
    }
    function S(E, R) {
      var C = function(oe, fe, _e) {
        return oe - (oe - fe) * _e;
      }, L = Math.max(0, Math.min(1, +u(R))), D = Li(E.__hexCenter, 2), B = D[0], U = D[1], N = L === 0 ? E.__hexGeoJson : E.__hexGeoJson.map(function(ee) {
        var oe = Li(ee, 2), fe = oe[0], _e = oe[1];
        return [[fe, U], [_e, B]].map(function(Te) {
          var Ce = Li(Te, 2), Je = Ce[0], Qe = Ce[1];
          return C(Je, Qe, L);
        });
      }), O = e.hexTopCurvatureResolution;
      E.geometry && E.geometry.dispose(), E.geometry = new DS([N], 0, Ci, !1, !0, !0, O);
      var G = {
        alt: +o(R)
      }, H = function(oe) {
        var fe = E.__currentTargetD = oe, _e = fe.alt;
        E.scale.x = E.scale.y = E.scale.z = 1 + _e;
        var Te = Ci / (_e + 1);
        E.geometry.setAttribute("surfaceRadius", ll(Array(E.geometry.getAttribute("position").count).fill(Te), 1));
      }, Y = E.__currentTargetD || Object.assign({}, G, {
        alt: -1e-3
      });
      if (Object.keys(G).some(function(ee) {
        return Y[ee] !== G[ee];
      }) && (e.hexBinMerge || !e.hexTransitionDuration || e.hexTransitionDuration < 0 ? H(G) : e.tweenGroup.add(new xs(Y).to(G, e.hexTransitionDuration).easing(Ar.Quadratic.InOut).onUpdate(H).start())), !e.hexBinMerge) {
        var K = l(R), X = a(R);
        [K, X].forEach(function(ee) {
          if (!m.hasOwnProperty(ee)) {
            var oe = ya(ee);
            m[ee] = Aw(new vu.MeshLambertMaterial({
              color: al(ee),
              transparent: oe < 1,
              opacity: oe,
              side: vu.DoubleSide
            }), a3);
          }
        }), E.material = [K, X].map(function(ee) {
          return m[ee];
        });
      }
    }
  }
}), YI = function(e) {
  return e * e;
}, Ml = function(e) {
  return e * Math.PI / 180;
};
function aue(i, e) {
  var t = Math.sqrt, n = Math.cos, r = function(c) {
    return YI(Math.sin(c / 2));
  }, s = Ml(i[1]), o = Ml(e[1]), a = Ml(i[0]), l = Ml(e[0]);
  return 2 * Math.asin(t(r(o - s) + n(s) * n(o) * r(l - a)));
}
var lue = Math.sqrt(2 * Math.PI);
function uue(i, e) {
  return Math.exp(-YI(i / e) / 2) / (e * lue);
}
var cue = function(e) {
  var t = Li(e, 2), n = t[0], r = t[1], s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, a = o.lngAccessor, l = a === void 0 ? function(b) {
    return b[0];
  } : a, u = o.latAccessor, c = u === void 0 ? function(b) {
    return b[1];
  } : u, A = o.weightAccessor, m = A === void 0 ? function() {
    return 1;
  } : A, _ = o.bandwidth, y = [n, r], T = _ * Math.PI / 180;
  return QH(s.map(function(b) {
    var S = m(b);
    if (!S) return 0;
    var E = aue(y, [l(b), c(b)]);
    return uue(E, T) * S;
  }));
}, hue = /* @__PURE__ */ (function() {
  var i = Ole(/* @__PURE__ */ s3().m(function e(t) {
    var n, r, s, o, a, l, u, c, A, m, _, y, T, b, S, E, R, C, L, D, B, U, N, O, G, H, Y, K, X, ee, oe, fe, _e, Te, Ce, Je, Qe, zt, Tt, Pe, ke = arguments, at, wt, ot;
    return s3().w(function(Wt) {
      for (; ; ) switch (Wt.n) {
        case 0:
          if (r = ke.length > 1 && ke[1] !== void 0 ? ke[1] : [], s = ke.length > 2 && ke[2] !== void 0 ? ke[2] : {}, o = s.lngAccessor, a = o === void 0 ? function(en) {
            return en[0];
          } : o, l = s.latAccessor, u = l === void 0 ? function(en) {
            return en[1];
          } : l, c = s.weightAccessor, A = c === void 0 ? function() {
            return 1;
          } : c, m = s.bandwidth, (n = navigator) !== null && n !== void 0 && n.gpu) {
            Wt.n = 1;
            break;
          }
          return console.warn("WebGPU not enabled in browser. Please consider enabling it to improve performance."), Wt.a(2, t.map(function(en) {
            return cue(en, r, {
              lngAccessor: a,
              latAccessor: u,
              weightAccessor: A,
              bandwidth: m
            });
          }));
        case 1:
          return _ = 4, y = ple, T = mle, b = Ele, S = Mle, E = vle, R = ble, C = gle, L = wle, D = Tle, B = xle, U = _le, N = yle, O = Sle, G = S(new a1(new Float32Array(t.flat().map(Ml)), 2), "vec2", t.length), H = S(new a1(new Float32Array(r.map(function(en) {
            return [Ml(a(en)), Ml(u(en)), A(en)];
          }).flat()), 3), "vec3", r.length), Y = new a1(t.length, 1), K = S(Y, "float", t.length), X = E(Math.PI), ee = L(X.mul(2)), oe = function(z) {
            return z.mul(z);
          }, fe = function(z) {
            return oe(D(z.div(2)));
          }, _e = function(z, ue) {
            var he = E(z[1]), Ee = E(ue[1]), Ye = E(z[0]), te = E(ue[0]);
            return E(2).mul(U(L(fe(Ee.sub(he)).add(B(he).mul(B(Ee)).mul(fe(te.sub(Ye)))))));
          }, Te = function(z, ue) {
            return N(O(oe(z.div(ue)).div(2))).div(ue.mul(ee));
          }, Ce = b(Ml(m)), Je = b(Ml(m * _)), Qe = b(r.length), zt = y(function() {
            var en = G.element(R), z = K.element(R);
            z.assign(0), C(Qe, function(ue) {
              var he = ue.i, Ee = H.element(he), Ye = Ee.z;
              T(Ye, function() {
                var te = _e(Ee.xy, en.xy);
                T(te && te.lessThan(Je), function() {
                  z.addAssign(Te(te, Ce).mul(Ye));
                });
              });
            });
          }), Tt = zt().compute(t.length), Pe = new FI(), Wt.n = 2, Pe.computeAsync(Tt);
        case 2:
          return at = Array, wt = Float32Array, Wt.n = 3, Pe.getArrayBufferAsync(Y);
        case 3:
          return ot = Wt.v, Wt.a(2, at.from.call(at, new wt(ot)));
      }
    }, e);
  }));
  return function(t) {
    return i.apply(this, arguments);
  };
})(), Bg = window.THREE ? window.THREE : {
  Mesh: Tn,
  MeshLambertMaterial: Ea,
  SphereGeometry: Co
}, due = 3.5, fue = 0.1, YC = 100, Aue = function(e) {
  var t = Hh(GQ(e));
  return t.opacity = Math.cbrt(e), t.formatRgb();
}, QI = Sr({
  props: {
    heatmapsData: {
      default: []
    },
    heatmapPoints: {
      default: function(e) {
        return e;
      }
    },
    heatmapPointLat: {
      default: function(e) {
        return e[0];
      }
    },
    heatmapPointLng: {
      default: function(e) {
        return e[1];
      }
    },
    heatmapPointWeight: {
      default: 1
    },
    heatmapBandwidth: {
      default: 2.5
    },
    // Gaussian kernel bandwidth, in angular degrees
    heatmapColorFn: {
      default: function() {
        return Aue;
      }
    },
    heatmapColorSaturation: {
      default: 1.5
    },
    // multiplier for color scale max
    heatmapBaseAltitude: {
      default: 0.01
    },
    // in units of globe radius
    heatmapTopAltitude: {},
    // in units of globe radius
    heatmapsTransitionDuration: {
      default: 0,
      triggerUpdate: !1
    }
    // ms
  },
  init: function(e, t, n) {
    var r = n.tweenGroup;
    bi(e), t.scene = e, t.tweenGroup = r, t.dataMapper = new co(e, {
      objBindAttr: "__threeObjHeatmap"
    }).onCreateObj(function() {
      var s = new Bg.Mesh(new Bg.SphereGeometry(Ci), Aw(new Bg.MeshLambertMaterial({
        vertexColors: !0,
        transparent: !0
      }), iue));
      return s.__globeObjType = "heatmap", s;
    });
  },
  update: function(e) {
    var t = je(e.heatmapPoints), n = je(e.heatmapPointLat), r = je(e.heatmapPointLng), s = je(e.heatmapPointWeight), o = je(e.heatmapBandwidth), a = je(e.heatmapColorFn), l = je(e.heatmapColorSaturation), u = je(e.heatmapBaseAltitude), c = je(e.heatmapTopAltitude);
    e.dataMapper.onUpdateObj(function(A, m) {
      var _ = o(m), y = a(m), T = l(m), b = u(m), S = c(m), E = t(m).map(function(B) {
        var U = n(B), N = r(B), O = Xo(U, N), G = O.x, H = O.y, Y = O.z;
        return {
          x: G,
          y: H,
          z: Y,
          lat: U,
          lng: N,
          weight: s(B)
        };
      }), R = Math.max(fue, _ / due), C = Math.ceil(360 / (R || -1));
      A.geometry.parameters.widthSegments !== C && (A.geometry.dispose(), A.geometry = new Bg.SphereGeometry(Ci, C, C / 2));
      var L = nue(A.geometry.getAttribute("position")), D = L.map(function(B) {
        var U = Li(B, 3), N = U[0], O = U[1], G = U[2], H = qI({
          x: N,
          y: O,
          z: G
        }), Y = H.lng, K = H.lat;
        return [Y, K];
      });
      hue(D, E, {
        latAccessor: function(U) {
          return U.lat;
        },
        lngAccessor: function(U) {
          return U.lng;
        },
        weightAccessor: function(U) {
          return U.weight;
        },
        bandwidth: _
      }).then(function(B) {
        var U = _i(new Array(YC)).map(function(H, Y) {
          return Qu(y(Y / (YC - 1)));
        }), N = function(Y) {
          var K = A.__currentTargetD = Y, X = K.kdeVals, ee = K.topAlt, oe = K.saturation, fe = jH(X.map(Math.abs)) || 1e-15, _e = X8([0, fe / oe], U);
          A.geometry.setAttribute("color", ll(X.map(function(Ce) {
            return _e(Math.abs(Ce));
          }), 4));
          var Te = $l([0, fe], [Ci * (1 + b), Ci * (1 + (ee || b))]);
          A.geometry.setAttribute("r", ll(X.map(Te)));
        }, O = {
          kdeVals: B,
          topAlt: S,
          saturation: T
        }, G = A.__currentTargetD || Object.assign({}, O, {
          kdeVals: B.map(function() {
            return 0;
          }),
          topAlt: S && b,
          saturation: 0.5
        });
        G.kdeVals.length !== B.length && (G.kdeVals = B.slice()), Object.keys(O).some(function(H) {
          return G[H] !== O[H];
        }) && (!e.heatmapsTransitionDuration || e.heatmapsTransitionDuration < 0 ? N(O) : e.tweenGroup.add(new xs(G).to(O, e.heatmapsTransitionDuration).easing(Ar.Quadratic.InOut).onUpdate(N).start()));
      });
    }).digest(e.heatmapsData);
  }
}), bu = window.THREE ? window.THREE : {
  DoubleSide: er,
  Group: As,
  LineBasicMaterial: br,
  LineSegments: Qo,
  Mesh: Tn,
  MeshBasicMaterial: Nr
}, KI = Sr({
  props: {
    polygonsData: {
      default: []
    },
    polygonGeoJsonGeometry: {
      default: "geometry"
    },
    polygonSideColor: {
      default: function() {
        return "#ffffaa";
      }
    },
    polygonSideMaterial: {},
    polygonCapColor: {
      default: function() {
        return "#ffffaa";
      }
    },
    polygonCapMaterial: {},
    polygonStrokeColor: {},
    polygonAltitude: {
      default: 0.01
    },
    // in units of globe radius
    polygonCapCurvatureResolution: {
      default: 5
    },
    // in angular degrees
    polygonsTransitionDuration: {
      default: 1e3,
      triggerUpdate: !1
    }
    // ms
  },
  init: function(e, t, n) {
    var r = n.tweenGroup;
    bi(e), t.scene = e, t.tweenGroup = r, t.dataMapper = new co(e, {
      objBindAttr: "__threeObjPolygon"
    }).id(function(s) {
      return s.id;
    }).onCreateObj(function() {
      var s = new bu.Group();
      return s.__defaultSideMaterial = Aw(new bu.MeshBasicMaterial({
        side: bu.DoubleSide,
        depthWrite: !0
      }), a3), s.__defaultCapMaterial = new bu.MeshBasicMaterial({
        side: bu.DoubleSide,
        depthWrite: !0
      }), s.add(new bu.Mesh(void 0, [
        s.__defaultSideMaterial,
        // side material
        s.__defaultCapMaterial
        // cap material
      ])), s.add(new bu.LineSegments(void 0, new bu.LineBasicMaterial())), s.__globeObjType = "polygon", s;
    });
  },
  update: function(e) {
    var t = je(e.polygonGeoJsonGeometry), n = je(e.polygonAltitude), r = je(e.polygonCapCurvatureResolution), s = je(e.polygonCapColor), o = je(e.polygonCapMaterial), a = je(e.polygonSideColor), l = je(e.polygonSideMaterial), u = je(e.polygonStrokeColor), c = [];
    e.polygonsData.forEach(function(A) {
      var m = {
        data: A,
        capColor: s(A),
        capMaterial: o(A),
        sideColor: a(A),
        sideMaterial: l(A),
        strokeColor: u(A),
        altitude: +n(A),
        capCurvatureResolution: +r(A)
      }, _ = t(A), y = A.__id || "".concat(Math.round(Math.random() * 1e9));
      A.__id = y, _.type === "Polygon" ? c.push(ai({
        id: "".concat(y, "_0"),
        coords: _.coordinates
      }, m)) : _.type === "MultiPolygon" ? c.push.apply(c, _i(_.coordinates.map(function(T, b) {
        return ai({
          id: "".concat(y, "_").concat(b),
          coords: T
        }, m);
      }))) : console.warn("Unsupported GeoJson geometry type: ".concat(_.type, ". Skipping geometry..."));
    }), e.dataMapper.onUpdateObj(function(A, m) {
      var _ = m.coords, y = m.capColor, T = m.capMaterial, b = m.sideColor, S = m.sideMaterial, E = m.strokeColor, R = m.altitude, C = m.capCurvatureResolution, L = Li(A.children, 2), D = L[0], B = L[1], U = !!E;
      B.visible = U;
      var N = !!(y || T), O = !!(b || S);
      pue(D.geometry.parameters || {}, {
        polygonGeoJson: _,
        curvatureResolution: C,
        closedTop: N,
        includeSides: O
      }) || (D.geometry && D.geometry.dispose(), D.geometry = new DS(_, 0, Ci, !1, N, O, C)), U && (!B.geometry.parameters || B.geometry.parameters.geoJson.coordinates !== _ || B.geometry.parameters.resolution !== C) && (B.geometry && B.geometry.dispose(), B.geometry = new RP({
        type: "Polygon",
        coordinates: _
      }, Ci, C));
      var G = O ? 0 : -1, H = N ? O ? 1 : 0 : -1;
      if (G >= 0 && (D.material[G] = S || A.__defaultSideMaterial), H >= 0 && (D.material[H] = T || A.__defaultCapMaterial), [[!S && b, G], [!T && y, H]].forEach(function(fe) {
        var _e = Li(fe, 2), Te = _e[0], Ce = _e[1];
        if (!(!Te || Ce < 0)) {
          var Je = D.material[Ce], Qe = ya(Te);
          Je.color.set(al(Te)), Je.transparent = Qe < 1, Je.opacity = Qe;
        }
      }), U) {
        var Y = B.material, K = ya(E);
        Y.color.set(al(E)), Y.transparent = K < 1, Y.opacity = K;
      }
      var X = {
        alt: R
      }, ee = function(_e) {
        var Te = A.__currentTargetD = _e, Ce = Te.alt;
        D.scale.x = D.scale.y = D.scale.z = 1 + Ce, U && (B.scale.x = B.scale.y = B.scale.z = 1 + Ce + 1e-4), rue(A.__defaultSideMaterial, function(Je) {
          return Je.uSurfaceRadius.value = Ci / (Ce + 1);
        });
      }, oe = A.__currentTargetD || Object.assign({}, X, {
        alt: -1e-3
      });
      Object.keys(X).some(function(fe) {
        return oe[fe] !== X[fe];
      }) && (!e.polygonsTransitionDuration || e.polygonsTransitionDuration < 0 || oe.alt === X.alt ? ee(X) : e.tweenGroup.add(new xs(oe).to(X, e.polygonsTransitionDuration).easing(Ar.Quadratic.InOut).onUpdate(ee).start()));
    }).digest(c);
  }
});
function pue(i, e) {
  var t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : function() {
    return function(n, r) {
      return n === r;
    };
  };
  return Object.entries(e).every(function(n) {
    var r = Li(n, 2), s = r[0], o = r[1];
    return i.hasOwnProperty(s) && t(s)(i[s], o);
  });
}
var ef = window.THREE ? window.THREE : {
  BufferGeometry: Yt,
  DoubleSide: er,
  Mesh: Tn,
  MeshLambertMaterial: Ea,
  Vector3: j
}, QC = Object.assign({}, ES), KC = QC.BufferGeometryUtils || QC, ZI = Sr({
  props: {
    hexPolygonsData: {
      default: []
    },
    hexPolygonGeoJsonGeometry: {
      default: "geometry"
    },
    hexPolygonColor: {
      default: function() {
        return "#ffffaa";
      }
    },
    hexPolygonAltitude: {
      default: 1e-3
    },
    // in units of globe radius
    hexPolygonResolution: {
      default: 3
    },
    // 0-15. Level 0 partitions the earth in 122 (mostly) hexagonal cells. Each subsequent level sub-divides the previous in roughly 7 hexagons.
    hexPolygonMargin: {
      default: 0.2
    },
    // in fraction of hex diameter
    hexPolygonUseDots: {
      default: !1
    },
    // if points should be circular instead of hexagonal
    hexPolygonCurvatureResolution: {
      default: 5
    },
    // in angular degrees, only relevant for hex tops
    hexPolygonDotResolution: {
      default: 12
    },
    // how many slice segments in the dot circle's circumference
    hexPolygonsTransitionDuration: {
      default: 0,
      triggerUpdate: !1
    }
    // ms
  },
  init: function(e, t, n) {
    var r = n.tweenGroup;
    bi(e), t.scene = e, t.tweenGroup = r, t.dataMapper = new co(e, {
      objBindAttr: "__threeObjHexPolygon"
    }).onCreateObj(function() {
      var s = new ef.Mesh(void 0, new ef.MeshLambertMaterial({
        side: ef.DoubleSide
      }));
      return s.__globeObjType = "hexPolygon", s;
    });
  },
  update: function(e) {
    var t = je(e.hexPolygonGeoJsonGeometry), n = je(e.hexPolygonColor), r = je(e.hexPolygonAltitude), s = je(e.hexPolygonResolution), o = je(e.hexPolygonMargin), a = je(e.hexPolygonUseDots), l = je(e.hexPolygonCurvatureResolution), u = je(e.hexPolygonDotResolution);
    e.dataMapper.onUpdateObj(function(c, A) {
      var m = t(A), _ = s(A), y = r(A), T = Math.max(0, Math.min(1, +o(A))), b = a(A), S = l(A), E = u(A), R = n(A), C = ya(R);
      c.material.color.set(al(R)), c.material.transparent = C < 1, c.material.opacity = C;
      var L = {
        alt: y,
        margin: T,
        curvatureResolution: S
      }, D = {
        geoJson: m,
        h3Res: _
      }, B = c.__currentTargetD || Object.assign({}, L, {
        alt: -1e-3
      }), U = c.__currentMemD || D;
      if (Object.keys(L).some(function(H) {
        return B[H] !== L[H];
      }) || Object.keys(D).some(function(H) {
        return U[H] !== D[H];
      })) {
        c.__currentMemD = D;
        var N = [];
        m.type === "Polygon" ? fR(m.coordinates, _, !0).forEach(function(H) {
          return N.push(H);
        }) : m.type === "MultiPolygon" ? m.coordinates.forEach(function(H) {
          return fR(H, _, !0).forEach(function(Y) {
            return N.push(Y);
          });
        }) : console.warn("Unsupported GeoJson geometry type: ".concat(m.type, ". Skipping geometry..."));
        var O = N.map(function(H) {
          var Y = jP(H), K = XP(H, !0).reverse(), X = Y[1];
          return K.forEach(function(ee) {
            var oe = ee[0];
            Math.abs(X - oe) > 170 && (ee[0] += X > oe ? 360 : -360);
          }), {
            h3Idx: H,
            hexCenter: Y,
            hexGeoJson: K
          };
        }), G = function(Y) {
          var K = c.__currentTargetD = Y, X = K.alt, ee = K.margin, oe = K.curvatureResolution;
          c.geometry && c.geometry.dispose(), c.geometry = O.length ? (KC.mergeGeometries || KC.mergeBufferGeometries)(O.map(function(fe) {
            var _e = Li(fe.hexCenter, 2), Te = _e[0], Ce = _e[1];
            if (b) {
              var Je = Xo(Te, Ce, X), Qe = Xo(fe.hexGeoJson[0][1], fe.hexGeoJson[0][0], X), zt = 0.85 * (1 - ee) * new ef.Vector3(Je.x, Je.y, Je.z).distanceTo(new ef.Vector3(Qe.x, Qe.y, Qe.z)), Tt = new lA(zt, E);
              return Tt.rotateX(jc(-Te)), Tt.rotateY(jc(Ce)), Tt.translate(Je.x, Je.y, Je.z), Tt;
            } else {
              var Pe = function(wt, ot, Wt) {
                return wt - (wt - ot) * Wt;
              }, ke = ee === 0 ? fe.hexGeoJson : fe.hexGeoJson.map(function(at) {
                var wt = Li(at, 2), ot = wt[0], Wt = wt[1];
                return [[ot, Ce], [Wt, Te]].map(function(en) {
                  var z = Li(en, 2), ue = z[0], he = z[1];
                  return Pe(ue, he, ee);
                });
              });
              return new DS([ke], Ci, Ci * (1 + X), !1, !0, !1, oe);
            }
          })) : new ef.BufferGeometry();
        };
        !e.hexPolygonsTransitionDuration || e.hexPolygonsTransitionDuration < 0 ? G(L) : e.tweenGroup.add(new xs(B).to(L, e.hexPolygonsTransitionDuration).easing(Ar.Quadratic.InOut).onUpdate(G).start());
      }
    }).digest(e.hexPolygonsData);
  }
}), mue = window.THREE ? window.THREE : {
  Vector3: j
};
function gue(i, e) {
  var t = function(o, a) {
    var l = o[o.length - 1];
    return [].concat(_i(o), _i(Array(a - o.length).fill(l)));
  }, n = Math.max(i.length, e.length), r = dW.apply(void 0, _i([i, e].map(function(s) {
    return s.map(function(o) {
      var a = o.x, l = o.y, u = o.z;
      return [a, l, u];
    });
  }).map(function(s) {
    return t(s, n);
  })));
  return function(s) {
    return s === 0 ? i : s === 1 ? e : r(s).map(function(o) {
      var a = Li(o, 3), l = a[0], u = a[1], c = a[2];
      return new mue.Vector3(l, u, c);
    });
  };
}
var kc = window.THREE ? window.THREE : {
  BufferGeometry: Yt,
  Color: ct,
  Group: As,
  Line: va,
  NormalBlending: gs,
  ShaderMaterial: Fr,
  Vector3: j
}, _ue = $f.default || $f, JI = Sr({
  props: {
    pathsData: {
      default: []
    },
    pathPoints: {
      default: function(e) {
        return e;
      }
    },
    pathPointLat: {
      default: function(e) {
        return e[0];
      }
    },
    pathPointLng: {
      default: function(e) {
        return e[1];
      }
    },
    pathPointAlt: {
      default: 1e-3
    },
    pathResolution: {
      default: 2
    },
    // in deg
    pathColor: {
      default: function() {
        return "#ffffaa";
      }
    },
    // single color, array of colors or color interpolation fn
    pathStroke: {},
    // in deg
    pathDashLength: {
      default: 1
    },
    // in units of line length
    pathDashGap: {
      default: 0
    },
    pathDashInitialGap: {
      default: 0
    },
    pathDashAnimateTime: {
      default: 0
    },
    // ms
    pathTransitionDuration: {
      default: 1e3,
      triggerUpdate: !1
    },
    // ms
    rendererSize: {}
    // necessary to set correct fatline proportions
  },
  methods: {
    pauseAnimation: function(e) {
      var t;
      (t = e.ticker) === null || t === void 0 || t.pause();
    },
    resumeAnimation: function(e) {
      var t;
      (t = e.ticker) === null || t === void 0 || t.resume();
    },
    _destructor: function(e) {
      var t;
      (t = e.ticker) === null || t === void 0 || t.dispose();
    }
  },
  stateInit: function(e) {
    var t = e.tweenGroup;
    return {
      tweenGroup: t,
      ticker: new _ue(),
      sharedMaterial: new kc.ShaderMaterial(ai(ai({}, $I()), {}, {
        transparent: !0,
        blending: kc.NormalBlending
      }))
    };
  },
  init: function(e, t) {
    bi(e), t.scene = e, t.dataMapper = new co(e, {
      objBindAttr: "__threeObjPath"
    }).onCreateObj(function() {
      var n = new kc.Group();
      return n.__globeObjType = "path", n;
    }), t.ticker.onTick.add(function(n, r) {
      t.dataMapper.entries().map(function(s) {
        var o = Li(s, 2), a = o[1];
        return a;
      }).filter(function(s) {
        return s.children.length && s.children[0].material && s.children[0].__dashAnimateStep;
      }).forEach(function(s) {
        var o = s.children[0], a = o.__dashAnimateStep * r;
        if (o.type === "Line") {
          var l = o.material.uniforms.dashTranslate.value % 1e9;
          o.material.uniforms.dashTranslate.value = l + a;
        } else if (o.type === "Line2") {
          for (var u = o.material.dashOffset - a, c = o.material.dashSize + o.material.gapSize; u <= -c; ) u += c;
          o.material.dashOffset = u;
        }
      });
    });
  },
  update: function(e) {
    var t = je(e.pathPoints), n = je(e.pathPointLat), r = je(e.pathPointLng), s = je(e.pathPointAlt), o = je(e.pathStroke), a = je(e.pathColor), l = je(e.pathDashLength), u = je(e.pathDashGap), c = je(e.pathDashInitialGap), A = je(e.pathDashAnimateTime);
    e.dataMapper.onUpdateObj(function(b, S) {
      var E = o(S), R = E != null;
      if (!b.children.length || R === (b.children[0].type === "Line")) {
        bi(b);
        var C = R ? new Nle(new OI(), new cw()) : new kc.Line(
          new kc.BufferGeometry(),
          e.sharedMaterial.clone()
          // Separate material instance per object to have dedicated uniforms (but shared shaders)
        );
        b.add(C);
      }
      var L = b.children[0], D = _(t(S), n, r, s, e.pathResolution), B = A(S);
      if (L.__dashAnimateStep = B > 0 ? 1e3 / B : 0, R) {
        L.material.resolution = e.rendererSize;
        {
          var O = l(S), G = u(S), H = c(S);
          L.material.dashed = G > 0, L.material.dashed ? L.material.defines.USE_DASH = "" : delete L.material.defines.USE_DASH, L.material.dashed && (L.material.dashScale = 1 / m(D), L.material.dashSize = O, L.material.gapSize = G, L.material.dashOffset = -H);
        }
        {
          var Y = a(S);
          if (Y instanceof Array) {
            var K = y(
              a(S),
              // single, array of colors or interpolator
              D.length - 1,
              // numSegments
              1,
              // num vertices per segment
              !1
            );
            L.geometry.setColors(K.array), L.material.vertexColors = !0;
          } else {
            var X = Y, ee = ya(X);
            L.material.color = new kc.Color(al(X)), L.material.transparent = ee < 1, L.material.opacity = ee, L.material.vertexColors = !1;
          }
        }
        L.material.needsUpdate = !0;
      } else {
        Object.assign(L.material.uniforms, {
          dashSize: {
            value: l(S)
          },
          gapSize: {
            value: u(S)
          },
          dashOffset: {
            value: c(S)
          }
        });
        var U = y(
          a(S),
          // single, array of colors or interpolator
          D.length
          // numSegments
        ), N = T(
          D.length,
          // numSegments
          1,
          // num vertices per segment
          !0
          // run from end to start, to animate in the correct direction
        );
        L.geometry.setAttribute("color", U), L.geometry.setAttribute("relDistance", N);
      }
      var oe = gue(b.__currentTargetD && b.__currentTargetD.points || [D[0]], D), fe = function(Je) {
        var Qe = b.__currentTargetD = Je, zt = Qe.stroke, Tt = Qe.interpolK, Pe = b.__currentTargetD.points = oe(Tt);
        if (R) {
          var ke;
          L.geometry.setPositions((ke = []).concat.apply(ke, _i(Pe.map(function(at) {
            var wt = at.x, ot = at.y, Wt = at.z;
            return [wt, ot, Wt];
          })))), L.material.linewidth = zt, L.material.dashed && L.computeLineDistances();
        } else
          L.geometry.setFromPoints(Pe), L.geometry.computeBoundingSphere();
      }, _e = {
        stroke: E,
        interpolK: 1
      }, Te = Object.assign({}, b.__currentTargetD || _e, {
        interpolK: 0
      });
      Object.keys(_e).some(function(Ce) {
        return Te[Ce] !== _e[Ce];
      }) && (!e.pathTransitionDuration || e.pathTransitionDuration < 0 ? fe(_e) : e.tweenGroup.add(new xs(Te).to(_e, e.pathTransitionDuration).easing(Ar.Quadratic.InOut).onUpdate(fe).start()));
    }).digest(e.pathsData);
    function m(b) {
      var S = 0, E;
      return b.forEach(function(R) {
        E && (S += E.distanceTo(R)), E = R;
      }), S;
    }
    function _(b, S, E, R, C) {
      var L = function(N, O, G) {
        for (var H = [], Y = 1; Y <= G; Y++)
          H.push(N + (O - N) * Y / (G + 1));
        return H;
      }, D = function() {
        var N = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], O = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1, G = [], H = null;
        return N.forEach(function(Y) {
          if (H) {
            for (; Math.abs(H[1] - Y[1]) > 180; ) H[1] += 360 * (H[1] < Y[1] ? 1 : -1);
            var K = Math.sqrt(Math.pow(Y[0] - H[0], 2) + Math.pow(Y[1] - H[1], 2));
            if (K > O)
              for (var X = Math.floor(K / O), ee = L(H[0], Y[0], X), oe = L(H[1], Y[1], X), fe = L(H[2], Y[2], X), _e = 0, Te = ee.length; _e < Te; _e++)
                G.push([ee[_e], oe[_e], fe[_e]]);
          }
          G.push(H = Y);
        }), G;
      }, B = function(N) {
        var O = Li(N, 3), G = O[0], H = O[1], Y = O[2], K = Xo(G, H, Y), X = K.x, ee = K.y, oe = K.z;
        return new kc.Vector3(X, ee, oe);
      };
      return D(b.map(function(U) {
        return [S(U), E(U), R(U)];
      }), C).map(B);
    }
    function y(b, S) {
      var E = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1, R = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !0, C = S + 1, L;
      if (b instanceof Array || b instanceof Function) {
        var D = b instanceof Array ? $l().domain(b.map(function(Y, K) {
          return K / (b.length - 1);
        })).range(b) : b;
        L = function(K) {
          return Qu(D(K), R, !0);
        };
      } else {
        var B = Qu(b, R, !0);
        L = function() {
          return B;
        };
      }
      for (var U = [], N = 0, O = C; N < O; N++)
        for (var G = L(N / (O - 1)), H = 0; H < E; H++)
          U.push(G);
      return ll(U, R ? 4 : 3);
    }
    function T(b) {
      for (var S = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1, E = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, R = b + 1, C = [], L = 0, D = R; L < D; L++)
        for (var B = L / (D - 1), U = 0; U < S; U++)
          C.push(B);
      return E && C.reverse(), ll(C, 1);
    }
  }
}), Fg = window.THREE ? window.THREE : {
  Euler: Ir,
  Mesh: Tn,
  MeshLambertMaterial: Ea,
  SphereGeometry: Co
}, e7 = Sr({
  props: {
    tilesData: {
      default: []
    },
    tileLat: {
      default: "lat"
    },
    // tile centroid
    tileLng: {
      default: "lng"
    },
    tileAltitude: {
      default: 0.01
    },
    // in units of globe radius
    tileWidth: {
      default: 1
    },
    // in lng degrees
    tileHeight: {
      default: 1
    },
    // in lat degrees
    tileUseGlobeProjection: {
      default: !0
    },
    // whether to size tiles relative to the globe coordinate system, or independently
    tileMaterial: {
      default: function() {
        return new Fg.MeshLambertMaterial({
          color: "#ffbb88",
          opacity: 0.4,
          transparent: !0
        });
      }
    },
    tileCurvatureResolution: {
      default: 5
    },
    // in angular degrees
    tilesTransitionDuration: {
      default: 1e3,
      triggerUpdate: !1
    }
    // ms
  },
  init: function(e, t, n) {
    var r = n.tweenGroup;
    bi(e), t.scene = e, t.tweenGroup = r, t.dataMapper = new co(e, {
      objBindAttr: "__threeObjTile"
    }).onCreateObj(function() {
      var s = new Fg.Mesh();
      return s.__globeObjType = "tile", s;
    });
  },
  update: function(e) {
    var t = je(e.tileLat), n = je(e.tileLng), r = je(e.tileAltitude), s = je(e.tileWidth), o = je(e.tileHeight), a = je(e.tileUseGlobeProjection), l = je(e.tileMaterial), u = je(e.tileCurvatureResolution);
    e.dataMapper.onUpdateObj(function(c, A) {
      c.material = l(A);
      var m = a(A), _ = u(A), y = function(E) {
        var R = c.__currentTargetD = E, C = R.lat, L = R.lng, D = R.alt, B = R.width, U = R.height, N = tf(L), O = tf(-C);
        c.geometry && c.geometry.dispose(), c.geometry = new Fg.SphereGeometry(Ci * (1 + D), Math.ceil(B / (_ || -1)), Math.ceil(U / (_ || -1)), tf(90 - B / 2) + (m ? N : 0), tf(B), tf(90 - U / 2) + (m ? O : 0), tf(U)), m || c.setRotationFromEuler(new Fg.Euler(O, N, 0, "YXZ"));
      }, T = {
        lat: +t(A),
        lng: +n(A),
        alt: +r(A),
        width: +s(A),
        height: +o(A)
      }, b = c.__currentTargetD || Object.assign({}, T, {
        width: 0,
        height: 0
      });
      Object.keys(T).some(function(S) {
        return b[S] !== T[S];
      }) && (!e.tilesTransitionDuration || e.tilesTransitionDuration < 0 ? y(T) : e.tweenGroup.add(new xs(b).to(T, e.tilesTransitionDuration).easing(Ar.Quadratic.InOut).onUpdate(y).start()));
    }).digest(e.tilesData);
  }
}), tf = function(e) {
  return e * Math.PI / 180;
}, op = window.THREE ? window.THREE : {
  BufferGeometry: Yt,
  Color: ct,
  Points: I3,
  PointsMaterial: S0
}, t7 = Sr({
  props: {
    particlesData: {
      default: []
    },
    particlesList: {
      default: function(e) {
        return e;
      }
    },
    // arrays of arrays
    particleLat: {
      default: "lat"
    },
    particleLng: {
      default: "lng"
    },
    particleAltitude: {
      default: 0.01
    },
    // in units of globe radius
    particlesSize: {
      default: 0.5
    },
    particlesSizeAttenuation: {
      default: !0
    },
    particlesColor: {
      default: function() {
        return "white";
      }
    },
    particlesTexture: {}
  },
  init: function(e, t) {
    bi(e), t.scene = e, t.dataMapper = new co(e, {
      objBindAttr: "__threeObjParticles"
    }).onCreateObj(function() {
      var n = new op.Points(new op.BufferGeometry(), new op.PointsMaterial());
      return n.__globeObjType = "particles", n;
    }).onUpdateObj(function(n, r) {
      var s = je(t.particlesList), o = je(t.particleLat), a = je(t.particleLng), l = je(t.particleAltitude);
      n.geometry.setAttribute("position", ll(s(r).map(function(u) {
        return Object.values(Xo(o(u), a(u), l(u)));
      }), 3));
    });
  },
  update: function(e, t) {
    ["particlesData", "particlesList", "particleLat", "particleLng", "particleAltitude"].some(function(a) {
      return t.hasOwnProperty(a);
    }) && e.dataMapper.digest(e.particlesData);
    var n = je(e.particlesColor), r = je(e.particlesSize), s = je(e.particlesSizeAttenuation), o = je(e.particlesTexture);
    e.dataMapper.entries().forEach(function(a) {
      var l = Li(a, 2), u = l[0], c = l[1];
      if (c.material.size = r(u), c.material.sizeAttenuation = s(u), e.particlesTexture)
        c.material.color = new op.Color(16777215), c.material.transparent = !1, c.material.alphaTest = 0.5, c.material.map = o(u);
      else {
        var A = n(u), m = ya(A);
        c.material.color = new op.Color(al(A)), c.material.transparent = m < 1, c.material.opacity = m, c.material.alphaTest = 0;
      }
    });
  }
}), xue = window.THREE ? window.THREE : {
  BufferGeometry: Yt
}, yue = /* @__PURE__ */ (function(i) {
  function e() {
    var t, n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1, r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 32;
    ox(this, e), t = sx(this, e), t.type = "CircleLineGeometry", t.parameters = {
      radius: n,
      segmentCount: r
    };
    for (var s = [], o = 0; o <= r; o++) {
      var a = (o / r - 0.25) * Math.PI * 2;
      s.push({
        x: Math.cos(a) * n,
        y: Math.sin(a) * n,
        z: 0
      });
    }
    return t.setFromPoints(s), t;
  }
  return lx(e, i), ax(e);
})(xue.BufferGeometry), nf = window.THREE ? window.THREE : {
  Color: ct,
  Group: As,
  Line: va,
  LineBasicMaterial: br,
  Vector3: j
}, vue = $f.default || $f, n7 = Sr({
  props: {
    ringsData: {
      default: []
    },
    ringLat: {
      default: "lat"
    },
    ringLng: {
      default: "lng"
    },
    ringAltitude: {
      default: 15e-4
    },
    ringColor: {
      default: function() {
        return "#ffffaa";
      },
      triggerUpdate: !1
    },
    // single color, array of colors or color interpolation fn
    ringResolution: {
      default: 64,
      triggerUpdate: !1
    },
    // how many slice segments in each circle's circumference
    ringMaxRadius: {
      default: 2,
      triggerUpdate: !1
    },
    // degrees
    ringPropagationSpeed: {
      default: 1,
      triggerUpdate: !1
    },
    // degrees/s
    ringRepeatPeriod: {
      default: 700,
      triggerUpdate: !1
    }
    // ms
  },
  methods: {
    pauseAnimation: function(e) {
      var t;
      (t = e.ticker) === null || t === void 0 || t.pause();
    },
    resumeAnimation: function(e) {
      var t;
      (t = e.ticker) === null || t === void 0 || t.resume();
    },
    _destructor: function(e) {
      var t;
      (t = e.ticker) === null || t === void 0 || t.dispose();
    }
  },
  init: function(e, t, n) {
    var r = n.tweenGroup;
    bi(e), t.scene = e, t.tweenGroup = r, t.dataMapper = new co(e, {
      objBindAttr: "__threeObjRing",
      removeDelay: 3e4
      // wait until all rings are gone
    }).onCreateObj(function() {
      var s = new nf.Group();
      return s.__globeObjType = "ring", s;
    }), t.ticker = new vue(), t.ticker.onTick.add(function(s) {
      if (t.ringsData.length) {
        var o = je(t.ringColor), a = je(t.ringAltitude), l = je(t.ringMaxRadius), u = je(t.ringPropagationSpeed), c = je(t.ringRepeatPeriod);
        t.dataMapper.entries().filter(function(A) {
          var m = Li(A, 2), _ = m[1];
          return _;
        }).forEach(function(A) {
          var m = Li(A, 2), _ = m[0], y = m[1];
          if ((y.__nextRingTime || 0) <= s) {
            var T = c(_) / 1e3;
            y.__nextRingTime = s + (T <= 0 ? 1 / 0 : T);
            var b = new nf.Line(new yue(1, t.ringResolution), new nf.LineBasicMaterial()), S = o(_), E = S instanceof Array || S instanceof Function, R;
            E ? S instanceof Array ? (R = $l().domain(S.map(function(G, H) {
              return H / (S.length - 1);
            })).range(S), b.material.transparent = S.some(function(G) {
              return ya(G) < 1;
            })) : (R = S, b.material.transparent = !0) : (b.material.color = new nf.Color(al(S)), tue(b.material, ya(S)));
            var C = Ci * (1 + a(_)), L = l(_), D = L * Math.PI / 180, B = u(_), U = B <= 0, N = function(H) {
              var Y = H.t, K = (U ? 1 - Y : Y) * D;
              if (b.scale.x = b.scale.y = C * Math.sin(K), b.position.z = C * (1 - Math.cos(K)), E) {
                var X = R(Y);
                b.material.color = new nf.Color(al(X)), b.material.transparent && (b.material.opacity = ya(X));
              }
            };
            if (B === 0)
              N({
                t: 0
              }), y.add(b);
            else {
              var O = Math.abs(L / B) * 1e3;
              t.tweenGroup.add(new xs({
                t: 0
              }).to({
                t: 1
              }, O).onUpdate(N).onStart(function() {
                return y.add(b);
              }).onComplete(function() {
                y.remove(b), fw(b);
              }).start());
            }
          }
        });
      }
    });
  },
  update: function(e) {
    var t = je(e.ringLat), n = je(e.ringLng), r = je(e.ringAltitude), s = e.scene.localToWorld(new nf.Vector3(0, 0, 0));
    e.dataMapper.onUpdateObj(function(o, a) {
      var l = t(a), u = n(a), c = r(a);
      Object.assign(o.position, Xo(l, u, c)), o.lookAt(s);
    }).digest(e.ringsData);
  }
}), bue = { 0: { x_min: 73, x_max: 715, ha: 792, o: "m 394 -29 q 153 129 242 -29 q 73 479 73 272 q 152 829 73 687 q 394 989 241 989 q 634 829 545 989 q 715 479 715 684 q 635 129 715 270 q 394 -29 546 -29 m 394 89 q 546 211 489 89 q 598 479 598 322 q 548 748 598 640 q 394 871 491 871 q 241 748 298 871 q 190 479 190 637 q 239 211 190 319 q 394 89 296 89 " }, 1: { x_min: 215.671875, x_max: 574, ha: 792, o: "m 574 0 l 442 0 l 442 697 l 215 697 l 215 796 q 386 833 330 796 q 475 986 447 875 l 574 986 l 574 0 " }, 2: { x_min: 59, x_max: 731, ha: 792, o: "m 731 0 l 59 0 q 197 314 59 188 q 457 487 199 315 q 598 691 598 580 q 543 819 598 772 q 411 867 488 867 q 272 811 328 867 q 209 630 209 747 l 81 630 q 182 901 81 805 q 408 986 271 986 q 629 909 536 986 q 731 694 731 826 q 613 449 731 541 q 378 316 495 383 q 201 122 235 234 l 731 122 l 731 0 " }, 3: { x_min: 54, x_max: 737, ha: 792, o: "m 737 284 q 635 55 737 141 q 399 -25 541 -25 q 156 52 248 -25 q 54 308 54 140 l 185 308 q 245 147 185 202 q 395 96 302 96 q 539 140 484 96 q 602 280 602 190 q 510 429 602 390 q 324 454 451 454 l 324 565 q 487 584 441 565 q 565 719 565 617 q 515 835 565 791 q 395 879 466 879 q 255 824 307 879 q 203 661 203 769 l 78 661 q 166 909 78 822 q 387 992 250 992 q 603 921 513 992 q 701 723 701 844 q 669 607 701 656 q 578 524 637 558 q 696 434 655 499 q 737 284 737 369 " }, 4: { x_min: 48, x_max: 742.453125, ha: 792, o: "m 742 243 l 602 243 l 602 0 l 476 0 l 476 243 l 48 243 l 48 368 l 476 958 l 602 958 l 602 354 l 742 354 l 742 243 m 476 354 l 476 792 l 162 354 l 476 354 " }, 5: { x_min: 54.171875, x_max: 738, ha: 792, o: "m 738 314 q 626 60 738 153 q 382 -23 526 -23 q 155 47 248 -23 q 54 256 54 125 l 183 256 q 259 132 204 174 q 382 91 314 91 q 533 149 471 91 q 602 314 602 213 q 538 469 602 411 q 386 528 475 528 q 284 506 332 528 q 197 439 237 484 l 81 439 l 159 958 l 684 958 l 684 840 l 254 840 l 214 579 q 306 627 258 612 q 407 643 354 643 q 636 552 540 643 q 738 314 738 457 " }, 6: { x_min: 53, x_max: 739, ha: 792, o: "m 739 312 q 633 62 739 162 q 400 -31 534 -31 q 162 78 257 -31 q 53 439 53 206 q 178 859 53 712 q 441 986 284 986 q 643 912 559 986 q 732 713 732 833 l 601 713 q 544 830 594 786 q 426 875 494 875 q 268 793 331 875 q 193 517 193 697 q 301 597 240 570 q 427 624 362 624 q 643 540 552 624 q 739 312 739 451 m 603 298 q 540 461 603 400 q 404 516 484 516 q 268 461 323 516 q 207 300 207 401 q 269 137 207 198 q 405 83 325 83 q 541 137 486 83 q 603 298 603 197 " }, 7: { x_min: 58.71875, x_max: 730.953125, ha: 792, o: "m 730 839 q 469 448 560 641 q 335 0 378 255 l 192 0 q 328 441 235 252 q 593 830 421 630 l 58 830 l 58 958 l 730 958 l 730 839 " }, 8: { x_min: 55, x_max: 736, ha: 792, o: "m 571 527 q 694 424 652 491 q 736 280 736 358 q 648 71 736 158 q 395 -26 551 -26 q 142 69 238 -26 q 55 279 55 157 q 96 425 55 359 q 220 527 138 491 q 120 615 153 562 q 88 726 88 668 q 171 904 88 827 q 395 986 261 986 q 618 905 529 986 q 702 727 702 830 q 670 616 702 667 q 571 527 638 565 m 394 565 q 519 610 475 565 q 563 717 563 655 q 521 823 563 781 q 392 872 474 872 q 265 824 312 872 q 224 720 224 783 q 265 613 224 656 q 394 565 312 565 m 395 91 q 545 150 488 91 q 597 280 597 204 q 546 408 597 355 q 395 465 492 465 q 244 408 299 465 q 194 280 194 356 q 244 150 194 203 q 395 91 299 91 " }, 9: { x_min: 53, x_max: 739, ha: 792, o: "m 739 524 q 619 94 739 241 q 362 -32 516 -32 q 150 47 242 -32 q 59 244 59 126 l 191 244 q 246 129 191 176 q 373 82 301 82 q 526 161 466 82 q 597 440 597 255 q 363 334 501 334 q 130 432 216 334 q 53 650 53 521 q 134 880 53 786 q 383 986 226 986 q 659 841 566 986 q 739 524 739 719 m 388 449 q 535 514 480 449 q 585 658 585 573 q 535 805 585 744 q 388 873 480 873 q 242 809 294 873 q 191 658 191 745 q 239 514 191 572 q 388 449 292 449 " }, : { x_min: 0, x_max: 712, ha: 815, o: "m 356 -25 q 96 88 192 -25 q 0 368 0 201 q 92 642 0 533 q 356 761 192 761 q 617 644 517 761 q 712 368 712 533 q 619 91 712 201 q 356 -25 520 -25 m 356 85 q 527 175 465 85 q 583 369 583 255 q 528 562 583 484 q 356 651 466 651 q 189 560 250 651 q 135 369 135 481 q 187 177 135 257 q 356 85 250 85 " }, S: { x_min: 0, x_max: 788, ha: 890, o: "m 788 291 q 662 54 788 144 q 397 -26 550 -26 q 116 68 226 -26 q 0 337 0 168 l 131 337 q 200 152 131 220 q 384 85 269 85 q 557 129 479 85 q 650 270 650 183 q 490 429 650 379 q 194 513 341 470 q 33 739 33 584 q 142 964 33 881 q 388 1041 242 1041 q 644 957 543 1041 q 756 716 756 867 l 625 716 q 561 874 625 816 q 395 933 497 933 q 243 891 309 933 q 164 759 164 841 q 325 609 164 656 q 625 526 475 568 q 788 291 788 454 " }, "": { x_min: 343, x_max: 449, ha: 792, o: "m 449 462 l 343 462 l 343 986 l 449 986 l 449 462 m 449 -242 l 343 -242 l 343 280 l 449 280 l 449 -242 " }, "/": { x_min: 183.25, x_max: 608.328125, ha: 792, o: "m 608 1041 l 266 -129 l 183 -129 l 520 1041 l 608 1041 " }, : { x_min: -0.4375, x_max: 777.453125, ha: 839, o: "m 777 893 l 458 893 l 458 0 l 319 0 l 319 892 l 0 892 l 0 1013 l 777 1013 l 777 893 " }, y: { x_min: 0, x_max: 684.78125, ha: 771, o: "m 684 738 l 388 -83 q 311 -216 356 -167 q 173 -279 252 -279 q 97 -266 133 -279 l 97 -149 q 132 -155 109 -151 q 168 -160 155 -160 q 240 -114 213 -160 q 274 -26 248 -98 l 0 738 l 137 737 l 341 139 l 548 737 l 684 738 " }, : { x_min: 0, x_max: 803, ha: 917, o: "m 803 0 l 667 0 l 667 886 l 140 886 l 140 0 l 0 0 l 0 1012 l 803 1012 l 803 0 " }, : { x_min: -111, x_max: 339, ha: 361, o: "m 339 800 l 229 800 l 229 925 l 339 925 l 339 800 m -1 800 l -111 800 l -111 925 l -1 925 l -1 800 m 284 3 q 233 -10 258 -5 q 182 -15 207 -15 q 85 26 119 -15 q 42 200 42 79 l 42 737 l 167 737 l 168 215 q 172 141 168 157 q 226 101 183 101 q 248 103 239 101 q 284 112 257 104 l 284 3 m 302 1040 l 113 819 l 30 819 l 165 1040 l 302 1040 " }, g: { x_min: 0, x_max: 686, ha: 838, o: "m 686 34 q 586 -213 686 -121 q 331 -306 487 -306 q 131 -252 216 -306 q 31 -84 31 -190 l 155 -84 q 228 -174 166 -138 q 345 -207 284 -207 q 514 -109 454 -207 q 564 89 564 -27 q 461 6 521 36 q 335 -23 401 -23 q 88 100 184 -23 q 0 370 0 215 q 87 634 0 522 q 330 758 183 758 q 457 728 398 758 q 564 644 515 699 l 564 737 l 686 737 l 686 34 m 582 367 q 529 560 582 481 q 358 652 468 652 q 189 561 250 652 q 135 369 135 482 q 189 176 135 255 q 361 85 251 85 q 529 176 468 85 q 582 367 582 255 " }, "": { x_min: 0, x_max: 442, ha: 539, o: "m 442 383 l 0 383 q 91 566 0 492 q 260 668 176 617 q 354 798 354 727 q 315 875 354 845 q 227 905 277 905 q 136 869 173 905 q 99 761 99 833 l 14 761 q 82 922 14 864 q 232 974 141 974 q 379 926 316 974 q 442 797 442 878 q 351 635 442 704 q 183 539 321 611 q 92 455 92 491 l 442 455 l 442 383 " }, "": { x_min: 0, x_max: 705.5625, ha: 803, o: "m 705 334 l 0 334 l 0 410 l 705 410 l 705 334 " }, : { x_min: 0, x_max: 819.5625, ha: 893, o: "m 819 0 l 650 0 l 294 509 l 139 356 l 139 0 l 0 0 l 0 1013 l 139 1013 l 139 526 l 626 1013 l 809 1013 l 395 600 l 819 0 " }, : { x_min: -46.265625, x_max: 392, ha: 513, o: "m 392 651 l 259 651 l 79 -279 l -46 -278 l 134 651 l 14 651 l 14 751 l 135 751 q 151 948 135 900 q 304 1041 185 1041 q 334 1040 319 1041 q 392 1034 348 1039 l 392 922 q 337 931 360 931 q 271 883 287 931 q 260 793 260 853 l 260 751 l 392 751 l 392 651 " }, e: { x_min: 0, x_max: 714, ha: 813, o: "m 714 326 l 140 326 q 200 157 140 227 q 359 87 260 87 q 488 130 431 87 q 561 245 545 174 l 697 245 q 577 48 670 123 q 358 -26 484 -26 q 97 85 195 -26 q 0 363 0 197 q 94 642 0 529 q 358 765 195 765 q 626 627 529 765 q 714 326 714 503 m 576 429 q 507 583 564 522 q 355 650 445 650 q 206 583 266 650 q 140 429 152 522 l 576 429 " }, : { x_min: 0, x_max: 712, ha: 815, o: "m 356 -25 q 94 91 194 -25 q 0 368 0 202 q 92 642 0 533 q 356 761 192 761 q 617 644 517 761 q 712 368 712 533 q 619 91 712 201 q 356 -25 520 -25 m 356 85 q 527 175 465 85 q 583 369 583 255 q 528 562 583 484 q 356 651 466 651 q 189 560 250 651 q 135 369 135 481 q 187 177 135 257 q 356 85 250 85 m 576 1040 l 387 819 l 303 819 l 438 1040 l 576 1040 " }, J: { x_min: 0, x_max: 588, ha: 699, o: "m 588 279 q 287 -26 588 -26 q 58 73 126 -26 q 0 327 0 158 l 133 327 q 160 172 133 227 q 288 96 198 96 q 426 171 391 96 q 449 336 449 219 l 449 1013 l 588 1013 l 588 279 " }, "": { x_min: -1, x_max: 503, ha: 601, o: "m 503 302 l 280 136 l 281 256 l 429 373 l 281 486 l 280 608 l 503 440 l 503 302 m 221 302 l 0 136 l 0 255 l 145 372 l 0 486 l -1 608 l 221 440 l 221 302 " }, "": { x_min: -3, x_max: 1008, ha: 1106, o: "m 502 -7 q 123 151 263 -7 q -3 501 -3 294 q 123 851 -3 706 q 502 1011 263 1011 q 881 851 739 1011 q 1008 501 1008 708 q 883 151 1008 292 q 502 -7 744 -7 m 502 60 q 830 197 709 60 q 940 501 940 322 q 831 805 940 681 q 502 944 709 944 q 174 805 296 944 q 65 501 65 680 q 173 197 65 320 q 502 60 294 60 m 741 394 q 661 246 731 302 q 496 190 591 190 q 294 285 369 190 q 228 497 228 370 q 295 714 228 625 q 499 813 370 813 q 656 762 588 813 q 733 625 724 711 l 634 625 q 589 704 629 673 q 498 735 550 735 q 377 666 421 735 q 334 504 334 597 q 374 340 334 408 q 490 272 415 272 q 589 304 549 272 q 638 394 628 337 l 741 394 " }, : { x_min: 0, x_max: 922, ha: 1030, o: "m 687 1040 l 498 819 l 415 819 l 549 1040 l 687 1040 m 922 339 q 856 97 922 203 q 650 -26 780 -26 q 538 9 587 -26 q 461 103 489 44 q 387 12 436 46 q 277 -22 339 -22 q 69 97 147 -22 q 0 338 0 202 q 45 551 0 444 q 161 737 84 643 l 302 737 q 175 552 219 647 q 124 336 124 446 q 155 179 124 248 q 275 88 197 88 q 375 163 341 88 q 400 294 400 219 l 400 572 l 524 572 l 524 294 q 561 135 524 192 q 643 88 591 88 q 762 182 719 88 q 797 341 797 257 q 745 555 797 450 q 619 737 705 637 l 760 737 q 874 551 835 640 q 922 339 922 444 " }, "^": { x_min: 193.0625, x_max: 598.609375, ha: 792, o: "m 598 772 l 515 772 l 395 931 l 277 772 l 193 772 l 326 1013 l 462 1013 l 598 772 " }, "": { x_min: 0, x_max: 507.203125, ha: 604, o: "m 506 136 l 284 302 l 284 440 l 506 608 l 507 485 l 360 371 l 506 255 l 506 136 m 222 136 l 0 302 l 0 440 l 222 608 l 221 486 l 73 373 l 222 256 l 222 136 " }, D: { x_min: 0, x_max: 828, ha: 935, o: "m 389 1013 q 714 867 593 1013 q 828 521 828 729 q 712 161 828 309 q 382 0 587 0 l 0 0 l 0 1013 l 389 1013 m 376 124 q 607 247 523 124 q 681 510 681 355 q 607 771 681 662 q 376 896 522 896 l 139 896 l 139 124 l 376 124 " }, "": { x_min: 0, x_max: 142, ha: 239, o: "m 142 585 l 0 585 l 0 738 l 142 738 l 142 585 " }, : { x_min: 0, x_max: 47, ha: 125, o: "m 47 3 q 37 -7 47 -7 q 28 0 30 -7 q 39 -4 32 -4 q 45 3 45 -1 l 37 0 q 28 9 28 0 q 39 19 28 19 l 47 16 l 47 19 l 47 3 m 37 1 q 44 8 44 1 q 37 16 44 16 q 30 8 30 16 q 37 1 30 1 m 26 1 l 23 22 l 14 0 l 3 22 l 3 3 l 0 25 l 13 1 l 22 25 l 26 1 " }, w: { x_min: 0, x_max: 1009.71875, ha: 1100, o: "m 1009 738 l 783 0 l 658 0 l 501 567 l 345 0 l 222 0 l 0 738 l 130 738 l 284 174 l 432 737 l 576 738 l 721 173 l 881 737 l 1009 738 " }, $: { x_min: 0, x_max: 700, ha: 793, o: "m 664 717 l 542 717 q 490 825 531 785 q 381 872 450 865 l 381 551 q 620 446 540 522 q 700 241 700 370 q 618 45 700 116 q 381 -25 536 -25 l 381 -152 l 307 -152 l 307 -25 q 81 62 162 -25 q 0 297 0 149 l 124 297 q 169 146 124 204 q 307 81 215 89 l 307 441 q 80 536 148 469 q 13 725 13 603 q 96 910 13 839 q 307 982 180 982 l 307 1077 l 381 1077 l 381 982 q 574 917 494 982 q 664 717 664 845 m 307 565 l 307 872 q 187 831 233 872 q 142 724 142 791 q 180 618 142 656 q 307 565 218 580 m 381 76 q 562 237 562 96 q 517 361 562 313 q 381 423 472 409 l 381 76 " }, "\\": { x_min: -0.015625, x_max: 425.0625, ha: 522, o: "m 425 -129 l 337 -129 l 0 1041 l 83 1041 l 425 -129 " }, : { x_min: 0, x_max: 697.21875, ha: 747, o: "m 697 -4 q 629 -14 658 -14 q 498 97 513 -14 q 422 9 470 41 q 313 -23 374 -23 q 207 4 258 -23 q 119 81 156 32 l 119 -278 l 0 -278 l 0 738 l 124 738 l 124 343 q 165 173 124 246 q 308 83 216 83 q 452 178 402 83 q 493 359 493 255 l 493 738 l 617 738 l 617 214 q 623 136 617 160 q 673 92 637 92 q 697 96 684 92 l 697 -4 " }, : { x_min: 42, x_max: 181, ha: 297, o: "m 181 0 l 42 0 l 42 1013 l 181 1013 l 181 0 " }, : { x_min: 0, x_max: 1144.5, ha: 1214, o: "m 1144 1012 l 807 416 l 807 0 l 667 0 l 667 416 l 325 1012 l 465 1012 l 736 533 l 1004 1012 l 1144 1012 m 277 1040 l 83 799 l 0 799 l 140 1040 l 277 1040 " }, "": { x_min: 0, x_max: 139, ha: 236, o: "m 139 851 q 102 737 139 784 q 0 669 65 690 l 0 734 q 59 787 42 741 q 72 873 72 821 l 0 873 l 0 1013 l 139 1013 l 139 851 " }, : { x_min: 0, x_max: 801, ha: 915, o: "m 801 0 l 651 0 l 131 822 l 131 0 l 0 0 l 0 1013 l 151 1013 l 670 191 l 670 1013 l 801 1013 l 801 0 " }, "-": { x_min: 8.71875, x_max: 350.390625, ha: 478, o: "m 350 317 l 8 317 l 8 428 l 350 428 l 350 317 " }, Q: { x_min: 0, x_max: 968, ha: 1072, o: "m 954 5 l 887 -79 l 744 35 q 622 -11 687 2 q 483 -26 556 -26 q 127 130 262 -26 q 0 504 0 279 q 127 880 0 728 q 484 1041 262 1041 q 841 884 708 1041 q 968 507 968 735 q 933 293 968 398 q 832 104 899 188 l 954 5 m 723 191 q 802 330 777 248 q 828 499 828 412 q 744 790 828 673 q 483 922 650 922 q 228 791 322 922 q 142 505 142 673 q 227 221 142 337 q 487 91 323 91 q 632 123 566 91 l 520 215 l 587 301 l 723 191 " }, : { x_min: 1, x_max: 676.28125, ha: 740, o: "m 676 460 l 551 460 q 498 595 542 546 q 365 651 448 651 q 199 578 263 651 q 136 401 136 505 q 266 178 136 241 q 508 106 387 142 q 640 -50 640 62 q 625 -158 640 -105 q 583 -278 611 -211 l 465 -278 q 498 -182 490 -211 q 515 -80 515 -126 q 381 12 515 -15 q 134 91 197 51 q 1 388 1 179 q 100 651 1 542 q 354 761 199 761 q 587 680 498 761 q 676 460 676 599 " }, M: { x_min: 0, x_max: 954, ha: 1067, o: "m 954 0 l 819 0 l 819 869 l 537 0 l 405 0 l 128 866 l 128 0 l 0 0 l 0 1013 l 200 1013 l 472 160 l 757 1013 l 954 1013 l 954 0 " }, : { x_min: 0, x_max: 1006, ha: 1094, o: "m 1006 678 q 914 319 1006 429 q 571 200 814 200 l 571 0 l 433 0 l 433 200 q 92 319 194 200 q 0 678 0 429 l 0 1013 l 139 1013 l 139 679 q 191 417 139 492 q 433 326 255 326 l 433 1013 l 571 1013 l 571 326 l 580 326 q 813 423 747 326 q 868 679 868 502 l 868 1013 l 1006 1013 l 1006 678 " }, C: { x_min: 0, x_max: 886, ha: 944, o: "m 886 379 q 760 87 886 201 q 455 -26 634 -26 q 112 136 236 -26 q 0 509 0 283 q 118 882 0 737 q 469 1041 245 1041 q 748 955 630 1041 q 879 708 879 859 l 745 708 q 649 862 724 805 q 473 920 573 920 q 219 791 312 920 q 136 509 136 675 q 217 229 136 344 q 470 99 311 99 q 672 179 591 99 q 753 379 753 259 l 886 379 " }, "!": { x_min: 0, x_max: 138, ha: 236, o: "m 138 684 q 116 409 138 629 q 105 244 105 299 l 33 244 q 16 465 33 313 q 0 684 0 616 l 0 1013 l 138 1013 l 138 684 m 138 0 l 0 0 l 0 151 l 138 151 l 138 0 " }, "{": { x_min: 0, x_max: 480.5625, ha: 578, o: "m 480 -286 q 237 -213 303 -286 q 187 -45 187 -159 q 194 48 187 -15 q 201 141 201 112 q 164 264 201 225 q 0 314 118 314 l 0 417 q 164 471 119 417 q 201 605 201 514 q 199 665 201 644 q 193 772 193 769 q 241 941 193 887 q 480 1015 308 1015 l 480 915 q 336 866 375 915 q 306 742 306 828 q 310 662 306 717 q 314 577 314 606 q 288 452 314 500 q 176 365 256 391 q 289 275 257 337 q 314 143 314 226 q 313 84 314 107 q 310 -11 310 -5 q 339 -131 310 -94 q 480 -182 377 -182 l 480 -286 " }, X: { x_min: -0.015625, x_max: 854.15625, ha: 940, o: "m 854 0 l 683 0 l 423 409 l 166 0 l 0 0 l 347 519 l 18 1013 l 186 1013 l 428 637 l 675 1013 l 836 1013 l 504 520 l 854 0 " }, "#": { x_min: 0, x_max: 963.890625, ha: 1061, o: "m 963 690 l 927 590 l 719 590 l 655 410 l 876 410 l 840 310 l 618 310 l 508 -3 l 393 -2 l 506 309 l 329 310 l 215 -2 l 102 -3 l 212 310 l 0 310 l 36 410 l 248 409 l 312 590 l 86 590 l 120 690 l 347 690 l 459 1006 l 573 1006 l 462 690 l 640 690 l 751 1006 l 865 1006 l 754 690 l 963 690 m 606 590 l 425 590 l 362 410 l 543 410 l 606 590 " }, : { x_min: 42, x_max: 284, ha: 361, o: "m 284 3 q 233 -10 258 -5 q 182 -15 207 -15 q 85 26 119 -15 q 42 200 42 79 l 42 738 l 167 738 l 168 215 q 172 141 168 157 q 226 101 183 101 q 248 103 239 101 q 284 112 257 104 l 284 3 " }, : { x_min: 0, x_max: 906.953125, ha: 982, o: "m 283 1040 l 88 799 l 5 799 l 145 1040 l 283 1040 m 906 0 l 756 0 l 650 303 l 251 303 l 143 0 l 0 0 l 376 1012 l 529 1012 l 906 0 m 609 421 l 452 866 l 293 421 l 609 421 " }, ")": { x_min: 0, x_max: 318, ha: 415, o: "m 318 365 q 257 25 318 191 q 87 -290 197 -141 l 0 -290 q 140 21 93 -128 q 193 360 193 189 q 141 704 193 537 q 0 1024 97 850 l 87 1024 q 257 706 197 871 q 318 365 318 542 " }, : { x_min: 0, x_max: 634.71875, ha: 714, o: "m 634 234 q 527 38 634 110 q 300 -25 433 -25 q 98 29 183 -25 q 0 204 0 93 q 37 314 0 265 q 128 390 67 353 q 56 460 82 419 q 26 555 26 505 q 114 712 26 654 q 295 763 191 763 q 499 700 416 763 q 589 515 589 631 l 478 515 q 419 618 464 580 q 307 657 374 657 q 207 630 253 657 q 151 547 151 598 q 238 445 151 469 q 389 434 280 434 l 389 331 l 349 331 q 206 315 255 331 q 125 210 125 287 q 183 107 125 145 q 302 76 233 76 q 436 117 379 76 q 509 234 493 159 l 634 234 " }, : { x_min: 0, x_max: 952.78125, ha: 1028, o: "m 952 0 l 0 0 l 400 1013 l 551 1013 l 952 0 m 762 124 l 476 867 l 187 124 l 762 124 " }, "}": { x_min: 0, x_max: 481, ha: 578, o: "m 481 314 q 318 262 364 314 q 282 136 282 222 q 284 65 282 97 q 293 -58 293 -48 q 241 -217 293 -166 q 0 -286 174 -286 l 0 -182 q 143 -130 105 -182 q 171 -2 171 -93 q 168 81 171 22 q 165 144 165 140 q 188 275 165 229 q 306 365 220 339 q 191 455 224 391 q 165 588 165 505 q 168 681 165 624 q 171 742 171 737 q 141 865 171 827 q 0 915 102 915 l 0 1015 q 243 942 176 1015 q 293 773 293 888 q 287 675 293 741 q 282 590 282 608 q 318 466 282 505 q 481 417 364 417 l 481 314 " }, "": { x_min: -3, x_max: 1672, ha: 1821, o: "m 846 0 q 664 76 732 0 q 603 244 603 145 q 662 412 603 344 q 846 489 729 489 q 1027 412 959 489 q 1089 244 1089 343 q 1029 76 1089 144 q 846 0 962 0 m 845 103 q 945 143 910 103 q 981 243 981 184 q 947 340 981 301 q 845 385 910 385 q 745 342 782 385 q 709 243 709 300 q 742 147 709 186 q 845 103 781 103 m 888 986 l 284 -25 l 199 -25 l 803 986 l 888 986 m 241 468 q 58 545 126 468 q -3 715 -3 615 q 56 881 -3 813 q 238 958 124 958 q 421 881 353 958 q 483 712 483 813 q 423 544 483 612 q 241 468 356 468 m 241 855 q 137 811 175 855 q 100 710 100 768 q 136 612 100 653 q 240 572 172 572 q 344 614 306 572 q 382 713 382 656 q 347 810 382 771 q 241 855 308 855 m 1428 0 q 1246 76 1314 0 q 1185 244 1185 145 q 1244 412 1185 344 q 1428 489 1311 489 q 1610 412 1542 489 q 1672 244 1672 343 q 1612 76 1672 144 q 1428 0 1545 0 m 1427 103 q 1528 143 1492 103 q 1564 243 1564 184 q 1530 340 1564 301 q 1427 385 1492 385 q 1327 342 1364 385 q 1291 243 1291 300 q 1324 147 1291 186 q 1427 103 1363 103 " }, a: { x_min: 0, x_max: 698.609375, ha: 794, o: "m 698 0 q 661 -12 679 -7 q 615 -17 643 -17 q 536 12 564 -17 q 500 96 508 41 q 384 6 456 37 q 236 -25 312 -25 q 65 31 130 -25 q 0 194 0 88 q 118 390 0 334 q 328 435 180 420 q 488 483 476 451 q 495 523 495 504 q 442 619 495 584 q 325 654 389 654 q 209 617 257 654 q 152 513 161 580 l 33 513 q 123 705 33 633 q 332 772 207 772 q 528 712 448 772 q 617 531 617 645 l 617 163 q 624 108 617 126 q 664 90 632 90 l 698 94 l 698 0 m 491 262 l 491 372 q 272 329 350 347 q 128 201 128 294 q 166 113 128 144 q 264 83 205 83 q 414 130 346 83 q 491 262 491 183 " }, "": { x_min: 0, x_max: 941.671875, ha: 1039, o: "m 941 334 l 0 334 l 0 410 l 941 410 l 941 334 " }, "=": { x_min: 8.71875, x_max: 780.953125, ha: 792, o: "m 780 510 l 8 510 l 8 606 l 780 606 l 780 510 m 780 235 l 8 235 l 8 332 l 780 332 l 780 235 " }, N: { x_min: 0, x_max: 801, ha: 914, o: "m 801 0 l 651 0 l 131 823 l 131 0 l 0 0 l 0 1013 l 151 1013 l 670 193 l 670 1013 l 801 1013 l 801 0 " }, : { x_min: 0, x_max: 712, ha: 797, o: "m 712 369 q 620 94 712 207 q 362 -26 521 -26 q 230 2 292 -26 q 119 83 167 30 l 119 -278 l 0 -278 l 0 362 q 91 643 0 531 q 355 764 190 764 q 617 647 517 764 q 712 369 712 536 m 583 366 q 530 559 583 480 q 359 651 469 651 q 190 562 252 651 q 135 370 135 483 q 189 176 135 257 q 359 85 250 85 q 528 175 466 85 q 583 366 583 254 " }, "": { x_min: 0, x_max: 941.671875, ha: 938, o: "m 941 1033 l 0 1033 l 0 1109 l 941 1109 l 941 1033 " }, Z: { x_min: 0, x_max: 779, ha: 849, o: "m 779 0 l 0 0 l 0 113 l 621 896 l 40 896 l 40 1013 l 779 1013 l 778 887 l 171 124 l 779 124 l 779 0 " }, u: { x_min: 0, x_max: 617, ha: 729, o: "m 617 0 l 499 0 l 499 110 q 391 10 460 45 q 246 -25 322 -25 q 61 58 127 -25 q 0 258 0 136 l 0 738 l 125 738 l 125 284 q 156 148 125 202 q 273 82 197 82 q 433 165 369 82 q 493 340 493 243 l 493 738 l 617 738 l 617 0 " }, k: { x_min: 0, x_max: 612.484375, ha: 697, o: "m 612 738 l 338 465 l 608 0 l 469 0 l 251 382 l 121 251 l 121 0 l 0 0 l 0 1013 l 121 1013 l 121 402 l 456 738 l 612 738 " }, : { x_min: 0, x_max: 803, ha: 917, o: "m 803 0 l 667 0 l 667 475 l 140 475 l 140 0 l 0 0 l 0 1013 l 140 1013 l 140 599 l 667 599 l 667 1013 l 803 1013 l 803 0 " }, : { x_min: 0, x_max: 906.953125, ha: 985, o: "m 906 0 l 756 0 l 650 303 l 251 303 l 143 0 l 0 0 l 376 1013 l 529 1013 l 906 0 m 609 421 l 452 866 l 293 421 l 609 421 " }, s: { x_min: 0, x_max: 604, ha: 697, o: "m 604 217 q 501 36 604 104 q 292 -23 411 -23 q 86 43 166 -23 q 0 238 0 114 l 121 237 q 175 122 121 164 q 300 85 223 85 q 415 112 363 85 q 479 207 479 147 q 361 309 479 276 q 140 372 141 370 q 21 544 21 426 q 111 708 21 647 q 298 761 190 761 q 492 705 413 761 q 583 531 583 643 l 462 531 q 412 625 462 594 q 298 657 363 657 q 199 636 242 657 q 143 558 143 608 q 262 454 143 486 q 484 394 479 397 q 604 217 604 341 " }, B: { x_min: 0, x_max: 778, ha: 876, o: "m 580 546 q 724 469 670 535 q 778 311 778 403 q 673 83 778 171 q 432 0 575 0 l 0 0 l 0 1013 l 411 1013 q 629 957 541 1013 q 732 768 732 892 q 691 633 732 693 q 580 546 650 572 m 393 899 l 139 899 l 139 588 l 379 588 q 521 624 462 588 q 592 744 592 667 q 531 859 592 819 q 393 899 471 899 m 419 124 q 566 169 504 124 q 635 303 635 219 q 559 436 635 389 q 402 477 494 477 l 139 477 l 139 124 l 419 124 " }, "": { x_min: 0, x_max: 614, ha: 708, o: "m 142 0 l 0 0 l 0 151 l 142 151 l 142 0 m 378 0 l 236 0 l 236 151 l 378 151 l 378 0 m 614 0 l 472 0 l 472 151 l 614 151 l 614 0 " }, "?": { x_min: 0, x_max: 607, ha: 704, o: "m 607 777 q 543 599 607 674 q 422 474 482 537 q 357 272 357 391 l 236 272 q 297 487 236 395 q 411 619 298 490 q 474 762 474 691 q 422 885 474 838 q 301 933 371 933 q 179 880 228 933 q 124 706 124 819 l 0 706 q 94 963 0 872 q 302 1044 177 1044 q 511 973 423 1044 q 607 777 607 895 m 370 0 l 230 0 l 230 151 l 370 151 l 370 0 " }, H: { x_min: 0, x_max: 803, ha: 915, o: "m 803 0 l 667 0 l 667 475 l 140 475 l 140 0 l 0 0 l 0 1013 l 140 1013 l 140 599 l 667 599 l 667 1013 l 803 1013 l 803 0 " }, : { x_min: 0, x_max: 675, ha: 761, o: "m 675 738 l 404 0 l 272 0 l 0 738 l 133 738 l 340 147 l 541 738 l 675 738 " }, c: { x_min: 1, x_max: 701.390625, ha: 775, o: "m 701 264 q 584 53 681 133 q 353 -26 487 -26 q 91 91 188 -26 q 1 370 1 201 q 92 645 1 537 q 353 761 190 761 q 572 688 479 761 q 690 493 666 615 l 556 493 q 487 606 545 562 q 356 650 428 650 q 186 563 246 650 q 134 372 134 487 q 188 179 134 258 q 359 88 250 88 q 492 136 437 88 q 566 264 548 185 l 701 264 " }, "": { x_min: 0, x_max: 566.671875, ha: 678, o: "m 21 892 l 52 892 l 98 761 l 145 892 l 176 892 l 178 741 l 157 741 l 157 867 l 108 741 l 88 741 l 40 871 l 40 741 l 21 741 l 21 892 m 308 854 l 308 731 q 252 691 308 691 q 227 691 240 691 q 207 696 213 695 l 207 712 l 253 706 q 288 733 288 706 l 288 763 q 244 741 279 741 q 193 797 193 741 q 261 860 193 860 q 287 860 273 860 q 308 854 302 855 m 288 842 l 263 843 q 213 796 213 843 q 248 756 213 756 q 288 796 288 756 l 288 842 m 566 988 l 502 988 l 502 -1 l 439 -1 l 439 988 l 317 988 l 317 -1 l 252 -1 l 252 602 q 81 653 155 602 q 0 805 0 711 q 101 989 0 918 q 309 1053 194 1053 l 566 1053 l 566 988 " }, : { x_min: 0, x_max: 660, ha: 745, o: "m 471 550 q 610 450 561 522 q 660 280 660 378 q 578 64 660 151 q 367 -22 497 -22 q 239 5 299 -22 q 126 82 178 32 l 126 -278 l 0 -278 l 0 593 q 54 903 0 801 q 318 1042 127 1042 q 519 964 436 1042 q 603 771 603 887 q 567 644 603 701 q 471 550 532 586 m 337 79 q 476 138 418 79 q 535 279 535 198 q 427 437 535 386 q 226 477 344 477 l 226 583 q 398 620 329 583 q 486 762 486 668 q 435 884 486 833 q 312 935 384 935 q 169 861 219 935 q 126 698 126 797 l 126 362 q 170 169 126 242 q 337 79 224 79 " }, : { x_min: 0, x_max: 954, ha: 1068, o: "m 954 0 l 819 0 l 819 868 l 537 0 l 405 0 l 128 865 l 128 0 l 0 0 l 0 1013 l 199 1013 l 472 158 l 758 1013 l 954 1013 l 954 0 " }, : { x_min: 0.109375, x_max: 1120, ha: 1217, o: "m 1120 505 q 994 132 1120 282 q 642 -29 861 -29 q 290 130 422 -29 q 167 505 167 280 q 294 883 167 730 q 650 1046 430 1046 q 999 882 868 1046 q 1120 505 1120 730 m 977 504 q 896 784 977 669 q 644 915 804 915 q 391 785 484 915 q 307 504 307 669 q 391 224 307 339 q 644 95 486 95 q 894 224 803 95 q 977 504 977 339 m 277 1040 l 83 799 l 0 799 l 140 1040 l 277 1040 " }, : { x_min: 0, x_max: 1158, ha: 1275, o: "m 1158 0 l 1022 0 l 1022 475 l 496 475 l 496 0 l 356 0 l 356 1012 l 496 1012 l 496 599 l 1022 599 l 1022 1012 l 1158 1012 l 1158 0 m 277 1040 l 83 799 l 0 799 l 140 1040 l 277 1040 " }, "": { x_min: 0, x_max: 663.890625, ha: 775, o: "m 663 529 q 566 293 663 391 q 331 196 469 196 q 97 294 194 196 q 0 529 0 393 q 96 763 0 665 q 331 861 193 861 q 566 763 469 861 q 663 529 663 665 " }, "": { x_min: 0.1875, x_max: 819.546875, ha: 886, o: "m 563 561 l 697 561 l 696 487 l 520 487 l 482 416 l 482 380 l 697 380 l 695 308 l 482 308 l 482 0 l 342 0 l 342 308 l 125 308 l 125 380 l 342 380 l 342 417 l 303 487 l 125 487 l 125 561 l 258 561 l 0 1013 l 140 1013 l 411 533 l 679 1013 l 819 1013 l 563 561 " }, "(": { x_min: 0, x_max: 318.0625, ha: 415, o: "m 318 -290 l 230 -290 q 61 23 122 -142 q 0 365 0 190 q 62 712 0 540 q 230 1024 119 869 l 318 1024 q 175 705 219 853 q 125 360 125 542 q 176 22 125 187 q 318 -290 223 -127 " }, U: { x_min: 0, x_max: 796, ha: 904, o: "m 796 393 q 681 93 796 212 q 386 -25 566 -25 q 101 95 208 -25 q 0 393 0 211 l 0 1013 l 138 1013 l 138 391 q 204 191 138 270 q 394 107 276 107 q 586 191 512 107 q 656 391 656 270 l 656 1013 l 796 1013 l 796 393 " }, : { x_min: 0.5, x_max: 744.953125, ha: 822, o: "m 744 737 l 463 54 l 463 -278 l 338 -278 l 338 54 l 154 495 q 104 597 124 569 q 13 651 67 651 l 0 651 l 0 751 l 39 753 q 168 711 121 753 q 242 594 207 676 l 403 208 l 617 737 l 744 737 " }, : { x_min: 0, x_max: 765.5625, ha: 809, o: "m 765 -4 q 698 -14 726 -14 q 564 97 586 -14 q 466 7 525 40 q 337 -26 407 -26 q 88 98 186 -26 q 0 369 0 212 q 88 637 0 525 q 337 760 184 760 q 465 728 407 760 q 563 637 524 696 l 563 739 l 685 739 l 685 222 q 693 141 685 168 q 748 94 708 94 q 765 96 760 94 l 765 -4 m 584 371 q 531 562 584 485 q 360 653 470 653 q 192 566 254 653 q 135 379 135 489 q 186 181 135 261 q 358 84 247 84 q 528 176 465 84 q 584 371 584 260 " }, F: { x_min: 0, x_max: 683.328125, ha: 717, o: "m 683 888 l 140 888 l 140 583 l 613 583 l 613 458 l 140 458 l 140 0 l 0 0 l 0 1013 l 683 1013 l 683 888 " }, "": { x_min: 0, x_max: 705.5625, ha: 803, o: "m 705 334 l 0 334 l 0 410 l 705 410 l 705 334 " }, ":": { x_min: 0, x_max: 142, ha: 239, o: "m 142 585 l 0 585 l 0 738 l 142 738 l 142 585 m 142 0 l 0 0 l 0 151 l 142 151 l 142 0 " }, : { x_min: 0, x_max: 854.171875, ha: 935, o: "m 854 0 l 683 0 l 423 409 l 166 0 l 0 0 l 347 519 l 18 1013 l 186 1013 l 427 637 l 675 1013 l 836 1013 l 504 521 l 854 0 " }, "*": { x_min: 116, x_max: 674, ha: 792, o: "m 674 768 l 475 713 l 610 544 l 517 477 l 394 652 l 272 478 l 178 544 l 314 713 l 116 766 l 153 876 l 341 812 l 342 1013 l 446 1013 l 446 811 l 635 874 l 674 768 " }, "": { x_min: 0, x_max: 777, ha: 835, o: "m 458 804 l 777 804 l 777 683 l 458 683 l 458 0 l 319 0 l 319 681 l 0 683 l 0 804 l 319 804 l 319 1015 l 458 1013 l 458 804 " }, "": { x_min: 0, x_max: 347, ha: 444, o: "m 173 802 q 43 856 91 802 q 0 977 0 905 q 45 1101 0 1049 q 173 1153 90 1153 q 303 1098 255 1153 q 347 977 347 1049 q 303 856 347 905 q 173 802 256 802 m 173 884 q 238 910 214 884 q 262 973 262 937 q 239 1038 262 1012 q 173 1064 217 1064 q 108 1037 132 1064 q 85 973 85 1010 q 108 910 85 937 q 173 884 132 884 " }, V: { x_min: 0, x_max: 862.71875, ha: 940, o: "m 862 1013 l 505 0 l 361 0 l 0 1013 l 143 1013 l 434 165 l 718 1012 l 862 1013 " }, : { x_min: 0, x_max: 734.71875, ha: 763, o: "m 723 889 l 9 889 l 9 1013 l 723 1013 l 723 889 m 673 463 l 61 463 l 61 589 l 673 589 l 673 463 m 734 0 l 0 0 l 0 124 l 734 124 l 734 0 " }, "": { x_min: 0, x_max: 0, ha: 853 }, : { x_min: 0.328125, x_max: 819.515625, ha: 889, o: "m 588 1046 l 460 1046 l 460 1189 l 588 1189 l 588 1046 m 360 1046 l 232 1046 l 232 1189 l 360 1189 l 360 1046 m 819 1012 l 482 416 l 482 0 l 342 0 l 342 416 l 0 1012 l 140 1012 l 411 533 l 679 1012 l 819 1012 " }, "": { x_min: 0, x_max: 347, ha: 454, o: "m 139 851 q 102 737 139 784 q 0 669 65 690 l 0 734 q 59 787 42 741 q 72 873 72 821 l 0 873 l 0 1013 l 139 1013 l 139 851 m 347 851 q 310 737 347 784 q 208 669 273 690 l 208 734 q 267 787 250 741 q 280 873 280 821 l 208 873 l 208 1013 l 347 1013 l 347 851 " }, "@": { x_min: 0, x_max: 1260, ha: 1357, o: "m 1098 -45 q 877 -160 1001 -117 q 633 -203 752 -203 q 155 -29 327 -203 q 0 360 0 127 q 176 802 0 616 q 687 1008 372 1008 q 1123 854 969 1008 q 1260 517 1260 718 q 1155 216 1260 341 q 868 82 1044 82 q 772 106 801 82 q 737 202 737 135 q 647 113 700 144 q 527 82 594 82 q 367 147 420 82 q 314 312 314 212 q 401 565 314 452 q 639 690 498 690 q 810 588 760 690 l 849 668 l 938 668 q 877 441 900 532 q 833 226 833 268 q 853 182 833 198 q 902 167 873 167 q 1088 272 1012 167 q 1159 512 1159 372 q 1051 793 1159 681 q 687 925 925 925 q 248 747 415 925 q 97 361 97 586 q 226 26 97 159 q 627 -122 370 -122 q 856 -87 737 -122 q 1061 8 976 -53 l 1098 -45 m 786 488 q 738 580 777 545 q 643 615 700 615 q 483 517 548 615 q 425 322 425 430 q 457 203 425 250 q 552 156 490 156 q 722 273 665 156 q 786 488 738 309 " }, : { x_min: 0, x_max: 499, ha: 613, o: "m 277 1040 l 83 799 l 0 799 l 140 1040 l 277 1040 m 499 0 l 360 0 l 360 1012 l 499 1012 l 499 0 " }, i: { x_min: 14, x_max: 136, ha: 275, o: "m 136 873 l 14 873 l 14 1013 l 136 1013 l 136 873 m 136 0 l 14 0 l 14 737 l 136 737 l 136 0 " }, : { x_min: 0, x_max: 778, ha: 877, o: "m 580 545 q 724 468 671 534 q 778 310 778 402 q 673 83 778 170 q 432 0 575 0 l 0 0 l 0 1013 l 411 1013 q 629 957 541 1013 q 732 768 732 891 q 691 632 732 692 q 580 545 650 571 m 393 899 l 139 899 l 139 587 l 379 587 q 521 623 462 587 q 592 744 592 666 q 531 859 592 819 q 393 899 471 899 m 419 124 q 566 169 504 124 q 635 302 635 219 q 559 435 635 388 q 402 476 494 476 l 139 476 l 139 124 l 419 124 " }, : { x_min: 0, x_max: 617, ha: 725, o: "m 617 352 q 540 94 617 199 q 308 -24 455 -24 q 76 94 161 -24 q 0 352 0 199 l 0 739 l 126 739 l 126 355 q 169 185 126 257 q 312 98 220 98 q 451 185 402 98 q 492 355 492 257 l 492 739 l 617 739 l 617 352 " }, "]": { x_min: 0, x_max: 275, ha: 372, o: "m 275 -281 l 0 -281 l 0 -187 l 151 -187 l 151 920 l 0 920 l 0 1013 l 275 1013 l 275 -281 " }, m: { x_min: 0, x_max: 1019, ha: 1128, o: "m 1019 0 l 897 0 l 897 454 q 860 591 897 536 q 739 660 816 660 q 613 586 659 660 q 573 436 573 522 l 573 0 l 447 0 l 447 455 q 412 591 447 535 q 294 657 372 657 q 165 586 213 657 q 122 437 122 521 l 122 0 l 0 0 l 0 738 l 117 738 l 117 640 q 202 730 150 697 q 316 763 254 763 q 437 730 381 763 q 525 642 494 697 q 621 731 559 700 q 753 763 682 763 q 943 694 867 763 q 1019 512 1019 625 l 1019 0 " }, : { x_min: 8.328125, x_max: 780.5625, ha: 815, o: "m 780 -278 q 715 -294 747 -294 q 616 -257 663 -294 q 548 -175 576 -227 l 379 133 l 143 -277 l 9 -277 l 313 254 l 163 522 q 127 586 131 580 q 36 640 91 640 q 8 637 27 640 l 8 752 l 52 757 q 162 719 113 757 q 236 627 200 690 l 383 372 l 594 737 l 726 737 l 448 250 l 625 -69 q 670 -153 647 -110 q 743 -188 695 -188 q 780 -184 759 -188 l 780 -278 " }, : { x_min: 42, x_max: 326.71875, ha: 361, o: "m 284 3 q 233 -10 258 -5 q 182 -15 207 -15 q 85 26 119 -15 q 42 200 42 79 l 42 737 l 167 737 l 168 215 q 172 141 168 157 q 226 101 183 101 q 248 102 239 101 q 284 112 257 104 l 284 3 m 326 1040 l 137 819 l 54 819 l 189 1040 l 326 1040 " }, : { x_min: 0, x_max: 779.171875, ha: 850, o: "m 779 0 l 0 0 l 0 113 l 620 896 l 40 896 l 40 1013 l 779 1013 l 779 887 l 170 124 l 779 124 l 779 0 " }, R: { x_min: 0, x_max: 781.953125, ha: 907, o: "m 781 0 l 623 0 q 587 242 590 52 q 407 433 585 433 l 138 433 l 138 0 l 0 0 l 0 1013 l 396 1013 q 636 946 539 1013 q 749 731 749 868 q 711 597 749 659 q 608 502 674 534 q 718 370 696 474 q 729 207 722 352 q 781 26 736 62 l 781 0 m 373 551 q 533 594 465 551 q 614 731 614 645 q 532 859 614 815 q 373 896 465 896 l 138 896 l 138 551 l 373 551 " }, o: { x_min: 0, x_max: 713, ha: 821, o: "m 357 -25 q 94 91 194 -25 q 0 368 0 202 q 93 642 0 533 q 357 761 193 761 q 618 644 518 761 q 713 368 713 533 q 619 91 713 201 q 357 -25 521 -25 m 357 85 q 528 175 465 85 q 584 369 584 255 q 529 562 584 484 q 357 651 467 651 q 189 560 250 651 q 135 369 135 481 q 187 177 135 257 q 357 85 250 85 " }, K: { x_min: 0, x_max: 819.46875, ha: 906, o: "m 819 0 l 649 0 l 294 509 l 139 355 l 139 0 l 0 0 l 0 1013 l 139 1013 l 139 526 l 626 1013 l 809 1013 l 395 600 l 819 0 " }, ",": { x_min: 0, x_max: 142, ha: 239, o: "m 142 -12 q 105 -132 142 -82 q 0 -205 68 -182 l 0 -138 q 57 -82 40 -124 q 70 0 70 -51 l 0 0 l 0 151 l 142 151 l 142 -12 " }, d: { x_min: 0, x_max: 683, ha: 796, o: "m 683 0 l 564 0 l 564 93 q 456 6 516 38 q 327 -25 395 -25 q 87 100 181 -25 q 0 365 0 215 q 90 639 0 525 q 343 763 187 763 q 564 647 486 763 l 564 1013 l 683 1013 l 683 0 m 582 373 q 529 562 582 484 q 361 653 468 653 q 190 561 253 653 q 135 365 135 479 q 189 175 135 254 q 358 85 251 85 q 529 178 468 85 q 582 373 582 258 " }, "": { x_min: -109, x_max: 247, ha: 232, o: "m 247 1046 l 119 1046 l 119 1189 l 247 1189 l 247 1046 m 19 1046 l -109 1046 l -109 1189 l 19 1189 l 19 1046 " }, E: { x_min: 0, x_max: 736.109375, ha: 789, o: "m 736 0 l 0 0 l 0 1013 l 725 1013 l 725 889 l 139 889 l 139 585 l 677 585 l 677 467 l 139 467 l 139 125 l 736 125 l 736 0 " }, Y: { x_min: 0, x_max: 820, ha: 886, o: "m 820 1013 l 482 416 l 482 0 l 342 0 l 342 416 l 0 1013 l 140 1013 l 411 534 l 679 1012 l 820 1013 " }, '"': { x_min: 0, x_max: 299, ha: 396, o: "m 299 606 l 203 606 l 203 988 l 299 988 l 299 606 m 96 606 l 0 606 l 0 988 l 96 988 l 96 606 " }, "": { x_min: 17.984375, x_max: 773.609375, ha: 792, o: "m 773 40 l 18 376 l 17 465 l 773 799 l 773 692 l 159 420 l 773 149 l 773 40 " }, "": { x_min: 0, x_max: 364, ha: 467, o: "m 141 -12 q 104 -132 141 -82 q 0 -205 67 -182 l 0 -138 q 56 -82 40 -124 q 69 0 69 -51 l 0 0 l 0 151 l 141 151 l 141 -12 m 364 -12 q 327 -132 364 -82 q 222 -205 290 -182 l 222 -138 q 279 -82 262 -124 q 292 0 292 -51 l 222 0 l 222 151 l 364 151 l 364 -12 " }, : { x_min: 1, x_max: 710, ha: 810, o: "m 710 360 q 616 87 710 196 q 356 -28 518 -28 q 99 82 197 -28 q 1 356 1 192 q 100 606 1 509 q 355 703 199 703 q 180 829 288 754 q 70 903 124 866 l 70 1012 l 643 1012 l 643 901 l 258 901 q 462 763 422 794 q 636 592 577 677 q 710 360 710 485 m 584 365 q 552 501 584 447 q 451 602 521 555 q 372 611 411 611 q 197 541 258 611 q 136 355 136 472 q 190 171 136 245 q 358 85 252 85 q 528 173 465 85 q 584 365 584 252 " }, : { x_min: 0, x_max: 634.71875, ha: 714, o: "m 634 234 q 527 38 634 110 q 300 -25 433 -25 q 98 29 183 -25 q 0 204 0 93 q 37 313 0 265 q 128 390 67 352 q 56 459 82 419 q 26 555 26 505 q 114 712 26 654 q 295 763 191 763 q 499 700 416 763 q 589 515 589 631 l 478 515 q 419 618 464 580 q 307 657 374 657 q 207 630 253 657 q 151 547 151 598 q 238 445 151 469 q 389 434 280 434 l 389 331 l 349 331 q 206 315 255 331 q 125 210 125 287 q 183 107 125 145 q 302 76 233 76 q 436 117 379 76 q 509 234 493 159 l 634 234 m 520 1040 l 331 819 l 248 819 l 383 1040 l 520 1040 " }, : { x_min: 0, x_max: 922, ha: 1031, o: "m 922 339 q 856 97 922 203 q 650 -26 780 -26 q 538 9 587 -26 q 461 103 489 44 q 387 12 436 46 q 277 -22 339 -22 q 69 97 147 -22 q 0 339 0 203 q 45 551 0 444 q 161 738 84 643 l 302 738 q 175 553 219 647 q 124 336 124 446 q 155 179 124 249 q 275 88 197 88 q 375 163 341 88 q 400 294 400 219 l 400 572 l 524 572 l 524 294 q 561 135 524 192 q 643 88 591 88 q 762 182 719 88 q 797 342 797 257 q 745 556 797 450 q 619 738 705 638 l 760 738 q 874 551 835 640 q 922 339 922 444 " }, "": { x_min: 0, x_max: 96, ha: 251, o: "m 96 606 l 0 606 l 0 988 l 96 988 l 96 606 " }, "": { x_min: 11, x_max: 781, ha: 792, o: "m 781 490 l 446 490 l 446 255 l 349 255 l 349 490 l 11 490 l 11 586 l 349 586 l 349 819 l 446 819 l 446 586 l 781 586 l 781 490 m 781 21 l 11 21 l 11 115 l 781 115 l 781 21 " }, "|": { x_min: 343, x_max: 449, ha: 792, o: "m 449 462 l 343 462 l 343 986 l 449 986 l 449 462 m 449 -242 l 343 -242 l 343 280 l 449 280 l 449 -242 " }, : { x_min: 0, x_max: 617, ha: 725, o: "m 482 800 l 372 800 l 372 925 l 482 925 l 482 800 m 239 800 l 129 800 l 129 925 l 239 925 l 239 800 m 617 352 q 540 93 617 199 q 308 -24 455 -24 q 76 93 161 -24 q 0 352 0 199 l 0 738 l 126 738 l 126 354 q 169 185 126 257 q 312 98 220 98 q 451 185 402 98 q 492 354 492 257 l 492 738 l 617 738 l 617 352 " }, "": { x_min: 0, x_max: 593, ha: 690, o: "m 593 425 q 554 312 593 369 q 467 233 516 254 q 537 83 537 172 q 459 -74 537 -12 q 288 -133 387 -133 q 115 -69 184 -133 q 47 96 47 -6 l 166 96 q 199 7 166 40 q 288 -26 232 -26 q 371 -5 332 -26 q 420 60 420 21 q 311 201 420 139 q 108 309 210 255 q 0 490 0 383 q 33 602 0 551 q 124 687 66 654 q 75 743 93 712 q 58 812 58 773 q 133 984 58 920 q 300 1043 201 1043 q 458 987 394 1043 q 529 814 529 925 l 411 814 q 370 908 404 877 q 289 939 336 939 q 213 911 246 939 q 180 841 180 883 q 286 720 180 779 q 484 612 480 615 q 593 425 593 534 m 467 409 q 355 544 467 473 q 196 630 228 612 q 146 587 162 609 q 124 525 124 558 q 239 387 124 462 q 398 298 369 315 q 448 345 429 316 q 467 409 467 375 " }, b: { x_min: 0, x_max: 685, ha: 783, o: "m 685 372 q 597 99 685 213 q 347 -25 501 -25 q 219 5 277 -25 q 121 93 161 36 l 121 0 l 0 0 l 0 1013 l 121 1013 l 121 634 q 214 723 157 692 q 341 754 272 754 q 591 637 493 754 q 685 372 685 526 m 554 356 q 499 550 554 470 q 328 644 437 644 q 162 556 223 644 q 108 369 108 478 q 160 176 108 256 q 330 83 221 83 q 498 169 435 83 q 554 356 554 245 " }, q: { x_min: 0, x_max: 683, ha: 876, o: "m 683 -278 l 564 -278 l 564 97 q 474 8 533 39 q 345 -23 415 -23 q 91 93 188 -23 q 0 364 0 203 q 87 635 0 522 q 337 760 184 760 q 466 727 408 760 q 564 637 523 695 l 564 737 l 683 737 l 683 -278 m 582 375 q 527 564 582 488 q 358 652 466 652 q 190 565 253 652 q 135 377 135 488 q 189 179 135 261 q 361 84 251 84 q 530 179 469 84 q 582 375 582 260 " }, : { x_min: -0.171875, x_max: 969.5625, ha: 1068, o: "m 969 0 l 555 0 l 555 123 q 744 308 675 194 q 814 558 814 423 q 726 812 814 709 q 484 922 633 922 q 244 820 334 922 q 154 567 154 719 q 223 316 154 433 q 412 123 292 199 l 412 0 l 0 0 l 0 124 l 217 124 q 68 327 122 210 q 15 572 15 444 q 144 911 15 781 q 484 1041 274 1041 q 822 909 691 1041 q 953 569 953 777 q 899 326 953 443 q 750 124 846 210 l 969 124 l 969 0 " }, : { x_min: 0, x_max: 617, ha: 725, o: "m 617 352 q 540 93 617 199 q 308 -24 455 -24 q 76 93 161 -24 q 0 352 0 199 l 0 738 l 126 738 l 126 354 q 169 185 126 257 q 312 98 220 98 q 451 185 402 98 q 492 354 492 257 l 492 738 l 617 738 l 617 352 m 535 1040 l 346 819 l 262 819 l 397 1040 l 535 1040 " }, z: { x_min: -0.015625, x_max: 613.890625, ha: 697, o: "m 613 0 l 0 0 l 0 100 l 433 630 l 20 630 l 20 738 l 594 738 l 593 636 l 163 110 l 613 110 l 613 0 " }, "": { x_min: 0, x_max: 894, ha: 1e3, o: "m 389 951 l 229 951 l 229 503 l 160 503 l 160 951 l 0 951 l 0 1011 l 389 1011 l 389 951 m 894 503 l 827 503 l 827 939 l 685 503 l 620 503 l 481 937 l 481 503 l 417 503 l 417 1011 l 517 1011 l 653 580 l 796 1010 l 894 1011 l 894 503 " }, : { x_min: 0.78125, x_max: 697, ha: 810, o: "m 697 -278 l 572 -278 l 572 454 q 540 587 572 536 q 425 650 501 650 q 271 579 337 650 q 206 420 206 509 l 206 0 l 81 0 l 81 489 q 73 588 81 562 q 0 644 56 644 l 0 741 q 68 755 38 755 q 158 721 124 755 q 200 630 193 687 q 297 726 234 692 q 434 761 359 761 q 620 692 544 761 q 697 516 697 624 l 697 -278 m 479 1040 l 290 819 l 207 819 l 341 1040 l 479 1040 " }, : { x_min: 0, x_max: 960, ha: 1056, o: "m 960 507 q 833 129 960 280 q 476 -32 698 -32 q 123 129 255 -32 q 0 507 0 280 q 123 883 0 732 q 476 1045 255 1045 q 832 883 696 1045 q 960 507 960 732 m 817 500 q 733 789 817 669 q 476 924 639 924 q 223 792 317 924 q 142 507 142 675 q 222 222 142 339 q 476 89 315 89 q 730 218 636 89 q 817 500 817 334 m 716 449 l 243 449 l 243 571 l 716 571 l 716 449 " }, "": { x_min: -3, x_max: 1008, ha: 1106, o: "m 503 532 q 614 562 566 532 q 672 658 672 598 q 614 747 672 716 q 503 772 569 772 l 338 772 l 338 532 l 503 532 m 502 -7 q 123 151 263 -7 q -3 501 -3 294 q 123 851 -3 706 q 502 1011 263 1011 q 881 851 739 1011 q 1008 501 1008 708 q 883 151 1008 292 q 502 -7 744 -7 m 502 60 q 830 197 709 60 q 940 501 940 322 q 831 805 940 681 q 502 944 709 944 q 174 805 296 944 q 65 501 65 680 q 173 197 65 320 q 502 60 294 60 m 788 146 l 678 146 q 653 316 655 183 q 527 449 652 449 l 338 449 l 338 146 l 241 146 l 241 854 l 518 854 q 688 808 621 854 q 766 658 766 755 q 739 563 766 607 q 668 497 713 519 q 751 331 747 472 q 788 164 756 190 l 788 146 " }, "~": { x_min: 0, x_max: 833, ha: 931, o: "m 833 958 q 778 753 833 831 q 594 665 716 665 q 402 761 502 665 q 240 857 302 857 q 131 795 166 857 q 104 665 104 745 l 0 665 q 54 867 0 789 q 237 958 116 958 q 429 861 331 958 q 594 765 527 765 q 704 827 670 765 q 729 958 729 874 l 833 958 " }, : { x_min: 0, x_max: 736.21875, ha: 778, o: "m 736 0 l 0 0 l 0 1013 l 725 1013 l 725 889 l 139 889 l 139 585 l 677 585 l 677 467 l 139 467 l 139 125 l 736 125 l 736 0 " }, "": { x_min: 0, x_max: 450, ha: 547, o: "m 450 552 q 379 413 450 464 q 220 366 313 366 q 69 414 130 366 q 0 567 0 470 l 85 567 q 126 470 85 504 q 225 437 168 437 q 320 467 280 437 q 360 552 360 498 q 318 632 360 608 q 213 657 276 657 q 195 657 203 657 q 176 657 181 657 l 176 722 q 279 733 249 722 q 334 815 334 752 q 300 881 334 856 q 220 907 267 907 q 133 875 169 907 q 97 781 97 844 l 15 781 q 78 926 15 875 q 220 972 135 972 q 364 930 303 972 q 426 817 426 888 q 344 697 426 733 q 421 642 392 681 q 450 552 450 603 " }, "[": { x_min: 0, x_max: 273.609375, ha: 371, o: "m 273 -281 l 0 -281 l 0 1013 l 273 1013 l 273 920 l 124 920 l 124 -187 l 273 -187 l 273 -281 " }, L: { x_min: 0, x_max: 645.828125, ha: 696, o: "m 645 0 l 0 0 l 0 1013 l 140 1013 l 140 126 l 645 126 l 645 0 " }, : { x_min: 0, x_max: 803.390625, ha: 894, o: "m 803 628 l 633 628 q 713 368 713 512 q 618 93 713 204 q 357 -25 518 -25 q 94 91 194 -25 q 0 368 0 201 q 94 644 0 533 q 356 761 194 761 q 481 750 398 761 q 608 739 564 739 l 803 739 l 803 628 m 360 85 q 529 180 467 85 q 584 374 584 262 q 527 566 584 490 q 352 651 463 651 q 187 559 247 651 q 135 368 135 478 q 189 175 135 254 q 360 85 251 85 " }, : { x_min: 0, x_max: 573, ha: 642, o: "m 573 -40 q 553 -162 573 -97 q 510 -278 543 -193 l 400 -278 q 441 -187 428 -219 q 462 -90 462 -132 q 378 -14 462 -14 q 108 45 197 -14 q 0 290 0 117 q 108 631 0 462 q 353 901 194 767 l 55 901 l 55 1012 l 561 1012 l 561 924 q 261 669 382 831 q 128 301 128 489 q 243 117 128 149 q 458 98 350 108 q 573 -40 573 80 " }, : { x_min: 0, x_max: 674, ha: 778, o: "m 674 496 q 601 160 674 304 q 336 -26 508 -26 q 73 153 165 -26 q 0 485 0 296 q 72 840 0 683 q 343 1045 166 1045 q 605 844 516 1045 q 674 496 674 692 m 546 579 q 498 798 546 691 q 336 935 437 935 q 178 798 237 935 q 126 579 137 701 l 546 579 m 546 475 l 126 475 q 170 233 126 348 q 338 80 230 80 q 504 233 447 80 q 546 475 546 346 " }, : { x_min: 0, x_max: 958, ha: 1054, o: "m 485 1042 q 834 883 703 1042 q 958 511 958 735 q 834 136 958 287 q 481 -26 701 -26 q 126 130 261 -26 q 0 504 0 279 q 127 880 0 729 q 485 1042 263 1042 m 480 98 q 731 225 638 98 q 815 504 815 340 q 733 783 815 670 q 480 913 640 913 q 226 785 321 913 q 142 504 142 671 q 226 224 142 339 q 480 98 319 98 " }, : { x_min: 0, x_max: 705.28125, ha: 749, o: "m 705 886 l 140 886 l 140 0 l 0 0 l 0 1012 l 705 1012 l 705 886 " }, " ": { x_min: 0, x_max: 0, ha: 375 }, "%": { x_min: -3, x_max: 1089, ha: 1186, o: "m 845 0 q 663 76 731 0 q 602 244 602 145 q 661 412 602 344 q 845 489 728 489 q 1027 412 959 489 q 1089 244 1089 343 q 1029 76 1089 144 q 845 0 962 0 m 844 103 q 945 143 909 103 q 981 243 981 184 q 947 340 981 301 q 844 385 909 385 q 744 342 781 385 q 708 243 708 300 q 741 147 708 186 q 844 103 780 103 m 888 986 l 284 -25 l 199 -25 l 803 986 l 888 986 m 241 468 q 58 545 126 468 q -3 715 -3 615 q 56 881 -3 813 q 238 958 124 958 q 421 881 353 958 q 483 712 483 813 q 423 544 483 612 q 241 468 356 468 m 241 855 q 137 811 175 855 q 100 710 100 768 q 136 612 100 653 q 240 572 172 572 q 344 614 306 572 q 382 713 382 656 q 347 810 382 771 q 241 855 308 855 " }, P: { x_min: 0, x_max: 726, ha: 806, o: "m 424 1013 q 640 931 555 1013 q 726 719 726 850 q 637 506 726 587 q 413 426 548 426 l 140 426 l 140 0 l 0 0 l 0 1013 l 424 1013 m 379 889 l 140 889 l 140 548 l 372 548 q 522 589 459 548 q 593 720 593 637 q 528 845 593 801 q 379 889 463 889 " }, : { x_min: 0, x_max: 1078.21875, ha: 1118, o: "m 1078 0 l 342 0 l 342 1013 l 1067 1013 l 1067 889 l 481 889 l 481 585 l 1019 585 l 1019 467 l 481 467 l 481 125 l 1078 125 l 1078 0 m 277 1040 l 83 799 l 0 799 l 140 1040 l 277 1040 " }, : { x_min: 0.125, x_max: 1136.546875, ha: 1235, o: "m 1136 0 l 722 0 l 722 123 q 911 309 842 194 q 981 558 981 423 q 893 813 981 710 q 651 923 800 923 q 411 821 501 923 q 321 568 321 720 q 390 316 321 433 q 579 123 459 200 l 579 0 l 166 0 l 166 124 l 384 124 q 235 327 289 210 q 182 572 182 444 q 311 912 182 782 q 651 1042 441 1042 q 989 910 858 1042 q 1120 569 1120 778 q 1066 326 1120 443 q 917 124 1013 210 l 1136 124 l 1136 0 m 277 1040 l 83 800 l 0 800 l 140 1041 l 277 1040 " }, _: { x_min: 0, x_max: 705.5625, ha: 803, o: "m 705 -334 l 0 -334 l 0 -234 l 705 -234 l 705 -334 " }, : { x_min: -110, x_max: 246, ha: 275, o: "m 246 1046 l 118 1046 l 118 1189 l 246 1189 l 246 1046 m 18 1046 l -110 1046 l -110 1189 l 18 1189 l 18 1046 m 136 0 l 0 0 l 0 1012 l 136 1012 l 136 0 " }, "+": { x_min: 23, x_max: 768, ha: 792, o: "m 768 372 l 444 372 l 444 0 l 347 0 l 347 372 l 23 372 l 23 468 l 347 468 l 347 840 l 444 840 l 444 468 l 768 468 l 768 372 " }, "": { x_min: 0, x_max: 1050, ha: 1149, o: "m 1050 0 l 625 0 q 712 178 625 108 q 878 277 722 187 q 967 385 967 328 q 932 456 967 429 q 850 484 897 484 q 759 450 798 484 q 721 352 721 416 l 640 352 q 706 502 640 448 q 851 551 766 551 q 987 509 931 551 q 1050 385 1050 462 q 976 251 1050 301 q 829 179 902 215 q 717 68 740 133 l 1050 68 l 1050 0 m 834 985 l 215 -28 l 130 -28 l 750 984 l 834 985 m 224 422 l 142 422 l 142 811 l 0 811 l 0 867 q 104 889 62 867 q 164 973 157 916 l 224 973 l 224 422 " }, : { x_min: 0, x_max: 720, ha: 783, o: "m 424 1013 q 637 933 554 1013 q 720 723 720 853 q 633 508 720 591 q 413 426 546 426 l 140 426 l 140 0 l 0 0 l 0 1013 l 424 1013 m 378 889 l 140 889 l 140 548 l 371 548 q 521 589 458 548 q 592 720 592 637 q 527 845 592 801 q 378 889 463 889 " }, "'": { x_min: 0, x_max: 139, ha: 236, o: "m 139 851 q 102 737 139 784 q 0 669 65 690 l 0 734 q 59 787 42 741 q 72 873 72 821 l 0 873 l 0 1013 l 139 1013 l 139 851 " }, : { x_min: 0, x_max: 350, ha: 397, o: "m 350 625 q 307 616 328 616 q 266 631 281 616 q 247 673 251 645 q 190 628 225 644 q 116 613 156 613 q 32 641 64 613 q 0 722 0 669 q 72 826 0 800 q 247 866 159 846 l 247 887 q 220 934 247 916 q 162 953 194 953 q 104 934 129 953 q 76 882 80 915 l 16 882 q 60 976 16 941 q 166 1011 104 1011 q 266 979 224 1011 q 308 891 308 948 l 308 706 q 311 679 308 688 q 331 670 315 670 l 350 672 l 350 625 m 247 757 l 247 811 q 136 790 175 798 q 64 726 64 773 q 83 682 64 697 q 132 667 103 667 q 207 690 174 667 q 247 757 247 718 " }, "": { x_min: 0, x_max: 450, ha: 553, o: "m 450 800 l 340 800 l 340 925 l 450 925 l 450 800 m 406 1040 l 212 800 l 129 800 l 269 1040 l 406 1040 m 110 800 l 0 800 l 0 925 l 110 925 l 110 800 " }, T: { x_min: 0, x_max: 777, ha: 835, o: "m 777 894 l 458 894 l 458 0 l 319 0 l 319 894 l 0 894 l 0 1013 l 777 1013 l 777 894 " }, : { x_min: 0, x_max: 915, ha: 997, o: "m 527 0 l 389 0 l 389 122 q 110 231 220 122 q 0 509 0 340 q 110 785 0 677 q 389 893 220 893 l 389 1013 l 527 1013 l 527 893 q 804 786 693 893 q 915 509 915 679 q 805 231 915 341 q 527 122 696 122 l 527 0 m 527 226 q 712 310 641 226 q 779 507 779 389 q 712 705 779 627 q 527 787 641 787 l 527 226 m 389 226 l 389 787 q 205 698 275 775 q 136 505 136 620 q 206 308 136 391 q 389 226 276 226 " }, "": { x_min: 0, x_max: 0, ha: 694 }, j: { x_min: -77.78125, x_max: 167, ha: 349, o: "m 167 871 l 42 871 l 42 1013 l 167 1013 l 167 871 m 167 -80 q 121 -231 167 -184 q -26 -278 76 -278 l -77 -278 l -77 -164 l -41 -164 q 26 -143 11 -164 q 42 -65 42 -122 l 42 737 l 167 737 l 167 -80 " }, : { x_min: 0, x_max: 756.953125, ha: 819, o: "m 756 0 l 0 0 l 0 107 l 395 523 l 22 904 l 22 1013 l 745 1013 l 745 889 l 209 889 l 566 523 l 187 125 l 756 125 l 756 0 " }, "": { x_min: 18.0625, x_max: 774, ha: 792, o: "m 774 376 l 18 40 l 18 149 l 631 421 l 18 692 l 18 799 l 774 465 l 774 376 " }, "<": { x_min: 17.984375, x_max: 773.609375, ha: 792, o: "m 773 40 l 18 376 l 17 465 l 773 799 l 773 692 l 159 420 l 773 149 l 773 40 " }, "": { x_min: 0, x_max: 704.484375, ha: 801, o: "m 704 41 q 623 -10 664 5 q 543 -26 583 -26 q 359 15 501 -26 q 243 36 288 36 q 158 23 197 36 q 73 -21 119 10 l 6 76 q 125 195 90 150 q 175 331 175 262 q 147 443 175 383 l 0 443 l 0 512 l 108 512 q 43 734 43 623 q 120 929 43 854 q 358 1010 204 1010 q 579 936 487 1010 q 678 729 678 857 l 678 684 l 552 684 q 504 838 552 780 q 362 896 457 896 q 216 852 263 896 q 176 747 176 815 q 199 627 176 697 q 248 512 217 574 l 468 512 l 468 443 l 279 443 q 297 356 297 398 q 230 194 297 279 q 153 107 211 170 q 227 133 190 125 q 293 142 264 142 q 410 119 339 142 q 516 96 482 96 q 579 105 550 96 q 648 142 608 115 l 704 41 " }, t: { x_min: 0, x_max: 367, ha: 458, o: "m 367 0 q 312 -5 339 -2 q 262 -8 284 -8 q 145 28 183 -8 q 108 143 108 64 l 108 638 l 0 638 l 0 738 l 108 738 l 108 944 l 232 944 l 232 738 l 367 738 l 367 638 l 232 638 l 232 185 q 248 121 232 140 q 307 102 264 102 q 345 104 330 102 q 367 107 360 107 l 367 0 " }, "": { x_min: 0, x_max: 706, ha: 803, o: "m 706 411 l 706 158 l 630 158 l 630 335 l 0 335 l 0 411 l 706 411 " }, : { x_min: 0, x_max: 750, ha: 803, o: "m 750 -7 q 679 -15 716 -15 q 538 59 591 -15 q 466 214 512 97 l 336 551 l 126 0 l 0 0 l 270 705 q 223 837 247 770 q 116 899 190 899 q 90 898 100 899 l 90 1004 q 152 1011 125 1011 q 298 938 244 1011 q 373 783 326 901 l 605 192 q 649 115 629 136 q 716 95 669 95 l 736 95 q 750 97 745 97 l 750 -7 " }, W: { x_min: 0, x_max: 1263.890625, ha: 1351, o: "m 1263 1013 l 995 0 l 859 0 l 627 837 l 405 0 l 265 0 l 0 1013 l 136 1013 l 342 202 l 556 1013 l 701 1013 l 921 207 l 1133 1012 l 1263 1013 " }, ">": { x_min: 18.0625, x_max: 774, ha: 792, o: "m 774 376 l 18 40 l 18 149 l 631 421 l 18 692 l 18 799 l 774 465 l 774 376 " }, v: { x_min: 0, x_max: 675.15625, ha: 761, o: "m 675 738 l 404 0 l 272 0 l 0 738 l 133 737 l 340 147 l 541 737 l 675 738 " }, : { x_min: 0.28125, x_max: 644.5, ha: 703, o: "m 644 628 l 382 628 l 382 179 q 388 120 382 137 q 436 91 401 91 q 474 94 447 91 q 504 97 501 97 l 504 0 q 454 -9 482 -5 q 401 -14 426 -14 q 278 67 308 -14 q 260 233 260 118 l 260 628 l 0 628 l 0 739 l 644 739 l 644 628 " }, : { x_min: 0, x_max: 624.9375, ha: 699, o: "m 624 -37 q 608 -153 624 -96 q 563 -278 593 -211 l 454 -278 q 491 -183 486 -200 q 511 -83 511 -126 q 484 -23 511 -44 q 370 1 452 1 q 323 0 354 1 q 283 -1 293 -1 q 84 76 169 -1 q 0 266 0 154 q 56 431 0 358 q 197 538 108 498 q 94 613 134 562 q 54 730 54 665 q 77 823 54 780 q 143 901 101 867 l 27 901 l 27 1012 l 576 1012 l 576 901 l 380 901 q 244 863 303 901 q 178 745 178 820 q 312 600 178 636 q 532 582 380 582 l 532 479 q 276 455 361 479 q 118 281 118 410 q 165 173 118 217 q 274 120 208 133 q 494 101 384 110 q 624 -37 624 76 " }, "&": { x_min: -3, x_max: 894.25, ha: 992, o: "m 894 0 l 725 0 l 624 123 q 471 0 553 40 q 306 -41 390 -41 q 168 -7 231 -41 q 62 92 105 26 q 14 187 31 139 q -3 276 -3 235 q 55 433 -3 358 q 248 581 114 508 q 170 689 196 640 q 137 817 137 751 q 214 985 137 922 q 384 1041 284 1041 q 548 988 483 1041 q 622 824 622 928 q 563 666 622 739 q 431 556 516 608 l 621 326 q 649 407 639 361 q 663 493 653 426 l 781 493 q 703 229 781 352 l 894 0 m 504 818 q 468 908 504 877 q 384 940 433 940 q 293 907 331 940 q 255 818 255 875 q 289 714 255 767 q 363 628 313 678 q 477 729 446 682 q 504 818 504 771 m 556 209 l 314 499 q 179 395 223 449 q 135 283 135 341 q 146 222 135 253 q 183 158 158 192 q 333 80 241 80 q 556 209 448 80 " }, : { x_min: 0, x_max: 862.5, ha: 942, o: "m 862 0 l 719 0 l 426 847 l 143 0 l 0 0 l 356 1013 l 501 1013 l 862 0 " }, I: { x_min: 41, x_max: 180, ha: 293, o: "m 180 0 l 41 0 l 41 1013 l 180 1013 l 180 0 " }, G: { x_min: 0, x_max: 921, ha: 1011, o: "m 921 0 l 832 0 l 801 136 q 655 15 741 58 q 470 -28 568 -28 q 126 133 259 -28 q 0 499 0 284 q 125 881 0 731 q 486 1043 259 1043 q 763 957 647 1043 q 905 709 890 864 l 772 709 q 668 866 747 807 q 486 926 589 926 q 228 795 322 926 q 142 507 142 677 q 228 224 142 342 q 483 94 323 94 q 712 195 625 94 q 796 435 796 291 l 477 435 l 477 549 l 921 549 l 921 0 " }, : { x_min: 0, x_max: 617, ha: 725, o: "m 524 800 l 414 800 l 414 925 l 524 925 l 524 800 m 183 800 l 73 800 l 73 925 l 183 925 l 183 800 m 617 352 q 540 93 617 199 q 308 -24 455 -24 q 76 93 161 -24 q 0 352 0 199 l 0 738 l 126 738 l 126 354 q 169 185 126 257 q 312 98 220 98 q 451 185 402 98 q 492 354 492 257 l 492 738 l 617 738 l 617 352 m 489 1040 l 300 819 l 216 819 l 351 1040 l 489 1040 " }, "`": { x_min: 0, x_max: 138.890625, ha: 236, o: "m 138 699 l 0 699 l 0 861 q 36 974 0 929 q 138 1041 72 1020 l 138 977 q 82 931 95 969 q 69 839 69 893 l 138 839 l 138 699 " }, "": { x_min: 0, x_max: 142, ha: 239, o: "m 142 585 l 0 585 l 0 738 l 142 738 l 142 585 " }, : { x_min: 0.328125, x_max: 819.515625, ha: 889, o: "m 819 1013 l 482 416 l 482 0 l 342 0 l 342 416 l 0 1013 l 140 1013 l 411 533 l 679 1013 l 819 1013 " }, r: { x_min: 0, x_max: 355.5625, ha: 432, o: "m 355 621 l 343 621 q 179 569 236 621 q 122 411 122 518 l 122 0 l 0 0 l 0 737 l 117 737 l 117 604 q 204 719 146 686 q 355 753 262 753 l 355 621 " }, x: { x_min: 0, x_max: 675, ha: 764, o: "m 675 0 l 525 0 l 331 286 l 144 0 l 0 0 l 256 379 l 12 738 l 157 737 l 336 473 l 516 738 l 661 738 l 412 380 l 675 0 " }, : { x_min: 0, x_max: 696.609375, ha: 747, o: "m 696 -4 q 628 -14 657 -14 q 498 97 513 -14 q 422 8 470 41 q 313 -24 374 -24 q 207 3 258 -24 q 120 80 157 31 l 120 -278 l 0 -278 l 0 738 l 124 738 l 124 343 q 165 172 124 246 q 308 82 216 82 q 451 177 402 82 q 492 358 492 254 l 492 738 l 616 738 l 616 214 q 623 136 616 160 q 673 92 636 92 q 696 95 684 92 l 696 -4 " }, h: { x_min: 0, x_max: 615, ha: 724, o: "m 615 472 l 615 0 l 490 0 l 490 454 q 456 590 490 535 q 338 654 416 654 q 186 588 251 654 q 122 436 122 522 l 122 0 l 0 0 l 0 1013 l 122 1013 l 122 633 q 218 727 149 694 q 362 760 287 760 q 552 676 484 760 q 615 472 615 600 " }, ".": { x_min: 0, x_max: 142, ha: 239, o: "m 142 0 l 0 0 l 0 151 l 142 151 l 142 0 " }, : { x_min: -2, x_max: 878, ha: 974, o: "m 496 -279 l 378 -279 l 378 -17 q 101 88 204 -17 q -2 367 -2 194 q 68 626 -2 510 q 283 758 151 758 l 283 646 q 167 537 209 626 q 133 373 133 462 q 192 177 133 254 q 378 93 259 93 l 378 758 q 445 764 426 763 q 476 765 464 765 q 765 659 653 765 q 878 377 878 553 q 771 96 878 209 q 496 -17 665 -17 l 496 -279 m 496 93 l 514 93 q 687 183 623 93 q 746 380 746 265 q 691 569 746 491 q 522 658 629 658 l 496 656 l 496 93 " }, ";": { x_min: 0, x_max: 142, ha: 239, o: "m 142 585 l 0 585 l 0 738 l 142 738 l 142 585 m 142 -12 q 105 -132 142 -82 q 0 -206 68 -182 l 0 -138 q 58 -82 43 -123 q 68 0 68 -56 l 0 0 l 0 151 l 142 151 l 142 -12 " }, f: { x_min: 0, x_max: 378, ha: 472, o: "m 378 638 l 246 638 l 246 0 l 121 0 l 121 638 l 0 638 l 0 738 l 121 738 q 137 935 121 887 q 290 1028 171 1028 q 320 1027 305 1028 q 378 1021 334 1026 l 378 908 q 323 918 346 918 q 257 870 273 918 q 246 780 246 840 l 246 738 l 378 738 l 378 638 " }, "": { x_min: 1, x_max: 348.21875, ha: 454, o: "m 140 670 l 1 670 l 1 830 q 37 943 1 897 q 140 1011 74 990 l 140 947 q 82 900 97 940 q 68 810 68 861 l 140 810 l 140 670 m 348 670 l 209 670 l 209 830 q 245 943 209 897 q 348 1011 282 990 l 348 947 q 290 900 305 940 q 276 810 276 861 l 348 810 l 348 670 " }, A: { x_min: 0.03125, x_max: 906.953125, ha: 1008, o: "m 906 0 l 756 0 l 648 303 l 251 303 l 142 0 l 0 0 l 376 1013 l 529 1013 l 906 0 m 610 421 l 452 867 l 293 421 l 610 421 " }, "": { x_min: 1, x_max: 139.890625, ha: 236, o: "m 139 670 l 1 670 l 1 830 q 37 943 1 897 q 139 1011 74 990 l 139 947 q 82 900 97 940 q 68 810 68 861 l 139 810 l 139 670 " }, : { x_min: -70, x_max: 283, ha: 361, o: "m 283 800 l 173 800 l 173 925 l 283 925 l 283 800 m 40 800 l -70 800 l -70 925 l 40 925 l 40 800 m 283 3 q 232 -10 257 -5 q 181 -15 206 -15 q 84 26 118 -15 q 41 200 41 79 l 41 737 l 166 737 l 167 215 q 171 141 167 157 q 225 101 182 101 q 247 103 238 101 q 283 112 256 104 l 283 3 " }, : { x_min: -0.21875, x_max: 773.21875, ha: 857, o: "m 773 -7 l 707 -11 q 575 40 607 -11 q 552 174 552 77 l 552 226 l 552 626 l 222 626 l 222 0 l 97 0 l 97 626 l 0 626 l 0 737 l 773 737 l 773 626 l 676 626 l 676 171 q 695 103 676 117 q 773 90 714 90 l 773 -7 " }, : { x_min: 0, x_max: 765.5625, ha: 809, o: "m 765 -4 q 698 -14 726 -14 q 564 97 586 -14 q 466 7 525 40 q 337 -26 407 -26 q 88 98 186 -26 q 0 369 0 212 q 88 637 0 525 q 337 760 184 760 q 465 727 407 760 q 563 637 524 695 l 563 738 l 685 738 l 685 222 q 693 141 685 168 q 748 94 708 94 q 765 95 760 94 l 765 -4 m 584 371 q 531 562 584 485 q 360 653 470 653 q 192 566 254 653 q 135 379 135 489 q 186 181 135 261 q 358 84 247 84 q 528 176 465 84 q 584 371 584 260 m 604 1040 l 415 819 l 332 819 l 466 1040 l 604 1040 " }, O: { x_min: 0, x_max: 958, ha: 1057, o: "m 485 1041 q 834 882 702 1041 q 958 512 958 734 q 834 136 958 287 q 481 -26 702 -26 q 126 130 261 -26 q 0 504 0 279 q 127 880 0 728 q 485 1041 263 1041 m 480 98 q 731 225 638 98 q 815 504 815 340 q 733 783 815 669 q 480 912 640 912 q 226 784 321 912 q 142 504 142 670 q 226 224 142 339 q 480 98 319 98 " }, n: { x_min: 0, x_max: 615, ha: 724, o: "m 615 463 l 615 0 l 490 0 l 490 454 q 453 592 490 537 q 331 656 410 656 q 178 585 240 656 q 117 421 117 514 l 117 0 l 0 0 l 0 738 l 117 738 l 117 630 q 218 728 150 693 q 359 764 286 764 q 552 675 484 764 q 615 463 615 593 " }, l: { x_min: 41, x_max: 166, ha: 279, o: "m 166 0 l 41 0 l 41 1013 l 166 1013 l 166 0 " }, "": { x_min: 40.09375, x_max: 728.796875, ha: 825, o: "m 728 304 l 649 224 l 512 363 q 383 331 458 331 q 256 363 310 331 l 119 224 l 40 304 l 177 441 q 150 553 150 493 q 184 673 150 621 l 40 818 l 119 898 l 267 749 q 321 766 291 759 q 384 773 351 773 q 447 766 417 773 q 501 749 477 759 l 649 898 l 728 818 l 585 675 q 612 618 604 648 q 621 553 621 587 q 591 441 621 491 l 728 304 m 384 682 q 280 643 318 682 q 243 551 243 604 q 279 461 243 499 q 383 423 316 423 q 487 461 449 423 q 525 553 525 500 q 490 641 525 605 q 384 682 451 682 " }, : { x_min: 0, x_max: 632.328125, ha: 679, o: "m 632 0 l 482 0 l 225 384 l 124 288 l 124 0 l 0 0 l 0 738 l 124 738 l 124 446 l 433 738 l 596 738 l 312 466 l 632 0 " }, p: { x_min: 0, x_max: 685, ha: 786, o: "m 685 364 q 598 96 685 205 q 350 -23 504 -23 q 121 89 205 -23 l 121 -278 l 0 -278 l 0 738 l 121 738 l 121 633 q 220 726 159 691 q 351 761 280 761 q 598 636 504 761 q 685 364 685 522 m 557 371 q 501 560 557 481 q 330 651 437 651 q 162 559 223 651 q 108 366 108 479 q 162 177 108 254 q 333 87 224 87 q 502 178 441 87 q 557 371 557 258 " }, "": { x_min: 0, x_max: 777, ha: 835, o: "m 458 238 l 458 0 l 319 0 l 319 238 l 0 238 l 0 360 l 319 360 l 319 681 l 0 683 l 0 804 l 319 804 l 319 1015 l 458 1013 l 458 804 l 777 804 l 777 683 l 458 683 l 458 360 l 777 360 l 777 238 l 458 238 " }, : { x_min: 0, x_max: 808, ha: 907, o: "m 465 -278 l 341 -278 l 341 -15 q 87 102 180 -15 q 0 378 0 210 l 0 739 l 133 739 l 133 379 q 182 195 133 275 q 341 98 242 98 l 341 922 l 465 922 l 465 98 q 623 195 563 98 q 675 382 675 278 l 675 742 l 808 742 l 808 381 q 720 104 808 213 q 466 -13 627 -13 l 465 -278 " }, : { x_min: 0.78125, x_max: 697, ha: 810, o: "m 697 -278 l 572 -278 l 572 454 q 540 587 572 536 q 425 650 501 650 q 271 579 337 650 q 206 420 206 509 l 206 0 l 81 0 l 81 489 q 73 588 81 562 q 0 644 56 644 l 0 741 q 68 755 38 755 q 158 720 124 755 q 200 630 193 686 q 297 726 234 692 q 434 761 359 761 q 620 692 544 761 q 697 516 697 624 l 697 -278 " } }, Sue = "normal", Tue = 1189, wue = -100, Mue = "normal", Eue = { yMin: -334, xMin: -111, yMax: 1189, xMax: 1672 }, Rue = 1e3, Cue = { postscript_name: "Helvetiker-Regular", version_string: "Version 1.00 2004 initial release", vendor_url: "http://www.magenta.gr/", full_font_name: "Helvetiker", font_family_name: "Helvetiker", copyright: "Copyright (c) agenta ltd, 2004", description: "", trademark: "", designer: "", designer_url: "", unique_font_identifier: "agenta ltd:Helvetiker:22-10-104", license_url: "http://www.ellak.gr/fonts/MgOpen/license.html", license_description: `Copyright (c) 2004 by MAGENTA Ltd. All Rights Reserved.\r
\r
Permission is hereby granted, free of charge, to any person obtaining a copy of the fonts accompanying this license ("Fonts") and associated documentation files (the "Font Software"), to reproduce and distribute the Font Software, including without limitation the rights to use, copy, merge, publish, distribute, and/or sell copies of the Font Software, and to permit persons to whom the Font Software is furnished to do so, subject to the following conditions: \r
\r
The above copyright and this permission notice shall be included in all copies of one or more of the Font Software typefaces.\r
\r
The Font Software may be modified, altered, or added to, and in particular the designs of glyphs or characters in the Fonts may be modified and additional glyphs or characters may be added to the Fonts, only if the fonts are renamed to names not containing the word "MgOpen", or if the modifications are accepted for inclusion in the Font Software itself by the each appointed Administrator.\r
\r
This License becomes null and void to the extent applicable to Fonts or Font Software that has been modified and is distributed under the "MgOpen" name.\r
\r
The Font Software may be sold as part of a larger software package but no copy of one or more of the Font Software typefaces may be sold by itself. \r
\r
THE FONT SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF COPYRIGHT, PATENT, TRADEMARK, OR OTHER RIGHT. IN NO EVENT SHALL MAGENTA OR PERSONS OR BODIES IN CHARGE OF ADMINISTRATION AND MAINTENANCE OF THE FONT SOFTWARE BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, INCLUDING ANY GENERAL, SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF THE USE OR INABILITY TO USE THE FONT SOFTWARE OR FROM OTHER DEALINGS IN THE FONT SOFTWARE.`, manufacturer_name: "agenta ltd", font_sub_family_name: "Regular" }, Pue = -334, Nue = "Helvetiker", Due = 1522, Lue = 50, Iue = { glyphs: bue, cssFontWeight: Sue, ascender: Tue, underlinePosition: wue, cssFontStyle: Mue, boundingBox: Eue, resolution: Rue, original_font_information: Cue, descender: Pue, familyName: Nue, lineHeight: Due, underlineThickness: Lue }, la = ai(ai({}, window.THREE ? window.THREE : {
  BoxGeometry: ul,
  CircleGeometry: lA,
  DoubleSide: er,
  Group: As,
  Mesh: Tn,
  MeshLambertMaterial: Ea,
  TextGeometry: VC,
  Vector3: j
}), {}, {
  Font: Dle,
  TextGeometry: VC
}), i7 = Sr({
  props: {
    labelsData: {
      default: []
    },
    labelLat: {
      default: "lat"
    },
    labelLng: {
      default: "lng"
    },
    labelAltitude: {
      default: 2e-3
    },
    // in units of globe radius
    labelText: {
      default: "text"
    },
    labelSize: {
      default: 0.5
    },
    // text height in deg
    labelTypeFace: {
      default: Iue,
      onChange: function(e, t) {
        t.font = new la.Font(e);
      }
    },
    labelColor: {
      default: function() {
        return "lightgrey";
      }
    },
    labelRotation: {
      default: 0
    },
    // clockwise degrees, relative to the latitute parallel plane
    labelResolution: {
      default: 3
    },
    // how many segments in the text's curves
    labelIncludeDot: {
      default: !0
    },
    labelDotRadius: {
      default: 0.1
    },
    // in deg
    labelDotOrientation: {
      default: function() {
        return "bottom";
      }
    },
    // right, top, bottom
    labelsTransitionDuration: {
      default: 1e3,
      triggerUpdate: !1
    }
    // ms
  },
  init: function(e, t, n) {
    var r = n.tweenGroup;
    bi(e), t.scene = e, t.tweenGroup = r;
    var s = new la.CircleGeometry(1, 32);
    t.dataMapper = new co(e, {
      objBindAttr: "__threeObjLabel"
    }).onCreateObj(function() {
      var o = new la.MeshLambertMaterial();
      o.side = er;
      var a = new la.Group();
      a.add(new la.Mesh(s, o));
      var l = new la.Mesh(void 0, o);
      a.add(l);
      var u = new la.Mesh();
      return u.visible = !1, l.add(u), a.__globeObjType = "label", a;
    });
  },
  update: function(e) {
    var t = je(e.labelLat), n = je(e.labelLng), r = je(e.labelAltitude), s = je(e.labelText), o = je(e.labelSize), a = je(e.labelRotation), l = je(e.labelColor), u = je(e.labelIncludeDot), c = je(e.labelDotRadius), A = je(e.labelDotOrientation), m = /* @__PURE__ */ new Set(["right", "top", "bottom"]), _ = 2 * Math.PI * Ci / 360;
    e.dataMapper.onUpdateObj(function(y, T) {
      var b = Li(y.children, 2), S = b[0], E = b[1], R = Li(E.children, 1), C = R[0], L = l(T), D = ya(L);
      E.material.color.set(al(L)), E.material.transparent = D < 1, E.material.opacity = D;
      var B = u(T), U = A(T);
      !B || !m.has(U) && (U = "bottom");
      var N = B ? +c(T) * _ : 1e-12;
      S.scale.x = S.scale.y = N;
      var O = +o(T) * _;
      if (E.geometry && E.geometry.dispose(), E.geometry = new la.TextGeometry(s(T), {
        font: e.font,
        size: O,
        depth: 0,
        bevelEnabled: !0,
        bevelThickness: 0,
        bevelSize: 0,
        curveSegments: e.labelResolution
      }), C.geometry && C.geometry.dispose(), E.geometry.computeBoundingBox(), C.geometry = hw(la.BoxGeometry, _i(new la.Vector3().subVectors(E.geometry.boundingBox.max, E.geometry.boundingBox.min).clampScalar(0, 1 / 0).toArray())), U !== "right" && E.geometry.center(), B) {
        var G = N + O / 2;
        U === "right" && (E.position.x = G), E.position.y = {
          right: -O / 2,
          // center vertically
          top: G + O / 2,
          bottom: -G - O / 2
        }[U];
      }
      var H = function(ee) {
        var oe = y.__currentTargetD = ee, fe = oe.lat, _e = oe.lng, Te = oe.alt, Ce = oe.rot, Je = oe.scale;
        Object.assign(y.position, Xo(fe, _e, Te)), y.lookAt(e.scene.localToWorld(new la.Vector3(0, 0, 0))), y.rotateY(Math.PI), y.rotateZ(-Ce * Math.PI / 180), y.scale.x = y.scale.y = y.scale.z = Je;
      }, Y = {
        lat: +t(T),
        lng: +n(T),
        alt: +r(T),
        rot: +a(T),
        scale: 1
      }, K = y.__currentTargetD || Object.assign({}, Y, {
        scale: 1e-12
      });
      Object.keys(Y).some(function(X) {
        return K[X] !== Y[X];
      }) && (!e.labelsTransitionDuration || e.labelsTransitionDuration < 0 ? H(Y) : e.tweenGroup.add(new xs(K).to(Y, e.labelsTransitionDuration).easing(Ar.Quadratic.InOut).onUpdate(H).start()));
    }).digest(e.labelsData);
  }
}), Bue = ai(ai({}, window.THREE ? window.THREE : {}), {}, {
  CSS2DObject: Fq
}), r7 = Sr({
  props: {
    htmlElementsData: {
      default: []
    },
    htmlLat: {
      default: "lat"
    },
    htmlLng: {
      default: "lng"
    },
    htmlAltitude: {
      default: 0
    },
    // in units of globe radius
    htmlElement: {},
    htmlElementVisibilityModifier: {
      triggerUpdate: !1
    },
    htmlTransitionDuration: {
      default: 1e3,
      triggerUpdate: !1
    },
    // ms
    isBehindGlobe: {
      onChange: function() {
        this.updateObjVisibility();
      },
      triggerUpdate: !1
    }
  },
  methods: {
    updateObjVisibility: function(e, t) {
      if (e.dataMapper) {
        var n = t ? [t] : e.dataMapper.entries().map(function(r) {
          var s = Li(r, 2), o = s[1];
          return o;
        }).filter(function(r) {
          return r;
        });
        n.forEach(function(r) {
          var s = !e.isBehindGlobe || !e.isBehindGlobe(r.position);
          e.htmlElementVisibilityModifier ? (r.visible = !0, e.htmlElementVisibilityModifier(r.element, s)) : r.visible = s;
        });
      }
    }
  },
  init: function(e, t, n) {
    var r = n.tweenGroup;
    bi(e), t.scene = e, t.tweenGroup = r, t.dataMapper = new co(e, {
      objBindAttr: "__threeObjHtml"
    }).onCreateObj(function(s) {
      var o = je(t.htmlElement)(s), a = new Bue.CSS2DObject(o);
      return a.__globeObjType = "html", a;
    });
  },
  update: function(e, t) {
    var n = this, r = je(e.htmlLat), s = je(e.htmlLng), o = je(e.htmlAltitude);
    t.hasOwnProperty("htmlElement") && e.dataMapper.clear(), e.dataMapper.onUpdateObj(function(a, l) {
      var u = function(m) {
        var _ = a.__currentTargetD = m, y = _.alt, T = _.lat, b = _.lng;
        Object.assign(a.position, Xo(T, b, y)), n.updateObjVisibility(a);
      }, c = {
        lat: +r(l),
        lng: +s(l),
        alt: +o(l)
      };
      !e.htmlTransitionDuration || e.htmlTransitionDuration < 0 || !a.__currentTargetD ? u(c) : e.tweenGroup.add(new xs(a.__currentTargetD).to(c, e.htmlTransitionDuration).easing(Ar.Quadratic.InOut).onUpdate(u).start());
    }).digest(e.htmlElementsData);
  }
}), Ug = window.THREE ? window.THREE : {
  Group: As,
  Mesh: Tn,
  MeshLambertMaterial: Ea,
  SphereGeometry: Co
}, s7 = Sr({
  props: {
    objectsData: {
      default: []
    },
    objectLat: {
      default: "lat"
    },
    objectLng: {
      default: "lng"
    },
    objectAltitude: {
      default: 0.01
    },
    // in units of globe radius
    objectFacesSurface: {
      default: !0
    },
    objectRotation: {},
    objectThreeObject: {
      default: new Ug.Mesh(
        // default object: yellow sphere
        new Ug.SphereGeometry(1, 16, 8),
        new Ug.MeshLambertMaterial({
          color: "#ffffaa",
          transparent: !0,
          opacity: 0.7
        })
      )
    }
  },
  init: function(e, t) {
    bi(e), t.scene = e, t.dataMapper = new co(e, {
      objBindAttr: "__threeObjObject"
    }).onCreateObj(function(n) {
      var r = je(t.objectThreeObject)(n);
      t.objectThreeObject === r && (r = r.clone());
      var s = new Ug.Group();
      return s.add(r), s.__globeObjType = "object", s;
    });
  },
  update: function(e, t) {
    var n = je(e.objectLat), r = je(e.objectLng), s = je(e.objectAltitude), o = je(e.objectFacesSurface), a = je(e.objectRotation);
    t.hasOwnProperty("objectThreeObject") && e.dataMapper.clear(), e.dataMapper.onUpdateObj(function(l, u) {
      var c = +n(u), A = +r(u), m = +s(u);
      Object.assign(l.position, Xo(c, A, m)), o(u) ? l.setRotationFromEuler(new Ir(jc(-c), jc(A), 0, "YXZ")) : l.rotation.set(0, 0, 0);
      var _ = l.children[0], y = a(u);
      y && _.setRotationFromEuler(new Ir(jc(y.x || 0), jc(y.y || 0), jc(y.z || 0)));
    }).digest(e.objectsData);
  }
}), o7 = Sr({
  props: {
    customLayerData: {
      default: []
    },
    customThreeObject: {},
    customThreeObjectUpdate: {
      triggerUpdate: !1
    }
  },
  init: function(e, t) {
    bi(e), t.scene = e, t.dataMapper = new co(e, {
      objBindAttr: "__threeObjCustom"
    }).onCreateObj(function(n) {
      var r = je(t.customThreeObject)(n, Ci);
      return r && (t.customThreeObject === r && (r = r.clone()), r.__globeObjType = "custom"), r;
    });
  },
  update: function(e, t) {
    e.customThreeObjectUpdate || bi(e.scene);
    var n = je(e.customThreeObjectUpdate);
    t.hasOwnProperty("customThreeObject") && e.dataMapper.clear(), e.dataMapper.onUpdateObj(function(r, s) {
      return n(r, s, Ci);
    }).digest(e.customLayerData);
  }
}), Og = window.THREE ? window.THREE : {
  Camera: Jh,
  Group: As,
  Vector2: Le,
  Vector3: j
}, Fue = ["globeLayer", "pointsLayer", "arcsLayer", "hexBinLayer", "heatmapsLayer", "polygonsLayer", "hexedPolygonsLayer", "pathsLayer", "tilesLayer", "particlesLayer", "ringsLayer", "labelsLayer", "htmlElementsLayer", "objectsLayer", "customLayer"], a7 = Us("globeLayer", HI), Uue = Object.assign.apply(Object, _i(["globeImageUrl", "bumpImageUrl", "globeCurvatureResolution", "globeTileEngineUrl", "globeTileEngineMaxLevel", "showGlobe", "showGraticules", "showAtmosphere", "atmosphereColor", "atmosphereAltitude"].map(function(i) {
  return Ur({}, i, a7.linkProp(i));
}))), Oue = Object.assign.apply(Object, _i(["globeMaterial", "globeTileEngineClearCache"].map(function(i) {
  return Ur({}, i, a7.linkMethod(i));
}))), kue = Us("pointsLayer", WI), Vue = Object.assign.apply(Object, _i(["pointsData", "pointLat", "pointLng", "pointColor", "pointAltitude", "pointRadius", "pointResolution", "pointsMerge", "pointsTransitionDuration"].map(function(i) {
  return Ur({}, i, kue.linkProp(i));
}))), Gue = Us("arcsLayer", jI), zue = Object.assign.apply(Object, _i(["arcsData", "arcStartLat", "arcStartLng", "arcStartAltitude", "arcEndLat", "arcEndLng", "arcEndAltitude", "arcColor", "arcAltitude", "arcAltitudeAutoScale", "arcStroke", "arcCurveResolution", "arcCircularResolution", "arcDashLength", "arcDashGap", "arcDashInitialGap", "arcDashAnimateTime", "arcsTransitionDuration"].map(function(i) {
  return Ur({}, i, Gue.linkProp(i));
}))), que = Us("hexBinLayer", XI), Hue = Object.assign.apply(Object, _i(["hexBinPointsData", "hexBinPointLat", "hexBinPointLng", "hexBinPointWeight", "hexBinResolution", "hexMargin", "hexTopCurvatureResolution", "hexTopColor", "hexSideColor", "hexAltitude", "hexBinMerge", "hexTransitionDuration"].map(function(i) {
  return Ur({}, i, que.linkProp(i));
}))), Wue = Us("heatmapsLayer", QI), $ue = Object.assign.apply(Object, _i(["heatmapsData", "heatmapPoints", "heatmapPointLat", "heatmapPointLng", "heatmapPointWeight", "heatmapBandwidth", "heatmapColorFn", "heatmapColorSaturation", "heatmapBaseAltitude", "heatmapTopAltitude", "heatmapsTransitionDuration"].map(function(i) {
  return Ur({}, i, Wue.linkProp(i));
}))), jue = Us("hexedPolygonsLayer", ZI), Xue = Object.assign.apply(Object, _i(["hexPolygonsData", "hexPolygonGeoJsonGeometry", "hexPolygonColor", "hexPolygonAltitude", "hexPolygonResolution", "hexPolygonMargin", "hexPolygonUseDots", "hexPolygonCurvatureResolution", "hexPolygonDotResolution", "hexPolygonsTransitionDuration"].map(function(i) {
  return Ur({}, i, jue.linkProp(i));
}))), Yue = Us("polygonsLayer", KI), Que = Object.assign.apply(Object, _i(["polygonsData", "polygonGeoJsonGeometry", "polygonCapColor", "polygonCapMaterial", "polygonSideColor", "polygonSideMaterial", "polygonStrokeColor", "polygonAltitude", "polygonCapCurvatureResolution", "polygonsTransitionDuration"].map(function(i) {
  return Ur({}, i, Yue.linkProp(i));
}))), Kue = Us("pathsLayer", JI), Zue = Object.assign.apply(Object, _i(["pathsData", "pathPoints", "pathPointLat", "pathPointLng", "pathPointAlt", "pathResolution", "pathColor", "pathStroke", "pathDashLength", "pathDashGap", "pathDashInitialGap", "pathDashAnimateTime", "pathTransitionDuration"].map(function(i) {
  return Ur({}, i, Kue.linkProp(i));
}))), Jue = Us("tilesLayer", e7), ece = Object.assign.apply(Object, _i(["tilesData", "tileLat", "tileLng", "tileAltitude", "tileWidth", "tileHeight", "tileUseGlobeProjection", "tileMaterial", "tileCurvatureResolution", "tilesTransitionDuration"].map(function(i) {
  return Ur({}, i, Jue.linkProp(i));
}))), tce = Us("particlesLayer", t7), nce = Object.assign.apply(Object, _i(["particlesData", "particlesList", "particleLat", "particleLng", "particleAltitude", "particlesSize", "particlesSizeAttenuation", "particlesColor", "particlesTexture"].map(function(i) {
  return Ur({}, i, tce.linkProp(i));
}))), ice = Us("ringsLayer", n7), rce = Object.assign.apply(Object, _i(["ringsData", "ringLat", "ringLng", "ringAltitude", "ringColor", "ringResolution", "ringMaxRadius", "ringPropagationSpeed", "ringRepeatPeriod"].map(function(i) {
  return Ur({}, i, ice.linkProp(i));
}))), sce = Us("labelsLayer", i7), oce = Object.assign.apply(Object, _i(["labelsData", "labelLat", "labelLng", "labelAltitude", "labelRotation", "labelText", "labelSize", "labelTypeFace", "labelColor", "labelResolution", "labelIncludeDot", "labelDotRadius", "labelDotOrientation", "labelsTransitionDuration"].map(function(i) {
  return Ur({}, i, sce.linkProp(i));
}))), ace = Us("htmlElementsLayer", r7), lce = Object.assign.apply(Object, _i(["htmlElementsData", "htmlLat", "htmlLng", "htmlAltitude", "htmlElement", "htmlElementVisibilityModifier", "htmlTransitionDuration"].map(function(i) {
  return Ur({}, i, ace.linkProp(i));
}))), uce = Us("objectsLayer", s7), cce = Object.assign.apply(Object, _i(["objectsData", "objectLat", "objectLng", "objectAltitude", "objectRotation", "objectFacesSurface", "objectThreeObject"].map(function(i) {
  return Ur({}, i, uce.linkProp(i));
}))), hce = Us("customLayer", o7), dce = Object.assign.apply(Object, _i(["customLayerData", "customThreeObject", "customThreeObjectUpdate"].map(function(i) {
  return Ur({}, i, hce.linkProp(i));
}))), fce = Sr({
  props: ai(ai(ai(ai(ai(ai(ai(ai(ai(ai(ai(ai(ai(ai(ai({
    onGlobeReady: {
      triggerUpdate: !1
    },
    rendererSize: {
      default: new Og.Vector2(window.innerWidth, window.innerHeight),
      onChange: function(e, t) {
        t.pathsLayer.rendererSize(e);
      },
      triggerUpdate: !1
    }
  }, Uue), Vue), zue), Hue), $ue), Que), Xue), Zue), ece), nce), rce), oce), lce), cce), dce),
  methods: ai({
    getGlobeRadius: qC,
    getCoords: function(e) {
      for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
        n[r - 1] = arguments[r];
      return Xo.apply(void 0, n);
    },
    toGeoCoords: function(e) {
      for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
        n[r - 1] = arguments[r];
      return qI.apply(void 0, n);
    },
    setPointOfView: function(e, t) {
      var n = t instanceof Og.Camera ? t.position : t, r = qC(), s = void 0;
      if (e.scene && n) {
        var o, a, l, u;
        s = function(A) {
          o === void 0 && (o = n.clone().applyMatrix4(e.scene.matrixWorld.clone().invert())), a === void 0 && (a = o.length()), l === void 0 && (l = Math.sqrt(Math.pow(a, 2) - Math.pow(r, 2))), u === void 0 && (u = Math.acos(l / a));
          var m = o.distanceTo(A);
          if (m < l) return !1;
          var _ = A.length(), y = Math.acos((Math.pow(a, 2) + Math.pow(m, 2) - Math.pow(_, 2)) / (2 * a * m));
          return y < u;
        };
      }
      e.layersThatNeedUpdatePov.forEach(function(c) {
        return c.updatePov(t);
      }), e.layersThatNeedBehindGlobeChecker.forEach(function(c) {
        return c.isBehindGlobe(s);
      });
    },
    pauseAnimation: function(e) {
      return e.animationFrameRequestId !== null && (cancelAnimationFrame(e.animationFrameRequestId), e.animationFrameRequestId = null), e.pausableLayers.forEach(function(t) {
        var n;
        return (n = t.pauseAnimation) === null || n === void 0 ? void 0 : n.call(t);
      }), this;
    },
    resumeAnimation: function(e) {
      return e.animationFrameRequestId === null && this._animationCycle(), e.pausableLayers.forEach(function(t) {
        var n;
        return (n = t.resumeAnimation) === null || n === void 0 ? void 0 : n.call(t);
      }), this;
    },
    _animationCycle: function(e) {
      e.animationFrameRequestId = requestAnimationFrame(this._animationCycle), e.tweenGroup.update();
    },
    _destructor: function(e) {
      this.pauseAnimation(), e.destructableLayers.forEach(function(t) {
        return t._destructor();
      });
    }
  }, Oue),
  stateInit: function() {
    var e = new b2(), t = {
      tweenGroup: e
    }, n = {
      globeLayer: HI(t),
      pointsLayer: WI(t),
      arcsLayer: jI(t),
      hexBinLayer: XI(t),
      heatmapsLayer: QI(t),
      polygonsLayer: KI(t),
      hexedPolygonsLayer: ZI(t),
      pathsLayer: JI(t),
      tilesLayer: e7(t),
      particlesLayer: t7(t),
      ringsLayer: n7(t),
      labelsLayer: i7(t),
      htmlElementsLayer: r7(t),
      objectsLayer: s7(t),
      customLayer: o7(t)
    };
    return ai(ai({
      tweenGroup: e
    }, n), {}, {
      layersThatNeedUpdatePov: Object.values(n).filter(function(r) {
        return r.hasOwnProperty("updatePov");
      }),
      layersThatNeedBehindGlobeChecker: Object.values(n).filter(function(r) {
        return r.hasOwnProperty("isBehindGlobe");
      }),
      destructableLayers: Object.values(n).filter(function(r) {
        return r.hasOwnProperty("_destructor");
      }),
      pausableLayers: Object.values(n).filter(function(r) {
        return r.hasOwnProperty("pauseAnimation");
      })
    });
  },
  init: function(e, t, n) {
    var r = n.animateIn, s = r === void 0 ? !0 : r, o = n.waitForGlobeReady, a = o === void 0 ? !0 : o;
    bi(e), t.scene = e, t.scene.visible = !1, Fue.forEach(function(u) {
      var c = new Og.Group();
      t.scene.add(c), t[u](c);
    });
    var l = function() {
      if (s) {
        t.scene.scale.set(1e-6, 1e-6, 1e-6), t.tweenGroup.add(new xs({
          k: 1e-6
        }).to({
          k: 1
        }, 600).easing(Ar.Quadratic.Out).onUpdate(function(A) {
          var m = A.k;
          return t.scene.scale.set(m, m, m);
        }).start());
        var c = new Og.Vector3(0, 1, 0);
        t.tweenGroup.add(new xs({
          rot: Math.PI * 2
        }).to({
          rot: 0
        }, 1200).easing(Ar.Quintic.Out).onUpdate(function(A) {
          var m = A.rot;
          return t.scene.setRotationFromAxisAngle(c, m);
        }).start());
      }
      t.scene.visible = !0, t.onGlobeReady && t.onGlobeReady();
    };
    a ? t.globeLayer.onReady(l) : l(), this._animationCycle();
  },
  update: function(e) {
  }
});
function Ace(i) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Object, t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, n = /* @__PURE__ */ (function(r) {
    function s() {
      var o;
      ox(this, s);
      for (var a = arguments.length, l = new Array(a), u = 0; u < a; u++)
        l[u] = arguments[u];
      return o = sx(this, s, [].concat(l)), o.__kapsuleInstance = hw(i, [].concat(_i(t ? [o] : []), l)), o;
    }
    return lx(s, r), ax(s);
  })(e);
  return Object.keys(i()).forEach(function(r) {
    return n.prototype[r] = function() {
      var s, o = (s = this.__kapsuleInstance)[r].apply(s, arguments);
      return o === this.__kapsuleInstance ? this : o;
    };
  }), n;
}
var pce = window.THREE ? window.THREE : {
  Group: As
}, l7 = Ace(fce, pce.Group, !0);
const Rv = { type: "change" }, pw = { type: "start" }, mw = { type: "end" }, ZC = 1e-6, ii = { NONE: -1, ROTATE: 0, ZOOM: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_ZOOM_PAN: 4 }, kg = new Le(), Su = new Le(), mce = new j(), Vg = new j(), Cv = new j(), rf = new hr(), JC = new j(), Gg = new j(), Pv = new j(), zg = new j();
class gce extends x2 {
  /**
   * Constructs a new controls instance.
   *
   * @param {Object3D} object - The object that is managed by the controls.
   * @param {?HTMLElement} domElement - The HTML element used for event listeners.
   */
  constructor(e, t = null) {
    super(e, t), this.screen = { left: 0, top: 0, width: 0, height: 0 }, this.rotateSpeed = 1, this.zoomSpeed = 1.2, this.panSpeed = 0.3, this.noRotate = !1, this.noZoom = !1, this.noPan = !1, this.staticMoving = !1, this.dynamicDampingFactor = 0.2, this.minDistance = 0, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.keys = [
      "KeyA",
      "KeyS",
      "KeyD"
      /*D*/
    ], this.mouseButtons = { LEFT: So.ROTATE, MIDDLE: So.DOLLY, RIGHT: So.PAN }, this.target = new j(), this.state = ii.NONE, this.keyState = ii.NONE, this._lastPosition = new j(), this._lastZoom = 1, this._touchZoomDistanceStart = 0, this._touchZoomDistanceEnd = 0, this._lastAngle = 0, this._eye = new j(), this._movePrev = new Le(), this._moveCurr = new Le(), this._lastAxis = new j(), this._zoomStart = new Le(), this._zoomEnd = new Le(), this._panStart = new Le(), this._panEnd = new Le(), this._pointers = [], this._pointerPositions = {}, this._onPointerMove = xce.bind(this), this._onPointerDown = _ce.bind(this), this._onPointerUp = yce.bind(this), this._onPointerCancel = vce.bind(this), this._onContextMenu = Rce.bind(this), this._onMouseWheel = Ece.bind(this), this._onKeyDown = Sce.bind(this), this._onKeyUp = bce.bind(this), this._onTouchStart = Cce.bind(this), this._onTouchMove = Pce.bind(this), this._onTouchEnd = Nce.bind(this), this._onMouseDown = Tce.bind(this), this._onMouseMove = wce.bind(this), this._onMouseUp = Mce.bind(this), this._target0 = this.target.clone(), this._position0 = this.object.position.clone(), this._up0 = this.object.up.clone(), this._zoom0 = this.object.zoom, t !== null && (this.connect(t), this.handleResize()), this.update();
  }
  connect(e) {
    super.connect(e), window.addEventListener("keydown", this._onKeyDown), window.addEventListener("keyup", this._onKeyUp), this.domElement.addEventListener("pointerdown", this._onPointerDown), this.domElement.addEventListener("pointercancel", this._onPointerCancel), this.domElement.addEventListener("wheel", this._onMouseWheel, { passive: !1 }), this.domElement.addEventListener("contextmenu", this._onContextMenu), this.domElement.style.touchAction = "none";
  }
  disconnect() {
    window.removeEventListener("keydown", this._onKeyDown), window.removeEventListener("keyup", this._onKeyUp), this.domElement.removeEventListener("pointerdown", this._onPointerDown), this.domElement.ownerDocument.removeEventListener("pointermove", this._onPointerMove), this.domElement.ownerDocument.removeEventListener("pointerup", this._onPointerUp), this.domElement.removeEventListener("pointercancel", this._onPointerCancel), this.domElement.removeEventListener("wheel", this._onMouseWheel), this.domElement.removeEventListener("contextmenu", this._onContextMenu), this.domElement.style.touchAction = "auto";
  }
  dispose() {
    this.disconnect();
  }
  /**
   * Must be called if the application window is resized.
   */
  handleResize() {
    const e = this.domElement.getBoundingClientRect(), t = this.domElement.ownerDocument.documentElement;
    this.screen.left = e.left + window.pageXOffset - t.clientLeft, this.screen.top = e.top + window.pageYOffset - t.clientTop, this.screen.width = e.width, this.screen.height = e.height;
  }
  update() {
    this._eye.subVectors(this.object.position, this.target), this.noRotate || this._rotateCamera(), this.noZoom || this._zoomCamera(), this.noPan || this._panCamera(), this.object.position.addVectors(this.target, this._eye), this.object.isPerspectiveCamera ? (this._checkDistances(), this.object.lookAt(this.target), this._lastPosition.distanceToSquared(this.object.position) > ZC && (this.dispatchEvent(Rv), this._lastPosition.copy(this.object.position))) : this.object.isOrthographicCamera ? (this.object.lookAt(this.target), (this._lastPosition.distanceToSquared(this.object.position) > ZC || this._lastZoom !== this.object.zoom) && (this.dispatchEvent(Rv), this._lastPosition.copy(this.object.position), this._lastZoom = this.object.zoom)) : console.warn("THREE.TrackballControls: Unsupported camera type.");
  }
  /**
   * Resets the controls to its initial state.
   */
  reset() {
    this.state = ii.NONE, this.keyState = ii.NONE, this.target.copy(this._target0), this.object.position.copy(this._position0), this.object.up.copy(this._up0), this.object.zoom = this._zoom0, this.object.updateProjectionMatrix(), this._eye.subVectors(this.object.position, this.target), this.object.lookAt(this.target), this.dispatchEvent(Rv), this._lastPosition.copy(this.object.position), this._lastZoom = this.object.zoom;
  }
  _panCamera() {
    if (Su.copy(this._panEnd).sub(this._panStart), Su.lengthSq()) {
      if (this.object.isOrthographicCamera) {
        const e = (this.object.right - this.object.left) / this.object.zoom / this.domElement.clientWidth, t = (this.object.top - this.object.bottom) / this.object.zoom / this.domElement.clientWidth;
        Su.x *= e, Su.y *= t;
      }
      Su.multiplyScalar(this._eye.length() * this.panSpeed), Vg.copy(this._eye).cross(this.object.up).setLength(Su.x), Vg.add(mce.copy(this.object.up).setLength(Su.y)), this.object.position.add(Vg), this.target.add(Vg), this.staticMoving ? this._panStart.copy(this._panEnd) : this._panStart.add(Su.subVectors(this._panEnd, this._panStart).multiplyScalar(this.dynamicDampingFactor));
    }
  }
  _rotateCamera() {
    zg.set(this._moveCurr.x - this._movePrev.x, this._moveCurr.y - this._movePrev.y, 0);
    let e = zg.length();
    e ? (this._eye.copy(this.object.position).sub(this.target), JC.copy(this._eye).normalize(), Gg.copy(this.object.up).normalize(), Pv.crossVectors(Gg, JC).normalize(), Gg.setLength(this._moveCurr.y - this._movePrev.y), Pv.setLength(this._moveCurr.x - this._movePrev.x), zg.copy(Gg.add(Pv)), Cv.crossVectors(zg, this._eye).normalize(), e *= this.rotateSpeed, rf.setFromAxisAngle(Cv, e), this._eye.applyQuaternion(rf), this.object.up.applyQuaternion(rf), this._lastAxis.copy(Cv), this._lastAngle = e) : !this.staticMoving && this._lastAngle && (this._lastAngle *= Math.sqrt(1 - this.dynamicDampingFactor), this._eye.copy(this.object.position).sub(this.target), rf.setFromAxisAngle(this._lastAxis, this._lastAngle), this._eye.applyQuaternion(rf), this.object.up.applyQuaternion(rf)), this._movePrev.copy(this._moveCurr);
  }
  _zoomCamera() {
    let e;
    this.state === ii.TOUCH_ZOOM_PAN ? (e = this._touchZoomDistanceStart / this._touchZoomDistanceEnd, this._touchZoomDistanceStart = this._touchZoomDistanceEnd, this.object.isPerspectiveCamera ? this._eye.multiplyScalar(e) : this.object.isOrthographicCamera ? (this.object.zoom = zh.clamp(this.object.zoom / e, this.minZoom, this.maxZoom), this._lastZoom !== this.object.zoom && this.object.updateProjectionMatrix()) : console.warn("THREE.TrackballControls: Unsupported camera type")) : (e = 1 + (this._zoomEnd.y - this._zoomStart.y) * this.zoomSpeed, e !== 1 && e > 0 && (this.object.isPerspectiveCamera ? this._eye.multiplyScalar(e) : this.object.isOrthographicCamera ? (this.object.zoom = zh.clamp(this.object.zoom / e, this.minZoom, this.maxZoom), this._lastZoom !== this.object.zoom && this.object.updateProjectionMatrix()) : console.warn("THREE.TrackballControls: Unsupported camera type")), this.staticMoving ? this._zoomStart.copy(this._zoomEnd) : this._zoomStart.y += (this._zoomEnd.y - this._zoomStart.y) * this.dynamicDampingFactor);
  }
  _getMouseOnScreen(e, t) {
    return kg.set(
      (e - this.screen.left) / this.screen.width,
      (t - this.screen.top) / this.screen.height
    ), kg;
  }
  _getMouseOnCircle(e, t) {
    return kg.set(
      (e - this.screen.width * 0.5 - this.screen.left) / (this.screen.width * 0.5),
      (this.screen.height + 2 * (this.screen.top - t)) / this.screen.width
      // screen.width intentional
    ), kg;
  }
  _addPointer(e) {
    this._pointers.push(e);
  }
  _removePointer(e) {
    delete this._pointerPositions[e.pointerId];
    for (let t = 0; t < this._pointers.length; t++)
      if (this._pointers[t].pointerId == e.pointerId) {
        this._pointers.splice(t, 1);
        return;
      }
  }
  _trackPointer(e) {
    let t = this._pointerPositions[e.pointerId];
    t === void 0 && (t = new Le(), this._pointerPositions[e.pointerId] = t), t.set(e.pageX, e.pageY);
  }
  _getSecondPointerPosition(e) {
    const t = e.pointerId === this._pointers[0].pointerId ? this._pointers[1] : this._pointers[0];
    return this._pointerPositions[t.pointerId];
  }
  _checkDistances() {
    (!this.noZoom || !this.noPan) && (this._eye.lengthSq() > this.maxDistance * this.maxDistance && (this.object.position.addVectors(this.target, this._eye.setLength(this.maxDistance)), this._zoomStart.copy(this._zoomEnd)), this._eye.lengthSq() < this.minDistance * this.minDistance && (this.object.position.addVectors(this.target, this._eye.setLength(this.minDistance)), this._zoomStart.copy(this._zoomEnd)));
  }
}
function _ce(i) {
  this.enabled !== !1 && (this._pointers.length === 0 && (this.domElement.setPointerCapture(i.pointerId), this.domElement.ownerDocument.addEventListener("pointermove", this._onPointerMove), this.domElement.ownerDocument.addEventListener("pointerup", this._onPointerUp)), this._addPointer(i), i.pointerType === "touch" ? this._onTouchStart(i) : this._onMouseDown(i));
}
function xce(i) {
  this.enabled !== !1 && (i.pointerType === "touch" ? this._onTouchMove(i) : this._onMouseMove(i));
}
function yce(i) {
  this.enabled !== !1 && (i.pointerType === "touch" ? this._onTouchEnd(i) : this._onMouseUp(), this._removePointer(i), this._pointers.length === 0 && (this.domElement.releasePointerCapture(i.pointerId), this.domElement.ownerDocument.removeEventListener("pointermove", this._onPointerMove), this.domElement.ownerDocument.removeEventListener("pointerup", this._onPointerUp)));
}
function vce(i) {
  this._removePointer(i);
}
function bce() {
  this.enabled !== !1 && (this.keyState = ii.NONE, window.addEventListener("keydown", this._onKeyDown));
}
function Sce(i) {
  this.enabled !== !1 && (window.removeEventListener("keydown", this._onKeyDown), this.keyState === ii.NONE && (i.code === this.keys[ii.ROTATE] && !this.noRotate ? this.keyState = ii.ROTATE : i.code === this.keys[ii.ZOOM] && !this.noZoom ? this.keyState = ii.ZOOM : i.code === this.keys[ii.PAN] && !this.noPan && (this.keyState = ii.PAN)));
}
function Tce(i) {
  let e;
  switch (i.button) {
    case 0:
      e = this.mouseButtons.LEFT;
      break;
    case 1:
      e = this.mouseButtons.MIDDLE;
      break;
    case 2:
      e = this.mouseButtons.RIGHT;
      break;
    default:
      e = -1;
  }
  switch (e) {
    case So.DOLLY:
      this.state = ii.ZOOM;
      break;
    case So.ROTATE:
      this.state = ii.ROTATE;
      break;
    case So.PAN:
      this.state = ii.PAN;
      break;
    default:
      this.state = ii.NONE;
  }
  const t = this.keyState !== ii.NONE ? this.keyState : this.state;
  t === ii.ROTATE && !this.noRotate ? (this._moveCurr.copy(this._getMouseOnCircle(i.pageX, i.pageY)), this._movePrev.copy(this._moveCurr)) : t === ii.ZOOM && !this.noZoom ? (this._zoomStart.copy(this._getMouseOnScreen(i.pageX, i.pageY)), this._zoomEnd.copy(this._zoomStart)) : t === ii.PAN && !this.noPan && (this._panStart.copy(this._getMouseOnScreen(i.pageX, i.pageY)), this._panEnd.copy(this._panStart)), this.dispatchEvent(pw);
}
function wce(i) {
  const e = this.keyState !== ii.NONE ? this.keyState : this.state;
  e === ii.ROTATE && !this.noRotate ? (this._movePrev.copy(this._moveCurr), this._moveCurr.copy(this._getMouseOnCircle(i.pageX, i.pageY))) : e === ii.ZOOM && !this.noZoom ? this._zoomEnd.copy(this._getMouseOnScreen(i.pageX, i.pageY)) : e === ii.PAN && !this.noPan && this._panEnd.copy(this._getMouseOnScreen(i.pageX, i.pageY));
}
function Mce() {
  this.state = ii.NONE, this.dispatchEvent(mw);
}
function Ece(i) {
  if (this.enabled !== !1 && this.noZoom !== !0) {
    switch (i.preventDefault(), i.deltaMode) {
      case 2:
        this._zoomStart.y -= i.deltaY * 0.025;
        break;
      case 1:
        this._zoomStart.y -= i.deltaY * 0.01;
        break;
      default:
        this._zoomStart.y -= i.deltaY * 25e-5;
        break;
    }
    this.dispatchEvent(pw), this.dispatchEvent(mw);
  }
}
function Rce(i) {
  this.enabled !== !1 && i.preventDefault();
}
function Cce(i) {
  if (this._trackPointer(i), this._pointers.length === 1)
    this.state = ii.TOUCH_ROTATE, this._moveCurr.copy(this._getMouseOnCircle(this._pointers[0].pageX, this._pointers[0].pageY)), this._movePrev.copy(this._moveCurr);
  else {
    this.state = ii.TOUCH_ZOOM_PAN;
    const e = this._pointers[0].pageX - this._pointers[1].pageX, t = this._pointers[0].pageY - this._pointers[1].pageY;
    this._touchZoomDistanceEnd = this._touchZoomDistanceStart = Math.sqrt(e * e + t * t);
    const n = (this._pointers[0].pageX + this._pointers[1].pageX) / 2, r = (this._pointers[0].pageY + this._pointers[1].pageY) / 2;
    this._panStart.copy(this._getMouseOnScreen(n, r)), this._panEnd.copy(this._panStart);
  }
  this.dispatchEvent(pw);
}
function Pce(i) {
  if (this._trackPointer(i), this._pointers.length === 1)
    this._movePrev.copy(this._moveCurr), this._moveCurr.copy(this._getMouseOnCircle(i.pageX, i.pageY));
  else {
    const e = this._getSecondPointerPosition(i), t = i.pageX - e.x, n = i.pageY - e.y;
    this._touchZoomDistanceEnd = Math.sqrt(t * t + n * n);
    const r = (i.pageX + e.x) / 2, s = (i.pageY + e.y) / 2;
    this._panEnd.copy(this._getMouseOnScreen(r, s));
  }
}
function Nce(i) {
  switch (this._pointers.length) {
    case 0:
      this.state = ii.NONE;
      break;
    case 1:
      this.state = ii.TOUCH_ROTATE, this._moveCurr.copy(this._getMouseOnCircle(i.pageX, i.pageY)), this._movePrev.copy(this._moveCurr);
      break;
    case 2:
      this.state = ii.TOUCH_ZOOM_PAN;
      for (let e = 0; e < this._pointers.length; e++)
        if (this._pointers[e].pointerId !== i.pointerId) {
          const t = this._pointerPositions[this._pointers[e].pointerId];
          this._moveCurr.copy(this._getMouseOnCircle(t.x, t.y)), this._movePrev.copy(this._moveCurr);
          break;
        }
      break;
  }
  this.dispatchEvent(mw);
}
const e5 = { type: "change" }, gw = { type: "start" }, u7 = { type: "end" }, qg = new Zh(), t5 = new ca(), Dce = Math.cos(70 * zh.DEG2RAD), mr = new j(), qs = 2 * Math.PI, yi = {
  NONE: -1,
  ROTATE: 0,
  DOLLY: 1,
  PAN: 2,
  TOUCH_ROTATE: 3,
  TOUCH_PAN: 4,
  TOUCH_DOLLY_PAN: 5,
  TOUCH_DOLLY_ROTATE: 6
}, Nv = 1e-6;
class Lce extends x2 {
  /**
   * Constructs a new controls instance.
   *
   * @param {Object3D} object - The object that is managed by the controls.
   * @param {?HTMLElement} domElement - The HTML element used for event listeners.
   */
  constructor(e, t = null) {
    super(e, t), this.state = yi.NONE, this.target = new j(), this.cursor = new j(), this.minDistance = 0, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.minTargetRadius = 0, this.maxTargetRadius = 1 / 0, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.enableDamping = !1, this.dampingFactor = 0.05, this.enableZoom = !0, this.zoomSpeed = 1, this.enableRotate = !0, this.rotateSpeed = 1, this.keyRotateSpeed = 1, this.enablePan = !0, this.panSpeed = 1, this.screenSpacePanning = !0, this.keyPanSpeed = 7, this.zoomToCursor = !1, this.autoRotate = !1, this.autoRotateSpeed = 2, this.keys = { LEFT: "ArrowLeft", UP: "ArrowUp", RIGHT: "ArrowRight", BOTTOM: "ArrowDown" }, this.mouseButtons = { LEFT: So.ROTATE, MIDDLE: So.DOLLY, RIGHT: So.PAN }, this.touches = { ONE: Qc.ROTATE, TWO: Qc.DOLLY_PAN }, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this._domElementKeyEvents = null, this._lastPosition = new j(), this._lastQuaternion = new hr(), this._lastTargetPosition = new j(), this._quat = new hr().setFromUnitVectors(e.up, new j(0, 1, 0)), this._quatInverse = this._quat.clone().invert(), this._spherical = new Hv(), this._sphericalDelta = new Hv(), this._scale = 1, this._panOffset = new j(), this._rotateStart = new Le(), this._rotateEnd = new Le(), this._rotateDelta = new Le(), this._panStart = new Le(), this._panEnd = new Le(), this._panDelta = new Le(), this._dollyStart = new Le(), this._dollyEnd = new Le(), this._dollyDelta = new Le(), this._dollyDirection = new j(), this._mouse = new Le(), this._performCursorZoom = !1, this._pointers = [], this._pointerPositions = {}, this._controlActive = !1, this._onPointerMove = Bce.bind(this), this._onPointerDown = Ice.bind(this), this._onPointerUp = Fce.bind(this), this._onContextMenu = qce.bind(this), this._onMouseWheel = kce.bind(this), this._onKeyDown = Vce.bind(this), this._onTouchStart = Gce.bind(this), this._onTouchMove = zce.bind(this), this._onMouseDown = Uce.bind(this), this._onMouseMove = Oce.bind(this), this._interceptControlDown = Hce.bind(this), this._interceptControlUp = Wce.bind(this), this.domElement !== null && this.connect(this.domElement), this.update();
  }
  connect(e) {
    super.connect(e), this.domElement.addEventListener("pointerdown", this._onPointerDown), this.domElement.addEventListener("pointercancel", this._onPointerUp), this.domElement.addEventListener("contextmenu", this._onContextMenu), this.domElement.addEventListener("wheel", this._onMouseWheel, { passive: !1 }), this.domElement.getRootNode().addEventListener("keydown", this._interceptControlDown, { passive: !0, capture: !0 }), this.domElement.style.touchAction = "none";
  }
  disconnect() {
    this.domElement.removeEventListener("pointerdown", this._onPointerDown), this.domElement.ownerDocument.removeEventListener("pointermove", this._onPointerMove), this.domElement.ownerDocument.removeEventListener("pointerup", this._onPointerUp), this.domElement.removeEventListener("pointercancel", this._onPointerUp), this.domElement.removeEventListener("wheel", this._onMouseWheel), this.domElement.removeEventListener("contextmenu", this._onContextMenu), this.stopListenToKeyEvents(), this.domElement.getRootNode().removeEventListener("keydown", this._interceptControlDown, { capture: !0 }), this.domElement.style.touchAction = "auto";
  }
  dispose() {
    this.disconnect();
  }
  /**
   * Get the current vertical rotation, in radians.
   *
   * @return {number} The current vertical rotation, in radians.
   */
  getPolarAngle() {
    return this._spherical.phi;
  }
  /**
   * Get the current horizontal rotation, in radians.
   *
   * @return {number} The current horizontal rotation, in radians.
   */
  getAzimuthalAngle() {
    return this._spherical.theta;
  }
  /**
   * Returns the distance from the camera to the target.
   *
   * @return {number} The distance from the camera to the target.
   */
  getDistance() {
    return this.object.position.distanceTo(this.target);
  }
  /**
   * Adds key event listeners to the given DOM element.
   * `window` is a recommended argument for using this method.
   *
   * @param {HTMLElement} domElement - The DOM element
   */
  listenToKeyEvents(e) {
    e.addEventListener("keydown", this._onKeyDown), this._domElementKeyEvents = e;
  }
  /**
   * Removes the key event listener previously defined with `listenToKeyEvents()`.
   */
  stopListenToKeyEvents() {
    this._domElementKeyEvents !== null && (this._domElementKeyEvents.removeEventListener("keydown", this._onKeyDown), this._domElementKeyEvents = null);
  }
  /**
   * Save the current state of the controls. This can later be recovered with `reset()`.
   */
  saveState() {
    this.target0.copy(this.target), this.position0.copy(this.object.position), this.zoom0 = this.object.zoom;
  }
  /**
   * Reset the controls to their state from either the last time the `saveState()`
   * was called, or the initial state.
   */
  reset() {
    this.target.copy(this.target0), this.object.position.copy(this.position0), this.object.zoom = this.zoom0, this.object.updateProjectionMatrix(), this.dispatchEvent(e5), this.update(), this.state = yi.NONE;
  }
  update(e = null) {
    const t = this.object.position;
    mr.copy(t).sub(this.target), mr.applyQuaternion(this._quat), this._spherical.setFromVector3(mr), this.autoRotate && this.state === yi.NONE && this._rotateLeft(this._getAutoRotationAngle(e)), this.enableDamping ? (this._spherical.theta += this._sphericalDelta.theta * this.dampingFactor, this._spherical.phi += this._sphericalDelta.phi * this.dampingFactor) : (this._spherical.theta += this._sphericalDelta.theta, this._spherical.phi += this._sphericalDelta.phi);
    let n = this.minAzimuthAngle, r = this.maxAzimuthAngle;
    isFinite(n) && isFinite(r) && (n < -Math.PI ? n += qs : n > Math.PI && (n -= qs), r < -Math.PI ? r += qs : r > Math.PI && (r -= qs), n <= r ? this._spherical.theta = Math.max(n, Math.min(r, this._spherical.theta)) : this._spherical.theta = this._spherical.theta > (n + r) / 2 ? Math.max(n, this._spherical.theta) : Math.min(r, this._spherical.theta)), this._spherical.phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, this._spherical.phi)), this._spherical.makeSafe(), this.enableDamping === !0 ? this.target.addScaledVector(this._panOffset, this.dampingFactor) : this.target.add(this._panOffset), this.target.sub(this.cursor), this.target.clampLength(this.minTargetRadius, this.maxTargetRadius), this.target.add(this.cursor);
    let s = !1;
    if (this.zoomToCursor && this._performCursorZoom || this.object.isOrthographicCamera)
      this._spherical.radius = this._clampDistance(this._spherical.radius);
    else {
      const o = this._spherical.radius;
      this._spherical.radius = this._clampDistance(this._spherical.radius * this._scale), s = o != this._spherical.radius;
    }
    if (mr.setFromSpherical(this._spherical), mr.applyQuaternion(this._quatInverse), t.copy(this.target).add(mr), this.object.lookAt(this.target), this.enableDamping === !0 ? (this._sphericalDelta.theta *= 1 - this.dampingFactor, this._sphericalDelta.phi *= 1 - this.dampingFactor, this._panOffset.multiplyScalar(1 - this.dampingFactor)) : (this._sphericalDelta.set(0, 0, 0), this._panOffset.set(0, 0, 0)), this.zoomToCursor && this._performCursorZoom) {
      let o = null;
      if (this.object.isPerspectiveCamera) {
        const a = mr.length();
        o = this._clampDistance(a * this._scale);
        const l = a - o;
        this.object.position.addScaledVector(this._dollyDirection, l), this.object.updateMatrixWorld(), s = !!l;
      } else if (this.object.isOrthographicCamera) {
        const a = new j(this._mouse.x, this._mouse.y, 0);
        a.unproject(this.object);
        const l = this.object.zoom;
        this.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom / this._scale)), this.object.updateProjectionMatrix(), s = l !== this.object.zoom;
        const u = new j(this._mouse.x, this._mouse.y, 0);
        u.unproject(this.object), this.object.position.sub(u).add(a), this.object.updateMatrixWorld(), o = mr.length();
      } else
        console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."), this.zoomToCursor = !1;
      o !== null && (this.screenSpacePanning ? this.target.set(0, 0, -1).transformDirection(this.object.matrix).multiplyScalar(o).add(this.object.position) : (qg.origin.copy(this.object.position), qg.direction.set(0, 0, -1).transformDirection(this.object.matrix), Math.abs(this.object.up.dot(qg.direction)) < Dce ? this.object.lookAt(this.target) : (t5.setFromNormalAndCoplanarPoint(this.object.up, this.target), qg.intersectPlane(t5, this.target))));
    } else if (this.object.isOrthographicCamera) {
      const o = this.object.zoom;
      this.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom / this._scale)), o !== this.object.zoom && (this.object.updateProjectionMatrix(), s = !0);
    }
    return this._scale = 1, this._performCursorZoom = !1, s || this._lastPosition.distanceToSquared(this.object.position) > Nv || 8 * (1 - this._lastQuaternion.dot(this.object.quaternion)) > Nv || this._lastTargetPosition.distanceToSquared(this.target) > Nv ? (this.dispatchEvent(e5), this._lastPosition.copy(this.object.position), this._lastQuaternion.copy(this.object.quaternion), this._lastTargetPosition.copy(this.target), !0) : !1;
  }
  _getAutoRotationAngle(e) {
    return e !== null ? qs / 60 * this.autoRotateSpeed * e : qs / 60 / 60 * this.autoRotateSpeed;
  }
  _getZoomScale(e) {
    const t = Math.abs(e * 0.01);
    return Math.pow(0.95, this.zoomSpeed * t);
  }
  _rotateLeft(e) {
    this._sphericalDelta.theta -= e;
  }
  _rotateUp(e) {
    this._sphericalDelta.phi -= e;
  }
  _panLeft(e, t) {
    mr.setFromMatrixColumn(t, 0), mr.multiplyScalar(-e), this._panOffset.add(mr);
  }
  _panUp(e, t) {
    this.screenSpacePanning === !0 ? mr.setFromMatrixColumn(t, 1) : (mr.setFromMatrixColumn(t, 0), mr.crossVectors(this.object.up, mr)), mr.multiplyScalar(e), this._panOffset.add(mr);
  }
  // deltaX and deltaY are in pixels; right and down are positive
  _pan(e, t) {
    const n = this.domElement;
    if (this.object.isPerspectiveCamera) {
      const r = this.object.position;
      mr.copy(r).sub(this.target);
      let s = mr.length();
      s *= Math.tan(this.object.fov / 2 * Math.PI / 180), this._panLeft(2 * e * s / n.clientHeight, this.object.matrix), this._panUp(2 * t * s / n.clientHeight, this.object.matrix);
    } else this.object.isOrthographicCamera ? (this._panLeft(e * (this.object.right - this.object.left) / this.object.zoom / n.clientWidth, this.object.matrix), this._panUp(t * (this.object.top - this.object.bottom) / this.object.zoom / n.clientHeight, this.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), this.enablePan = !1);
  }
  _dollyOut(e) {
    this.object.isPerspectiveCamera || this.object.isOrthographicCamera ? this._scale /= e : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), this.enableZoom = !1);
  }
  _dollyIn(e) {
    this.object.isPerspectiveCamera || this.object.isOrthographicCamera ? this._scale *= e : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), this.enableZoom = !1);
  }
  _updateZoomParameters(e, t) {
    if (!this.zoomToCursor)
      return;
    this._performCursorZoom = !0;
    const n = this.domElement.getBoundingClientRect(), r = e - n.left, s = t - n.top, o = n.width, a = n.height;
    this._mouse.x = r / o * 2 - 1, this._mouse.y = -(s / a) * 2 + 1, this._dollyDirection.set(this._mouse.x, this._mouse.y, 1).unproject(this.object).sub(this.object.position).normalize();
  }
  _clampDistance(e) {
    return Math.max(this.minDistance, Math.min(this.maxDistance, e));
  }
  //
  // event callbacks - update the object state
  //
  _handleMouseDownRotate(e) {
    this._rotateStart.set(e.clientX, e.clientY);
  }
  _handleMouseDownDolly(e) {
    this._updateZoomParameters(e.clientX, e.clientX), this._dollyStart.set(e.clientX, e.clientY);
  }
  _handleMouseDownPan(e) {
    this._panStart.set(e.clientX, e.clientY);
  }
  _handleMouseMoveRotate(e) {
    this._rotateEnd.set(e.clientX, e.clientY), this._rotateDelta.subVectors(this._rotateEnd, this._rotateStart).multiplyScalar(this.rotateSpeed);
    const t = this.domElement;
    this._rotateLeft(qs * this._rotateDelta.x / t.clientHeight), this._rotateUp(qs * this._rotateDelta.y / t.clientHeight), this._rotateStart.copy(this._rotateEnd), this.update();
  }
  _handleMouseMoveDolly(e) {
    this._dollyEnd.set(e.clientX, e.clientY), this._dollyDelta.subVectors(this._dollyEnd, this._dollyStart), this._dollyDelta.y > 0 ? this._dollyOut(this._getZoomScale(this._dollyDelta.y)) : this._dollyDelta.y < 0 && this._dollyIn(this._getZoomScale(this._dollyDelta.y)), this._dollyStart.copy(this._dollyEnd), this.update();
  }
  _handleMouseMovePan(e) {
    this._panEnd.set(e.clientX, e.clientY), this._panDelta.subVectors(this._panEnd, this._panStart).multiplyScalar(this.panSpeed), this._pan(this._panDelta.x, this._panDelta.y), this._panStart.copy(this._panEnd), this.update();
  }
  _handleMouseWheel(e) {
    this._updateZoomParameters(e.clientX, e.clientY), e.deltaY < 0 ? this._dollyIn(this._getZoomScale(e.deltaY)) : e.deltaY > 0 && this._dollyOut(this._getZoomScale(e.deltaY)), this.update();
  }
  _handleKeyDown(e) {
    let t = !1;
    switch (e.code) {
      case this.keys.UP:
        e.ctrlKey || e.metaKey || e.shiftKey ? this.enableRotate && this._rotateUp(qs * this.keyRotateSpeed / this.domElement.clientHeight) : this.enablePan && this._pan(0, this.keyPanSpeed), t = !0;
        break;
      case this.keys.BOTTOM:
        e.ctrlKey || e.metaKey || e.shiftKey ? this.enableRotate && this._rotateUp(-qs * this.keyRotateSpeed / this.domElement.clientHeight) : this.enablePan && this._pan(0, -this.keyPanSpeed), t = !0;
        break;
      case this.keys.LEFT:
        e.ctrlKey || e.metaKey || e.shiftKey ? this.enableRotate && this._rotateLeft(qs * this.keyRotateSpeed / this.domElement.clientHeight) : this.enablePan && this._pan(this.keyPanSpeed, 0), t = !0;
        break;
      case this.keys.RIGHT:
        e.ctrlKey || e.metaKey || e.shiftKey ? this.enableRotate && this._rotateLeft(-qs * this.keyRotateSpeed / this.domElement.clientHeight) : this.enablePan && this._pan(-this.keyPanSpeed, 0), t = !0;
        break;
    }
    t && (e.preventDefault(), this.update());
  }
  _handleTouchStartRotate(e) {
    if (this._pointers.length === 1)
      this._rotateStart.set(e.pageX, e.pageY);
    else {
      const t = this._getSecondPointerPosition(e), n = 0.5 * (e.pageX + t.x), r = 0.5 * (e.pageY + t.y);
      this._rotateStart.set(n, r);
    }
  }
  _handleTouchStartPan(e) {
    if (this._pointers.length === 1)
      this._panStart.set(e.pageX, e.pageY);
    else {
      const t = this._getSecondPointerPosition(e), n = 0.5 * (e.pageX + t.x), r = 0.5 * (e.pageY + t.y);
      this._panStart.set(n, r);
    }
  }
  _handleTouchStartDolly(e) {
    const t = this._getSecondPointerPosition(e), n = e.pageX - t.x, r = e.pageY - t.y, s = Math.sqrt(n * n + r * r);
    this._dollyStart.set(0, s);
  }
  _handleTouchStartDollyPan(e) {
    this.enableZoom && this._handleTouchStartDolly(e), this.enablePan && this._handleTouchStartPan(e);
  }
  _handleTouchStartDollyRotate(e) {
    this.enableZoom && this._handleTouchStartDolly(e), this.enableRotate && this._handleTouchStartRotate(e);
  }
  _handleTouchMoveRotate(e) {
    if (this._pointers.length == 1)
      this._rotateEnd.set(e.pageX, e.pageY);
    else {
      const n = this._getSecondPointerPosition(e), r = 0.5 * (e.pageX + n.x), s = 0.5 * (e.pageY + n.y);
      this._rotateEnd.set(r, s);
    }
    this._rotateDelta.subVectors(this._rotateEnd, this._rotateStart).multiplyScalar(this.rotateSpeed);
    const t = this.domElement;
    this._rotateLeft(qs * this._rotateDelta.x / t.clientHeight), this._rotateUp(qs * this._rotateDelta.y / t.clientHeight), this._rotateStart.copy(this._rotateEnd);
  }
  _handleTouchMovePan(e) {
    if (this._pointers.length === 1)
      this._panEnd.set(e.pageX, e.pageY);
    else {
      const t = this._getSecondPointerPosition(e), n = 0.5 * (e.pageX + t.x), r = 0.5 * (e.pageY + t.y);
      this._panEnd.set(n, r);
    }
    this._panDelta.subVectors(this._panEnd, this._panStart).multiplyScalar(this.panSpeed), this._pan(this._panDelta.x, this._panDelta.y), this._panStart.copy(this._panEnd);
  }
  _handleTouchMoveDolly(e) {
    const t = this._getSecondPointerPosition(e), n = e.pageX - t.x, r = e.pageY - t.y, s = Math.sqrt(n * n + r * r);
    this._dollyEnd.set(0, s), this._dollyDelta.set(0, Math.pow(this._dollyEnd.y / this._dollyStart.y, this.zoomSpeed)), this._dollyOut(this._dollyDelta.y), this._dollyStart.copy(this._dollyEnd);
    const o = (e.pageX + t.x) * 0.5, a = (e.pageY + t.y) * 0.5;
    this._updateZoomParameters(o, a);
  }
  _handleTouchMoveDollyPan(e) {
    this.enableZoom && this._handleTouchMoveDolly(e), this.enablePan && this._handleTouchMovePan(e);
  }
  _handleTouchMoveDollyRotate(e) {
    this.enableZoom && this._handleTouchMoveDolly(e), this.enableRotate && this._handleTouchMoveRotate(e);
  }
  // pointers
  _addPointer(e) {
    this._pointers.push(e.pointerId);
  }
  _removePointer(e) {
    delete this._pointerPositions[e.pointerId];
    for (let t = 0; t < this._pointers.length; t++)
      if (this._pointers[t] == e.pointerId) {
        this._pointers.splice(t, 1);
        return;
      }
  }
  _isTrackingPointer(e) {
    for (let t = 0; t < this._pointers.length; t++)
      if (this._pointers[t] == e.pointerId) return !0;
    return !1;
  }
  _trackPointer(e) {
    let t = this._pointerPositions[e.pointerId];
    t === void 0 && (t = new Le(), this._pointerPositions[e.pointerId] = t), t.set(e.pageX, e.pageY);
  }
  _getSecondPointerPosition(e) {
    const t = e.pointerId === this._pointers[0] ? this._pointers[1] : this._pointers[0];
    return this._pointerPositions[t];
  }
  //
  _customWheelEvent(e) {
    const t = e.deltaMode, n = {
      clientX: e.clientX,
      clientY: e.clientY,
      deltaY: e.deltaY
    };
    switch (t) {
      case 1:
        n.deltaY *= 16;
        break;
      case 2:
        n.deltaY *= 100;
        break;
    }
    return e.ctrlKey && !this._controlActive && (n.deltaY *= 10), n;
  }
}
function Ice(i) {
  this.enabled !== !1 && (this._pointers.length === 0 && (this.domElement.setPointerCapture(i.pointerId), this.domElement.ownerDocument.addEventListener("pointermove", this._onPointerMove), this.domElement.ownerDocument.addEventListener("pointerup", this._onPointerUp)), !this._isTrackingPointer(i) && (this._addPointer(i), i.pointerType === "touch" ? this._onTouchStart(i) : this._onMouseDown(i)));
}
function Bce(i) {
  this.enabled !== !1 && (i.pointerType === "touch" ? this._onTouchMove(i) : this._onMouseMove(i));
}
function Fce(i) {
  switch (this._removePointer(i), this._pointers.length) {
    case 0:
      this.domElement.releasePointerCapture(i.pointerId), this.domElement.ownerDocument.removeEventListener("pointermove", this._onPointerMove), this.domElement.ownerDocument.removeEventListener("pointerup", this._onPointerUp), this.dispatchEvent(u7), this.state = yi.NONE;
      break;
    case 1:
      const e = this._pointers[0], t = this._pointerPositions[e];
      this._onTouchStart({ pointerId: e, pageX: t.x, pageY: t.y });
      break;
  }
}
function Uce(i) {
  let e;
  switch (i.button) {
    case 0:
      e = this.mouseButtons.LEFT;
      break;
    case 1:
      e = this.mouseButtons.MIDDLE;
      break;
    case 2:
      e = this.mouseButtons.RIGHT;
      break;
    default:
      e = -1;
  }
  switch (e) {
    case So.DOLLY:
      if (this.enableZoom === !1) return;
      this._handleMouseDownDolly(i), this.state = yi.DOLLY;
      break;
    case So.ROTATE:
      if (i.ctrlKey || i.metaKey || i.shiftKey) {
        if (this.enablePan === !1) return;
        this._handleMouseDownPan(i), this.state = yi.PAN;
      } else {
        if (this.enableRotate === !1) return;
        this._handleMouseDownRotate(i), this.state = yi.ROTATE;
      }
      break;
    case So.PAN:
      if (i.ctrlKey || i.metaKey || i.shiftKey) {
        if (this.enableRotate === !1) return;
        this._handleMouseDownRotate(i), this.state = yi.ROTATE;
      } else {
        if (this.enablePan === !1) return;
        this._handleMouseDownPan(i), this.state = yi.PAN;
      }
      break;
    default:
      this.state = yi.NONE;
  }
  this.state !== yi.NONE && this.dispatchEvent(gw);
}
function Oce(i) {
  switch (this.state) {
    case yi.ROTATE:
      if (this.enableRotate === !1) return;
      this._handleMouseMoveRotate(i);
      break;
    case yi.DOLLY:
      if (this.enableZoom === !1) return;
      this._handleMouseMoveDolly(i);
      break;
    case yi.PAN:
      if (this.enablePan === !1) return;
      this._handleMouseMovePan(i);
      break;
  }
}
function kce(i) {
  this.enabled === !1 || this.enableZoom === !1 || this.state !== yi.NONE || (i.preventDefault(), this.dispatchEvent(gw), this._handleMouseWheel(this._customWheelEvent(i)), this.dispatchEvent(u7));
}
function Vce(i) {
  this.enabled !== !1 && this._handleKeyDown(i);
}
function Gce(i) {
  switch (this._trackPointer(i), this._pointers.length) {
    case 1:
      switch (this.touches.ONE) {
        case Qc.ROTATE:
          if (this.enableRotate === !1) return;
          this._handleTouchStartRotate(i), this.state = yi.TOUCH_ROTATE;
          break;
        case Qc.PAN:
          if (this.enablePan === !1) return;
          this._handleTouchStartPan(i), this.state = yi.TOUCH_PAN;
          break;
        default:
          this.state = yi.NONE;
      }
      break;
    case 2:
      switch (this.touches.TWO) {
        case Qc.DOLLY_PAN:
          if (this.enableZoom === !1 && this.enablePan === !1) return;
          this._handleTouchStartDollyPan(i), this.state = yi.TOUCH_DOLLY_PAN;
          break;
        case Qc.DOLLY_ROTATE:
          if (this.enableZoom === !1 && this.enableRotate === !1) return;
          this._handleTouchStartDollyRotate(i), this.state = yi.TOUCH_DOLLY_ROTATE;
          break;
        default:
          this.state = yi.NONE;
      }
      break;
    default:
      this.state = yi.NONE;
  }
  this.state !== yi.NONE && this.dispatchEvent(gw);
}
function zce(i) {
  switch (this._trackPointer(i), this.state) {
    case yi.TOUCH_ROTATE:
      if (this.enableRotate === !1) return;
      this._handleTouchMoveRotate(i), this.update();
      break;
    case yi.TOUCH_PAN:
      if (this.enablePan === !1) return;
      this._handleTouchMovePan(i), this.update();
      break;
    case yi.TOUCH_DOLLY_PAN:
      if (this.enableZoom === !1 && this.enablePan === !1) return;
      this._handleTouchMoveDollyPan(i), this.update();
      break;
    case yi.TOUCH_DOLLY_ROTATE:
      if (this.enableZoom === !1 && this.enableRotate === !1) return;
      this._handleTouchMoveDollyRotate(i), this.update();
      break;
    default:
      this.state = yi.NONE;
  }
}
function qce(i) {
  this.enabled !== !1 && i.preventDefault();
}
function Hce(i) {
  i.key === "Control" && (this._controlActive = !0, this.domElement.getRootNode().addEventListener("keyup", this._interceptControlUp, { passive: !0, capture: !0 }));
}
function Wce(i) {
  i.key === "Control" && (this._controlActive = !1, this.domElement.getRootNode().removeEventListener("keyup", this._interceptControlUp, { passive: !0, capture: !0 }));
}
const $ce = { type: "change" }, n5 = 1e-6, i5 = new hr();
class jce extends x2 {
  /**
   * Constructs a new controls instance.
   *
   * @param {Object3D} object - The object that is managed by the controls.
   * @param {?HTMLElement} domElement - The HTML element used for event listeners.
   */
  constructor(e, t = null) {
    super(e, t), this.movementSpeed = 1, this.rollSpeed = 5e-3, this.dragToLook = !1, this.autoForward = !1, this._moveState = { up: 0, down: 0, left: 0, right: 0, forward: 0, back: 0, pitchUp: 0, pitchDown: 0, yawLeft: 0, yawRight: 0, rollLeft: 0, rollRight: 0 }, this._moveVector = new j(0, 0, 0), this._rotationVector = new j(0, 0, 0), this._lastQuaternion = new hr(), this._lastPosition = new j(), this._status = 0, this._onKeyDown = Xce.bind(this), this._onKeyUp = Yce.bind(this), this._onPointerMove = Kce.bind(this), this._onPointerDown = Qce.bind(this), this._onPointerUp = Zce.bind(this), this._onPointerCancel = Jce.bind(this), this._onContextMenu = ehe.bind(this), t !== null && this.connect(t);
  }
  connect(e) {
    super.connect(e), window.addEventListener("keydown", this._onKeyDown), window.addEventListener("keyup", this._onKeyUp), this.domElement.addEventListener("pointermove", this._onPointerMove), this.domElement.addEventListener("pointerdown", this._onPointerDown), this.domElement.addEventListener("pointerup", this._onPointerUp), this.domElement.addEventListener("pointercancel", this._onPointerCancel), this.domElement.addEventListener("contextmenu", this._onContextMenu);
  }
  disconnect() {
    window.removeEventListener("keydown", this._onKeyDown), window.removeEventListener("keyup", this._onKeyUp), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.domElement.removeEventListener("pointerdown", this._onPointerDown), this.domElement.removeEventListener("pointerup", this._onPointerUp), this.domElement.removeEventListener("pointercancel", this._onPointerCancel), this.domElement.removeEventListener("contextmenu", this._onContextMenu);
  }
  dispose() {
    this.disconnect();
  }
  update(e) {
    if (this.enabled === !1) return;
    const t = this.object, n = e * this.movementSpeed, r = e * this.rollSpeed;
    t.translateX(this._moveVector.x * n), t.translateY(this._moveVector.y * n), t.translateZ(this._moveVector.z * n), i5.set(this._rotationVector.x * r, this._rotationVector.y * r, this._rotationVector.z * r, 1).normalize(), t.quaternion.multiply(i5), (this._lastPosition.distanceToSquared(t.position) > n5 || 8 * (1 - this._lastQuaternion.dot(t.quaternion)) > n5) && (this.dispatchEvent($ce), this._lastQuaternion.copy(t.quaternion), this._lastPosition.copy(t.position));
  }
  // private
  _updateMovementVector() {
    const e = this._moveState.forward || this.autoForward && !this._moveState.back ? 1 : 0;
    this._moveVector.x = -this._moveState.left + this._moveState.right, this._moveVector.y = -this._moveState.down + this._moveState.up, this._moveVector.z = -e + this._moveState.back;
  }
  _updateRotationVector() {
    this._rotationVector.x = -this._moveState.pitchDown + this._moveState.pitchUp, this._rotationVector.y = -this._moveState.yawRight + this._moveState.yawLeft, this._rotationVector.z = -this._moveState.rollRight + this._moveState.rollLeft;
  }
  _getContainerDimensions() {
    return this.domElement != document ? {
      size: [this.domElement.offsetWidth, this.domElement.offsetHeight],
      offset: [this.domElement.offsetLeft, this.domElement.offsetTop]
    } : {
      size: [window.innerWidth, window.innerHeight],
      offset: [0, 0]
    };
  }
}
function Xce(i) {
  if (!(i.altKey || this.enabled === !1)) {
    switch (i.code) {
      case "ShiftLeft":
      case "ShiftRight":
        this.movementSpeedMultiplier = 0.1;
        break;
      case "KeyW":
        this._moveState.forward = 1;
        break;
      case "KeyS":
        this._moveState.back = 1;
        break;
      case "KeyA":
        this._moveState.left = 1;
        break;
      case "KeyD":
        this._moveState.right = 1;
        break;
      case "KeyR":
        this._moveState.up = 1;
        break;
      case "KeyF":
        this._moveState.down = 1;
        break;
      case "ArrowUp":
        this._moveState.pitchUp = 1;
        break;
      case "ArrowDown":
        this._moveState.pitchDown = 1;
        break;
      case "ArrowLeft":
        this._moveState.yawLeft = 1;
        break;
      case "ArrowRight":
        this._moveState.yawRight = 1;
        break;
      case "KeyQ":
        this._moveState.rollLeft = 1;
        break;
      case "KeyE":
        this._moveState.rollRight = 1;
        break;
    }
    this._updateMovementVector(), this._updateRotationVector();
  }
}
function Yce(i) {
  if (this.enabled !== !1) {
    switch (i.code) {
      case "ShiftLeft":
      case "ShiftRight":
        this.movementSpeedMultiplier = 1;
        break;
      case "KeyW":
        this._moveState.forward = 0;
        break;
      case "KeyS":
        this._moveState.back = 0;
        break;
      case "KeyA":
        this._moveState.left = 0;
        break;
      case "KeyD":
        this._moveState.right = 0;
        break;
      case "KeyR":
        this._moveState.up = 0;
        break;
      case "KeyF":
        this._moveState.down = 0;
        break;
      case "ArrowUp":
        this._moveState.pitchUp = 0;
        break;
      case "ArrowDown":
        this._moveState.pitchDown = 0;
        break;
      case "ArrowLeft":
        this._moveState.yawLeft = 0;
        break;
      case "ArrowRight":
        this._moveState.yawRight = 0;
        break;
      case "KeyQ":
        this._moveState.rollLeft = 0;
        break;
      case "KeyE":
        this._moveState.rollRight = 0;
        break;
    }
    this._updateMovementVector(), this._updateRotationVector();
  }
}
function Qce(i) {
  if (this.enabled !== !1)
    if (this.dragToLook)
      this._status++;
    else {
      switch (i.button) {
        case 0:
          this._moveState.forward = 1;
          break;
        case 2:
          this._moveState.back = 1;
          break;
      }
      this._updateMovementVector();
    }
}
function Kce(i) {
  if (this.enabled !== !1 && (!this.dragToLook || this._status > 0)) {
    const e = this._getContainerDimensions(), t = e.size[0] / 2, n = e.size[1] / 2;
    this._moveState.yawLeft = -(i.pageX - e.offset[0] - t) / t, this._moveState.pitchDown = (i.pageY - e.offset[1] - n) / n, this._updateRotationVector();
  }
}
function Zce(i) {
  if (this.enabled !== !1) {
    if (this.dragToLook)
      this._status--, this._moveState.yawLeft = this._moveState.pitchDown = 0;
    else {
      switch (i.button) {
        case 0:
          this._moveState.forward = 0;
          break;
        case 2:
          this._moveState.back = 0;
          break;
      }
      this._updateMovementVector();
    }
    this._updateRotationVector();
  }
}
function Jce() {
  this.enabled !== !1 && (this.dragToLook ? (this._status = 0, this._moveState.yawLeft = this._moveState.pitchDown = 0) : (this._moveState.forward = 0, this._moveState.back = 0, this._updateMovementVector()), this._updateRotationVector());
}
function ehe(i) {
  this.enabled !== !1 && i.preventDefault();
}
const the = {
  name: "CopyShader",
  uniforms: {
    tDiffuse: { value: null },
    opacity: { value: 1 }
  },
  vertexShader: (
    /* glsl */
    `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		uniform float opacity;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );
			gl_FragColor = opacity * texel;


		}`
  )
};
class ux {
  /**
   * Constructs a new pass.
   */
  constructor() {
    this.isPass = !0, this.enabled = !0, this.needsSwap = !0, this.clear = !1, this.renderToScreen = !1;
  }
  /**
   * Sets the size of the pass.
   *
   * @abstract
   * @param {number} width - The width to set.
   * @param {number} height - The height to set.
   */
  setSize() {
  }
  /**
   * This method holds the render logic of a pass. It must be implemented in all derived classes.
   *
   * @abstract
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering
   * destination for the pass.
   * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the
   * previous pass from this buffer.
   * @param {number} deltaTime - The delta time in seconds.
   * @param {boolean} maskActive - Whether masking is active or not.
   */
  render() {
    console.error("THREE.Pass: .render() must be implemented in derived pass.");
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever the pass is no longer used in your app.
   *
   * @abstract
   */
  dispose() {
  }
}
const nhe = new ic(-1, 1, 1, -1, 0, 1);
class ihe extends Yt {
  constructor() {
    super(), this.setAttribute("position", new xt([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)), this.setAttribute("uv", new xt([0, 2, 0, 0, 2, 0], 2));
  }
}
const rhe = new ihe();
class she {
  /**
   * Constructs a new full screen quad.
   *
   * @param {?Material} material - The material to render te full screen quad with.
   */
  constructor(e) {
    this._mesh = new Tn(rhe, e);
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever the instance is no longer used in your app.
   */
  dispose() {
    this._mesh.geometry.dispose();
  }
  /**
   * Renders the full screen quad.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   */
  render(e) {
    e.render(this._mesh, nhe);
  }
  /**
   * The quad's material.
   *
   * @type {?Material}
   */
  get material() {
    return this._mesh.material;
  }
  set material(e) {
    this._mesh.material = e;
  }
}
class ohe extends ux {
  /**
   * Constructs a new shader pass.
   *
   * @param {Object|ShaderMaterial} [shader] - A shader object holding vertex and fragment shader as well as
   * defines and uniforms. It's also valid to pass a custom shader material.
   * @param {string} [textureID='tDiffuse'] - The name of the texture uniform that should sample
   * the read buffer.
   */
  constructor(e, t = "tDiffuse") {
    super(), this.textureID = t, this.uniforms = null, this.material = null, e instanceof Fr ? (this.uniforms = e.uniforms, this.material = e) : e && (this.uniforms = v0.clone(e.uniforms), this.material = new Fr({
      name: e.name !== void 0 ? e.name : "unspecified",
      defines: Object.assign({}, e.defines),
      uniforms: this.uniforms,
      vertexShader: e.vertexShader,
      fragmentShader: e.fragmentShader
    })), this._fsQuad = new she(this.material);
  }
  /**
   * Performs the shader pass.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering
   * destination for the pass.
   * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the
   * previous pass from this buffer.
   * @param {number} deltaTime - The delta time in seconds.
   * @param {boolean} maskActive - Whether masking is active or not.
   */
  render(e, t, n) {
    this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = n.texture), this._fsQuad.material = this.material, this.renderToScreen ? (e.setRenderTarget(null), this._fsQuad.render(e)) : (e.setRenderTarget(t), this.clear && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), this._fsQuad.render(e));
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever the pass is no longer used in your app.
   */
  dispose() {
    this.material.dispose(), this._fsQuad.dispose();
  }
}
class r5 extends ux {
  /**
   * Constructs a new mask pass.
   *
   * @param {Scene} scene - The 3D objects in this scene will define the mask.
   * @param {Camera} camera - The camera.
   */
  constructor(e, t) {
    super(), this.scene = e, this.camera = t, this.clear = !0, this.needsSwap = !1, this.inverse = !1;
  }
  /**
   * Performs a mask pass with the configured scene and camera.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering
   * destination for the pass.
   * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the
   * previous pass from this buffer.
   * @param {number} deltaTime - The delta time in seconds.
   * @param {boolean} maskActive - Whether masking is active or not.
   */
  render(e, t, n) {
    const r = e.getContext(), s = e.state;
    s.buffers.color.setMask(!1), s.buffers.depth.setMask(!1), s.buffers.color.setLocked(!0), s.buffers.depth.setLocked(!0);
    let o, a;
    this.inverse ? (o = 0, a = 1) : (o = 1, a = 0), s.buffers.stencil.setTest(!0), s.buffers.stencil.setOp(r.REPLACE, r.REPLACE, r.REPLACE), s.buffers.stencil.setFunc(r.ALWAYS, o, 4294967295), s.buffers.stencil.setClear(a), s.buffers.stencil.setLocked(!0), e.setRenderTarget(n), this.clear && e.clear(), e.render(this.scene, this.camera), e.setRenderTarget(t), this.clear && e.clear(), e.render(this.scene, this.camera), s.buffers.color.setLocked(!1), s.buffers.depth.setLocked(!1), s.buffers.color.setMask(!0), s.buffers.depth.setMask(!0), s.buffers.stencil.setLocked(!1), s.buffers.stencil.setFunc(r.EQUAL, 1, 4294967295), s.buffers.stencil.setOp(r.KEEP, r.KEEP, r.KEEP), s.buffers.stencil.setLocked(!0);
  }
}
class ahe extends ux {
  /**
   * Constructs a new clear mask pass.
   */
  constructor() {
    super(), this.needsSwap = !1;
  }
  /**
   * Performs the clear of the currently defined mask.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering
   * destination for the pass.
   * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the
   * previous pass from this buffer.
   * @param {number} deltaTime - The delta time in seconds.
   * @param {boolean} maskActive - Whether masking is active or not.
   */
  render(e) {
    e.state.buffers.stencil.setLocked(!1), e.state.buffers.stencil.setTest(!1);
  }
}
class lhe {
  /**
   * Constructs a new effect composer.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} [renderTarget] - This render target and a clone will
   * be used as the internal read and write buffers. If not given, the composer creates
   * the buffers automatically.
   */
  constructor(e, t) {
    if (this.renderer = e, this._pixelRatio = e.getPixelRatio(), t === void 0) {
      const n = e.getSize(new Le());
      this._width = n.width, this._height = n.height, t = new eo(this._width * this._pixelRatio, this._height * this._pixelRatio, { type: Ri }), t.texture.name = "EffectComposer.rt1";
    } else
      this._width = t.width, this._height = t.height;
    this.renderTarget1 = t, this.renderTarget2 = t.clone(), this.renderTarget2.texture.name = "EffectComposer.rt2", this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2, this.renderToScreen = !0, this.passes = [], this.copyPass = new ohe(the), this.copyPass.material.blending = ms, this.clock = new _2();
  }
  /**
   * Swaps the internal read/write buffers.
   */
  swapBuffers() {
    const e = this.readBuffer;
    this.readBuffer = this.writeBuffer, this.writeBuffer = e;
  }
  /**
   * Adds the given pass to the pass chain.
   *
   * @param {Pass} pass - The pass to add.
   */
  addPass(e) {
    this.passes.push(e), e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
  }
  /**
   * Inserts the given pass at a given index.
   *
   * @param {Pass} pass - The pass to insert.
   * @param {number} index - The index into the pass chain.
   */
  insertPass(e, t) {
    this.passes.splice(t, 0, e), e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
  }
  /**
   * Removes the given pass from the pass chain.
   *
   * @param {Pass} pass - The pass to remove.
   */
  removePass(e) {
    const t = this.passes.indexOf(e);
    t !== -1 && this.passes.splice(t, 1);
  }
  /**
   * Returns `true` if the pass for the given index is the last enabled pass in the pass chain.
   *
   * @param {number} passIndex - The pass index.
   * @return {boolean} Whether the pass for the given index is the last pass in the pass chain.
   */
  isLastEnabledPass(e) {
    for (let t = e + 1; t < this.passes.length; t++)
      if (this.passes[t].enabled)
        return !1;
    return !0;
  }
  /**
   * Executes all enabled post-processing passes in order to produce the final frame.
   *
   * @param {number} deltaTime - The delta time in seconds. If not given, the composer computes
   * its own time delta value.
   */
  render(e) {
    e === void 0 && (e = this.clock.getDelta());
    const t = this.renderer.getRenderTarget();
    let n = !1;
    for (let r = 0, s = this.passes.length; r < s; r++) {
      const o = this.passes[r];
      if (o.enabled !== !1) {
        if (o.renderToScreen = this.renderToScreen && this.isLastEnabledPass(r), o.render(this.renderer, this.writeBuffer, this.readBuffer, e, n), o.needsSwap) {
          if (n) {
            const a = this.renderer.getContext(), l = this.renderer.state.buffers.stencil;
            l.setFunc(a.NOTEQUAL, 1, 4294967295), this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, e), l.setFunc(a.EQUAL, 1, 4294967295);
          }
          this.swapBuffers();
        }
        r5 !== void 0 && (o instanceof r5 ? n = !0 : o instanceof ahe && (n = !1));
      }
    }
    this.renderer.setRenderTarget(t);
  }
  /**
   * Resets the internal state of the EffectComposer.
   *
   * @param {WebGLRenderTarget} [renderTarget] - This render target has the same purpose like
   * the one from the constructor. If set, it is used to setup the read and write buffers.
   */
  reset(e) {
    if (e === void 0) {
      const t = this.renderer.getSize(new Le());
      this._pixelRatio = this.renderer.getPixelRatio(), this._width = t.width, this._height = t.height, e = this.renderTarget1.clone(), e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
    }
    this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.renderTarget1 = e, this.renderTarget2 = e.clone(), this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2;
  }
  /**
   * Resizes the internal read and write buffers as well as all passes. Similar to {@link WebGLRenderer#setSize},
   * this method honors the current pixel ration.
   *
   * @param {number} width - The width in logical pixels.
   * @param {number} height - The height in logical pixels.
   */
  setSize(e, t) {
    this._width = e, this._height = t;
    const n = this._width * this._pixelRatio, r = this._height * this._pixelRatio;
    this.renderTarget1.setSize(n, r), this.renderTarget2.setSize(n, r);
    for (let s = 0; s < this.passes.length; s++)
      this.passes[s].setSize(n, r);
  }
  /**
   * Sets device pixel ratio. This is usually used for HiDPI device to prevent blurring output.
   * Setting the pixel ratio will automatically resize the composer.
   *
   * @param {number} pixelRatio - The pixel ratio to set.
   */
  setPixelRatio(e) {
    this._pixelRatio = e, this.setSize(this._width, this._height);
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever the composer is no longer used in your app.
   */
  dispose() {
    this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.copyPass.dispose();
  }
}
class uhe extends ux {
  /**
   * Constructs a new render pass.
   *
   * @param {Scene} scene - The scene to render.
   * @param {Camera} camera - The camera.
   * @param {?Material} [overrideMaterial=null] - The override material. If set, this material is used
   * for all objects in the scene.
   * @param {?(number|Color|string)} [clearColor=null] - The clear color of the render pass.
   * @param {?number} [clearAlpha=null] - The clear alpha of the render pass.
   */
  constructor(e, t, n = null, r = null, s = null) {
    super(), this.scene = e, this.camera = t, this.overrideMaterial = n, this.clearColor = r, this.clearAlpha = s, this.clear = !0, this.clearDepth = !1, this.needsSwap = !1, this.isRenderPass = !0, this._oldClearColor = new ct();
  }
  /**
   * Performs a beauty pass with the configured scene and camera.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGLRenderTarget} writeBuffer - The write buffer. This buffer is intended as the rendering
   * destination for the pass.
   * @param {WebGLRenderTarget} readBuffer - The read buffer. The pass can access the result from the
   * previous pass from this buffer.
   * @param {number} deltaTime - The delta time in seconds.
   * @param {boolean} maskActive - Whether masking is active or not.
   */
  render(e, t, n) {
    const r = e.autoClear;
    e.autoClear = !1;
    let s, o;
    this.overrideMaterial !== null && (o = this.scene.overrideMaterial, this.scene.overrideMaterial = this.overrideMaterial), this.clearColor !== null && (e.getClearColor(this._oldClearColor), e.setClearColor(this.clearColor, e.getClearAlpha())), this.clearAlpha !== null && (s = e.getClearAlpha(), e.setClearAlpha(this.clearAlpha)), this.clearDepth == !0 && e.clearDepth(), e.setRenderTarget(this.renderToScreen ? null : n), this.clear === !0 && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), e.render(this.scene, this.camera), this.clearColor !== null && e.setClearColor(this._oldClearColor), this.clearAlpha !== null && e.setClearAlpha(s), this.overrideMaterial !== null && (this.scene.overrideMaterial = o), e.autoClear = r;
  }
}
function ao() {
  return ao = Object.assign ? Object.assign.bind() : function(i) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var n in t) ({}).hasOwnProperty.call(t, n) && (i[n] = t[n]);
    }
    return i;
  }, ao.apply(null, arguments);
}
function che(i) {
  if (i === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return i;
}
function d0(i, e) {
  return d0 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, n) {
    return t.__proto__ = n, t;
  }, d0(i, e);
}
function hhe(i, e) {
  i.prototype = Object.create(e.prototype), i.prototype.constructor = i, d0(i, e);
}
function l3(i) {
  return l3 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e) {
    return e.__proto__ || Object.getPrototypeOf(e);
  }, l3(i);
}
function dhe(i) {
  try {
    return Function.toString.call(i).indexOf("[native code]") !== -1;
  } catch {
    return typeof i == "function";
  }
}
function c7() {
  try {
    var i = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (c7 = function() {
    return !!i;
  })();
}
function fhe(i, e, t) {
  if (c7()) return Reflect.construct.apply(null, arguments);
  var n = [null];
  n.push.apply(n, e);
  var r = new (i.bind.apply(i, n))();
  return t && d0(r, t.prototype), r;
}
function u3(i) {
  var e = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
  return u3 = function(n) {
    if (n === null || !dhe(n)) return n;
    if (typeof n != "function") throw new TypeError("Super expression must either be null or a function");
    if (e !== void 0) {
      if (e.has(n)) return e.get(n);
      e.set(n, r);
    }
    function r() {
      return fhe(n, arguments, l3(this).constructor);
    }
    return r.prototype = Object.create(n.prototype, {
      constructor: {
        value: r,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }), d0(r, n);
  }, u3(i);
}
var Ahe = {
  1: `Passed invalid arguments to hsl, please pass multiple numbers e.g. hsl(360, 0.75, 0.4) or an object e.g. rgb({ hue: 255, saturation: 0.4, lightness: 0.75 }).

`,
  2: `Passed invalid arguments to hsla, please pass multiple numbers e.g. hsla(360, 0.75, 0.4, 0.7) or an object e.g. rgb({ hue: 255, saturation: 0.4, lightness: 0.75, alpha: 0.7 }).

`,
  3: `Passed an incorrect argument to a color function, please pass a string representation of a color.

`,
  4: `Couldn't generate valid rgb string from %s, it returned %s.

`,
  5: `Couldn't parse the color string. Please provide the color as a string in hex, rgb, rgba, hsl or hsla notation.

`,
  6: `Passed invalid arguments to rgb, please pass multiple numbers e.g. rgb(255, 205, 100) or an object e.g. rgb({ red: 255, green: 205, blue: 100 }).

`,
  7: `Passed invalid arguments to rgba, please pass multiple numbers e.g. rgb(255, 205, 100, 0.75) or an object e.g. rgb({ red: 255, green: 205, blue: 100, alpha: 0.75 }).

`,
  8: `Passed invalid argument to toColorString, please pass a RgbColor, RgbaColor, HslColor or HslaColor object.

`,
  9: `Please provide a number of steps to the modularScale helper.

`,
  10: `Please pass a number or one of the predefined scales to the modularScale helper as the ratio.

`,
  11: `Invalid value passed as base to modularScale, expected number or em string but got "%s"

`,
  12: `Expected a string ending in "px" or a number passed as the first argument to %s(), got "%s" instead.

`,
  13: `Expected a string ending in "px" or a number passed as the second argument to %s(), got "%s" instead.

`,
  14: `Passed invalid pixel value ("%s") to %s(), please pass a value like "12px" or 12.

`,
  15: `Passed invalid base value ("%s") to %s(), please pass a value like "12px" or 12.

`,
  16: `You must provide a template to this method.

`,
  17: `You passed an unsupported selector state to this method.

`,
  18: `minScreen and maxScreen must be provided as stringified numbers with the same units.

`,
  19: `fromSize and toSize must be provided as stringified numbers with the same units.

`,
  20: `expects either an array of objects or a single object with the properties prop, fromSize, and toSize.

`,
  21: "expects the objects in the first argument array to have the properties `prop`, `fromSize`, and `toSize`.\n\n",
  22: "expects the first argument object to have the properties `prop`, `fromSize`, and `toSize`.\n\n",
  23: `fontFace expects a name of a font-family.

`,
  24: `fontFace expects either the path to the font file(s) or a name of a local copy.

`,
  25: `fontFace expects localFonts to be an array.

`,
  26: `fontFace expects fileFormats to be an array.

`,
  27: `radialGradient requries at least 2 color-stops to properly render.

`,
  28: `Please supply a filename to retinaImage() as the first argument.

`,
  29: `Passed invalid argument to triangle, please pass correct pointingDirection e.g. 'right'.

`,
  30: "Passed an invalid value to `height` or `width`. Please provide a pixel based unit.\n\n",
  31: `The animation shorthand only takes 8 arguments. See the specification for more information: http://mdn.io/animation

`,
  32: `To pass multiple animations please supply them in arrays, e.g. animation(['rotate', '2s'], ['move', '1s'])
To pass a single animation please supply them in simple values, e.g. animation('rotate', '2s')

`,
  33: `The animation shorthand arrays can only have 8 elements. See the specification for more information: http://mdn.io/animation

`,
  34: `borderRadius expects a radius value as a string or number as the second argument.

`,
  35: `borderRadius expects one of "top", "bottom", "left" or "right" as the first argument.

`,
  36: `Property must be a string value.

`,
  37: `Syntax Error at %s.

`,
  38: `Formula contains a function that needs parentheses at %s.

`,
  39: `Formula is missing closing parenthesis at %s.

`,
  40: `Formula has too many closing parentheses at %s.

`,
  41: `All values in a formula must have the same unit or be unitless.

`,
  42: `Please provide a number of steps to the modularScale helper.

`,
  43: `Please pass a number or one of the predefined scales to the modularScale helper as the ratio.

`,
  44: `Invalid value passed as base to modularScale, expected number or em/rem string but got %s.

`,
  45: `Passed invalid argument to hslToColorString, please pass a HslColor or HslaColor object.

`,
  46: `Passed invalid argument to rgbToColorString, please pass a RgbColor or RgbaColor object.

`,
  47: `minScreen and maxScreen must be provided as stringified numbers with the same units.

`,
  48: `fromSize and toSize must be provided as stringified numbers with the same units.

`,
  49: `Expects either an array of objects or a single object with the properties prop, fromSize, and toSize.

`,
  50: `Expects the objects in the first argument array to have the properties prop, fromSize, and toSize.

`,
  51: `Expects the first argument object to have the properties prop, fromSize, and toSize.

`,
  52: `fontFace expects either the path to the font file(s) or a name of a local copy.

`,
  53: `fontFace expects localFonts to be an array.

`,
  54: `fontFace expects fileFormats to be an array.

`,
  55: `fontFace expects a name of a font-family.

`,
  56: `linearGradient requries at least 2 color-stops to properly render.

`,
  57: `radialGradient requries at least 2 color-stops to properly render.

`,
  58: `Please supply a filename to retinaImage() as the first argument.

`,
  59: `Passed invalid argument to triangle, please pass correct pointingDirection e.g. 'right'.

`,
  60: "Passed an invalid value to `height` or `width`. Please provide a pixel based unit.\n\n",
  61: `Property must be a string value.

`,
  62: `borderRadius expects a radius value as a string or number as the second argument.

`,
  63: `borderRadius expects one of "top", "bottom", "left" or "right" as the first argument.

`,
  64: `The animation shorthand only takes 8 arguments. See the specification for more information: http://mdn.io/animation.

`,
  65: `To pass multiple animations please supply them in arrays, e.g. animation(['rotate', '2s'], ['move', '1s'])\\nTo pass a single animation please supply them in simple values, e.g. animation('rotate', '2s').

`,
  66: `The animation shorthand arrays can only have 8 elements. See the specification for more information: http://mdn.io/animation.

`,
  67: `You must provide a template to this method.

`,
  68: `You passed an unsupported selector state to this method.

`,
  69: `Expected a string ending in "px" or a number passed as the first argument to %s(), got %s instead.

`,
  70: `Expected a string ending in "px" or a number passed as the second argument to %s(), got %s instead.

`,
  71: `Passed invalid pixel value %s to %s(), please pass a value like "12px" or 12.

`,
  72: `Passed invalid base value %s to %s(), please pass a value like "12px" or 12.

`,
  73: `Please provide a valid CSS variable.

`,
  74: `CSS variable not found and no default was provided.

`,
  75: `important requires a valid style object, got a %s instead.

`,
  76: `fromSize and toSize must be provided as stringified numbers with the same units as minScreen and maxScreen.

`,
  77: `remToPx expects a value in "rem" but you provided it in "%s".

`,
  78: `base must be set in "px" or "%" but you set it in "%s".
`
};
function phe() {
  for (var i = arguments.length, e = new Array(i), t = 0; t < i; t++)
    e[t] = arguments[t];
  var n = e[0], r = [], s;
  for (s = 1; s < e.length; s += 1)
    r.push(e[s]);
  return r.forEach(function(o) {
    n = n.replace(/%[a-z]/, o);
  }), n;
}
var Xa = /* @__PURE__ */ (function(i) {
  hhe(e, i);
  function e(t) {
    var n;
    if (process.env.NODE_ENV === "production")
      n = i.call(this, "An error occurred. See https://github.com/styled-components/polished/blob/main/src/internalHelpers/errors.md#" + t + " for more information.") || this;
    else {
      for (var r = arguments.length, s = new Array(r > 1 ? r - 1 : 0), o = 1; o < r; o++)
        s[o - 1] = arguments[o];
      n = i.call(this, phe.apply(void 0, [Ahe[t]].concat(s))) || this;
    }
    return che(n);
  }
  return e;
})(/* @__PURE__ */ u3(Error));
function Dv(i) {
  return Math.round(i * 255);
}
function mhe(i, e, t) {
  return Dv(i) + "," + Dv(e) + "," + Dv(t);
}
function x_(i, e, t, n) {
  if (n === void 0 && (n = mhe), e === 0)
    return n(t, t, t);
  var r = (i % 360 + 360) % 360 / 60, s = (1 - Math.abs(2 * t - 1)) * e, o = s * (1 - Math.abs(r % 2 - 1)), a = 0, l = 0, u = 0;
  r >= 0 && r < 1 ? (a = s, l = o) : r >= 1 && r < 2 ? (a = o, l = s) : r >= 2 && r < 3 ? (l = s, u = o) : r >= 3 && r < 4 ? (l = o, u = s) : r >= 4 && r < 5 ? (a = o, u = s) : r >= 5 && r < 6 && (a = s, u = o);
  var c = t - s / 2, A = a + c, m = l + c, _ = u + c;
  return n(A, m, _);
}
var s5 = {
  aliceblue: "f0f8ff",
  antiquewhite: "faebd7",
  aqua: "00ffff",
  aquamarine: "7fffd4",
  azure: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "000",
  blanchedalmond: "ffebcd",
  blue: "0000ff",
  blueviolet: "8a2be2",
  brown: "a52a2a",
  burlywood: "deb887",
  cadetblue: "5f9ea0",
  chartreuse: "7fff00",
  chocolate: "d2691e",
  coral: "ff7f50",
  cornflowerblue: "6495ed",
  cornsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "00ffff",
  darkblue: "00008b",
  darkcyan: "008b8b",
  darkgoldenrod: "b8860b",
  darkgray: "a9a9a9",
  darkgreen: "006400",
  darkgrey: "a9a9a9",
  darkkhaki: "bdb76b",
  darkmagenta: "8b008b",
  darkolivegreen: "556b2f",
  darkorange: "ff8c00",
  darkorchid: "9932cc",
  darkred: "8b0000",
  darksalmon: "e9967a",
  darkseagreen: "8fbc8f",
  darkslateblue: "483d8b",
  darkslategray: "2f4f4f",
  darkslategrey: "2f4f4f",
  darkturquoise: "00ced1",
  darkviolet: "9400d3",
  deeppink: "ff1493",
  deepskyblue: "00bfff",
  dimgray: "696969",
  dimgrey: "696969",
  dodgerblue: "1e90ff",
  firebrick: "b22222",
  floralwhite: "fffaf0",
  forestgreen: "228b22",
  fuchsia: "ff00ff",
  gainsboro: "dcdcdc",
  ghostwhite: "f8f8ff",
  gold: "ffd700",
  goldenrod: "daa520",
  gray: "808080",
  green: "008000",
  greenyellow: "adff2f",
  grey: "808080",
  honeydew: "f0fff0",
  hotpink: "ff69b4",
  indianred: "cd5c5c",
  indigo: "4b0082",
  ivory: "fffff0",
  khaki: "f0e68c",
  lavender: "e6e6fa",
  lavenderblush: "fff0f5",
  lawngreen: "7cfc00",
  lemonchiffon: "fffacd",
  lightblue: "add8e6",
  lightcoral: "f08080",
  lightcyan: "e0ffff",
  lightgoldenrodyellow: "fafad2",
  lightgray: "d3d3d3",
  lightgreen: "90ee90",
  lightgrey: "d3d3d3",
  lightpink: "ffb6c1",
  lightsalmon: "ffa07a",
  lightseagreen: "20b2aa",
  lightskyblue: "87cefa",
  lightslategray: "789",
  lightslategrey: "789",
  lightsteelblue: "b0c4de",
  lightyellow: "ffffe0",
  lime: "0f0",
  limegreen: "32cd32",
  linen: "faf0e6",
  magenta: "f0f",
  maroon: "800000",
  mediumaquamarine: "66cdaa",
  mediumblue: "0000cd",
  mediumorchid: "ba55d3",
  mediumpurple: "9370db",
  mediumseagreen: "3cb371",
  mediumslateblue: "7b68ee",
  mediumspringgreen: "00fa9a",
  mediumturquoise: "48d1cc",
  mediumvioletred: "c71585",
  midnightblue: "191970",
  mintcream: "f5fffa",
  mistyrose: "ffe4e1",
  moccasin: "ffe4b5",
  navajowhite: "ffdead",
  navy: "000080",
  oldlace: "fdf5e6",
  olive: "808000",
  olivedrab: "6b8e23",
  orange: "ffa500",
  orangered: "ff4500",
  orchid: "da70d6",
  palegoldenrod: "eee8aa",
  palegreen: "98fb98",
  paleturquoise: "afeeee",
  palevioletred: "db7093",
  papayawhip: "ffefd5",
  peachpuff: "ffdab9",
  peru: "cd853f",
  pink: "ffc0cb",
  plum: "dda0dd",
  powderblue: "b0e0e6",
  purple: "800080",
  rebeccapurple: "639",
  red: "f00",
  rosybrown: "bc8f8f",
  royalblue: "4169e1",
  saddlebrown: "8b4513",
  salmon: "fa8072",
  sandybrown: "f4a460",
  seagreen: "2e8b57",
  seashell: "fff5ee",
  sienna: "a0522d",
  silver: "c0c0c0",
  skyblue: "87ceeb",
  slateblue: "6a5acd",
  slategray: "708090",
  slategrey: "708090",
  snow: "fffafa",
  springgreen: "00ff7f",
  steelblue: "4682b4",
  tan: "d2b48c",
  teal: "008080",
  thistle: "d8bfd8",
  tomato: "ff6347",
  turquoise: "40e0d0",
  violet: "ee82ee",
  wheat: "f5deb3",
  white: "fff",
  whitesmoke: "f5f5f5",
  yellow: "ff0",
  yellowgreen: "9acd32"
};
function ghe(i) {
  if (typeof i != "string") return i;
  var e = i.toLowerCase();
  return s5[e] ? "#" + s5[e] : i;
}
var _he = /^#[a-fA-F0-9]{6}$/, xhe = /^#[a-fA-F0-9]{8}$/, yhe = /^#[a-fA-F0-9]{3}$/, vhe = /^#[a-fA-F0-9]{4}$/, Lv = /^rgb\(\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*\)$/i, bhe = /^rgb(?:a)?\(\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,)?\s*(\d{1,3})\s*(?:,|\/)\s*([-+]?\d*[.]?\d+[%]?)\s*\)$/i, She = /^hsl\(\s*(\d{0,3}[.]?[0-9]+(?:deg)?)\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*\)$/i, The = /^hsl(?:a)?\(\s*(\d{0,3}[.]?[0-9]+(?:deg)?)\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,)?\s*(\d{1,3}[.]?[0-9]?)%\s*(?:,|\/)\s*([-+]?\d*[.]?\d+[%]?)\s*\)$/i;
function Jf(i) {
  if (typeof i != "string")
    throw new Xa(3);
  var e = ghe(i);
  if (e.match(_he))
    return {
      red: parseInt("" + e[1] + e[2], 16),
      green: parseInt("" + e[3] + e[4], 16),
      blue: parseInt("" + e[5] + e[6], 16)
    };
  if (e.match(xhe)) {
    var t = parseFloat((parseInt("" + e[7] + e[8], 16) / 255).toFixed(2));
    return {
      red: parseInt("" + e[1] + e[2], 16),
      green: parseInt("" + e[3] + e[4], 16),
      blue: parseInt("" + e[5] + e[6], 16),
      alpha: t
    };
  }
  if (e.match(yhe))
    return {
      red: parseInt("" + e[1] + e[1], 16),
      green: parseInt("" + e[2] + e[2], 16),
      blue: parseInt("" + e[3] + e[3], 16)
    };
  if (e.match(vhe)) {
    var n = parseFloat((parseInt("" + e[4] + e[4], 16) / 255).toFixed(2));
    return {
      red: parseInt("" + e[1] + e[1], 16),
      green: parseInt("" + e[2] + e[2], 16),
      blue: parseInt("" + e[3] + e[3], 16),
      alpha: n
    };
  }
  var r = Lv.exec(e);
  if (r)
    return {
      red: parseInt("" + r[1], 10),
      green: parseInt("" + r[2], 10),
      blue: parseInt("" + r[3], 10)
    };
  var s = bhe.exec(e.substring(0, 50));
  if (s)
    return {
      red: parseInt("" + s[1], 10),
      green: parseInt("" + s[2], 10),
      blue: parseInt("" + s[3], 10),
      alpha: parseFloat("" + s[4]) > 1 ? parseFloat("" + s[4]) / 100 : parseFloat("" + s[4])
    };
  var o = She.exec(e);
  if (o) {
    var a = parseInt("" + o[1], 10), l = parseInt("" + o[2], 10) / 100, u = parseInt("" + o[3], 10) / 100, c = "rgb(" + x_(a, l, u) + ")", A = Lv.exec(c);
    if (!A)
      throw new Xa(4, e, c);
    return {
      red: parseInt("" + A[1], 10),
      green: parseInt("" + A[2], 10),
      blue: parseInt("" + A[3], 10)
    };
  }
  var m = The.exec(e.substring(0, 50));
  if (m) {
    var _ = parseInt("" + m[1], 10), y = parseInt("" + m[2], 10) / 100, T = parseInt("" + m[3], 10) / 100, b = "rgb(" + x_(_, y, T) + ")", S = Lv.exec(b);
    if (!S)
      throw new Xa(4, e, b);
    return {
      red: parseInt("" + S[1], 10),
      green: parseInt("" + S[2], 10),
      blue: parseInt("" + S[3], 10),
      alpha: parseFloat("" + m[4]) > 1 ? parseFloat("" + m[4]) / 100 : parseFloat("" + m[4])
    };
  }
  throw new Xa(5);
}
function whe(i) {
  var e = i.red / 255, t = i.green / 255, n = i.blue / 255, r = Math.max(e, t, n), s = Math.min(e, t, n), o = (r + s) / 2;
  if (r === s)
    return i.alpha !== void 0 ? {
      hue: 0,
      saturation: 0,
      lightness: o,
      alpha: i.alpha
    } : {
      hue: 0,
      saturation: 0,
      lightness: o
    };
  var a, l = r - s, u = o > 0.5 ? l / (2 - r - s) : l / (r + s);
  switch (r) {
    case e:
      a = (t - n) / l + (t < n ? 6 : 0);
      break;
    case t:
      a = (n - e) / l + 2;
      break;
    default:
      a = (e - t) / l + 4;
      break;
  }
  return a *= 60, i.alpha !== void 0 ? {
    hue: a,
    saturation: u,
    lightness: o,
    alpha: i.alpha
  } : {
    hue: a,
    saturation: u,
    lightness: o
  };
}
function uc(i) {
  return whe(Jf(i));
}
var Mhe = function(e) {
  return e.length === 7 && e[1] === e[2] && e[3] === e[4] && e[5] === e[6] ? "#" + e[1] + e[3] + e[5] : e;
}, c3 = Mhe;
function zc(i) {
  var e = i.toString(16);
  return e.length === 1 ? "0" + e : e;
}
function Iv(i) {
  return zc(Math.round(i * 255));
}
function Ehe(i, e, t) {
  return c3("#" + Iv(i) + Iv(e) + Iv(t));
}
function h7(i, e, t) {
  return x_(i, e, t, Ehe);
}
function Rhe(i, e, t) {
  if (typeof i == "object" && e === void 0 && t === void 0)
    return h7(i.hue, i.saturation, i.lightness);
  throw new Xa(1);
}
function Che(i, e, t, n) {
  if (typeof i == "object" && e === void 0 && t === void 0 && n === void 0)
    return i.alpha >= 1 ? h7(i.hue, i.saturation, i.lightness) : "rgba(" + x_(i.hue, i.saturation, i.lightness) + "," + i.alpha + ")";
  throw new Xa(2);
}
function d7(i, e, t) {
  if (typeof i == "number" && typeof e == "number" && typeof t == "number")
    return c3("#" + zc(i) + zc(e) + zc(t));
  if (typeof i == "object" && e === void 0 && t === void 0)
    return c3("#" + zc(i.red) + zc(i.green) + zc(i.blue));
  throw new Xa(6);
}
function cx(i, e, t, n) {
  if (typeof i == "object" && e === void 0 && t === void 0 && n === void 0)
    return i.alpha >= 1 ? d7(i.red, i.green, i.blue) : "rgba(" + i.red + "," + i.green + "," + i.blue + "," + i.alpha + ")";
  throw new Xa(7);
}
var Phe = function(e) {
  return typeof e.red == "number" && typeof e.green == "number" && typeof e.blue == "number" && (typeof e.alpha != "number" || typeof e.alpha > "u");
}, Nhe = function(e) {
  return typeof e.red == "number" && typeof e.green == "number" && typeof e.blue == "number" && typeof e.alpha == "number";
}, Dhe = function(e) {
  return typeof e.hue == "number" && typeof e.saturation == "number" && typeof e.lightness == "number" && (typeof e.alpha != "number" || typeof e.alpha > "u");
}, Lhe = function(e) {
  return typeof e.hue == "number" && typeof e.saturation == "number" && typeof e.lightness == "number" && typeof e.alpha == "number";
};
function cc(i) {
  if (typeof i != "object") throw new Xa(8);
  if (Nhe(i)) return cx(i);
  if (Phe(i)) return d7(i);
  if (Lhe(i)) return Che(i);
  if (Dhe(i)) return Rhe(i);
  throw new Xa(8);
}
function f7(i, e, t) {
  return function() {
    var r = t.concat(Array.prototype.slice.call(arguments));
    return r.length >= e ? i.apply(this, r) : f7(i, e, r);
  };
}
function Po(i) {
  return f7(i, i.length, []);
}
function Ihe(i, e) {
  if (e === "transparent") return e;
  var t = uc(e);
  return cc(ao({}, t, {
    hue: t.hue + parseFloat(i)
  }));
}
Po(Ihe);
function pA(i, e, t) {
  return Math.max(i, Math.min(e, t));
}
function Bhe(i, e) {
  if (e === "transparent") return e;
  var t = uc(e);
  return cc(ao({}, t, {
    lightness: pA(0, 1, t.lightness - parseFloat(i))
  }));
}
Po(Bhe);
function Fhe(i, e) {
  if (e === "transparent") return e;
  var t = uc(e);
  return cc(ao({}, t, {
    saturation: pA(0, 1, t.saturation - parseFloat(i))
  }));
}
Po(Fhe);
function Uhe(i, e) {
  if (e === "transparent") return e;
  var t = uc(e);
  return cc(ao({}, t, {
    lightness: pA(0, 1, t.lightness + parseFloat(i))
  }));
}
Po(Uhe);
function Ohe(i, e, t) {
  if (e === "transparent") return t;
  if (t === "transparent") return e;
  if (i === 0) return t;
  var n = Jf(e), r = ao({}, n, {
    alpha: typeof n.alpha == "number" ? n.alpha : 1
  }), s = Jf(t), o = ao({}, s, {
    alpha: typeof s.alpha == "number" ? s.alpha : 1
  }), a = r.alpha - o.alpha, l = parseFloat(i) * 2 - 1, u = l * a === -1 ? l : l + a, c = 1 + l * a, A = (u / c + 1) / 2, m = 1 - A, _ = {
    red: Math.floor(r.red * A + o.red * m),
    green: Math.floor(r.green * A + o.green * m),
    blue: Math.floor(r.blue * A + o.blue * m),
    alpha: r.alpha * parseFloat(i) + o.alpha * (1 - parseFloat(i))
  };
  return cx(_);
}
var khe = Po(Ohe), A7 = khe;
function Vhe(i, e) {
  if (e === "transparent") return e;
  var t = Jf(e), n = typeof t.alpha == "number" ? t.alpha : 1, r = ao({}, t, {
    alpha: pA(0, 1, (n * 100 + parseFloat(i) * 100) / 100)
  });
  return cx(r);
}
var Ghe = Po(Vhe), zhe = Ghe;
function qhe(i, e) {
  if (e === "transparent") return e;
  var t = uc(e);
  return cc(ao({}, t, {
    saturation: pA(0, 1, t.saturation + parseFloat(i))
  }));
}
Po(qhe);
function Hhe(i, e) {
  return e === "transparent" ? e : cc(ao({}, uc(e), {
    hue: parseFloat(i)
  }));
}
Po(Hhe);
function Whe(i, e) {
  return e === "transparent" ? e : cc(ao({}, uc(e), {
    lightness: parseFloat(i)
  }));
}
Po(Whe);
function $he(i, e) {
  return e === "transparent" ? e : cc(ao({}, uc(e), {
    saturation: parseFloat(i)
  }));
}
Po($he);
function jhe(i, e) {
  return e === "transparent" ? e : A7(parseFloat(i), "rgb(0, 0, 0)", e);
}
Po(jhe);
function Xhe(i, e) {
  return e === "transparent" ? e : A7(parseFloat(i), "rgb(255, 255, 255)", e);
}
Po(Xhe);
function Yhe(i, e) {
  if (e === "transparent") return e;
  var t = Jf(e), n = typeof t.alpha == "number" ? t.alpha : 1, r = ao({}, t, {
    alpha: pA(0, 1, +(n * 100 - parseFloat(i) * 100).toFixed(2) / 100)
  });
  return cx(r);
}
Po(Yhe);
var h3 = "http://www.w3.org/1999/xhtml";
const o5 = {
  svg: "http://www.w3.org/2000/svg",
  xhtml: h3,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};
function p7(i) {
  var e = i += "", t = e.indexOf(":");
  return t >= 0 && (e = i.slice(0, t)) !== "xmlns" && (i = i.slice(t + 1)), o5.hasOwnProperty(e) ? { space: o5[e], local: i } : i;
}
function Qhe(i) {
  return function() {
    var e = this.ownerDocument, t = this.namespaceURI;
    return t === h3 && e.documentElement.namespaceURI === h3 ? e.createElement(i) : e.createElementNS(t, i);
  };
}
function Khe(i) {
  return function() {
    return this.ownerDocument.createElementNS(i.space, i.local);
  };
}
function m7(i) {
  var e = p7(i);
  return (e.local ? Khe : Qhe)(e);
}
function Zhe() {
}
function g7(i) {
  return i == null ? Zhe : function() {
    return this.querySelector(i);
  };
}
function Jhe(i) {
  typeof i != "function" && (i = g7(i));
  for (var e = this._groups, t = e.length, n = new Array(t), r = 0; r < t; ++r)
    for (var s = e[r], o = s.length, a = n[r] = new Array(o), l, u, c = 0; c < o; ++c)
      (l = s[c]) && (u = i.call(l, l.__data__, c, s)) && ("__data__" in l && (u.__data__ = l.__data__), a[c] = u);
  return new Yo(n, this._parents);
}
function ede(i) {
  return i == null ? [] : Array.isArray(i) ? i : Array.from(i);
}
function tde() {
  return [];
}
function nde(i) {
  return i == null ? tde : function() {
    return this.querySelectorAll(i);
  };
}
function ide(i) {
  return function() {
    return ede(i.apply(this, arguments));
  };
}
function rde(i) {
  typeof i == "function" ? i = ide(i) : i = nde(i);
  for (var e = this._groups, t = e.length, n = [], r = [], s = 0; s < t; ++s)
    for (var o = e[s], a = o.length, l, u = 0; u < a; ++u)
      (l = o[u]) && (n.push(i.call(l, l.__data__, u, o)), r.push(l));
  return new Yo(n, r);
}
function sde(i) {
  return function() {
    return this.matches(i);
  };
}
function _7(i) {
  return function(e) {
    return e.matches(i);
  };
}
var ode = Array.prototype.find;
function ade(i) {
  return function() {
    return ode.call(this.children, i);
  };
}
function lde() {
  return this.firstElementChild;
}
function ude(i) {
  return this.select(i == null ? lde : ade(typeof i == "function" ? i : _7(i)));
}
var cde = Array.prototype.filter;
function hde() {
  return Array.from(this.children);
}
function dde(i) {
  return function() {
    return cde.call(this.children, i);
  };
}
function fde(i) {
  return this.selectAll(i == null ? hde : dde(typeof i == "function" ? i : _7(i)));
}
function Ade(i) {
  typeof i != "function" && (i = sde(i));
  for (var e = this._groups, t = e.length, n = new Array(t), r = 0; r < t; ++r)
    for (var s = e[r], o = s.length, a = n[r] = [], l, u = 0; u < o; ++u)
      (l = s[u]) && i.call(l, l.__data__, u, s) && a.push(l);
  return new Yo(n, this._parents);
}
function x7(i) {
  return new Array(i.length);
}
function pde() {
  return new Yo(this._enter || this._groups.map(x7), this._parents);
}
function y_(i, e) {
  this.ownerDocument = i.ownerDocument, this.namespaceURI = i.namespaceURI, this._next = null, this._parent = i, this.__data__ = e;
}
y_.prototype = {
  constructor: y_,
  appendChild: function(i) {
    return this._parent.insertBefore(i, this._next);
  },
  insertBefore: function(i, e) {
    return this._parent.insertBefore(i, e);
  },
  querySelector: function(i) {
    return this._parent.querySelector(i);
  },
  querySelectorAll: function(i) {
    return this._parent.querySelectorAll(i);
  }
};
function mde(i) {
  return function() {
    return i;
  };
}
function gde(i, e, t, n, r, s) {
  for (var o = 0, a, l = e.length, u = s.length; o < u; ++o)
    (a = e[o]) ? (a.__data__ = s[o], n[o] = a) : t[o] = new y_(i, s[o]);
  for (; o < l; ++o)
    (a = e[o]) && (r[o] = a);
}
function _de(i, e, t, n, r, s, o) {
  var a, l, u = /* @__PURE__ */ new Map(), c = e.length, A = s.length, m = new Array(c), _;
  for (a = 0; a < c; ++a)
    (l = e[a]) && (m[a] = _ = o.call(l, l.__data__, a, e) + "", u.has(_) ? r[a] = l : u.set(_, l));
  for (a = 0; a < A; ++a)
    _ = o.call(i, s[a], a, s) + "", (l = u.get(_)) ? (n[a] = l, l.__data__ = s[a], u.delete(_)) : t[a] = new y_(i, s[a]);
  for (a = 0; a < c; ++a)
    (l = e[a]) && u.get(m[a]) === l && (r[a] = l);
}
function xde(i) {
  return i.__data__;
}
function yde(i, e) {
  if (!arguments.length) return Array.from(this, xde);
  var t = e ? _de : gde, n = this._parents, r = this._groups;
  typeof i != "function" && (i = mde(i));
  for (var s = r.length, o = new Array(s), a = new Array(s), l = new Array(s), u = 0; u < s; ++u) {
    var c = n[u], A = r[u], m = A.length, _ = vde(i.call(c, c && c.__data__, u, n)), y = _.length, T = a[u] = new Array(y), b = o[u] = new Array(y), S = l[u] = new Array(m);
    t(c, A, T, b, S, _, e);
    for (var E = 0, R = 0, C, L; E < y; ++E)
      if (C = T[E]) {
        for (E >= R && (R = E + 1); !(L = b[R]) && ++R < y; ) ;
        C._next = L || null;
      }
  }
  return o = new Yo(o, n), o._enter = a, o._exit = l, o;
}
function vde(i) {
  return typeof i == "object" && "length" in i ? i : Array.from(i);
}
function bde() {
  return new Yo(this._exit || this._groups.map(x7), this._parents);
}
function Sde(i, e, t) {
  var n = this.enter(), r = this, s = this.exit();
  return typeof i == "function" ? (n = i(n), n && (n = n.selection())) : n = n.append(i + ""), e != null && (r = e(r), r && (r = r.selection())), t == null ? s.remove() : t(s), n && r ? n.merge(r).order() : r;
}
function Tde(i) {
  for (var e = i.selection ? i.selection() : i, t = this._groups, n = e._groups, r = t.length, s = n.length, o = Math.min(r, s), a = new Array(r), l = 0; l < o; ++l)
    for (var u = t[l], c = n[l], A = u.length, m = a[l] = new Array(A), _, y = 0; y < A; ++y)
      (_ = u[y] || c[y]) && (m[y] = _);
  for (; l < r; ++l)
    a[l] = t[l];
  return new Yo(a, this._parents);
}
function wde() {
  for (var i = this._groups, e = -1, t = i.length; ++e < t; )
    for (var n = i[e], r = n.length - 1, s = n[r], o; --r >= 0; )
      (o = n[r]) && (s && o.compareDocumentPosition(s) ^ 4 && s.parentNode.insertBefore(o, s), s = o);
  return this;
}
function Mde(i) {
  i || (i = Ede);
  function e(A, m) {
    return A && m ? i(A.__data__, m.__data__) : !A - !m;
  }
  for (var t = this._groups, n = t.length, r = new Array(n), s = 0; s < n; ++s) {
    for (var o = t[s], a = o.length, l = r[s] = new Array(a), u, c = 0; c < a; ++c)
      (u = o[c]) && (l[c] = u);
    l.sort(e);
  }
  return new Yo(r, this._parents).order();
}
function Ede(i, e) {
  return i < e ? -1 : i > e ? 1 : i >= e ? 0 : NaN;
}
function Rde() {
  var i = arguments[0];
  return arguments[0] = this, i.apply(null, arguments), this;
}
function Cde() {
  return Array.from(this);
}
function Pde() {
  for (var i = this._groups, e = 0, t = i.length; e < t; ++e)
    for (var n = i[e], r = 0, s = n.length; r < s; ++r) {
      var o = n[r];
      if (o) return o;
    }
  return null;
}
function Nde() {
  let i = 0;
  for (const e of this) ++i;
  return i;
}
function Dde() {
  return !this.node();
}
function Lde(i) {
  for (var e = this._groups, t = 0, n = e.length; t < n; ++t)
    for (var r = e[t], s = 0, o = r.length, a; s < o; ++s)
      (a = r[s]) && i.call(a, a.__data__, s, r);
  return this;
}
function Ide(i) {
  return function() {
    this.removeAttribute(i);
  };
}
function Bde(i) {
  return function() {
    this.removeAttributeNS(i.space, i.local);
  };
}
function Fde(i, e) {
  return function() {
    this.setAttribute(i, e);
  };
}
function Ude(i, e) {
  return function() {
    this.setAttributeNS(i.space, i.local, e);
  };
}
function Ode(i, e) {
  return function() {
    var t = e.apply(this, arguments);
    t == null ? this.removeAttribute(i) : this.setAttribute(i, t);
  };
}
function kde(i, e) {
  return function() {
    var t = e.apply(this, arguments);
    t == null ? this.removeAttributeNS(i.space, i.local) : this.setAttributeNS(i.space, i.local, t);
  };
}
function Vde(i, e) {
  var t = p7(i);
  if (arguments.length < 2) {
    var n = this.node();
    return t.local ? n.getAttributeNS(t.space, t.local) : n.getAttribute(t);
  }
  return this.each((e == null ? t.local ? Bde : Ide : typeof e == "function" ? t.local ? kde : Ode : t.local ? Ude : Fde)(t, e));
}
function y7(i) {
  return i.ownerDocument && i.ownerDocument.defaultView || i.document && i || i.defaultView;
}
function Gde(i) {
  return function() {
    this.style.removeProperty(i);
  };
}
function zde(i, e, t) {
  return function() {
    this.style.setProperty(i, e, t);
  };
}
function qde(i, e, t) {
  return function() {
    var n = e.apply(this, arguments);
    n == null ? this.style.removeProperty(i) : this.style.setProperty(i, n, t);
  };
}
function Hde(i, e, t) {
  return arguments.length > 1 ? this.each((e == null ? Gde : typeof e == "function" ? qde : zde)(i, e, t ?? "")) : Wde(this.node(), i);
}
function Wde(i, e) {
  return i.style.getPropertyValue(e) || y7(i).getComputedStyle(i, null).getPropertyValue(e);
}
function $de(i) {
  return function() {
    delete this[i];
  };
}
function jde(i, e) {
  return function() {
    this[i] = e;
  };
}
function Xde(i, e) {
  return function() {
    var t = e.apply(this, arguments);
    t == null ? delete this[i] : this[i] = t;
  };
}
function Yde(i, e) {
  return arguments.length > 1 ? this.each((e == null ? $de : typeof e == "function" ? Xde : jde)(i, e)) : this.node()[i];
}
function v7(i) {
  return i.trim().split(/^|\s+/);
}
function _w(i) {
  return i.classList || new b7(i);
}
function b7(i) {
  this._node = i, this._names = v7(i.getAttribute("class") || "");
}
b7.prototype = {
  add: function(i) {
    var e = this._names.indexOf(i);
    e < 0 && (this._names.push(i), this._node.setAttribute("class", this._names.join(" ")));
  },
  remove: function(i) {
    var e = this._names.indexOf(i);
    e >= 0 && (this._names.splice(e, 1), this._node.setAttribute("class", this._names.join(" ")));
  },
  contains: function(i) {
    return this._names.indexOf(i) >= 0;
  }
};
function S7(i, e) {
  for (var t = _w(i), n = -1, r = e.length; ++n < r; ) t.add(e[n]);
}
function T7(i, e) {
  for (var t = _w(i), n = -1, r = e.length; ++n < r; ) t.remove(e[n]);
}
function Qde(i) {
  return function() {
    S7(this, i);
  };
}
function Kde(i) {
  return function() {
    T7(this, i);
  };
}
function Zde(i, e) {
  return function() {
    (e.apply(this, arguments) ? S7 : T7)(this, i);
  };
}
function Jde(i, e) {
  var t = v7(i + "");
  if (arguments.length < 2) {
    for (var n = _w(this.node()), r = -1, s = t.length; ++r < s; ) if (!n.contains(t[r])) return !1;
    return !0;
  }
  return this.each((typeof e == "function" ? Zde : e ? Qde : Kde)(t, e));
}
function efe() {
  this.textContent = "";
}
function tfe(i) {
  return function() {
    this.textContent = i;
  };
}
function nfe(i) {
  return function() {
    var e = i.apply(this, arguments);
    this.textContent = e ?? "";
  };
}
function ife(i) {
  return arguments.length ? this.each(i == null ? efe : (typeof i == "function" ? nfe : tfe)(i)) : this.node().textContent;
}
function rfe() {
  this.innerHTML = "";
}
function sfe(i) {
  return function() {
    this.innerHTML = i;
  };
}
function ofe(i) {
  return function() {
    var e = i.apply(this, arguments);
    this.innerHTML = e ?? "";
  };
}
function afe(i) {
  return arguments.length ? this.each(i == null ? rfe : (typeof i == "function" ? ofe : sfe)(i)) : this.node().innerHTML;
}
function lfe() {
  this.nextSibling && this.parentNode.appendChild(this);
}
function ufe() {
  return this.each(lfe);
}
function cfe() {
  this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function hfe() {
  return this.each(cfe);
}
function dfe(i) {
  var e = typeof i == "function" ? i : m7(i);
  return this.select(function() {
    return this.appendChild(e.apply(this, arguments));
  });
}
function ffe() {
  return null;
}
function Afe(i, e) {
  var t = typeof i == "function" ? i : m7(i), n = e == null ? ffe : typeof e == "function" ? e : g7(e);
  return this.select(function() {
    return this.insertBefore(t.apply(this, arguments), n.apply(this, arguments) || null);
  });
}
function pfe() {
  var i = this.parentNode;
  i && i.removeChild(this);
}
function mfe() {
  return this.each(pfe);
}
function gfe() {
  var i = this.cloneNode(!1), e = this.parentNode;
  return e ? e.insertBefore(i, this.nextSibling) : i;
}
function _fe() {
  var i = this.cloneNode(!0), e = this.parentNode;
  return e ? e.insertBefore(i, this.nextSibling) : i;
}
function xfe(i) {
  return this.select(i ? _fe : gfe);
}
function yfe(i) {
  return arguments.length ? this.property("__data__", i) : this.node().__data__;
}
function vfe(i) {
  return function(e) {
    i.call(this, e, this.__data__);
  };
}
function bfe(i) {
  return i.trim().split(/^|\s+/).map(function(e) {
    var t = "", n = e.indexOf(".");
    return n >= 0 && (t = e.slice(n + 1), e = e.slice(0, n)), { type: e, name: t };
  });
}
function Sfe(i) {
  return function() {
    var e = this.__on;
    if (e) {
      for (var t = 0, n = -1, r = e.length, s; t < r; ++t)
        s = e[t], (!i.type || s.type === i.type) && s.name === i.name ? this.removeEventListener(s.type, s.listener, s.options) : e[++n] = s;
      ++n ? e.length = n : delete this.__on;
    }
  };
}
function Tfe(i, e, t) {
  return function() {
    var n = this.__on, r, s = vfe(e);
    if (n) {
      for (var o = 0, a = n.length; o < a; ++o)
        if ((r = n[o]).type === i.type && r.name === i.name) {
          this.removeEventListener(r.type, r.listener, r.options), this.addEventListener(r.type, r.listener = s, r.options = t), r.value = e;
          return;
        }
    }
    this.addEventListener(i.type, s, t), r = { type: i.type, name: i.name, value: e, listener: s, options: t }, n ? n.push(r) : this.__on = [r];
  };
}
function wfe(i, e, t) {
  var n = bfe(i + ""), r, s = n.length, o;
  if (arguments.length < 2) {
    var a = this.node().__on;
    if (a) {
      for (var l = 0, u = a.length, c; l < u; ++l)
        for (r = 0, c = a[l]; r < s; ++r)
          if ((o = n[r]).type === c.type && o.name === c.name)
            return c.value;
    }
    return;
  }
  for (a = e ? Tfe : Sfe, r = 0; r < s; ++r) this.each(a(n[r], e, t));
  return this;
}
function w7(i, e, t) {
  var n = y7(i), r = n.CustomEvent;
  typeof r == "function" ? r = new r(e, t) : (r = n.document.createEvent("Event"), t ? (r.initEvent(e, t.bubbles, t.cancelable), r.detail = t.detail) : r.initEvent(e, !1, !1)), i.dispatchEvent(r);
}
function Mfe(i, e) {
  return function() {
    return w7(this, i, e);
  };
}
function Efe(i, e) {
  return function() {
    return w7(this, i, e.apply(this, arguments));
  };
}
function Rfe(i, e) {
  return this.each((typeof e == "function" ? Efe : Mfe)(i, e));
}
function* Cfe() {
  for (var i = this._groups, e = 0, t = i.length; e < t; ++e)
    for (var n = i[e], r = 0, s = n.length, o; r < s; ++r)
      (o = n[r]) && (yield o);
}
var Pfe = [null];
function Yo(i, e) {
  this._groups = i, this._parents = e;
}
function Nfe() {
  return this;
}
Yo.prototype = {
  constructor: Yo,
  select: Jhe,
  selectAll: rde,
  selectChild: ude,
  selectChildren: fde,
  filter: Ade,
  data: yde,
  enter: pde,
  exit: bde,
  join: Sde,
  merge: Tde,
  selection: Nfe,
  order: wde,
  sort: Mde,
  call: Rde,
  nodes: Cde,
  node: Pde,
  size: Nde,
  empty: Dde,
  each: Lde,
  attr: Vde,
  style: Hde,
  property: Yde,
  classed: Jde,
  text: ife,
  html: afe,
  raise: ufe,
  lower: hfe,
  append: dfe,
  insert: Afe,
  remove: mfe,
  clone: xfe,
  datum: yfe,
  on: wfe,
  dispatch: Rfe,
  [Symbol.iterator]: Cfe
};
function Dfe(i) {
  return typeof i == "string" ? new Yo([[document.querySelector(i)]], [document.documentElement]) : new Yo([[i]], Pfe);
}
function Lfe(i) {
  let e;
  for (; e = i.sourceEvent; ) i = e;
  return i;
}
function Ife(i, e) {
  if (i = Lfe(i), e === void 0 && (e = i.currentTarget), e) {
    var t = e.ownerSVGElement || e;
    if (t.createSVGPoint) {
      var n = t.createSVGPoint();
      return n.x = i.clientX, n.y = i.clientY, n = n.matrixTransform(e.getScreenCTM().inverse()), [n.x, n.y];
    }
    if (e.getBoundingClientRect) {
      var r = e.getBoundingClientRect();
      return [i.clientX - r.left - e.clientLeft, i.clientY - r.top - e.clientTop];
    }
  }
  return [i.pageX, i.pageY];
}
var j0, Gi, M7, E7, Xc, a5, R7, C7, P7, xw, d3, f3, f0 = {}, N7 = [], Bfe = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i, hx = Array.isArray;
function Ya(i, e) {
  for (var t in e) i[t] = e[t];
  return i;
}
function yw(i) {
  i && i.parentNode && i.parentNode.removeChild(i);
}
function Ffe(i, e, t) {
  var n, r, s, o = {};
  for (s in e) s == "key" ? n = e[s] : s == "ref" ? r = e[s] : o[s] = e[s];
  if (arguments.length > 2 && (o.children = arguments.length > 3 ? j0.call(arguments, 2) : t), typeof i == "function" && i.defaultProps != null) for (s in i.defaultProps) o[s] === void 0 && (o[s] = i.defaultProps[s]);
  return Bp(i, o, n, r, null);
}
function Bp(i, e, t, n, r) {
  var s = { type: i, props: e, key: t, ref: n, __k: null, __: null, __b: 0, __e: null, __c: null, constructor: void 0, __v: r ?? ++M7, __i: -1, __u: 0 };
  return r == null && Gi.vnode != null && Gi.vnode(s), s;
}
function dx(i) {
  return i.children;
}
function c1(i, e) {
  this.props = i, this.context = e;
}
function eA(i, e) {
  if (e == null) return i.__ ? eA(i.__, i.__i + 1) : null;
  for (var t; e < i.__k.length; e++) if ((t = i.__k[e]) != null && t.__e != null) return t.__e;
  return typeof i.type == "function" ? eA(i) : null;
}
function D7(i) {
  var e, t;
  if ((i = i.__) != null && i.__c != null) {
    for (i.__e = i.__c.base = null, e = 0; e < i.__k.length; e++) if ((t = i.__k[e]) != null && t.__e != null) {
      i.__e = i.__c.base = t.__e;
      break;
    }
    return D7(i);
  }
}
function l5(i) {
  (!i.__d && (i.__d = !0) && Xc.push(i) && !v_.__r++ || a5 != Gi.debounceRendering) && ((a5 = Gi.debounceRendering) || R7)(v_);
}
function v_() {
  for (var i, e, t, n, r, s, o, a = 1; Xc.length; ) Xc.length > a && Xc.sort(C7), i = Xc.shift(), a = Xc.length, i.__d && (t = void 0, n = void 0, r = (n = (e = i).__v).__e, s = [], o = [], e.__P && ((t = Ya({}, n)).__v = n.__v + 1, Gi.vnode && Gi.vnode(t), vw(e.__P, t, n, e.__n, e.__P.namespaceURI, 32 & n.__u ? [r] : null, s, r ?? eA(n), !!(32 & n.__u), o), t.__v = n.__v, t.__.__k[t.__i] = t, B7(s, t, o), n.__e = n.__ = null, t.__e != r && D7(t)));
  v_.__r = 0;
}
function L7(i, e, t, n, r, s, o, a, l, u, c) {
  var A, m, _, y, T, b, S, E = n && n.__k || N7, R = e.length;
  for (l = Ufe(t, e, E, l, R), A = 0; A < R; A++) (_ = t.__k[A]) != null && (m = _.__i == -1 ? f0 : E[_.__i] || f0, _.__i = A, b = vw(i, _, m, r, s, o, a, l, u, c), y = _.__e, _.ref && m.ref != _.ref && (m.ref && bw(m.ref, null, _), c.push(_.ref, _.__c || y, _)), T == null && y != null && (T = y), (S = !!(4 & _.__u)) || m.__k === _.__k ? l = I7(_, l, i, S) : typeof _.type == "function" && b !== void 0 ? l = b : y && (l = y.nextSibling), _.__u &= -7);
  return t.__e = T, l;
}
function Ufe(i, e, t, n, r) {
  var s, o, a, l, u, c = t.length, A = c, m = 0;
  for (i.__k = new Array(r), s = 0; s < r; s++) (o = e[s]) != null && typeof o != "boolean" && typeof o != "function" ? (typeof o == "string" || typeof o == "number" || typeof o == "bigint" || o.constructor == String ? o = i.__k[s] = Bp(null, o, null, null, null) : hx(o) ? o = i.__k[s] = Bp(dx, { children: o }, null, null, null) : o.constructor === void 0 && o.__b > 0 ? o = i.__k[s] = Bp(o.type, o.props, o.key, o.ref ? o.ref : null, o.__v) : i.__k[s] = o, l = s + m, o.__ = i, o.__b = i.__b + 1, a = null, (u = o.__i = Ofe(o, t, l, A)) != -1 && (A--, (a = t[u]) && (a.__u |= 2)), a == null || a.__v == null ? (u == -1 && (r > c ? m-- : r < c && m++), typeof o.type != "function" && (o.__u |= 4)) : u != l && (u == l - 1 ? m-- : u == l + 1 ? m++ : (u > l ? m-- : m++, o.__u |= 4))) : i.__k[s] = null;
  if (A) for (s = 0; s < c; s++) (a = t[s]) != null && (2 & a.__u) == 0 && (a.__e == n && (n = eA(a)), U7(a, a));
  return n;
}
function I7(i, e, t, n) {
  var r, s;
  if (typeof i.type == "function") {
    for (r = i.__k, s = 0; r && s < r.length; s++) r[s] && (r[s].__ = i, e = I7(r[s], e, t, n));
    return e;
  }
  i.__e != e && (n && (e && i.type && !e.parentNode && (e = eA(i)), t.insertBefore(i.__e, e || null)), e = i.__e);
  do
    e = e && e.nextSibling;
  while (e != null && e.nodeType == 8);
  return e;
}
function Ofe(i, e, t, n) {
  var r, s, o, a = i.key, l = i.type, u = e[t], c = u != null && (2 & u.__u) == 0;
  if (u === null && a == null || c && a == u.key && l == u.type) return t;
  if (n > (c ? 1 : 0)) {
    for (r = t - 1, s = t + 1; r >= 0 || s < e.length; ) if ((u = e[o = r >= 0 ? r-- : s++]) != null && (2 & u.__u) == 0 && a == u.key && l == u.type) return o;
  }
  return -1;
}
function u5(i, e, t) {
  e[0] == "-" ? i.setProperty(e, t ?? "") : i[e] = t == null ? "" : typeof t != "number" || Bfe.test(e) ? t : t + "px";
}
function Hg(i, e, t, n, r) {
  var s, o;
  e: if (e == "style") if (typeof t == "string") i.style.cssText = t;
  else {
    if (typeof n == "string" && (i.style.cssText = n = ""), n) for (e in n) t && e in t || u5(i.style, e, "");
    if (t) for (e in t) n && t[e] == n[e] || u5(i.style, e, t[e]);
  }
  else if (e[0] == "o" && e[1] == "n") s = e != (e = e.replace(P7, "$1")), o = e.toLowerCase(), e = o in i || e == "onFocusOut" || e == "onFocusIn" ? o.slice(2) : e.slice(2), i.l || (i.l = {}), i.l[e + s] = t, t ? n ? t.u = n.u : (t.u = xw, i.addEventListener(e, s ? f3 : d3, s)) : i.removeEventListener(e, s ? f3 : d3, s);
  else {
    if (r == "http://www.w3.org/2000/svg") e = e.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
    else if (e != "width" && e != "height" && e != "href" && e != "list" && e != "form" && e != "tabIndex" && e != "download" && e != "rowSpan" && e != "colSpan" && e != "role" && e != "popover" && e in i) try {
      i[e] = t ?? "";
      break e;
    } catch {
    }
    typeof t == "function" || (t == null || t === !1 && e[4] != "-" ? i.removeAttribute(e) : i.setAttribute(e, e == "popover" && t == 1 ? "" : t));
  }
}
function c5(i) {
  return function(e) {
    if (this.l) {
      var t = this.l[e.type + i];
      if (e.t == null) e.t = xw++;
      else if (e.t < t.u) return;
      return t(Gi.event ? Gi.event(e) : e);
    }
  };
}
function vw(i, e, t, n, r, s, o, a, l, u) {
  var c, A, m, _, y, T, b, S, E, R, C, L, D, B, U, N, O, G = e.type;
  if (e.constructor !== void 0) return null;
  128 & t.__u && (l = !!(32 & t.__u), s = [a = e.__e = t.__e]), (c = Gi.__b) && c(e);
  e: if (typeof G == "function") try {
    if (S = e.props, E = "prototype" in G && G.prototype.render, R = (c = G.contextType) && n[c.__c], C = c ? R ? R.props.value : c.__ : n, t.__c ? b = (A = e.__c = t.__c).__ = A.__E : (E ? e.__c = A = new G(S, C) : (e.__c = A = new c1(S, C), A.constructor = G, A.render = Vfe), R && R.sub(A), A.state || (A.state = {}), A.__n = n, m = A.__d = !0, A.__h = [], A._sb = []), E && A.__s == null && (A.__s = A.state), E && G.getDerivedStateFromProps != null && (A.__s == A.state && (A.__s = Ya({}, A.__s)), Ya(A.__s, G.getDerivedStateFromProps(S, A.__s))), _ = A.props, y = A.state, A.__v = e, m) E && G.getDerivedStateFromProps == null && A.componentWillMount != null && A.componentWillMount(), E && A.componentDidMount != null && A.__h.push(A.componentDidMount);
    else {
      if (E && G.getDerivedStateFromProps == null && S !== _ && A.componentWillReceiveProps != null && A.componentWillReceiveProps(S, C), e.__v == t.__v || !A.__e && A.shouldComponentUpdate != null && A.shouldComponentUpdate(S, A.__s, C) === !1) {
        for (e.__v != t.__v && (A.props = S, A.state = A.__s, A.__d = !1), e.__e = t.__e, e.__k = t.__k, e.__k.some(function(H) {
          H && (H.__ = e);
        }), L = 0; L < A._sb.length; L++) A.__h.push(A._sb[L]);
        A._sb = [], A.__h.length && o.push(A);
        break e;
      }
      A.componentWillUpdate != null && A.componentWillUpdate(S, A.__s, C), E && A.componentDidUpdate != null && A.__h.push(function() {
        A.componentDidUpdate(_, y, T);
      });
    }
    if (A.context = C, A.props = S, A.__P = i, A.__e = !1, D = Gi.__r, B = 0, E) {
      for (A.state = A.__s, A.__d = !1, D && D(e), c = A.render(A.props, A.state, A.context), U = 0; U < A._sb.length; U++) A.__h.push(A._sb[U]);
      A._sb = [];
    } else do
      A.__d = !1, D && D(e), c = A.render(A.props, A.state, A.context), A.state = A.__s;
    while (A.__d && ++B < 25);
    A.state = A.__s, A.getChildContext != null && (n = Ya(Ya({}, n), A.getChildContext())), E && !m && A.getSnapshotBeforeUpdate != null && (T = A.getSnapshotBeforeUpdate(_, y)), N = c, c != null && c.type === dx && c.key == null && (N = F7(c.props.children)), a = L7(i, hx(N) ? N : [N], e, t, n, r, s, o, a, l, u), A.base = e.__e, e.__u &= -161, A.__h.length && o.push(A), b && (A.__E = A.__ = null);
  } catch (H) {
    if (e.__v = null, l || s != null) if (H.then) {
      for (e.__u |= l ? 160 : 128; a && a.nodeType == 8 && a.nextSibling; ) a = a.nextSibling;
      s[s.indexOf(a)] = null, e.__e = a;
    } else {
      for (O = s.length; O--; ) yw(s[O]);
      A3(e);
    }
    else e.__e = t.__e, e.__k = t.__k, H.then || A3(e);
    Gi.__e(H, e, t);
  }
  else s == null && e.__v == t.__v ? (e.__k = t.__k, e.__e = t.__e) : a = e.__e = kfe(t.__e, e, t, n, r, s, o, l, u);
  return (c = Gi.diffed) && c(e), 128 & e.__u ? void 0 : a;
}
function A3(i) {
  i && i.__c && (i.__c.__e = !0), i && i.__k && i.__k.forEach(A3);
}
function B7(i, e, t) {
  for (var n = 0; n < t.length; n++) bw(t[n], t[++n], t[++n]);
  Gi.__c && Gi.__c(e, i), i.some(function(r) {
    try {
      i = r.__h, r.__h = [], i.some(function(s) {
        s.call(r);
      });
    } catch (s) {
      Gi.__e(s, r.__v);
    }
  });
}
function F7(i) {
  return typeof i != "object" || i == null || i.__b && i.__b > 0 ? i : hx(i) ? i.map(F7) : Ya({}, i);
}
function kfe(i, e, t, n, r, s, o, a, l) {
  var u, c, A, m, _, y, T, b = t.props || f0, S = e.props, E = e.type;
  if (E == "svg" ? r = "http://www.w3.org/2000/svg" : E == "math" ? r = "http://www.w3.org/1998/Math/MathML" : r || (r = "http://www.w3.org/1999/xhtml"), s != null) {
    for (u = 0; u < s.length; u++) if ((_ = s[u]) && "setAttribute" in _ == !!E && (E ? _.localName == E : _.nodeType == 3)) {
      i = _, s[u] = null;
      break;
    }
  }
  if (i == null) {
    if (E == null) return document.createTextNode(S);
    i = document.createElementNS(r, E, S.is && S), a && (Gi.__m && Gi.__m(e, s), a = !1), s = null;
  }
  if (E == null) b === S || a && i.data == S || (i.data = S);
  else {
    if (s = s && j0.call(i.childNodes), !a && s != null) for (b = {}, u = 0; u < i.attributes.length; u++) b[(_ = i.attributes[u]).name] = _.value;
    for (u in b) if (_ = b[u], u != "children") {
      if (u == "dangerouslySetInnerHTML") A = _;
      else if (!(u in S)) {
        if (u == "value" && "defaultValue" in S || u == "checked" && "defaultChecked" in S) continue;
        Hg(i, u, null, _, r);
      }
    }
    for (u in S) _ = S[u], u == "children" ? m = _ : u == "dangerouslySetInnerHTML" ? c = _ : u == "value" ? y = _ : u == "checked" ? T = _ : a && typeof _ != "function" || b[u] === _ || Hg(i, u, _, b[u], r);
    if (c) a || A && (c.__html == A.__html || c.__html == i.innerHTML) || (i.innerHTML = c.__html), e.__k = [];
    else if (A && (i.innerHTML = ""), L7(e.type == "template" ? i.content : i, hx(m) ? m : [m], e, t, n, E == "foreignObject" ? "http://www.w3.org/1999/xhtml" : r, s, o, s ? s[0] : t.__k && eA(t, 0), a, l), s != null) for (u = s.length; u--; ) yw(s[u]);
    a || (u = "value", E == "progress" && y == null ? i.removeAttribute("value") : y != null && (y !== i[u] || E == "progress" && !y || E == "option" && y != b[u]) && Hg(i, u, y, b[u], r), u = "checked", T != null && T != i[u] && Hg(i, u, T, b[u], r));
  }
  return i;
}
function bw(i, e, t) {
  try {
    if (typeof i == "function") {
      var n = typeof i.__u == "function";
      n && i.__u(), n && e == null || (i.__u = i(e));
    } else i.current = e;
  } catch (r) {
    Gi.__e(r, t);
  }
}
function U7(i, e, t) {
  var n, r;
  if (Gi.unmount && Gi.unmount(i), (n = i.ref) && (n.current && n.current != i.__e || bw(n, null, e)), (n = i.__c) != null) {
    if (n.componentWillUnmount) try {
      n.componentWillUnmount();
    } catch (s) {
      Gi.__e(s, e);
    }
    n.base = n.__P = null;
  }
  if (n = i.__k) for (r = 0; r < n.length; r++) n[r] && U7(n[r], e, t || typeof i.type != "function");
  t || yw(i.__e), i.__c = i.__ = i.__e = void 0;
}
function Vfe(i, e, t) {
  return this.constructor(i, t);
}
function Gfe(i, e, t) {
  var n, r, s, o;
  e == document && (e = document.documentElement), Gi.__ && Gi.__(i, e), r = (n = !1) ? null : e.__k, s = [], o = [], vw(e, i = e.__k = Ffe(dx, null, [i]), r || f0, f0, e.namespaceURI, r ? null : e.firstChild ? j0.call(e.childNodes) : null, s, r ? r.__e : e.firstChild, n, o), B7(s, i, o);
}
function O7(i, e, t) {
  var n, r, s, o, a = Ya({}, i.props);
  for (s in i.type && i.type.defaultProps && (o = i.type.defaultProps), e) s == "key" ? n = e[s] : s == "ref" ? r = e[s] : a[s] = e[s] === void 0 && o != null ? o[s] : e[s];
  return arguments.length > 2 && (a.children = arguments.length > 3 ? j0.call(arguments, 2) : t), Bp(i.type, a, n || i.key, r || i.ref, null);
}
j0 = N7.slice, Gi = { __e: function(i, e, t, n) {
  for (var r, s, o; e = e.__; ) if ((r = e.__c) && !r.__) try {
    if ((s = r.constructor) && s.getDerivedStateFromError != null && (r.setState(s.getDerivedStateFromError(i)), o = r.__d), r.componentDidCatch != null && (r.componentDidCatch(i, n || {}), o = r.__d), o) return r.__E = r;
  } catch (a) {
    i = a;
  }
  throw i;
} }, M7 = 0, E7 = function(i) {
  return i != null && i.constructor === void 0;
}, c1.prototype.setState = function(i, e) {
  var t;
  t = this.__s != null && this.__s != this.state ? this.__s : this.__s = Ya({}, this.state), typeof i == "function" && (i = i(Ya({}, t), this.props)), i && Ya(t, i), i != null && this.__v && (e && this._sb.push(e), l5(this));
}, c1.prototype.forceUpdate = function(i) {
  this.__v && (this.__e = !0, i && this.__h.push(i), l5(this));
}, c1.prototype.render = dx, Xc = [], R7 = typeof Promise == "function" ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, C7 = function(i, e) {
  return i.__v.__b - e.__v.__b;
}, v_.__r = 0, P7 = /(PointerCapture)$|Capture$/i, xw = 0, d3 = c5(!1), f3 = c5(!0);
function h5(i, e) {
  (e == null || e > i.length) && (e = i.length);
  for (var t = 0, n = Array(e); t < e; t++) n[t] = i[t];
  return n;
}
function zfe(i) {
  if (Array.isArray(i)) return i;
}
function qfe(i, e, t) {
  return (e = Yfe(e)) in i ? Object.defineProperty(i, e, {
    value: t,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : i[e] = t, i;
}
function Hfe(i, e) {
  var t = i == null ? null : typeof Symbol < "u" && i[Symbol.iterator] || i["@@iterator"];
  if (t != null) {
    var n, r, s, o, a = [], l = !0, u = !1;
    try {
      if (s = (t = t.call(i)).next, e !== 0) for (; !(l = (n = s.call(t)).done) && (a.push(n.value), a.length !== e); l = !0) ;
    } catch (c) {
      u = !0, r = c;
    } finally {
      try {
        if (!l && t.return != null && (o = t.return(), Object(o) !== o)) return;
      } finally {
        if (u) throw r;
      }
    }
    return a;
  }
}
function Wfe() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function d5(i, e) {
  var t = Object.keys(i);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(i);
    e && (n = n.filter(function(r) {
      return Object.getOwnPropertyDescriptor(i, r).enumerable;
    })), t.push.apply(t, n);
  }
  return t;
}
function $fe(i) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? d5(Object(t), !0).forEach(function(n) {
      qfe(i, n, t[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(i, Object.getOwnPropertyDescriptors(t)) : d5(Object(t)).forEach(function(n) {
      Object.defineProperty(i, n, Object.getOwnPropertyDescriptor(t, n));
    });
  }
  return i;
}
function jfe(i, e) {
  return zfe(i) || Hfe(i, e) || Qfe(i, e) || Wfe();
}
function Xfe(i, e) {
  if (typeof i != "object" || !i) return i;
  var t = i[Symbol.toPrimitive];
  if (t !== void 0) {
    var n = t.call(i, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(i);
}
function Yfe(i) {
  var e = Xfe(i, "string");
  return typeof e == "symbol" ? e : e + "";
}
function b_(i) {
  "@babel/helpers - typeof";
  return b_ = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, b_(i);
}
function Qfe(i, e) {
  if (i) {
    if (typeof i == "string") return h5(i, e);
    var t = {}.toString.call(i).slice(8, -1);
    return t === "Object" && i.constructor && (t = i.constructor.name), t === "Map" || t === "Set" ? Array.from(i) : t === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? h5(i, e) : void 0;
  }
}
var p3 = function(e) {
  if (b_(e) !== "object") return e;
  var t = O7(e);
  if (t.props) {
    var n;
    t.props = $fe({}, t.props), t != null && (n = t.props) !== null && n !== void 0 && n.children && (t.props.children = Array.isArray(t.props.children) ? t.props.children.map(p3) : p3(t.props.children));
  }
  return t;
}, Kfe = function(e) {
  return E7(O7(e));
}, Zfe = function(e, t) {
  delete t.__k, Gfe(p3(e), t);
};
function Jfe(i, e) {
  e === void 0 && (e = {});
  var t = e.insertAt;
  if (!(typeof document > "u")) {
    var n = document.head || document.getElementsByTagName("head")[0], r = document.createElement("style");
    r.type = "text/css", t === "top" && n.firstChild ? n.insertBefore(r, n.firstChild) : n.appendChild(r), r.styleSheet ? r.styleSheet.cssText = i : r.appendChild(document.createTextNode(i));
  }
}
var eAe = `.float-tooltip-kap {
  position: absolute;
  width: max-content; /* prevent shrinking near right edge */
  max-width: max(50%, 150px);
  padding: 3px 5px;
  border-radius: 3px;
  font: 12px sans-serif;
  color: #eee;
  background: rgba(0,0,0,0.6);
  pointer-events: none;
}
`;
Jfe(eAe);
var tAe = Sr({
  props: {
    content: {
      default: !1
    },
    offsetX: {
      triggerUpdate: !1
    },
    // null or number
    offsetY: {
      triggerUpdate: !1
    }
    // null or number
  },
  init: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, r = n.style, s = r === void 0 ? {} : r, o = !!e && b_(e) === "object" && !!e.node && typeof e.node == "function", a = Dfe(o ? e.node() : e);
    a.style("position") === "static" && a.style("position", "relative"), t.tooltipEl = a.append("div").attr("class", "float-tooltip-kap"), Object.entries(s).forEach(function(u) {
      var c = jfe(u, 2), A = c[0], m = c[1];
      return t.tooltipEl.style(A, m);
    }), t.tooltipEl.style("left", "-10000px").style("display", "none");
    var l = "tooltip-".concat(Math.round(Math.random() * 1e12));
    t.mouseInside = !1, a.on("mousemove.".concat(l), function(u) {
      t.mouseInside = !0;
      var c = Ife(u), A = a.node(), m = A.offsetWidth, _ = A.offsetHeight, y = [t.offsetX === null || t.offsetX === void 0 ? "-".concat(c[0] / m * 100, "%") : typeof t.offsetX == "number" ? "calc(-50% + ".concat(t.offsetX, "px)") : t.offsetX, t.offsetY === null || t.offsetY === void 0 ? _ > 130 && _ - c[1] < 100 ? "calc(-100% - 6px)" : "21px" : typeof t.offsetY == "number" ? t.offsetY < 0 ? "calc(-100% - ".concat(Math.abs(t.offsetY), "px)") : "".concat(t.offsetY, "px") : t.offsetY];
      t.tooltipEl.style("left", c[0] + "px").style("top", c[1] + "px").style("transform", "translate(".concat(y.join(","), ")")), t.content && t.tooltipEl.style("display", "inline");
    }), a.on("mouseover.".concat(l), function() {
      t.mouseInside = !0, t.content && t.tooltipEl.style("display", "inline");
    }), a.on("mouseout.".concat(l), function() {
      t.mouseInside = !1, t.tooltipEl.style("display", "none");
    });
  },
  update: function(e) {
    e.tooltipEl.style("display", e.content && e.mouseInside ? "inline" : "none"), e.content ? e.content instanceof HTMLElement ? (e.tooltipEl.text(""), e.tooltipEl.append(function() {
      return e.content;
    })) : typeof e.content == "string" ? e.tooltipEl.html(e.content) : Kfe(e.content) ? (e.tooltipEl.text(""), Zfe(e.content, e.tooltipEl.node())) : (e.tooltipEl.style("display", "none"), console.warn("Tooltip content is invalid, skipping.", e.content, e.content.toString())) : e.tooltipEl.text("");
  }
});
function nAe(i, e) {
  e === void 0 && (e = {});
  var t = e.insertAt;
  if (!(typeof document > "u")) {
    var n = document.head || document.getElementsByTagName("head")[0], r = document.createElement("style");
    r.type = "text/css", t === "top" && n.firstChild ? n.insertBefore(r, n.firstChild) : n.appendChild(r), r.styleSheet ? r.styleSheet.cssText = i : r.appendChild(document.createTextNode(i));
  }
}
var iAe = `.scene-nav-info {
  position: absolute;
  bottom: 5px;
  width: 100%;
  text-align: center;
  color: slategrey;
  opacity: 0.7;
  font-size: 10px;
  font-family: sans-serif;
  pointer-events: none;
  user-select: none;
}

.scene-container canvas:focus {
  outline: none;
}`;
nAe(iAe);
function m3(i, e) {
  (e == null || e > i.length) && (e = i.length);
  for (var t = 0, n = Array(e); t < e; t++) n[t] = i[t];
  return n;
}
function rAe(i) {
  if (Array.isArray(i)) return i;
}
function sAe(i) {
  if (Array.isArray(i)) return m3(i);
}
function oAe(i, e, t) {
  return (e = fAe(e)) in i ? Object.defineProperty(i, e, {
    value: t,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : i[e] = t, i;
}
function aAe(i) {
  if (typeof Symbol < "u" && i[Symbol.iterator] != null || i["@@iterator"] != null) return Array.from(i);
}
function lAe(i, e) {
  var t = i == null ? null : typeof Symbol < "u" && i[Symbol.iterator] || i["@@iterator"];
  if (t != null) {
    var n, r, s, o, a = [], l = !0, u = !1;
    try {
      if (s = (t = t.call(i)).next, e !== 0) for (; !(l = (n = s.call(t)).done) && (a.push(n.value), a.length !== e); l = !0) ;
    } catch (c) {
      u = !0, r = c;
    } finally {
      try {
        if (!l && t.return != null && (o = t.return(), Object(o) !== o)) return;
      } finally {
        if (u) throw r;
      }
    }
    return a;
  }
}
function uAe() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function cAe() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function hAe(i, e) {
  return rAe(i) || lAe(i, e) || k7(i, e) || uAe();
}
function Vc(i) {
  return sAe(i) || aAe(i) || k7(i) || cAe();
}
function dAe(i, e) {
  if (typeof i != "object" || !i) return i;
  var t = i[Symbol.toPrimitive];
  if (t !== void 0) {
    var n = t.call(i, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(i);
}
function fAe(i) {
  var e = dAe(i, "string");
  return typeof e == "symbol" ? e : e + "";
}
function k7(i, e) {
  if (i) {
    if (typeof i == "string") return m3(i, e);
    var t = {}.toString.call(i).slice(8, -1);
    return t === "Object" && i.constructor && (t = i.constructor.name), t === "Map" || t === "Set" ? Array.from(i) : t === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? m3(i, e) : void 0;
  }
}
var Oi = window.THREE ? window.THREE : {
  WebGLRenderer: P8,
  Scene: oA,
  PerspectiveCamera: Ji,
  Raycaster: y8,
  SRGBColorSpace: gr,
  TextureLoader: P0,
  Vector2: Le,
  Vector3: j,
  Box3: dr,
  Color: ct,
  Mesh: Tn,
  SphereGeometry: Co,
  MeshBasicMaterial: Nr,
  BackSide: si,
  Clock: _2
}, V7 = Sr({
  props: {
    width: {
      default: window.innerWidth,
      onChange: function(e, t, n) {
        isNaN(e) && (t.width = n);
      }
    },
    height: {
      default: window.innerHeight,
      onChange: function(e, t, n) {
        isNaN(e) && (t.height = n);
      }
    },
    viewOffset: {
      default: [0, 0]
    },
    backgroundColor: {
      default: "#000011"
    },
    backgroundImageUrl: {},
    onBackgroundImageLoaded: {},
    showNavInfo: {
      default: !0
    },
    skyRadius: {
      default: 5e4
    },
    objects: {
      default: []
    },
    lights: {
      default: []
    },
    enablePointerInteraction: {
      default: !0,
      onChange: function(e, t) {
        t.hoverObj = null, t.tooltip && t.tooltip.content(null);
      },
      triggerUpdate: !1
    },
    pointerRaycasterThrottleMs: {
      default: 50,
      triggerUpdate: !1
    },
    lineHoverPrecision: {
      default: 1,
      triggerUpdate: !1
    },
    pointsHoverPrecision: {
      default: 1,
      triggerUpdate: !1
    },
    hoverOrderComparator: {
      triggerUpdate: !1
    },
    // keep existing order by default
    hoverFilter: {
      default: function() {
        return !0;
      },
      triggerUpdate: !1
    },
    // exclude objects from interaction
    tooltipContent: {
      triggerUpdate: !1
    },
    hoverDuringDrag: {
      default: !1,
      triggerUpdate: !1
    },
    clickAfterDrag: {
      default: !1,
      triggerUpdate: !1
    },
    onHover: {
      default: function() {
      },
      triggerUpdate: !1
    },
    onClick: {
      default: function() {
      },
      triggerUpdate: !1
    },
    onRightClick: {
      triggerUpdate: !1
    }
  },
  methods: {
    tick: function(e) {
      if (e.initialised) {
        e.controls.enabled && e.controls.update && e.controls.update(Math.min(1, e.clock.getDelta())), e.postProcessingComposer ? e.postProcessingComposer.render() : e.renderer.render(e.scene, e.camera), e.extraRenderers.forEach(function(o) {
          return o.render(e.scene, e.camera);
        });
        var t = +/* @__PURE__ */ new Date();
        if (e.enablePointerInteraction && t - e.lastRaycasterCheck >= e.pointerRaycasterThrottleMs) {
          e.lastRaycasterCheck = t;
          var n = null;
          if (e.hoverDuringDrag || !e.isPointerDragging) {
            var r = this.intersectingObjects(e.pointerPos.x, e.pointerPos.y);
            e.hoverOrderComparator && r.sort(function(o, a) {
              return e.hoverOrderComparator(o.object, a.object);
            });
            var s = r.find(function(o) {
              return e.hoverFilter(o.object);
            }) || null;
            n = s ? s.object : null, e.intersection = s || null;
          }
          n !== e.hoverObj && (e.onHover(n, e.hoverObj, e.intersection), e.tooltip.content(n && je(e.tooltipContent)(n, e.intersection) || null), e.hoverObj = n);
        }
        e.tweenGroup.update();
      }
      return this;
    },
    getPointerPos: function(e) {
      var t = e.pointerPos, n = t.x, r = t.y;
      return {
        x: n,
        y: r
      };
    },
    cameraPosition: function(e, t, n, r) {
      var s = e.camera;
      if (t && e.initialised) {
        var o = t, a = n || {
          x: 0,
          y: 0,
          z: 0
        };
        if (!r)
          c(o), A(a);
        else {
          var l = Object.assign({}, s.position), u = m();
          e.tweenGroup.add(new xs(l).to(o, r).easing(Ar.Quadratic.Out).onUpdate(c).start()), e.tweenGroup.add(new xs(u).to(a, r / 3).easing(Ar.Quadratic.Out).onUpdate(A).start());
        }
        return this;
      }
      return Object.assign({}, s.position, {
        lookAt: m()
      });
      function c(_) {
        var y = _.x, T = _.y, b = _.z;
        y !== void 0 && (s.position.x = y), T !== void 0 && (s.position.y = T), b !== void 0 && (s.position.z = b);
      }
      function A(_) {
        var y = new Oi.Vector3(_.x, _.y, _.z);
        e.controls.enabled && e.controls.target ? e.controls.target = y : s.lookAt(y);
      }
      function m() {
        return Object.assign(new Oi.Vector3(0, 0, -1e3).applyQuaternion(s.quaternion).add(s.position));
      }
    },
    zoomToFit: function(e) {
      for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 10, r = arguments.length, s = new Array(r > 3 ? r - 3 : 0), o = 3; o < r; o++)
        s[o - 3] = arguments[o];
      return this.fitToBbox(this.getBbox.apply(this, s), t, n);
    },
    fitToBbox: function(e, t) {
      var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 10, s = e.camera;
      if (t) {
        var o = new Oi.Vector3(0, 0, 0), a = Math.max.apply(Math, Vc(Object.entries(t).map(function(_) {
          var y = hAe(_, 2), T = y[0], b = y[1];
          return Math.max.apply(Math, Vc(b.map(function(S) {
            return Math.abs(o[T] - S);
          })));
        }))) * 2, l = (1 - r * 2 / e.height) * s.fov, u = a / Math.atan(l * Math.PI / 180), c = u / s.aspect, A = Math.max(u, c);
        if (A > 0) {
          var m = o.clone().sub(s.position).normalize().multiplyScalar(-A);
          this.cameraPosition(m, o, n);
        }
      }
      return this;
    },
    getBbox: function(e) {
      var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : function() {
        return !0;
      }, n = new Oi.Box3(new Oi.Vector3(0, 0, 0), new Oi.Vector3(0, 0, 0)), r = e.objects.filter(t);
      return r.length ? (r.forEach(function(s) {
        return n.expandByObject(s);
      }), Object.assign.apply(Object, Vc(["x", "y", "z"].map(function(s) {
        return oAe({}, s, [n.min[s], n.max[s]]);
      })))) : null;
    },
    getScreenCoords: function(e, t, n, r) {
      var s = new Oi.Vector3(t, n, r);
      return s.project(this.camera()), {
        // align relative pos to canvas dimensions
        x: (s.x + 1) * e.width / 2,
        y: -(s.y - 1) * e.height / 2
      };
    },
    getSceneCoords: function(e, t, n) {
      var r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, s = new Oi.Vector2(t / e.width * 2 - 1, -(n / e.height) * 2 + 1), o = new Oi.Raycaster();
      return o.setFromCamera(s, e.camera), Object.assign({}, o.ray.at(r, new Oi.Vector3()));
    },
    intersectingObjects: function(e, t, n) {
      var r = new Oi.Vector2(t / e.width * 2 - 1, -(n / e.height) * 2 + 1), s = new Oi.Raycaster();
      return s.params.Line.threshold = e.lineHoverPrecision, s.params.Points.threshold = e.pointsHoverPrecision, s.setFromCamera(r, e.camera), s.intersectObjects(e.objects, !0);
    },
    renderer: function(e) {
      return e.renderer;
    },
    scene: function(e) {
      return e.scene;
    },
    camera: function(e) {
      return e.camera;
    },
    postProcessingComposer: function(e) {
      return e.postProcessingComposer;
    },
    controls: function(e) {
      return e.controls;
    },
    tbControls: function(e) {
      return e.controls;
    }
    // to be deprecated
  },
  stateInit: function() {
    return {
      scene: new Oi.Scene(),
      camera: new Oi.PerspectiveCamera(),
      clock: new Oi.Clock(),
      tweenGroup: new b2(),
      lastRaycasterCheck: 0
    };
  },
  init: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, r = n.controlType, s = r === void 0 ? "trackball" : r, o = n.useWebGPU, a = o === void 0 ? !1 : o, l = n.rendererConfig, u = l === void 0 ? {} : l, c = n.extraRenderers, A = c === void 0 ? [] : c, m = n.waitForLoadComplete, _ = m === void 0 ? !0 : m;
    e.innerHTML = "", e.appendChild(t.container = document.createElement("div")), t.container.className = "scene-container", t.container.style.position = "relative", t.container.appendChild(t.navInfo = document.createElement("div")), t.navInfo.className = "scene-nav-info", t.navInfo.textContent = {
      orbit: "Left-click: rotate, Mouse-wheel/middle-click: zoom, Right-click: pan",
      trackball: "Left-click: rotate, Mouse-wheel/middle-click: zoom, Right-click: pan",
      fly: "WASD: move, R|F: up | down, Q|E: roll, up|down: pitch, left|right: yaw"
    }[s] || "", t.navInfo.style.display = t.showNavInfo ? null : "none", t.tooltip = new tAe(t.container), t.pointerPos = new Oi.Vector2(), t.pointerPos.x = -2, t.pointerPos.y = -2, ["pointermove", "pointerdown"].forEach(function(y) {
      return t.container.addEventListener(y, function(T) {
        if (y === "pointerdown" && (t.isPointerPressed = !0), !t.isPointerDragging && T.type === "pointermove" && (T.pressure > 0 || t.isPointerPressed) && (T.pointerType === "mouse" || T.movementX === void 0 || [T.movementX, T.movementY].some(function(E) {
          return Math.abs(E) > 1;
        })) && (t.isPointerDragging = !0), t.enablePointerInteraction) {
          var b = S(t.container);
          t.pointerPos.x = T.pageX - b.left, t.pointerPos.y = T.pageY - b.top;
        }
        function S(E) {
          var R = E.getBoundingClientRect(), C = window.pageXOffset || document.documentElement.scrollLeft, L = window.pageYOffset || document.documentElement.scrollTop;
          return {
            top: R.top + L,
            left: R.left + C
          };
        }
      }, {
        passive: !0
      });
    }), t.container.addEventListener("pointerup", function(y) {
      t.isPointerPressed && (t.isPointerPressed = !1, !(t.isPointerDragging && (t.isPointerDragging = !1, !t.clickAfterDrag)) && requestAnimationFrame(function() {
        y.button === 0 && t.onClick(t.hoverObj || null, y, t.intersection), y.button === 2 && t.onRightClick && t.onRightClick(t.hoverObj || null, y, t.intersection);
      }));
    }, {
      passive: !0,
      capture: !0
    }), t.container.addEventListener("contextmenu", function(y) {
      t.onRightClick && y.preventDefault();
    }), t.renderer = new (a ? FI : Oi.WebGLRenderer)(Object.assign({
      antialias: !0,
      alpha: !0
    }, u)), t.renderer.setPixelRatio(Math.min(2, window.devicePixelRatio)), t.container.appendChild(t.renderer.domElement), t.extraRenderers = A, t.extraRenderers.forEach(function(y) {
      y.domElement.style.position = "absolute", y.domElement.style.top = "0px", y.domElement.style.pointerEvents = "none", t.container.appendChild(y.domElement);
    }), t.postProcessingComposer = new lhe(t.renderer), t.postProcessingComposer.addPass(new uhe(t.scene, t.camera)), t.controls = new {
      trackball: gce,
      orbit: Lce,
      fly: jce
    }[s](t.camera, t.renderer.domElement), s === "fly" && (t.controls.movementSpeed = 300, t.controls.rollSpeed = Math.PI / 6, t.controls.dragToLook = !0), (s === "trackball" || s === "orbit") && (t.controls.minDistance = 0.1, t.controls.maxDistance = t.skyRadius, t.controls.addEventListener("start", function() {
      t.controlsEngaged = !0;
    }), t.controls.addEventListener("change", function() {
      t.controlsEngaged && (t.controlsDragging = !0);
    }), t.controls.addEventListener("end", function() {
      t.controlsEngaged = !1, t.controlsDragging = !1;
    })), [t.renderer, t.postProcessingComposer].concat(Vc(t.extraRenderers)).forEach(function(y) {
      return y.setSize(t.width, t.height);
    }), t.camera.aspect = t.width / t.height, t.camera.updateProjectionMatrix(), t.camera.position.z = 1e3, t.scene.add(t.skysphere = new Oi.Mesh()), t.skysphere.visible = !1, t.loadComplete = t.scene.visible = !_, window.scene = t.scene;
  },
  update: function(e, t) {
    if (e.width && e.height && (t.hasOwnProperty("width") || t.hasOwnProperty("height"))) {
      var n, r = e.width, s = e.height;
      e.container.style.width = "".concat(r, "px"), e.container.style.height = "".concat(s, "px"), [e.renderer, e.postProcessingComposer].concat(Vc(e.extraRenderers)).forEach(function(_) {
        return _.setSize(r, s);
      }), e.camera.aspect = r / s;
      var o = e.viewOffset.slice(0, 2);
      o.some(function(_) {
        return _;
      }) && (n = e.camera).setViewOffset.apply(n, [r, s].concat(Vc(o), [r, s])), e.camera.updateProjectionMatrix();
    }
    if (t.hasOwnProperty("viewOffset")) {
      var a, l = e.width, u = e.height, c = e.viewOffset.slice(0, 2);
      c.some(function(_) {
        return _;
      }) ? (a = e.camera).setViewOffset.apply(a, [l, u].concat(Vc(c), [l, u])) : e.camera.clearViewOffset();
    }
    if (t.hasOwnProperty("skyRadius") && e.skyRadius && (e.controls.hasOwnProperty("maxDistance") && t.skyRadius && (e.controls.maxDistance = Math.min(e.controls.maxDistance, e.skyRadius)), e.camera.far = e.skyRadius * 2.5, e.camera.updateProjectionMatrix(), e.skysphere.geometry = new Oi.SphereGeometry(e.skyRadius)), t.hasOwnProperty("backgroundColor")) {
      var A = Jf(e.backgroundColor).alpha;
      A === void 0 && (A = 1), e.renderer.setClearColor(new Oi.Color(zhe(1, e.backgroundColor)), A);
    }
    t.hasOwnProperty("backgroundImageUrl") && (e.backgroundImageUrl ? new Oi.TextureLoader().load(e.backgroundImageUrl, function(_) {
      _.colorSpace = Oi.SRGBColorSpace, e.skysphere.material = new Oi.MeshBasicMaterial({
        map: _,
        side: Oi.BackSide
      }), e.skysphere.visible = !0, e.onBackgroundImageLoaded && setTimeout(e.onBackgroundImageLoaded), !e.loadComplete && m();
    }) : (e.skysphere.visible = !1, e.skysphere.material.map = null, !e.loadComplete && m())), t.hasOwnProperty("showNavInfo") && (e.navInfo.style.display = e.showNavInfo ? null : "none"), t.hasOwnProperty("lights") && ((t.lights || []).forEach(function(_) {
      return e.scene.remove(_);
    }), e.lights.forEach(function(_) {
      return e.scene.add(_);
    })), t.hasOwnProperty("objects") && ((t.objects || []).forEach(function(_) {
      return e.scene.remove(_);
    }), e.objects.forEach(function(_) {
      return e.scene.add(_);
    }));
    function m() {
      e.loadComplete = e.scene.visible = !0;
    }
  }
});
function AAe(i, e) {
  e === void 0 && (e = {});
  var t = e.insertAt;
  if (!(typeof document > "u")) {
    var n = document.head || document.getElementsByTagName("head")[0], r = document.createElement("style");
    r.type = "text/css", t === "top" && n.firstChild ? n.insertBefore(r, n.firstChild) : n.appendChild(r), r.styleSheet ? r.styleSheet.cssText = i : r.appendChild(document.createTextNode(i));
  }
}
var pAe = `.scene-container .clickable {
  cursor: pointer;
}`;
AAe(pAe);
function g3(i, e) {
  (e == null || e > i.length) && (e = i.length);
  for (var t = 0, n = Array(e); t < e; t++) n[t] = i[t];
  return n;
}
function mAe(i) {
  if (Array.isArray(i)) return g3(i);
}
function X0(i, e, t) {
  return (e = bAe(e)) in i ? Object.defineProperty(i, e, {
    value: t,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : i[e] = t, i;
}
function gAe(i) {
  if (typeof Symbol < "u" && i[Symbol.iterator] != null || i["@@iterator"] != null) return Array.from(i);
}
function _Ae() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function f5(i, e) {
  var t = Object.keys(i);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(i);
    e && (n = n.filter(function(r) {
      return Object.getOwnPropertyDescriptor(i, r).enumerable;
    })), t.push.apply(t, n);
  }
  return t;
}
function Yc(i) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? f5(Object(t), !0).forEach(function(n) {
      X0(i, n, t[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(i, Object.getOwnPropertyDescriptors(t)) : f5(Object(t)).forEach(function(n) {
      Object.defineProperty(i, n, Object.getOwnPropertyDescriptor(t, n));
    });
  }
  return i;
}
function xAe(i, e) {
  if (i == null) return {};
  var t, n, r = yAe(i, e);
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(i);
    for (n = 0; n < s.length; n++) t = s[n], e.indexOf(t) === -1 && {}.propertyIsEnumerable.call(i, t) && (r[t] = i[t]);
  }
  return r;
}
function yAe(i, e) {
  if (i == null) return {};
  var t = {};
  for (var n in i) if ({}.hasOwnProperty.call(i, n)) {
    if (e.indexOf(n) !== -1) continue;
    t[n] = i[n];
  }
  return t;
}
function fx(i) {
  return mAe(i) || gAe(i) || SAe(i) || _Ae();
}
function vAe(i, e) {
  if (typeof i != "object" || !i) return i;
  var t = i[Symbol.toPrimitive];
  if (t !== void 0) {
    var n = t.call(i, e);
    if (typeof n != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(i);
}
function bAe(i) {
  var e = vAe(i, "string");
  return typeof e == "symbol" ? e : e + "";
}
function SAe(i, e) {
  if (i) {
    if (typeof i == "string") return g3(i, e);
    var t = {}.toString.call(i).slice(8, -1);
    return t === "Object" && i.constructor && (t = i.constructor.name), t === "Map" || t === "Set" ? Array.from(i) : t === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? g3(i, e) : void 0;
  }
}
function G7(i, e) {
  var t = new e();
  return t._destructor && t._destructor(), {
    linkProp: function(r) {
      return {
        default: t[r](),
        onChange: function(o, a) {
          a[i][r](o);
        },
        triggerUpdate: !1
      };
    },
    linkMethod: function(r) {
      return function(s) {
        for (var o = s[i], a = arguments.length, l = new Array(a > 1 ? a - 1 : 0), u = 1; u < a; u++)
          l[u - 1] = arguments[u];
        var c = o[r].apply(o, l);
        return c === o ? this : c;
      };
    }
  };
}
var TAe = ["rendererConfig", "waitForGlobeReady"], ap = Yc(Yc({}, window.THREE ? window.THREE : {
  AmbientLight: m2,
  DirectionalLight: p2,
  Vector2: Le,
  REVISION: Ku
}), {}, {
  CSS2DRenderer: Uq
}), z7 = G7("globe", l7), wAe = Object.assign.apply(Object, fx(["globeImageUrl", "bumpImageUrl", "globeTileEngineUrl", "globeTileEngineMaxLevel", "globeCurvatureResolution", "showGlobe", "showGraticules", "showAtmosphere", "atmosphereColor", "atmosphereAltitude", "onGlobeReady", "pointsData", "pointLat", "pointLng", "pointColor", "pointAltitude", "pointRadius", "pointResolution", "pointsMerge", "pointsTransitionDuration", "arcsData", "arcStartLat", "arcStartLng", "arcStartAltitude", "arcEndLat", "arcEndLng", "arcEndAltitude", "arcColor", "arcAltitude", "arcAltitudeAutoScale", "arcStroke", "arcCurveResolution", "arcCircularResolution", "arcDashLength", "arcDashGap", "arcDashInitialGap", "arcDashAnimateTime", "arcsTransitionDuration", "polygonsData", "polygonGeoJsonGeometry", "polygonCapColor", "polygonCapMaterial", "polygonSideColor", "polygonSideMaterial", "polygonStrokeColor", "polygonAltitude", "polygonCapCurvatureResolution", "polygonsTransitionDuration", "pathsData", "pathPoints", "pathPointLat", "pathPointLng", "pathPointAlt", "pathResolution", "pathColor", "pathStroke", "pathDashLength", "pathDashGap", "pathDashInitialGap", "pathDashAnimateTime", "pathTransitionDuration", "heatmapsData", "heatmapPoints", "heatmapPointLat", "heatmapPointLng", "heatmapPointWeight", "heatmapBandwidth", "heatmapColorFn", "heatmapColorSaturation", "heatmapBaseAltitude", "heatmapTopAltitude", "heatmapsTransitionDuration", "hexBinPointsData", "hexBinPointLat", "hexBinPointLng", "hexBinPointWeight", "hexBinResolution", "hexMargin", "hexTopCurvatureResolution", "hexTopColor", "hexSideColor", "hexAltitude", "hexBinMerge", "hexTransitionDuration", "hexPolygonsData", "hexPolygonGeoJsonGeometry", "hexPolygonColor", "hexPolygonAltitude", "hexPolygonResolution", "hexPolygonMargin", "hexPolygonUseDots", "hexPolygonCurvatureResolution", "hexPolygonDotResolution", "hexPolygonsTransitionDuration", "tilesData", "tileLat", "tileLng", "tileAltitude", "tileWidth", "tileHeight", "tileUseGlobeProjection", "tileMaterial", "tileCurvatureResolution", "tilesTransitionDuration", "particlesData", "particlesList", "particleLat", "particleLng", "particleAltitude", "particlesSize", "particlesSizeAttenuation", "particlesColor", "particlesTexture", "ringsData", "ringLat", "ringLng", "ringAltitude", "ringColor", "ringResolution", "ringMaxRadius", "ringPropagationSpeed", "ringRepeatPeriod", "labelsData", "labelLat", "labelLng", "labelAltitude", "labelRotation", "labelText", "labelSize", "labelTypeFace", "labelColor", "labelResolution", "labelIncludeDot", "labelDotRadius", "labelDotOrientation", "labelsTransitionDuration", "htmlElementsData", "htmlLat", "htmlLng", "htmlAltitude", "htmlElement", "htmlElementVisibilityModifier", "htmlTransitionDuration", "objectsData", "objectLat", "objectLng", "objectAltitude", "objectRotation", "objectFacesSurface", "objectThreeObject", "customLayerData", "customThreeObject", "customThreeObjectUpdate"].map(function(i) {
  return X0({}, i, z7.linkProp(i));
}))), MAe = Object.assign.apply(Object, fx(["globeMaterial", "globeTileEngineClearCache", "getGlobeRadius", "getCoords", "toGeoCoords"].map(function(i) {
  return X0({}, i, z7.linkMethod(i));
}))), q7 = G7("renderObjs", V7), EAe = Object.assign.apply(Object, fx(["width", "height", "backgroundColor", "backgroundImageUrl", "enablePointerInteraction"].map(function(i) {
  return X0({}, i, q7.linkProp(i));
}))), RAe = Object.assign.apply(Object, fx(["lights", "postProcessingComposer"].map(function(i) {
  return X0({}, i, q7.linkMethod(i));
}))), CAe = Sr({
  props: Yc(Yc({
    onZoom: {
      triggerUpdate: !1
    },
    onGlobeClick: {
      triggerUpdate: !1
    },
    onGlobeRightClick: {
      triggerUpdate: !1
    },
    pointLabel: {
      default: "name",
      triggerUpdate: !1
    },
    onPointClick: {
      triggerUpdate: !1
    },
    onPointRightClick: {
      triggerUpdate: !1
    },
    onPointHover: {
      triggerUpdate: !1
    },
    arcLabel: {
      default: "name",
      triggerUpdate: !1
    },
    onArcClick: {
      triggerUpdate: !1
    },
    onArcRightClick: {
      triggerUpdate: !1
    },
    onArcHover: {
      triggerUpdate: !1
    },
    polygonLabel: {
      default: "name",
      triggerUpdate: !1
    },
    onPolygonClick: {
      triggerUpdate: !1
    },
    onPolygonRightClick: {
      triggerUpdate: !1
    },
    onPolygonHover: {
      triggerUpdate: !1
    },
    pathLabel: {
      default: "name",
      triggerUpdate: !1
    },
    onPathClick: {
      triggerUpdate: !1
    },
    onPathRightClick: {
      triggerUpdate: !1
    },
    onPathHover: {
      triggerUpdate: !1
    },
    onHeatmapClick: {
      triggerUpdate: !1
    },
    onHeatmapRightClick: {
      triggerUpdate: !1
    },
    onHeatmapHover: {
      triggerUpdate: !1
    },
    hexLabel: {
      triggerUpdate: !1
    },
    onHexClick: {
      triggerUpdate: !1
    },
    onHexRightClick: {
      triggerUpdate: !1
    },
    onHexHover: {
      triggerUpdate: !1
    },
    hexPolygonLabel: {
      triggerUpdate: !1
    },
    onHexPolygonClick: {
      triggerUpdate: !1
    },
    onHexPolygonRightClick: {
      triggerUpdate: !1
    },
    onHexPolygonHover: {
      triggerUpdate: !1
    },
    tileLabel: {
      default: "name",
      triggerUpdate: !1
    },
    onTileClick: {
      triggerUpdate: !1
    },
    onTileRightClick: {
      triggerUpdate: !1
    },
    onTileHover: {
      triggerUpdate: !1
    },
    particleLabel: {
      default: "name",
      triggerUpdate: !1
    },
    onParticleClick: {
      triggerUpdate: !1
    },
    onParticleRightClick: {
      triggerUpdate: !1
    },
    onParticleHover: {
      triggerUpdate: !1
    },
    labelLabel: {
      triggerUpdate: !1
    },
    onLabelClick: {
      triggerUpdate: !1
    },
    onLabelRightClick: {
      triggerUpdate: !1
    },
    onLabelHover: {
      triggerUpdate: !1
    },
    objectLabel: {
      default: "name",
      triggerUpdate: !1
    },
    onObjectClick: {
      triggerUpdate: !1
    },
    onObjectRightClick: {
      triggerUpdate: !1
    },
    onObjectHover: {
      triggerUpdate: !1
    },
    customLayerLabel: {
      default: "name",
      triggerUpdate: !1
    },
    onCustomLayerClick: {
      triggerUpdate: !1
    },
    onCustomLayerRightClick: {
      triggerUpdate: !1
    },
    onCustomLayerHover: {
      triggerUpdate: !1
    },
    pointerEventsFilter: {
      default: function() {
        return !0;
      },
      triggerUpdate: !1
    },
    lineHoverPrecision: {
      default: 0.2,
      triggerUpdate: !1,
      onChange: function(e, t) {
        t.renderObjs.lineHoverPrecision(e), t.renderObjs.pointsHoverPrecision(e);
      }
    },
    showPointerCursor: {
      default: !0,
      triggerUpdate: !1
    },
    globeOffset: {
      default: [0, 0],
      triggerUpdate: !1,
      onChange: function(e, t) {
        return Array.isArray(e) && e.length === 2 && t.renderObjs.viewOffset(e.map(function(n) {
          return -n;
        }));
      }
    }
  }, wAe), EAe),
  methods: Yc(Yc({
    pauseAnimation: function(e) {
      var t;
      return e.animationFrameRequestId !== null && (cancelAnimationFrame(e.animationFrameRequestId), e.animationFrameRequestId = null), (t = e.globe) === null || t === void 0 || t.pauseAnimation(), this;
    },
    resumeAnimation: function(e) {
      var t;
      return e.animationFrameRequestId === null && this._animationCycle(), (t = e.globe) === null || t === void 0 || t.resumeAnimation(), this;
    },
    _animationCycle: function(e) {
      e.renderObjs.tick(), e.tweenGroup.update(), e.animationFrameRequestId = requestAnimationFrame(this._animationCycle);
    },
    pointOfView: function(e) {
      var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, r = o();
      if (t.lat === void 0 && t.lng === void 0 && t.altitude === void 0)
        return r;
      var s = Object.assign({}, r, t);
      if (["lat", "lng", "altitude"].forEach(function(l) {
        return s[l] = +s[l];
      }), !n)
        a(s);
      else {
        for (; r.lng - s.lng > 180; ) r.lng -= 360;
        for (; r.lng - s.lng < -180; ) r.lng += 360;
        e.tweenGroup.add(new xs(r).to(s, n).easing(Ar.Cubic.InOut).onUpdate(a).start());
      }
      return this;
      function o() {
        return e.globe.toGeoCoords(e.renderObjs.cameraPosition());
      }
      function a(l) {
        var u = l.lat, c = l.lng, A = l.altitude;
        e.renderObjs.cameraPosition(e.globe.getCoords(u, c, A)), e.globe.setPointOfView(e.renderObjs.camera());
      }
    },
    getScreenCoords: function(e) {
      for (var t, n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), s = 1; s < n; s++)
        r[s - 1] = arguments[s];
      var o = (t = e.globe).getCoords.apply(t, r);
      return e.renderObjs.getScreenCoords(o.x, o.y, o.z);
    },
    toGlobeCoords: function(e, t, n) {
      var r = e.renderObjs.intersectingObjects(t, n).find(function(l) {
        return (l.object.__globeObjType || l.object.parent.__globeObjType) === "globe";
      });
      if (!r) return null;
      var s = e.globe.toGeoCoords(r.point), o = s.lat, a = s.lng;
      return {
        lat: o,
        lng: a
      };
    },
    scene: function(e) {
      return e.renderObjs.scene();
    },
    // Expose scene
    camera: function(e) {
      return e.renderObjs.camera();
    },
    // Expose camera
    renderer: function(e) {
      return e.renderObjs.renderer();
    },
    // Expose renderer
    controls: function(e) {
      return e.renderObjs.controls();
    },
    // Expose controls
    _destructor: function(e) {
      e.globe._destructor(), this.pauseAnimation(), this.pointsData([]), this.arcsData([]), this.polygonsData([]), this.pathsData([]), this.heatmapsData([]), this.hexBinPointsData([]), this.hexPolygonsData([]), this.tilesData([]), this.particlesData([]), this.labelsData([]), this.htmlElementsData([]), this.objectsData([]), this.customLayerData([]);
    }
  }, MAe), RAe),
  stateInit: function(e) {
    var t = e.rendererConfig, n = e.waitForGlobeReady, r = n === void 0 ? !0 : n, s = xAe(e, TAe), o = new l7(Yc({
      waitForGlobeReady: r
    }, s));
    return {
      globe: o,
      renderObjs: V7({
        controlType: "orbit",
        rendererConfig: t,
        waitForLoadComplete: r,
        extraRenderers: [new ap.CSS2DRenderer()]
        // Used in HTML elements layer
      }).skyRadius(o.getGlobeRadius() * 500).showNavInfo(!1).objects([o]).lights([new ap.AmbientLight(13421772, Math.PI), new ap.DirectionalLight(16777215, 0.6 * Math.PI)]),
      tweenGroup: new b2()
    };
  },
  init: function(e, t) {
    var n = this;
    e.innerHTML = "", e.appendChild(t.container = document.createElement("div")), t.container.style.position = "relative";
    var r = document.createElement("div");
    t.container.appendChild(r), t.renderObjs(r), t.globe.rendererSize(t.renderObjs.renderer().getSize(new ap.Vector2())), this.pointOfView({
      altitude: 2.5
    });
    var s = t.globe.getGlobeRadius(), o = t.renderObjs.controls();
    t.renderObjs.camera().near = 0.05, o.minDistance = s + Math.max(1e-3, t.renderObjs.camera().near * 1.1), o.maxDistance = s * 100, o.enablePan = !1, o.enableDamping = !0, o.dampingFactor = 0.1, o.rotateSpeed = 0.3, o.zoomSpeed = 0.3, o.zoomToCursor = !0, o.addEventListener("change", function() {
      o.target.setScalar(0);
      var u = n.pointOfView();
      o.rotateSpeed = u.altitude * 0.3, o.zoomSpeed = Math.sqrt(u.altitude) * 0.5, t.globe.setPointOfView(t.renderObjs.camera()), t.onZoom && t.onZoom(u);
    });
    var a = function(c) {
      for (var A = c; A && !A.hasOwnProperty("__globeObjType"); )
        A = A.parent;
      return A;
    }, l = {
      point: function(c) {
        return c;
      },
      arc: function(c) {
        return c;
      },
      polygon: function(c) {
        return c.data;
      },
      path: function(c) {
        return c;
      },
      heatmap: function(c) {
        return c;
      },
      hexbin: function(c) {
        return c;
      },
      hexPolygon: function(c) {
        return c;
      },
      tile: function(c) {
        return c;
      },
      particles: function(c, A) {
        return !A || !A.hasOwnProperty("index") || c.length <= A.index ? c : c[A.index];
      },
      label: function(c) {
        return c;
      },
      object: function(c) {
        return c;
      },
      custom: function(c) {
        return c;
      }
    };
    ap.REVISION < 155 && (t.renderObjs.renderer().useLegacyLights = !1), t.renderObjs.hoverFilter(function(u) {
      var c = a(u);
      if (!c) return !1;
      var A = c.__globeObjType;
      if (A !== "globe" && !l.hasOwnProperty(A)) return !1;
      var m = l.hasOwnProperty(A) && c.__data ? l[A](c.__data) : null;
      return ["points", "hexBinPoints"].some(function(_) {
        return _ === A;
      }) && Array.isArray(m) ? !1 : t.pointerEventsFilter(c, m);
    }).tooltipContent(function(u, c) {
      var A = {
        point: t.pointLabel,
        arc: t.arcLabel,
        polygon: t.polygonLabel,
        path: t.pathLabel,
        hexbin: t.hexLabel,
        hexPolygon: t.hexPolygonLabel,
        tile: t.tileLabel,
        particles: t.particleLabel,
        label: t.labelLabel,
        object: t.objectLabel,
        custom: t.customLayerLabel
      }, m = a(u), _ = m && m.__globeObjType;
      return m && _ && A.hasOwnProperty(_) && l.hasOwnProperty(_) && je(A[_])(l[_](m.__data, c)) || "";
    }).onHover(function(u, c, A) {
      var m = {
        point: t.onPointHover,
        arc: t.onArcHover,
        polygon: t.onPolygonHover,
        path: t.onPathHover,
        heatmap: t.onHeatmapHover,
        hexbin: t.onHexHover,
        hexPolygon: t.onHexPolygonHover,
        tile: t.onTileHover,
        particles: t.onParticleHover,
        label: t.onLabelHover,
        object: t.onObjectHover,
        custom: t.onCustomLayerHover
      }, _ = {
        globe: t.onGlobeClick,
        point: t.onPointClick,
        arc: t.onArcClick,
        polygon: t.onPolygonClick,
        path: t.onPathClick,
        heatmap: t.onHeatmapClick,
        hexbin: t.onHexClick,
        hexPolygon: t.onHexPolygonClick,
        tile: t.onTileClick,
        particles: t.onParticleClick,
        label: t.onLabelClick,
        object: t.onObjectClick,
        custom: t.onCustomLayerClick
      }, y = a(u);
      if (y && !m.hasOwnProperty(y.__globeObjType) && (y = null), y !== t.hoverObj) {
        var T, b = t.hoverObj ? t.hoverObj.__globeObjType : null, S = t.hoverData, E = y ? y.__globeObjType : null, R = (T = y) !== null && T !== void 0 && T.__data ? l[E](y.__data, A) : null;
        b && b !== E && m[b] && m[b](null, S || null), E && m[E] && m[E](R, b === E ? S : null), t.renderObjs.renderer().domElement.classList[E && _[E] && je(t.showPointerCursor)(E, R) ? "add" : "remove"]("clickable"), t.hoverObj = y, t.hoverData = R;
      }
    }).onClick(function(u, c, A) {
      if (u) {
        var m = {
          globe: t.onGlobeClick,
          point: t.onPointClick,
          arc: t.onArcClick,
          polygon: t.onPolygonClick,
          path: t.onPathClick,
          heatmap: t.onHeatmapClick,
          hexbin: t.onHexClick,
          hexPolygon: t.onHexPolygonClick,
          tile: t.onTileClick,
          particles: t.onParticleClick,
          label: t.onLabelClick,
          object: t.onObjectClick,
          custom: t.onCustomLayerClick
        }, _ = a(u), y = _.__globeObjType;
        if (_ && m.hasOwnProperty(y) && m[y]) {
          var T = [c], b = A != null && A.isVector3 ? A : A?.point;
          if (y === "globe") {
            var S = n.toGeoCoords(b), E = S.lat, R = S.lng;
            T.unshift({
              lat: E,
              lng: R
            });
          } else
            T.push(n.toGeoCoords(b));
          l.hasOwnProperty(y) && T.unshift(l[y](_.__data, A)), m[y].apply(m, T);
        }
      }
    }).onRightClick(function(u, c, A) {
      if (u) {
        var m = {
          globe: t.onGlobeRightClick,
          point: t.onPointRightClick,
          arc: t.onArcRightClick,
          polygon: t.onPolygonRightClick,
          path: t.onPathRightClick,
          heatmap: t.onHeatmapRightClick,
          hexbin: t.onHexRightClick,
          hexPolygon: t.onHexPolygonRightClick,
          tile: t.onTileRightClick,
          particles: t.onParticleRightClick,
          label: t.onLabelRightClick,
          object: t.onObjectRightClick,
          custom: t.onCustomLayerRightClick
        }, _ = a(u), y = _.__globeObjType;
        if (_ && m.hasOwnProperty(y) && m[y]) {
          var T = [c], b = A != null && A.isVector3 ? A : A?.point;
          if (y === "globe") {
            var S = n.toGeoCoords(b), E = S.lat, R = S.lng;
            T.unshift({
              lat: E,
              lng: R
            });
          } else
            T.push(n.toGeoCoords(b));
          l.hasOwnProperty(y) && T.unshift(l[y](_.__data, A)), m[y].apply(m, T);
        }
      }
    }), this._animationCycle();
  }
});
const PAe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: CAe
}, Symbol.toStringTag, { value: "Module" }));
export {
  FAe as default,
  Bq as render
};
